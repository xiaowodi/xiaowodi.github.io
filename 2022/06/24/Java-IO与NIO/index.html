<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xiaowodi.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="1. IO流1.1 File类的使用File类的理解 File类的一个对象，代表一个文件或一个目录（俗称：文件夹）  File类声明在java.io包下  File类中涉及到关于文件或文件目录的创建，删除、重命名、修改时间、文件大小等方法 并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流来完成  后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的“终">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1. IO流1.1 File类的使用File类的理解 File类的一个对象，代表一个文件或一个目录（俗称：文件夹）  File类声明在java.io包下  File类中涉及到关于文件或文件目录的创建，删除、重命名、修改时间、文件大小等方法 并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流来完成  后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的“终">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211012095630962.png">
<meta property="og:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211018141242195-16345375636911.png">
<meta property="og:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211018143034994-16345386387512.png">
<meta property="og:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211018145332931-16345400144173.png">
<meta property="og:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/7ce79819b9685ffc2bae685bec83b0f1.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/4dfa85f71b54ed2d8e3a43371933b7fb.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/09bdce6b569fe3cf80206cc704dbf7cb.png">
<meta property="og:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/e769997523201f9fa4f83e501931e6e1.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/cdbda7a9127a6319dcd57cc16be48849.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/e028a11c223c41376e42a0cecd7dc505.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/3125b3b4a4431912fa787bbeaea342b6.png">
<meta property="og:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211020210801147-16347352859511.png">
<meta property="og:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211020211145095-16347355066182.png">
<meta property="og:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/png2.png">
<meta property="og:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E5%88%86%E6%95%A3.png">
<meta property="og:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E8%81%9A%E9%9B%86%E5%86%99.png">
<meta property="og:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E4%B8%8ENIO/0021.png">
<meta property="og:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E4%B8%8ENIO/0018.png">
<meta property="og:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E4%B8%8ENIO/0019.png">
<meta property="og:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E4%B8%8ENIO/0020.png">
<meta property="og:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E4%B8%8ENIO/0021.png">
<meta property="og:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E4%B8%8ENIO/0022.png">
<meta property="og:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/src=http%253A%252F%252Fimg.mp.itc.cn%252Fupload%252F20160527%252F94502ff22866475a8ddaa3b832de64d2.jpg&refer=http%253A%252F%252Fimg.mp.itc-16354874682132.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg">
<meta property="og:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211029141706293-16354882280304.png">
<meta property="og:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fdl2.iteye.com%2Fupload%2Fattachment%2F0096%2F4782%2Fb8a7bad8-ec65-36dc-bb11-4f352e00cd67.png&refer=http%3A%2F%2Fdl2.iteye.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1638086744&t=8d1f749ef4dcf004a67f97d4223aaa68">
<meta property="og:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzQwMzg5Nzc1,size_16,color_FFFFFF,t_70.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190410105333435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzQwMzg5Nzc1,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211109100448562-16364234905571.png">
<meta property="og:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/src=http%253A%252F%252Fpic1.zhimg.com%252Fv2-805bb1b58bcc01045a6142e6e6fa1304_b.jpg&refer=http%253A%252F%252Fpic1.zhimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg">
<meta property="og:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211112100419343-16366826605741.png">
<meta property="og:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E4%B8%8ENIO/0023.png">
<meta property="og:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E4%B8%8ENIO/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96.png">
<meta property="og:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E4%B8%8ENIO/0033.png">
<meta property="og:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E4%B8%8ENIO/0039.png">
<meta property="og:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E4%B8%8ENIO/0035.png">
<meta property="og:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E4%B8%8ENIO/0038.png">
<meta property="og:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E4%B8%8ENIO/0037.png">
<meta property="og:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E4%B8%8ENIO/0034.png">
<meta property="og:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E4%B8%8ENIO/0036.png">
<meta property="og:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E4%B8%8ENIO/0024.png">
<meta property="og:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E4%B8%8ENIO/0025.png">
<meta property="og:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E4%B8%8ENIO/0026.png">
<meta property="og:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E4%B8%8ENIO/0027.png">
<meta property="article:published_time" content="2022-06-24T08:12:10.618Z">
<meta property="article:modified_time" content="2022-06-24T08:12:10.618Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211012095630962.png">

<link rel="canonical" href="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title> | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-24 08:12:10" itemprop="dateCreated datePublished" datetime="2022-06-24T08:12:10+00:00">2022-06-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-IO流"><a href="#1-IO流" class="headerlink" title="1. IO流"></a>1. IO流</h1><h2 id="1-1-File类的使用"><a href="#1-1-File类的使用" class="headerlink" title="1.1 File类的使用"></a>1.1 File类的使用</h2><h3 id="File类的理解"><a href="#File类的理解" class="headerlink" title="File类的理解"></a>File类的理解</h3><ol>
<li><p>File类的一个对象，代表一个文件或一个目录（俗称：文件夹）</p>
</li>
<li><p>File类声明在<code>java.io</code>包下</p>
</li>
<li><p>File类中涉及到关于文件或文件目录的创建，删除、重命名、修改时间、文件大小等方法</p>
<p>并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流来完成</p>
</li>
<li><p>后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的“终点”。</p>
</li>
</ol>
<h3 id="File的实例化"><a href="#File的实例化" class="headerlink" title="File的实例化"></a>File的实例化</h3><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p><img src="source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211012095630962.png" alt="image-20211012095630962"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(String filePath);</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(String parentPath, String childPath);</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(File parentFile, String childPath);</span><br></pre></td></tr></table></figure>



<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDirectory</span><span class="params">()</span>：判断是否是文件目录</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFile</span><span class="params">()</span> ：判断是否是文件</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exists</span><span class="params">()</span> ：判断是否存在</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canRead</span><span class="params">()</span> ：判断是否可读</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canWrite</span><span class="params">()</span> ：判断是否可写</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHidden</span><span class="params">()</span> ：判断是否隐藏</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">createNewFile</span><span class="params">()</span> ：创建文件。若文件存在，则不创建，返回<span class="literal">false</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">mkdirs</span><span class="params">()</span> ：创建文件目录。如果此文件目录存在，就不创建了。如果词文件目录的上层目录不存在， 也不创建。</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">mkdir</span><span class="params">()</span> ：创建文件目录，如果上层文件目录不存在，一并创建</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">()</span> ：删除文件或者文件夹（直接删除，不走回收站）</span><br><span class="line"><span class="comment">//  分隔符常量</span></span><br><span class="line">File.separator  用于路径的分隔符  <span class="comment">/* unix：/   windows： \\ */</span></span><br></pre></td></tr></table></figure>





<h2 id="1-2-IO流概述"><a href="#1-2-IO流概述" class="headerlink" title="1.2 IO流概述"></a>1.2 IO流概述</h2><ul>
<li><p>I/O是Input/Output的缩写，I/O技术是非常实用的技术，用于处理设备之间的数据传输。如读/写文件、网络通讯等。</p>
</li>
<li><p>Java程序中，对于数据的输入/输出操作以“流Stream”的方式进行。</p>
</li>
<li><p>java.io包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过标准的方法输入或输出数据。</p>
</li>
<li><p>输入Input：读取外部数据（磁盘，光盘等存储设备的数据）到程序（内存）中</p>
</li>
<li><p>输出output：将程序（内存）数据输出到磁盘、光盘等存储设备中</p>
</li>
</ul>
<p><strong>流的分类</strong></p>
<ul>
<li>按操作数据单位不同分为：<strong>字节流（8bit）</strong>、<strong>字符流（16bit）</strong></li>
<li>按数据流的流向不同分为：输入流、输出流</li>
<li>按数据流的角色不同分为：节点流、处理流</li>
</ul>
<table>
<thead>
<tr>
<th>抽象基类</th>
<th>字节流</th>
<th>字符流</th>
</tr>
</thead>
<tbody><tr>
<td>输入流</td>
<td>InputStream</td>
<td>Reader（往内存中读取数据）</td>
</tr>
<tr>
<td>输出流</td>
<td>OutputStream</td>
<td>Writer（将内存中数据写出）</td>
</tr>
</tbody></table>
<p>Java的IO流涉及40多个类，实际上非常规则，都是从上述4个抽象基类派生的；由这四个类派生出来的子类名称都是其父类名作为子类名后缀。</p>
<p><strong>IO流的体系</strong></p>
<table>
<thead>
<tr>
<th>分类</th>
<th>字节输入流</th>
<th>字节输出流</th>
<th>字符输入流</th>
<th>字符输出流</th>
</tr>
</thead>
<tbody><tr>
<td>抽象基类</td>
<td>InputStream</td>
<td>OutputStream</td>
<td>Reader</td>
<td>Writer</td>
</tr>
<tr>
<td>访问文件（节点流）</td>
<td>FileInputStream</td>
<td>FileOutputStream</td>
<td>FileReader</td>
<td>FileWriter</td>
</tr>
<tr>
<td>访问数组</td>
<td>ByteArrayInputStream</td>
<td>ByteArrayOutputStream</td>
<td>CharArrayReader</td>
<td>CharArrayWriter</td>
</tr>
<tr>
<td>访问管道</td>
<td>PipedInputStream</td>
<td>PipedOutputStream</td>
<td>PipedReader</td>
<td>PipedWriter</td>
</tr>
<tr>
<td>访问字符串</td>
<td></td>
<td></td>
<td>StringReader</td>
<td>StringWriter</td>
</tr>
<tr>
<td>缓冲流(处理流的一种)</td>
<td>BufferedInputStream</td>
<td>BufferedOutputStream</td>
<td>BufferedReader</td>
<td>BufferedWriter</td>
</tr>
<tr>
<td>转换流</td>
<td></td>
<td></td>
<td>InputStreamReader</td>
<td>OutputStreamWriter</td>
</tr>
<tr>
<td>对象流</td>
<td>ObjectInputStream</td>
<td>ObjectOutputStream</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>FilterInputStream</td>
<td>FilterOutputStream</td>
<td>FilterReader</td>
<td>FilterWriter</td>
</tr>
<tr>
<td>打印流</td>
<td></td>
<td>PrintStream</td>
<td></td>
<td>PrintWriter</td>
</tr>
<tr>
<td>推回输入流</td>
<td>PushbackinputStream</td>
<td></td>
<td>PushbackReader</td>
<td></td>
</tr>
<tr>
<td>特殊流</td>
<td>DataInputStream</td>
<td>DataOutputStream</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="1-3-文件流"><a href="#1-3-文件流" class="headerlink" title="1.3 文件流"></a>1.3 文件流</h2><h3 id="1-3-1-FileReader读入数据的基本操作"><a href="#1-3-1-FileReader读入数据的基本操作" class="headerlink" title="1.3.1 FileReader读入数据的基本操作"></a>1.3.1 FileReader读入数据的基本操作</h3><p><strong>四步骤：</strong></p>
<ol>
<li><p>建立一个流对象，将已存在的一个文件加载进流</p>
<ul>
<li>```java<br>FileReader fr = new FileReader(new File(“Test.txt”));<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 创建一个临时存放数据的数组</span><br><span class="line"></span><br><span class="line">   - ```java</span><br><span class="line">     char[] ch = new char[1024];</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>调用流对象对象的读取方法将流中的数据读入到数组中</p>
<ul>
<li>```java<br>fr.read(ch);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 关闭资源</span><br><span class="line"></span><br><span class="line">   - ```java</span><br><span class="line">     fr.close();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><strong>使用read()方法一个字符一个字符的读取</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IoDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Files\\file1.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fileReader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line">            <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> fileReader.read();</span><br><span class="line">            <span class="keyword">while</span> (read!=-<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.print((<span class="type">char</span>)read);</span><br><span class="line">                read = fileReader.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            fileReader.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果 </span></span><br><span class="line">asdfsdfasdfsdf</span><br><span class="line">dsfsd</span><br><span class="line">cvc</span><br><span class="line">qwref</span><br></pre></td></tr></table></figure>

<p><strong>使用read(char[] chars) 方法读入数据</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readDemo2</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Files\\file1.txt&quot;</span>);</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line">        <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len=fr.read(chars))!=-<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(len);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(chars,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-2-FileWriter写出数据的操作"><a href="#1-3-2-FileWriter写出数据的操作" class="headerlink" title="1.3.2 FileWriter写出数据的操作"></a>1.3.2 FileWriter写出数据的操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writterDemo</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Files\\fileOutput.txt&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Files\\fileOutput2.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 默认 每次 write 覆盖原有文件中的内容</span></span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file,<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 指定为true时， 每次write 表示追加内容到文件中</span></span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fw2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file2,<span class="literal">true</span>);</span><br><span class="line">    fw.write(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    fw2.write(<span class="string">&quot;hello2&quot;</span>);</span><br><span class="line">    fw.close();</span><br><span class="line">    fw2.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认 每次 write 覆盖原有文件中的内容</span></span><br><span class="line">    fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file,<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 指定为true时， 每次write 表示追加内容到文件中</span></span><br><span class="line">    fw2 = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file2,<span class="literal">true</span>);</span><br><span class="line">    fw.write(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    fw2.write(<span class="string">&quot;hello2&quot;</span>);</span><br><span class="line">    fw.close();</span><br><span class="line">    fw2.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211018141242195-16345375636911.png" alt="image-20211018141242195"></p>
<h3 id="1-3-3-FileReader-和-FileWriter实现文本复制"><a href="#1-3-3-FileReader-和-FileWriter实现文本复制" class="headerlink" title="1.3.3 FileReader 和 FileWriter实现文本复制"></a>1.3.3 FileReader 和 FileWriter实现文本复制</h3><p>小需求：要求将文件<code>file1.txt</code>中的内容复制到另一个文件<code>file2.txt</code>中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyContextToOther</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">filePath1</span> <span class="operator">=</span> <span class="string">&quot;Files\\file1.txt&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">filePath2</span> <span class="operator">=</span> <span class="string">&quot;Files\\file2.txt&quot;</span>;</span><br><span class="line">    <span class="type">File</span> <span class="variable">src</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath1);</span><br><span class="line">    <span class="type">File</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath2);</span><br><span class="line">    <span class="comment">// 将 file1.txt 中的内容读到内存中</span></span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(src);</span><br><span class="line">    <span class="comment">// 将读取的数据临时存放到buffer中</span></span><br><span class="line">    <span class="type">char</span>[] buffer = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="comment">// 将file1.txt 中的内容写到file2.txt中</span></span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(target);</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((len = fr.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        fw.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    fw.close();</span><br><span class="line">    fr.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211018143034994-16345386387512.png" alt="image-20211018143034994"></p>
<h3 id="1-3-4-FileInputStream和FileOutputStream不能读取文本文件"><a href="#1-3-4-FileInputStream和FileOutputStream不能读取文本文件" class="headerlink" title="1.3.4 FileInputStream和FileOutputStream不能读取文本文件"></a>1.3.4 FileInputStream和FileOutputStream不能读取文本文件</h3><p><strong>tip:</strong></p>
<p><strong>FileInputStream</strong>和<strong>FileOutputStream</strong>不能操作像<code>.java</code>,<code>.cpp</code>,<code>.txt</code>,<code>.c</code>等文本文件，操作文本文件使用<strong>FileReader</strong>和<strong>FileWriter</strong>字符流；</p>
<p>如果是<code>.jpg</code>,<code>.mp4</code>,<code>.mp3</code>等文件使用<strong>FileInputStream</strong>和<strong>FileOutputStream</strong>字节流操作</p>
<p><font color=green>使用字节流<strong>FileInputStream</strong>和<strong>FileOutputStream</strong>操作文本文件，有可能出现乱码的问题</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用字节流操作文本文件</span></span><br><span class="line">    <span class="comment">//使用字节流FileInputStream处理文本文件，可能出现乱码。</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileInputStream</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.造文件</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Files\\file1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.造流</span></span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.读数据</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="type">int</span> len;<span class="comment">//记录每次读取的字节的个数</span></span><br><span class="line">            <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer,<span class="number">0</span>,len);</span><br><span class="line">                System.out.print(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fis != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//4.关闭资源</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>使用<strong>FileInputStream</strong>和<strong>FileOutputStream</strong>实现文件的复制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyByte</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Files\\卡通 - 4.jpg&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Files\\卡通 - 5.jpg&quot;</span>);</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file1);</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file2);</span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((len=fis.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    fos.close();</span><br><span class="line">    fis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211018145332931-16345400144173.png" alt="image-20211018145332931"></p>
<h2 id="1-4-缓冲流的使用"><a href="#1-4-缓冲流的使用" class="headerlink" title="1.4 缓冲流的使用"></a>1.4 缓冲流的使用</h2><p><img src="source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/7ce79819b9685ffc2bae685bec83b0f1.png" alt="img"></p>
<ul>
<li>缓冲流要<code>套接</code>在相应的节点流之上，根据数据操作单位可以把缓冲流分为：<ul>
<li><strong>BufferedInputStream</strong>和<strong>BufferedOutputStream</strong></li>
<li><strong>BufferedReader</strong>和<strong>BufferedWriter</strong></li>
</ul>
</li>
<li>当读取数据时，数据按块读入缓冲区，其后的读操作则直接访问缓冲区</li>
<li>当使用BufferedInputStream读取字节文件时，BufferedInputStream会一次性从文件中读取8192（8kb）,存在缓冲区中，直到缓冲区装满了，才重新从文件中读取下一个8kb的字节数组。</li>
<li>向流中写入字节时，不会直接写到文件，先写到缓冲区中直到缓冲区写满，BufferedOutputStream才会把缓冲区中的数据一次性写到文件中。使用<code>flush()</code>可以强制将缓冲区的内容全部写入到输出流中。</li>
<li>关闭流的顺序和打开流的顺序相反。只要关闭最外层流即可，关闭最外层流也会相应关闭内层节点流</li>
<li>flush()方法的使用：手动将buffer中内容写入到文件</li>
<li>如果是带缓冲区的流对象的close()方法，不但会关闭流，还会在关闭流之间刷线缓冲区，关闭后不能再写出。</li>
</ul>
<h2 id="1-5-转换流的使用"><a href="#1-5-转换流的使用" class="headerlink" title="1.5 转换流的使用"></a>1.5 转换流的使用</h2><h3 id="1-5-1-转换流概述与InputStreamReader的使用"><a href="#1-5-1-转换流概述与InputStreamReader的使用" class="headerlink" title="1.5.1 转换流概述与InputStreamReader的使用"></a>1.5.1 转换流概述与InputStreamReader的使用</h3><ul>
<li>转换流提供了在字节流和字符流之间的转换</li>
<li>Java API提供了两个转换流：<ul>
<li><code>InputStreamReader</code>：将InputStream转换成Reader<ul>
<li>实现将字节的输入流按指定字符集转换成字符的输入流</li>
<li>需要和<code>InputStream</code>套接</li>
<li>构造器<ul>
<li><code>public InputStreamReader(InpurStream in)</code></li>
<li><code>public InputStreamReader(InpurStream in, String charsetName)</code></li>
<li>例如：<code>Reader isr=new InpurStreamReader(System.in, &quot;gbk&quot;)</code></li>
</ul>
</li>
</ul>
</li>
<li><code>OutputStreamWriter</code>：将Writer转换为OutputStream<ul>
<li>实现将字符的输出流按指定字符集转换为字节的输出流</li>
<li>需要和<code>OutputStream</code>套接</li>
<li>构造器<ul>
<li><code>public OutputStreamWriter(OutputStream out)</code></li>
<li><code>public OutputStreamWriter(OutputStream out, String charsetName)</code></li>
</ul>
</li>
</ul>
</li>
<li>字节流中的数据都是字符时，转换成字符流操作更高效</li>
<li>很多时候我们使用转换流来处理文本乱码问题。实现编码和解码的功能。</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4dfa85f71b54ed2d8e3a43371933b7fb.png" alt="img"></p>
<h3 id="1-5-2-转换流实现文件的读入和写出"><a href="#1-5-2-转换流实现文件的读入和写出" class="headerlink" title="1.5.2 转换流实现文件的读入和写出"></a>1.5.2 转换流实现文件的读入和写出</h3><p><strong>InputStreamReader</strong>：将一个字节的输入流转换为字符的输入流</p>
<p><strong>OutputStreamWriter</strong>：将一个字符的输出流转换为字节的输出流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transformation</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Files\\file1.txt&quot;</span>));</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Files\\file3.txt&quot;</span>));</span><br><span class="line">    <span class="comment">// 将字节流转换成字符流</span></span><br><span class="line">    <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream);</span><br><span class="line">    <span class="comment">// 将字符流转换成字节输出流</span></span><br><span class="line">    <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream);</span><br><span class="line">    <span class="comment">// 用字符数组承接字节流转换成字符流的数据</span></span><br><span class="line">    <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((len=isr.read(chars))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 将字符流通过转换流写出到字节流FileOutputStream中</span></span><br><span class="line">        osw.write(chars,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    osw.close();</span><br><span class="line">    isr.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="1-6-其他的流的使用"><a href="#1-6-其他的流的使用" class="headerlink" title="1.6 其他的流的使用"></a>1.6 其他的流的使用</h2><h3 id="1-6-1-标准输入、输出流"><a href="#1-6-1-标准输入、输出流" class="headerlink" title="1.6.1 标准输入、输出流"></a>1.6.1 标准输入、输出流</h3><ul>
<li>System.in 和 System.out 分别代表了系统标准的输入和输出设备</li>
<li>默认输入设备是键盘；输出设备是：显示器</li>
<li>System.in 的类型方式InputStream</li>
<li>System.out的类型是PrintStream，其是OutputStream的子类FilterOutputStream的子类</li>
<li>重定向：通过System类的setln，setOut方法对默认设备进行改变。<ul>
<li><code>public static void setln(InputStream in)</code></li>
<li><code>public static void setOut(PrintStream out)</code></li>
</ul>
</li>
</ul>
<h3 id="1-6-2-打印流"><a href="#1-6-2-打印流" class="headerlink" title="1.6.2 打印流"></a>1.6.2 打印流</h3><ul>
<li>实现将基本数据类型的数据格式转化为字符串输出</li>
<li>打印流：PrintStream和PrintWriter<ul>
<li>提供了一系列重载的print()和println()方法，用于多种数据类型的输出</li>
<li>PrintStream和PrintWriter的输出不会抛出IOException异常</li>
<li>PrintStream和PrintWriter有自动flush功能</li>
<li>PrintStream打印的所有字符都使用平台的默认字符编码转换为字节。在需要写入字符而不是写入字节的情况下，应该使用PrintWriter类。</li>
<li>System.out返回的是PrintStream的实例</li>
</ul>
</li>
</ul>
<h3 id="1-6-3-数据流"><a href="#1-6-3-数据流" class="headerlink" title="1.6.3 数据流"></a>1.6.3 数据流</h3><ul>
<li>为了方便地操作Java语言的基本数据类型和String的string数据，可以使用数据流</li>
<li>数据流有两个类：（用于读取和写出基本数据类型、String类的数据）<ul>
<li>DataInputStream和DataOutputStream</li>
<li>分别“套接”在InputStream和OutputStream</li>
</ul>
</li>
</ul>
<p><strong>数据流</strong>：</p>
<ul>
<li>DataInputStream：数据输入流</li>
<li>DataOutputStream：数据输出流</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dataStreamDemoWrite</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="comment">// 数据流 可以读取特定类型的数据，可以写特定的数据类型的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Files\\data.txt&quot;</span>)));</span><br><span class="line">    dos.writeChar(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">    dos.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">    dos.writeDouble(<span class="number">2.0798654</span>);</span><br><span class="line">    dos.writeLong(<span class="number">123456789L</span>);</span><br><span class="line">    dos.flush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dataStreamDemoReade</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Files\\data.txt&quot;</span>)));</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> dis.readChar();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> dis.readBoolean();</span><br><span class="line">    <span class="type">double</span> <span class="variable">v</span> <span class="operator">=</span> dis.readDouble();</span><br><span class="line">    <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> dis.readLong();</span><br><span class="line">    System.out.println(c+<span class="string">&quot;\t&quot;</span>+b+<span class="string">&quot;\t&quot;</span>+v+<span class="string">&quot;\t&quot;</span>+l+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="1-7-对象流"><a href="#1-7-对象流" class="headerlink" title="1.7 对象流"></a>1.7 对象流</h2><h3 id="1-7-1-对象序列化机制的理解"><a href="#1-7-1-对象序列化机制的理解" class="headerlink" title="1.7.1 对象序列化机制的理解"></a>1.7.1 对象序列化机制的理解</h3><ul>
<li><code>ObjectInputStream</code>和<code>ObjectOutputStream</code></li>
<li>用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。</li>
<li>序列化：用<code>ObjectInputStream</code>类读取基本类型数据或对象的机制</li>
<li>反序列化：用<code>ObjectInputStream</code>类读取基本类型数据或对象的机制</li>
<li><code>ObjectOutputStream</code>和<code>ObjectInputStream</code>不能序列化<code>static</code>和<code>transient</code>修饰的成员变量</li>
<li>对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其他程序获取这种二进制流，就可以恢复原来的Java对象。</li>
<li>序列化的好处在于可将任何实现了<code>Serializable</code>接口的对象转化为字节数据，使其在保存和传输时刻被还原</li>
<li>序列化是RMI（Remote Method Invoke-远程方法调用）过程的参数和返回值都必须实现的机制，而RMI是JavaEE的基础。因此序列化机制是JavaEE平台的基础</li>
<li>如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一。否则，会抛出<code>NotSerializableException</code>异常<ul>
<li><code>Serializable</code></li>
<li><code>Externalizable</code></li>
</ul>
</li>
</ul>
<h3 id="1-7-2-对象流序列化与反序列化字符串操作"><a href="#1-7-2-对象流序列化与反序列化字符串操作" class="headerlink" title="1.7.2 对象流序列化与反序列化字符串操作"></a>1.7.2 对象流序列化与反序列化字符串操作</h3><p>定义一个Person类，并实现<code>Serializable</code>接口，实现系列化功能，</p>
<p>通过<code>ObjectOutputStream</code>将Person对象写入到<code>person.dat</code>文件中，然后通过<code>ObjectInputStream</code>将person读回内存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化与反序列化</span></span><br><span class="line"><span class="comment">     *  实现Serializable接口，即可将对象通过ObjectOutputStream存储到磁盘中</span></span><br><span class="line"><span class="comment">     *                              通过ObjectInputStream读取到内存中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serializableDemo</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Files\\person.dat&quot;</span>)));</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;yu&quot;</span>, <span class="number">25</span>);</span><br><span class="line">    oos.writeObject(person);</span><br><span class="line"></span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Files\\person.data&quot;</span>)));</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> (Person)ois.readObject();</span><br><span class="line">    System.out.println(person1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-7-3-serialVersionUID的理解"><a href="#1-7-3-serialVersionUID的理解" class="headerlink" title="1.7.3 serialVersionUID的理解"></a>1.7.3 serialVersionUID的理解</h3><ul>
<li>凡是实现<code>Serializable</code>接口的类都有一个表示序列化版本标识符的静态变量<ul>
<li><code>private static final long serialVersionUID</code></li>
<li><code>serialVersionUID</code>用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容</li>
<li>如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实力变量做了修改，<code>serialVersionUID</code>可能发生变化，故建议显示声明</li>
</ul>
</li>
<li>简单来说，Java的序列化机制是通过在运行时判断类的<code>serialVersionUID</code>来验证版本一致的。在进行反序列化时，JVM会把传来的字节流中的<code>serialVersionUID</code>与本地相应实体类的<code>serialVersionUID</code>进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常（InvalidCastException）</li>
</ul>
<p>如果想要一个类的对象可序列化，除了实现<code>Serializable</code>接口之外，还必须保证其内部所有的属性也必须是可序列化的。（默认情况下，基本数据类型都可序列化）</p>
<p>一般情况下需要自定义<code>serialVersionUID</code></p>
<blockquote>
<p><strong>序列化机制</strong></p>
<p>对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其他程序获取了这种二进制流，就可以恢复成原来的Java对象。</p>
</blockquote>
<h2 id="1-8-RandomAccessFile-随机存取文件流-的使用"><a href="#1-8-RandomAccessFile-随机存取文件流-的使用" class="headerlink" title="1.8 RandomAccessFile(随机存取文件流)的使用"></a>1.8 RandomAccessFile(随机存取文件流)的使用</h2><ul>
<li><code>RandomAccessFile</code>声明在<code>java.io</code>包下，但直接继承于<code>java.lang.Object</code>类。并且它实现了<code>DataInput、DataOutput</code>这两个接口，也就意味着这个类<strong>既可以读也可以写</strong></li>
<li><code>RandomAccessFile</code>类支持“随机访问”的方式，程序可以直接跳到文件的任意地方来读、写文件<ul>
<li>支持只访问文件的部分内容</li>
<li>可以向已存在的文件后追加内容</li>
</ul>
</li>
<li><code>RandomAccessFile</code>对象包含一个记录指针，用以表示单签读写处的位置。<code>RandomAccessFile</code>类对象可以自己移动记录指针：<ul>
<li><code>long getFilePointer()</code></li>
<li><code>void seek(long pos)</code></li>
</ul>
</li>
<li>构造器<ul>
<li><code>public RandomAccessFile(File file, String mode)</code></li>
<li><code>public RandomAccessFile(String name, String mode)</code></li>
</ul>
</li>
<li>创建RandomAccessFile类实例需要指定一个mode参数，该参数指定RandomAccessFile的访问模式：<ul>
<li><code>r</code>：以只读方式打开</li>
<li><code>rw</code>：打开以便读取和写入</li>
<li><code>rwd</code>：打开以便读取和写入；同步文件内容的更新</li>
<li><code>rws</code>：打开以便读取和写入；同步文件内容和元数据的更新</li>
</ul>
</li>
<li>如果模式为只读<code>r</code>，则不会创建文件，而是会去读取一个已经存在的文件，如果读取的文件不存在则会出现异常。如果模式为<code>rw</code>读写，如果文件不存在则去创建文件，如果存在则不会创建。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RandomAccessFile的使用</span></span><br><span class="line"><span class="comment"> * 1.RandomAccessFile直接继承于java.lang.Object类，实现了DataInput和DataOutput接口</span></span><br><span class="line"><span class="comment"> * 2.RandomAccessFile既可以作为一个输入流，又可以作为一个输出流</span></span><br><span class="line"><span class="comment"> * 3.如果RandomAccessFile作为输出流时，写出到的文件如果不存在，则在执行过程中自动创建。</span></span><br><span class="line"><span class="comment"> *   如果写出到的文件存在，则会对原有文件内容进行覆盖。（默认情况下，从头覆盖）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomAccessFileTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">raf1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">raf2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            raf1 = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;爱情与友情.jpg&quot;</span>),<span class="string">&quot;r&quot;</span>);</span><br><span class="line">            raf2 = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;爱情与友情1.jpg&quot;</span>),<span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = raf1.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                raf2.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(raf1 != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    raf1.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(raf2 != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    raf2.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">raf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;hello.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">        raf1.write(<span class="string">&quot;xyz&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        raf1.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RandomAccessFile实现数据的插入（seek()方法会重置偏移量）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RandomAccessFile的使用</span></span><br><span class="line"><span class="comment"> * 1.RandomAccessFile直接继承于java.lang.Object类，实现了DataInput和DataOutput接口</span></span><br><span class="line"><span class="comment"> * 2.RandomAccessFile既可以作为一个输入流，又可以作为一个输出流</span></span><br><span class="line"><span class="comment"> * 3.如果RandomAccessFile作为输出流时，写出到的文件如果不存在，则在执行过程中自动创建。</span></span><br><span class="line"><span class="comment"> *   如果写出到的文件存在，则会对原有文件内容进行覆盖。（默认情况下，从头覆盖）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 4.可以通过相关的操作，实现RandomAccessFile“插入”数据的效果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomAccessFileTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用RandomAccessFile实现数据的插入效果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">raf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;hello.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">        raf1.seek(<span class="number">3</span>);<span class="comment">//将指针调到角标为3的位置</span></span><br><span class="line">        <span class="comment">//保存指针3后面的所有数据到StringBuilder中</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>((<span class="type">int</span>) <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>).length());</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = raf1.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            builder.append(<span class="keyword">new</span> <span class="title class_">String</span>(buffer,<span class="number">0</span>,len)) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调回指针，写入“xyz”</span></span><br><span class="line">        raf1.seek(<span class="number">3</span>);</span><br><span class="line">        raf1.write(<span class="string">&quot;xyz&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将StringBuilder中的数据写入到文件中</span></span><br><span class="line">        raf1.write(builder.toString().getBytes());</span><br><span class="line"></span><br><span class="line">        raf1.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//思考：将StringBuilder替换为ByteArrayOutputStream</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-9-Path、Paths、Files的使用"><a href="#1-9-Path、Paths、Files的使用" class="headerlink" title="1.9 Path、Paths、Files的使用"></a>1.9 Path、Paths、Files的使用</h2><h1 id="2-网络编程"><a href="#2-网络编程" class="headerlink" title="2. 网络编程"></a>2. 网络编程</h1><h3 id="2-1-网络编程概述"><a href="#2-1-网络编程概述" class="headerlink" title="2.1 网络编程概述"></a>2.1 网络编程概述</h3><ul>
<li>Java是Internet上的语言，它从语言级上提供了对网络应用程序的支持，程序员能够很容易开发常见的网络应用程序。</li>
<li>Java提供的网络类库，可以实现无痛的网络连接，联网的底层细节被隐藏在Java的本机安装系统中，有JVM进行控制。并且Java实现了一个跨平台的网络库，<strong>程序面对的是一个统一的网络编程环境</strong>。</li>
<li>网络编程的目的：直接或间接地通过网络协议与其它计算机实现数据交换，进行通讯</li>
<li>网络编程中有两个主要的问题：<ul>
<li>如果准确地定位网络上一台或多台主机；定位主机上的特定的应用</li>
<li>找到主机后如何可靠高效地进行数据传输</li>
</ul>
</li>
</ul>
<h3 id="2-2-网络通信要素概述"><a href="#2-2-网络通信要素概述" class="headerlink" title="2.2 网络通信要素概述"></a>2.2 网络通信要素概述</h3><ul>
<li>通信双方地址<ul>
<li>IP</li>
<li>端口号</li>
</ul>
</li>
<li>一定的规则（即：网络通信协议。有两套参考模型）<ul>
<li>OSI参考模型：模型过于理想化，未能在因特网上进行广泛推广</li>
<li>TCP/IP参考模型（或TCP/IP协议）：实事上的国际标准</li>
</ul>
</li>
<li>网络通信协议</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/09bdce6b569fe3cf80206cc704dbf7cb.png" alt="img"></p>
<p><img src="source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/e769997523201f9fa4f83e501931e6e1.png" alt="img"></p>
<blockquote>
<p>网络编程中有两个主要的问题：</p>
<ol>
<li>如何准确地定位网络上一台或多台主机；定位主机上的特定的应用</li>
<li>找到主机后如何可靠高效地进行数据传输</li>
</ol>
<p>网络编程中的两个要素：</p>
<ol>
<li>对应问题1：IP和端口号</li>
<li>对应问题2：提供网络通信协议：TCP/IP参考模型（应用层、传输层、网络层、物理+数据链路层）</li>
</ol>
</blockquote>
<h3 id="2-3-通信要素1：IP和端口号"><a href="#2-3-通信要素1：IP和端口号" class="headerlink" title="2.3 通信要素1：IP和端口号"></a>2.3 通信要素1：IP和端口号</h3><h4 id="2-3-1-IP的理解与InetAddress类的实例化"><a href="#2-3-1-IP的理解与InetAddress类的实例化" class="headerlink" title="2.3.1 IP的理解与InetAddress类的实例化"></a>2.3.1 IP的理解与InetAddress类的实例化</h4><ul>
<li>IP地址：<code>InetAddress</code><ul>
<li>唯一的表示Internet上的计算机（通信实体）</li>
<li>本地回环地址（hostAddress）：127.0.01 主机名（hostName）：localhost</li>
<li>IP地址分类方式1：IPV4和IPV6<ul>
<li>IPV4：由4个字节组成</li>
<li>IPV6：由16个字节组成</li>
</ul>
</li>
<li>IP地址分类方式2：公网地址（万维网使用）和私有地址（局域网使用）。<code>192.168. . </code>开头的就是私有地址，范围即为<code>192.168.0.0 ~ 192.168.255.255</code>，专门为组织内部使用。</li>
</ul>
</li>
<li>Internet上的主机有两种方式表示：<ul>
<li>域名（hostName）：<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a></li>
<li>IP地址（hostAddress）：220.181.38.149</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">    <span class="type">InetAddress</span> <span class="variable">inetAddress</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">    System.out.println(inetAddress);</span><br><span class="line">    <span class="comment">// 获取本地ip</span></span><br><span class="line">    System.out.println(InetAddress.getLocalHost());</span><br><span class="line">    <span class="comment">// 获取主机名</span></span><br><span class="line">    System.out.println(inetAddress.getHostName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">www.baidu.com/<span class="number">220.181</span><span class="number">.38</span><span class="number">.149</span></span><br><span class="line">DESKTOP-AQE9VH2/<span class="number">192.168</span><span class="number">.70</span><span class="number">.1</span></span><br><span class="line">www.baidu.com</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-端口号的理解"><a href="#2-3-2-端口号的理解" class="headerlink" title="2.3.2 端口号的理解"></a>2.3.2 端口号的理解</h4><ul>
<li>端口号表示正在计算机上运行的进程（程序）<ul>
<li>不同的进程有不同的端口号</li>
<li>被规定为一个16位的整数<code>0~65535</code></li>
<li>端口分类：<ul>
<li>公认端口：<code>0~1023</code>.被预先定义的服务通信占用（如：HTTP占用端口80，FTP占用端口21，Telnet占用端口23）</li>
<li>注册端口：<code>1024~49151</code>.分配给用户进程或应用程序。（如：Tomcat占用端口8080，MySQL占用端口3306，Oracle占用端口1521等）。</li>
<li>动态/私有端口：49152~65535.</li>
</ul>
</li>
</ul>
</li>
<li>端口号与IP地址的组合得出一个网络套接字：<code>Socket</code></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/cdbda7a9127a6319dcd57cc16be48849.png" alt="img"></p>
<h3 id="2-4-通信要素2：网络协议"><a href="#2-4-通信要素2：网络协议" class="headerlink" title="2.4 通信要素2：网络协议"></a>2.4 通信要素2：网络协议</h3><ul>
<li><p><strong>网络通信协议</strong></p>
<p>计算机网络中实现通信必须有一些约定，即通信协议，对速率，传输代码，代码结构，传输控制步骤，出错控制等制定标准。</p>
</li>
<li><p><strong>问题：网络协议太复杂</strong></p>
<p>计算机网络通信设计内容很多，比如指定源地址和目标地址，加密解密，压缩解压缩，差错控制，流量控制，路由控制等</p>
</li>
<li><p><strong>通信协议分层的思想</strong></p>
<p>在制定协议时，把复杂问题分解成一些简单的成分，再将他们复合起来。最常用的复合方式使层次方式，即同层间可以通信，上一层可以调用下一层，而与再下一层不发生关系。各层互不影响，利于系统的开发和扩展。</p>
</li>
</ul>
<h4 id="2-4-1-TCP和UDP网络通信协议的对比"><a href="#2-4-1-TCP和UDP网络通信协议的对比" class="headerlink" title="2.4.1 TCP和UDP网络通信协议的对比"></a>2.4.1 TCP和UDP网络通信协议的对比</h4><ul>
<li>传输层协议中有两个非常重要的协议：<ul>
<li>传输控制协议TCP</li>
<li>用户数据报协议UDP</li>
</ul>
</li>
<li>TCP/IP以其两个主要协议：传输控制协议（TCP）和网络互联协议（IP）而得名，实际上是一组协议，包括多个具有不同功能互为关联的协议。</li>
<li>IP协议是网络层的主要协议，支持网络间互连的数据通信</li>
<li>TCP/IP协议模型从更实用的角度出发，形成了高效的四层体系结构，即物理层、数据链路层、IP层、传输层T、应用层。</li>
<li>TCP协议：<ul>
<li>使用TCP协议前，需先建立TCP连接，形传输数据通道</li>
<li>传输前，采用“三次握手”方式，点对点通信，是可靠的</li>
<li>TCP协议进行通信的两个应用进程：客户端、服务端</li>
<li>在连接中进行大数据量的传输，传输完毕，需释放已建立的连接，效率低</li>
</ul>
</li>
<li>UDP协议：<ul>
<li>将数据、源、目的封装成数据包，不需要建立连接</li>
<li>每个数据报的大小限制在64K内</li>
<li>发送不管对方是否准备好，接收方收到也不确认，故是不可靠的</li>
<li>可以广播发送</li>
<li>发送数据结束时无需释放资源，开销小，速度快。</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e028a11c223c41376e42a0cecd7dc505.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/3125b3b4a4431912fa787bbeaea342b6.png" alt="img"></p>
<h3 id="2-5-TCP网络编程"><a href="#2-5-TCP网络编程" class="headerlink" title="2.5 TCP网络编程"></a>2.5 TCP网络编程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Client端 向 服务器端 发送数据</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// client 端 发送消息</span></span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建Socket对象，指明服务器端的ip和端口</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;192.168.137.237&quot;</span>);</span><br><span class="line">        socket = <span class="keyword">new</span> <span class="title class_">Socket</span>(inet, <span class="number">8899</span>);</span><br><span class="line">        <span class="comment">// 2. 获取一个输出流，用于输出数据</span></span><br><span class="line">        os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 3. 写出数据</span></span><br><span class="line">        os.write(<span class="string">&quot;hello world !&quot;</span>.getBytes());</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(os!=<span class="literal">null</span>)&#123;</span><br><span class="line">            os.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(socket!=<span class="literal">null</span>)&#123;</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Server端接收Client端发送来的数据</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// server 端 接收消息</span></span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 1. 创建服务器端的ServerSocket，指明自己的端口号</span></span><br><span class="line">    ss = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8899</span>);</span><br><span class="line">    <span class="comment">//2. 调用accept()表示接收来自客户端的socket</span></span><br><span class="line">    socket = ss.accept();</span><br><span class="line">    <span class="comment">// 3. 获取输入流    获取输出流的时候，会阻塞，等待Client端 给服务器端发送数据</span></span><br><span class="line">    is = socket.getInputStream();</span><br><span class="line">    <span class="comment">// 4. 读取输入流中的数据</span></span><br><span class="line">    baos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((len=is.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        baos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;收到来自：&quot;</span>+socket.getInetAddress().getHostAddress()+<span class="string">&quot;的数据&quot;</span>);</span><br><span class="line">    System.out.println(baos.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>TCP网络编程：从客户端发送文件给服务端，服务端保存到本地，并返回“发送成功”给客户端。并关闭相应的连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client2</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1. 客户端向服务端发送一张图片， 等待服务端接收完毕后返回 接收成功！ 信息</span></span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9090</span>);</span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Files\\卡通 - 4.jpg&quot;</span>));</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((len=fis.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 从文件中读取的数据写入到到socket输出流中</span></span><br><span class="line">        os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭socket数据的输出</span></span><br><span class="line">    socket.shutdownOutput();</span><br><span class="line">    <span class="comment">// 接收服务器端的数据，并显示到控制台上</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">    <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">    buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((len=is.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        baos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(baos.toString());</span><br><span class="line">    fis.close();</span><br><span class="line">    os.close();</span><br><span class="line">    socket.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server2</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9090</span>);</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Files\\图片1.jpg&quot;</span>));</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((len=is.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;服务器端接收数据完毕&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给客户端进行反馈</span></span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">    os.write(<span class="string">&quot;照片服务器端已经接收完毕&quot;</span>.getBytes());</span><br><span class="line">    os.close();</span><br><span class="line">    fos.close();</span><br><span class="line">    is.close();</span><br><span class="line">    socket.close();</span><br><span class="line">    ss.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-6-UDP网络编程"><a href="#2-6-UDP网络编程" class="headerlink" title="2.6 UDP网络编程"></a>2.6 UDP网络编程</h3><ul>
<li>类<strong>DatagramSocket</strong>和<strong>DatagramPacket</strong>实现了基于UDP协议网络程序。</li>
<li>UDP数据报通过数据报套接字DatagramSocket发送和接收，系统不保证UDP数据包一定能够安全送到目的地，也不能确定什么时候可以抵达</li>
<li>DatagramPacket对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号。</li>
<li>UDP协议中每个数据报都给出了完整的地址信息，因此无需建立发送方和接收方的连接。如同发快递包裹一样。</li>
<li>流程<ol>
<li>DatagramSocket与DatagramPacket</li>
<li>建立发送端，接收端</li>
<li>建立数据包</li>
<li>调用Socket的发送、接收方法</li>
<li>关闭Socket</li>
</ol>
</li>
</ul>
<blockquote>
<p>发送端与接收端是两个独立的运行程序</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">udpSend</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;我是UDP发送端&quot;</span>;</span><br><span class="line">    <span class="type">byte</span>[] data = str.getBytes();</span><br><span class="line">    <span class="type">InetAddress</span> <span class="variable">inetAddress</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">    <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data,<span class="number">0</span>,data.length,inetAddress,<span class="number">9090</span>);</span><br><span class="line">    socket.send(packet);</span><br><span class="line">    socket.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">udpReceive</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9090</span>);</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer,<span class="number">0</span>,buffer.length);</span><br><span class="line">    socket.receive(packet);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(),<span class="number">0</span>,packet.getLength()));</span><br><span class="line">    socket.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-7-URL编程"><a href="#2-7-URL编程" class="headerlink" title="2.7 URL编程"></a>2.7 URL编程</h3><p>URL网络编程实现数据下载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">urlDemo</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">HttpURLConnection</span> <span class="variable">urlConnection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;https://pic2.zhimg.com/80/v2-576df7c2088825cc388a4a8f74f8b2ed_720w.jpg&quot;</span>);</span><br><span class="line">    urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line">    urlConnection.connect();</span><br><span class="line">    is = urlConnection.getInputStream(); <span class="comment">// 得到输入流</span></span><br><span class="line">    fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Files\\spark.jpg&quot;</span>));</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        fos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;图片下载完成&quot;</span>);</span><br><span class="line">    fos.close();</span><br><span class="line">    is.close();</span><br><span class="line">    urlConnection.disconnect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="3-NIO"><a href="#3-NIO" class="headerlink" title="3. NIO"></a>3. NIO</h1><h2 id="3-1-Java-NIO-概述"><a href="#3-1-Java-NIO-概述" class="headerlink" title="3.1 Java NIO 概述"></a>3.1 Java NIO 概述</h2><h3 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h3><p>通常在进行同步I/O操作时，如果读取数据，代码会阻塞直至有可提供读取的数据。同样，写入调用将会阻塞直至数据能够写入。传统的Server/Client模式会基于（TPR：Thread per Request），服务器会为每个客户端请求建立一个线程，由该线程单独负责处理一个客户请求。这种模式带来的一个问题就是线程数量的剧增，大量的线程会增大服务器的开销。大多数的实现为了避免这个问题，都采用了线程池模型，并设置线程池线程的最大数量，这又带来了新的问题，如果线程池中有100个线程，而有100个用户都在进行大文件下载，会导致第101个用户的请求无法及时处理，即便第101个用户只想请求一个几kb大小的页面。传统的Server/Client模式如图所示：</p>
<p><img src="source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211020210801147-16347352859511.png" alt="image-20211020210801147"></p>
<h3 id="非阻塞IO（NIO）"><a href="#非阻塞IO（NIO）" class="headerlink" title="非阻塞IO（NIO）"></a>非阻塞IO（NIO）</h3><p>NIO中非阻塞I/O采用了基于Reactor模式的工作方式，I/O调用不会被阻塞，相反是注册感兴趣的特定I/O事件，如可读数据到达，新的套接字连接等等，在发生特定事件时，系统再通知我们。NIO中实现非阻塞I/O的核心对象就是Selector，Selector就是注册各种I/O事件地方，而且当我们感兴趣的事件发生时，就是这个对象告诉我们所发生的时间。</p>
<p><img src="source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211020211145095-16347355066182.png" alt="image-20211020211145095"></p>
<p>当有读或写等任何注册的时间发生时，可以从Selector中获得相应的SelectionKey，同时SelectionKey中可以找到发生的事件和该事件所发生的具体的SelectableChannel，以获得客户端发送过来的数据。</p>
<p>非阻塞指的是IO时间本身不阻塞，但是获取IO事件的select()方法是需要阻塞等待的。区别是阻塞的IO会阻塞IO操作上，NIO阻塞在事件获取上，没有事件就没有IO，从高层次看IO就不阻塞了。也就是说只有IO已经发生那么我们才评估IO是否阻塞，但是select()阻塞的时候IO还没有发生，何谈IO的阻塞呢？NIO的本质是延迟IO操作到真正发生IO的时候，而不是以前的只要IO流打开了就一直等到IO操作。</p>
<table>
<thead>
<tr>
<th>IO</th>
<th>NIO</th>
</tr>
</thead>
<tbody><tr>
<td>面向流(Stream Oriented)</td>
<td>面向缓冲区（Buffer Oriented）</td>
</tr>
<tr>
<td>阻塞IO（Blocking IO）</td>
<td>非阻塞IO（Non Blocking IO）</td>
</tr>
<tr>
<td>无</td>
<td>选择器（Selectors）</td>
</tr>
</tbody></table>
<p>Java的NIO由以下几个核心部分组成：</p>
<ul>
<li><p>Channels</p>
<ul>
<li><blockquote>
<p>NIO中的Channel和 IO中的Stream(流)是差不多一个等级的。只不过Stream是单向的，譬如：<strong>InputStream</strong>，<strong>OutputStream</strong>。而<strong>Channel</strong>是双向的，<strong>即可以用来进行读操作，又可以用来进行写操作</strong>。</p>
<p>NIO中的Channel的主要实现有：FileChannel，DatagramChannel，SocketChannel和ServerSocketChannel，分别对应文件IO，UDP和TCP（Server和Client）</p>
</blockquote>
</li>
</ul>
</li>
<li><p>Buffers</p>
<ul>
<li><blockquote>
<p>NIO中的关键实现有：ByteBuffer，CharBuffer，DoubleBuffer，FloatBuffer，IntBuffer，LongBuffer，ShortBuffer，分别对应基本数据类型：byte，char，double，float，int，long，short。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>Selectors</p>
<ul>
<li><blockquote>
<p>Selector运行单线程处理多个Channel，如果你的应用打开了多个通道，但每个连接的流量都很低，使用Selector就会很方便。例如在一个聊天服务器中。要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法就会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子就如新的连接进行，数据接收等。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>虽然Java NIO中除此之外还有很多类和组件，但Channel，Buffer和Selector构成了核心的API。其他组件，如Pipe和FileLock，只不过是与三个核心组件共同使用的工具类。</p>
<h2 id="3-2-Channel"><a href="#3-2-Channel" class="headerlink" title="3.2 Channel"></a>3.2 Channel</h2><p>Channel是一个通道，可以通过它读取和写入数据，它就像水管一样，网络数据通过Channel读取和写入。通道与流的不同之处在于通道是双向的，流只是在一个方向移动（一个流必须是InputStream或者OutputStream的子类），而且通道可以用于读，写或者同时用于读写。因为Channel是全双工的，所以它可以比流更好地映射底层操作系统的API。</p>
<p>NIO中通过Channel封装了数据源的操作，通过channel我们可以操作数据源，但又不必关系数据源的具体物理结构。这个数据源可能是多种的。比如：可以是文件，也可以是socket。在大多数应用中，Channel与文件描述或者socket是一一对应的。<strong>Channel用于在字节缓冲区和位于通道另一侧的实体</strong>（通常是一个文件或套接字）之间有效地传输数据。</p>
<p>与缓冲区不同，通道API主要由接口指定。不同的操作系统上通道实现（Channel Implementation）会有根本性的差异，所以通道API仅仅描述了可以做什么。因此很自然地，通道实现经常使用操作系统的本地代码。通道接口允许您以一种受控且可移植的方式来访问底层的I/O服务。</p>
<p>Channel是一个对象，可以通过它读取和写入数据。拿NIO与原来的I/O做个比对，通道就像是流。所有数据都通过<strong>Buffer</strong>对象来处理。您永远不会将字节直接写入同道中人，相反，您是将数据写入包含一个或者多个字节的缓冲区。同样，您不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。</p>
<p><strong>Java NIO的通道类似流，但又有些不同：</strong></p>
<ul>
<li>既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。</li>
<li>通道可以异步地读写</li>
<li>通道中的数据总是要先读到一个<strong>Buffer</strong>，或者总是要从一个<strong>Buffer</strong>中写入。</li>
</ul>
<p>如图所示：从通道读数据到缓冲区；从缓冲区写入数据到通道</p>
<p><img src="source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/png2.png"></p>
<h3 id="Channel-的实现"><a href="#Channel-的实现" class="headerlink" title="Channel 的实现"></a>Channel 的实现</h3><p>下面是Java IO 中最重要的Channel的实现：</p>
<ul>
<li><strong>FileChannel</strong><ul>
<li>FileChannel从文件中读写数据</li>
</ul>
</li>
<li><strong>DatagramChannel</strong><ul>
<li>DatagramChannel能通过UDP读写网络中的数据</li>
</ul>
</li>
<li><strong>SocketChannel</strong><ul>
<li>SocketChannel能通过TCP读写网络中的数据</li>
</ul>
</li>
<li><strong>ServerSocketChannel</strong><ul>
<li>ServerSocketChannel可以监听新进来的TCP连接，像Web服务器那样，对每一个新进来的连接都会创建一个SocketChannel。</li>
</ul>
</li>
</ul>
<h4 id="FileChannel-操作详解"><a href="#FileChannel-操作详解" class="headerlink" title="FileChannel 操作详解"></a>FileChannel 操作详解</h4><h5 id="FileChannel介绍和示例"><a href="#FileChannel介绍和示例" class="headerlink" title="FileChannel介绍和示例"></a>FileChannel介绍和示例</h5><p>FileChannel类可以实现常用的read，write以及scatter/gather操作，同时它也提供了很多专用于文件的新方法。这些方法中的许多都是我们所熟悉的文件操作。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>int read(ByteBuffer dst)</strong></td>
<td><strong>从Channel中读取数据到ByteBuffer</strong></td>
</tr>
<tr>
<td><strong>long read(ByteBuffer[] dsts)</strong></td>
<td><strong>将Channel中的数据“分散”到ByteBuffer[]</strong></td>
</tr>
<tr>
<td><strong>int write(ByteBuffer src)</strong></td>
<td><strong>将ByteBuffer中的数据写入到Channel</strong></td>
</tr>
<tr>
<td><strong>long write(ByteBuffer[] srcs)</strong></td>
<td><strong>将ByteBuffer[]中的数据“聚集”到Channel</strong></td>
</tr>
<tr>
<td>long position()</td>
<td>返回此通道的文件位置</td>
</tr>
<tr>
<td>FileChannel position(long p)</td>
<td>设置此通道的文件位置</td>
</tr>
<tr>
<td>long size()</td>
<td>返回此通道的文件的当前大小</td>
</tr>
<tr>
<td>FileChannel truncate(long s)</td>
<td>将此通道的文件截取为给定大小</td>
</tr>
<tr>
<td>void force(boolean metaData)</td>
<td>强制将所有对此通道的文件更新写入到存储设备中</td>
</tr>
</tbody></table>
<p><strong>FileChannel Demo</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileChannelDemo1</span> &#123;</span><br><span class="line">    <span class="comment">// FileChannel 读取数据到buffer中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建FileChannel</span></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">aFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;Files\\data.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> aFile.getChannel();</span><br><span class="line">        <span class="comment">// 2. 创建Buffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 读取数据到buffer中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">byteReads</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((byteReads=fileChannel.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;读取了：&quot;</span>+byteReads);</span><br><span class="line">            <span class="comment">// 读写反转，重置缓冲区的position</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="keyword">while</span> (buffer.hasRemaining())&#123;</span><br><span class="line">                System.out.print((<span class="type">char</span>)buffer.get());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// buffer 中的数据读取完成后 清空</span></span><br><span class="line">            System.out.println();</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭channel</span></span><br><span class="line">        aFile.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;结束了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Buffer通常的操作</strong></p>
<ul>
<li>将数据写入缓冲区</li>
<li>调用<code>buffer.flip()</code>反转读写模式</li>
<li>从缓冲区读取数据</li>
<li>调用<code>buffer.clear()</code>或<code>buffer.compact()</code>清除缓冲区内容</li>
</ul>
<h5 id="1-打开FileChannel"><a href="#1-打开FileChannel" class="headerlink" title="1.  打开FileChannel"></a>1.  打开FileChannel</h5><p>在使用<strong>FileChannel</strong>之前，必须先打开它。但是，无法直接打开一个FileChannel，需要通过使用一个InputStream、OutputStream或RandomAccessFile来获取一个FileChannel实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">aFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;Files\\data.txt&quot;</span>);</span><br><span class="line"><span class="type">FileChannle</span> <span class="variable">fileChannel</span> <span class="operator">=</span> aFile.getChannel();</span><br></pre></td></tr></table></figure>

<h5 id="2-从FileChannel读取数据"><a href="#2-从FileChannel读取数据" class="headerlink" title="2. 从FileChannel读取数据"></a>2. 从FileChannel读取数据</h5><p>使用FileChannel.read()方法从FileChannel中读取数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">byteRead</span> <span class="operator">=</span> fileChannel.read(buffer);</span><br></pre></td></tr></table></figure>

<p>首先分配一个Buffer。从FileChannel中读取的数据将被读取到Buffer中。然后，调用FileChannel.read()方法。该方法将数据从FileChannel读取到Buffer中。read()方法返回的int值表示有多少字节被读取到了Buffer中。如果返回-1，表示到了文件末尾。</p>
<h5 id="3-向FileChannel写数据"><a href="#3-向FileChannel写数据" class="headerlink" title="3. 向FileChannel写数据"></a>3. 向FileChannel写数据</h5><p>使用FileChannel.write()方法向FileChannel中写数据，该方法的参数是一个Buffer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeDemo</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">aFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Files\\data2.txt&quot;</span>),<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> aFile.getChannel();</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;new String to write file ........ !&quot;</span>+System.currentTimeMillis();</span><br><span class="line">    byteBuffer.clear();</span><br><span class="line">    byteBuffer.put(data.getBytes());</span><br><span class="line">    <span class="comment">// 将Buffer中的数据写入到Channel中，需要从buffer中读取数据，put的时候，buffer为写的模式，需要反转buffer的读写模式</span></span><br><span class="line">    <span class="comment">// todo 换言之，读 或者 写 之后的 写 或者 读 操作之前需要转换一下 buffer 的读写模式</span></span><br><span class="line">    byteBuffer.flip();</span><br><span class="line">    <span class="keyword">while</span>(byteBuffer.hasRemaining())&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;写入中。。。&quot;</span>);</span><br><span class="line">        fileChannel.write(byteBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭通道</span></span><br><span class="line">    fileChannel.close();</span><br><span class="line">    aFile.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：FileChannel.write()是在while循环中调用的。因为无法保证write()方法一次能向FileChannel写入多少字节，因此需要重复调用write()方法，直到Buffer中已经没有尚未写入通道的字节。</p>
<h5 id="4-关闭FileChannel"><a href="#4-关闭FileChannel" class="headerlink" title="4. 关闭FileChannel"></a>4. 关闭FileChannel</h5><p>用完FileChannel后必须将其关闭</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fileChannel.close();</span><br></pre></td></tr></table></figure>

<h5 id="5-FileChannel的position方法"><a href="#5-FileChannel的position方法" class="headerlink" title="5. FileChannel的position方法"></a>5. FileChannel的position方法</h5><p>有时可能需要在<strong>FileChannel</strong>的某个特定位置进行数据的读/写操作。可以通过调用<strong>position()<strong>方法获取</strong>FileChannel</strong>的当前位置。也可以通过调用<strong>position(long pos)</strong> 方法设置<strong>FileChannel</strong>的当前位置。</p>
<p>例子：</p>
<ul>
<li><code>long pos = channel.position();</code></li>
<li><code>channel.position(pos+123);</code></li>
</ul>
<p>如果将位置设置在文件结束符之后，然后试图从文件通道中读取数据，读方法将返回<code>-1</code>（文件结束标志）。</p>
<p>如果将位置设置在文件结束符之后，然后向通道中写数据，文件将撑大到当前位置并写入数据。这可能导致“<font color=red>文件空洞</font>”，磁盘上物理文件中写入的数据间有空隙。</p>
<h5 id="6-FileChannel的size方法"><a href="#6-FileChannel的size方法" class="headerlink" title="6. FileChannel的size方法"></a>6. FileChannel的size方法</h5><p>FileChannel实例的size()方法将返回该示例所关联文件的大小。如：</p>
<p><code>long fileSize = channel.size();</code></p>
<h5 id="7-FileChannel-的-truncate方法"><a href="#7-FileChannel-的-truncate方法" class="headerlink" title="7. FileChannel 的 truncate方法"></a>7. FileChannel 的 truncate方法</h5><p>可以使用<code>FileChannel.truncate()</code>方法截取一个文件。截取文件时，文件将指定长度后面的部分将被删除。如：</p>
<p><code>channel.truncate(1024);</code></p>
<p>这个例子截取文件的前<code>1024</code>个字节。</p>
<h5 id="8-FileChannel的force方法"><a href="#8-FileChannel的force方法" class="headerlink" title="8. FileChannel的force方法"></a>8. FileChannel的force方法</h5><p>FileChannel.force()方法将通道里面尚未写入磁盘的数据强制写到磁盘上 。处于性能方面的考虑，操作系统会将数据缓存在内存中，所以无法保证写入到FileChannel里面的数据一定会及时写到磁盘上。要保证这一点，需要调用<code>force()</code>方法。</p>
<p><code>force()</code>方法有一个<code>boolean</code>类型的参数，指明是否同时将文件元数据（权限信息等）写入到磁盘上。</p>
<h5 id="9-FileChannel的transferTo和transferFrom方法"><a href="#9-FileChannel的transferTo和transferFrom方法" class="headerlink" title="9. FileChannel的transferTo和transferFrom方法"></a>9. FileChannel的transferTo和transferFrom方法</h5><p><strong>通道之间的数据传输</strong></p>
<p>如果两个通道中有一个是FileChannel，那么可以直接将数据从一个C hannel传输到另外一个Channel。</p>
<ol>
<li><p><strong>transferFrom()</strong></p>
<ul>
<li><p>FileChannel的transferFrom()方法可以将数据从源通道传输到FileChannel中</p>
<ul>
<li>```java<br>@Test<br>public void transferFromDemo() throws IOException {<pre><code>// 定义 源 Channel
RandomAccessFile file = new RandomAccessFile(&quot;Files\\data.txt&quot;, &quot;rw&quot;);
FileChannel fromChannel = file.getChannel();
// 定义 目标 Channel
RandomAccessFile file1 = new RandomAccessFile(&quot;Files\\dataTo.txt&quot;, &quot;rw&quot;);
FileChannel toChannel = file1.getChannel();
long position = 0;
long count = fromChannel.size();
// transferFrom 从一个通道中复制数据到另一个通道中
toChannel.transferFrom(fromChannel,0,count);

toChannel.close();
fromChannel.close();
file1.close();
file.close();
System.out.println(&quot;over!&quot;);
</code></pre>
}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. **transferTo**</span><br><span class="line"></span><br><span class="line">   - transferTo()方法将数据从FileChannel传输到其他的channel中。</span><br><span class="line"></span><br><span class="line">     - ```java</span><br><span class="line">       @Test</span><br><span class="line">       public void transferToDemo() throws IOException&#123;</span><br><span class="line">           // 定义 源 Channel</span><br><span class="line">           RandomAccessFile file = new RandomAccessFile(&quot;Files\\data.txt&quot;, &quot;rw&quot;);</span><br><span class="line">           FileChannel fromChannel = file.getChannel();</span><br><span class="line">           // 定义 目标 Channel</span><br><span class="line">           RandomAccessFile file1 = new RandomAccessFile(&quot;Files\\dataTo2.txt&quot;, &quot;rw&quot;);</span><br><span class="line">           FileChannel toChannel = file1.getChannel();</span><br><span class="line">           long size = fromChannel.size();</span><br><span class="line">           int position = 0;</span><br><span class="line">       </span><br><span class="line">           fromChannel.transferTo(position, size, toChannel);</span><br><span class="line">       </span><br><span class="line">           fromChannel.close();</span><br><span class="line">           toChannel.close();</span><br><span class="line">           file.close();</span><br><span class="line">           file1.close();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ol>
<p><font color=red>注意</font></p>
<p>通道之间的传输方法每次最多只能传输<code>2GB</code>的数据，如果超过了<code>2GB</code>，就需要额外的处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransferToDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                <span class="type">FileChannel</span> <span class="variable">fromChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src\\Files\\data.txt&quot;</span>)).getChannel();</span><br><span class="line">                <span class="keyword">final</span> <span class="type">FileChannel</span> <span class="variable">targetChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src\\Files\\data2.txt&quot;</span>)).getChannel()</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">/*核心代码*/</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> fromChannel.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">long</span> <span class="variable">remain</span> <span class="operator">=</span> size; remain&gt;<span class="number">0</span>;)&#123;</span><br><span class="line">                remain -= fromChannel.transferTo(remain - size, size, targetChannel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="SocketChannel通道"><a href="#SocketChannel通道" class="headerlink" title="SocketChannel通道"></a>SocketChannel通道</h3><ol>
<li><blockquote>
<p><font size=4px color=green>新的 socket 通道类可以运行非阻塞模式并且是可选择的，可以激活大程序（如网络服务器和中间件组件）巨大的可伸缩性和灵活性。再也不需要为每个 socket 连接使用一个线程的必要了，也避免了管理大量线程所需的上下文交换开销。借助新的 NIO 类，一个或几个线程就可以管理成百上千的活动 socket 连接了并且只有很少甚至可能没有性能损失。所有的 socket 通道类(DatagramChannel、SocketChannel 和 ServerSocketChannel)都继承了位于 java.nio.channels.spi 包中的 AbstractSelectableChannel。这意味着我们可以用一个 Selector 对象来执行socket 通道的就绪选择（readiness selection）。</font></p>
</blockquote>
</li>
<li><blockquote>
<p><font size=4px color=green>请注意 DatagramChannel 和 SocketChannel 实现定义读和写的功能，而接口<br>ServerSocketChannel 没有实现。ServerSocketChannel 负责监听传入的连接和创建新<br>的 SocketChannel 对象，它本身从不传输数据。</font></p>
</blockquote>
</li>
<li><blockquote>
<p><strong>socket 和 socket 通道之间 的关系</strong>。通道是一个连接 I/O 服务导管并提供与该服务交互的方法。就某个 socket 而 言，它不会再次实现与之对应的 socket 通道类中的 socket 协议 API，而 java.net 中 已经存在的 socket 通道都可以被大多数协议操作重复使用。</p>
<p><font size=4px color=green>全部 socket 通道类（DatagramChannel、SocketChannel 和<br>ServerSocketChannel）在被实例化时都会创建一个对等 socket 对象。这些是我们所<br>熟悉的来自 java.net 的类（Socket、ServerSocket 和 DatagramSocket），它们已<br>经被更新以识别通道。对等 socket 可以通过调用 socket( )方法从一个通道上获取。<br>此外，这三个 java.net 类现在都有 getChannel( )方法。</font></p>
</blockquote>
</li>
<li><blockquote>
<p><font size=4px color=green>要把一个 socket 通道置于非阻塞模式，我们要依靠所有 socket 通道类的公有 超级类：SelectableChannel。就绪选择（readiness selection）是一种可以用来查 询通道的机制，该查询可以判断通道是否准备好执行一个目标操作，如读或写。非阻 塞 I/O 和可选择性是紧密相连的，那也正是管理阻塞模式的 API 代码要在 SelectableChannel 超级类中定义的原因。设置或重新设置一个通道的阻塞模式是很简单的，<strong>只要调用 configureBlocking( )方 法即可</strong>，传递参数值为 true 则设为阻塞模式，参数值为 false 值设为非阻塞模式。可 以通过调用 isBlocking( )方法来判断某个 socket 通道当前处于哪种模式。</font></p>
</blockquote>
</li>
</ol>
<p>非阻塞 socket 通常被认为是服务端使用的，因为它们使同时管理很多 socket 通道变 得更容易。但是，在客户端使用一个或几个非阻塞模式的 socket 通道也是有益处的， 例如，借助非阻塞 socket 通道，GUI 程序可以专注于用户请求并且同时维护与一个或 多个服务器的会话。在很多程序上，非阻塞模式都是有用的。 偶尔地，我们也会需要防止 socket 通道的阻塞模式被更改。API 中有一个 blockingLock( )方法，该方法会返回一个非透明的对象引用。返回的对象是通道实现 修改阻塞模式时内部使用的。只有拥有此对象的锁的线程才能更改通道的阻塞模式。</p>
<h4 id="1-ServerSocketChannel"><a href="#1-ServerSocketChannel" class="headerlink" title="1. ServerSocketChannel"></a>1. ServerSocketChannel</h4><p><code>ServerSocketChannel</code>是一个基于通道的socket监听器。它同我们所熟悉的<code>java.net.ServerSocket</code>执行相同的任务，不过它增加了通道语义，因此能够在非阻塞模式下运行。</p>
<p>由于<code>ServerSocketChannel</code>没有<code>bind()</code>方法，因此有必要取出对等的socket并使用它来绑定一个端口以开始监听连接。我们也是使用对等<code>ServerSocket</code>的API来根据需要设置其他的socket选项。</p>
<p>同<code>java.net.ServerSocket</code>一样，<code>ServerSocketChannel</code>也有<code>accept()</code>方法。一旦创建了一个<code>ServerSocketChannel</code>并用对等socket绑定了，然后就可以在其中一个上调用<code>accpet()</code>。如果您选择在<code>ServerSocket</code>上调用<code>accept()</code>方法，那么他会同任何其他的<code>ServerSocket</code>表现一样的行为：总是阻塞并返回一个<code>java.net.Socket</code>对象；如果您选择在<code>ServerSocketChannel</code>上调用<code>accept()</code>方法则会返回<code>SocketChannel</code>类型的对象，返回的对象能够在非阻塞模式下运行。</p>
<blockquote>
<p>换句话说：</p>
<p>ServerSocketChannel的accept()方法会返回ServerChannel类型对象，SocketChannel可以在非阻塞模式下运行。</p>
<p>其他Socket的accept()方法会阻塞返回一个Socket对象。如果ServerSocketChannel以非阻塞模式被调用，当没有传入在等待时，ServerSocketChannel.accept()会立即返回null。正是这种检查连接而不阻塞的能力实现了可伸缩性并降低了复杂性。可选择性也因此得到实现。我们可以使用一个选择器实例来注册<code>ServerSocketChannel</code>对象以实现新连接到达时自动通知的功能。</p>
</blockquote>
<p><strong>Server端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serverSocketChannelTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 定义一个端口号 8888</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8888</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开一个SocketServerChannel</span></span><br><span class="line">    <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">    <span class="comment">// 定义一个缓冲区</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="string">&quot;Hello java.nio&quot;</span>.getBytes());  <span class="comment">// 直接将一个字节数组包装成一个ByteBuffer</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">accept_buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">8</span>);  <span class="comment">// 申请一个8字节的字节缓冲区</span></span><br><span class="line">    <span class="comment">// 绑定端口号  用于接收数据</span></span><br><span class="line">    ssc.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>,port));</span><br><span class="line">    <span class="comment">// 设置非阻塞模式</span></span><br><span class="line">    ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//循环监听</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Waiting for connections&quot;</span>);</span><br><span class="line">        <span class="comment">// 此处得到的是一个非阻塞式的socketChannel</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept();</span><br><span class="line">        <span class="comment">//TODO 如果是阻塞式的socket，那么接下来的代码会被一直阻塞着，一直等到socket收到请求为止</span></span><br><span class="line">        <span class="keyword">if</span>(sc==<span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;connection is null&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Incoming connection from&quot;</span>+sc.socket().getRemoteSocketAddress());</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="comment">// 重置缓冲区位置</span></span><br><span class="line">            buffer.rewind();</span><br><span class="line">            sc.write(buffer);  <span class="comment">// 将buffer中的数据写入接收到的socket中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Client端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">socketClientDemo</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">8888</span>);</span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">    os.write(<span class="string">&quot;客户端发送消息！&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];</span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((len=is.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>)buffer[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    os.close();</span><br><span class="line">    is.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="打开ServerSocketChannel"><a href="#打开ServerSocketChannel" class="headerlink" title="打开ServerSocketChannel"></a>打开ServerSocketChannel</h5><p>通过调用ServerSocketChannel.open()方法来打开ServerSocketChannel。</p>
<p><code>ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</code></p>
<h5 id="关闭ServerSocketChannel"><a href="#关闭ServerSocketChannel" class="headerlink" title="关闭ServerSocketChannel"></a>关闭ServerSocketChannel</h5><p>通过调用ServerSocketChannel.close()方法来关闭ServerSocketChannel。</p>
<p><code>serverSocketChannel.close();</code></p>
<h5 id="监听新的连接"><a href="#监听新的连接" class="headerlink" title="监听新的连接"></a>监听新的连接</h5><p>通过<code>ServerSocketChannel.accept()</code>方法监听新进的连接。当<code>accept()</code>方法返回的时候，它会返回一个包含新进来的<code>SocketChannel</code>。因此，<code>accept()</code>方法会一直阻塞到有新连接到达。</p>
<p>通常不会仅仅只监听一个连接，在while循环中调用<code>accept()</code>方法。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Waiting for connections&quot;</span>);</span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> scc.accept();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="阻塞模式"><a href="#阻塞模式" class="headerlink" title="阻塞模式"></a>阻塞模式</h5><p>如果是阻塞模式下，那么调用<code>accept()</code>方法后，会被阻塞，知道有新的连接进来才会继续执行接下来的代码。</p>
<h5 id="非阻塞模式"><a href="#非阻塞模式" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h5><p><code>ServerSocketChannel</code>可以设置成非阻塞模式。在非阻塞模式下，<code>accept()</code>方法会立即返回，如果还没有进来的连接，返回的就是null。因此，需要检查返回的<code>SocketChannel</code>是否是null。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">ssc.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(port));</span><br><span class="line">ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">while</span>(ture)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Waiting for connections&quot;</span>);</span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept();</span><br><span class="line">    <span class="keyword">if</span>(sc==<span class="literal">null</span>)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-SocketChannel"><a href="#2-SocketChannel" class="headerlink" title="2.  SocketChannel"></a>2.  SocketChannel</h4><h5 id="SocketChannel介绍"><a href="#SocketChannel介绍" class="headerlink" title="SocketChannel介绍"></a>SocketChannel介绍</h5><p>JAVA NIO 中的SocketChannel是一个连接到TCP网络套接字的通道。它是一种面向流连接sockets套接字的可选择通道</p>
<ul>
<li>SocketChannel是用来连接Socket套接字</li>
<li>SocketChannel主要用途用来处理网络IO的通道</li>
<li>SocketChannel是基于TCP连接传输</li>
<li>SocketChannel实现了可选择通道，可以被多路复用的</li>
</ul>
<h5 id="SocketChannel特征"><a href="#SocketChannel特征" class="headerlink" title="SocketChannel特征"></a>SocketChannel特征</h5><ol>
<li><p>对于已经存在的socket不能创建SocketChannel</p>
</li>
<li><p>SocketChannel中提供的open接口创建的Channel并没有进行网络级联，需要使用connect接口连接到指定地址</p>
</li>
<li><p>未进行连接的SocketChannel执行IO操作时，会抛出<code>NotYetConnectedException</code></p>
</li>
<li><p>SocketChannel支持两种IO模式：阻塞式和非阻塞式</p>
</li>
<li><p>SocketChannel支持异步关闭。如果SocketChannel在一个线程上read阻塞，另一个线程对该SocketChannel调用<code>shutdowninput</code>，则读阻塞的线程将返回-1表示没有读取任何数据；如果SocketChannel在一个线程上write，另一个线程对该SocketChannel调用<code>shutdownWrite</code>，则写阻塞的线程将抛出<code>AsynchronousCloseException</code></p>
</li>
<li><p>SocketChannel支持设定参数</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>SO_SNDBUF</strong></td>
<td>套接字发送缓冲区大小</td>
</tr>
<tr>
<td><strong>SO_RCVBUF</strong></td>
<td>套接字接收缓冲区大小</td>
</tr>
<tr>
<td><strong>SO_KEEPALIVE</strong></td>
<td>保活连接</td>
</tr>
<tr>
<td><strong>O_REUSEADDR</strong></td>
<td>复用地址</td>
</tr>
<tr>
<td><strong>SO_LINGER</strong></td>
<td>有数据传输时延缓关闭Channel（只有在非阻塞模式下有用）</td>
</tr>
<tr>
<td><strong>TCP_NODELAY</strong></td>
<td>禁用Nagle</td>
</tr>
</tbody></table>
</li>
</ol>
<h5 id="SocketChannel使用"><a href="#SocketChannel使用" class="headerlink" title="SocketChannel使用"></a>SocketChannel使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">socketChannelTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">/* TODO 创建SocketChannel   */</span></span><br><span class="line">    <span class="comment">// 方式一</span></span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;www.baidu.com&quot;</span>, <span class="number">80</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式二</span></span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">socketChannel1</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">    socketChannel1.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;www.baidu.com&quot;</span>, <span class="number">80</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* TODO 连接校验 */</span></span><br><span class="line">    System.out.println(socketChannel.isOpen());                 <span class="comment">// 测试SocketChannel是否为open状态</span></span><br><span class="line">    System.out.println(socketChannel.isConnected());            <span class="comment">// 测试SocketChannel是否已经被连接</span></span><br><span class="line">    System.out.println(socketChannel.isConnectionPending());    <span class="comment">// 测试SocketChannel是否正在进行连接</span></span><br><span class="line">    System.out.println(socketChannel.finishConnect());          <span class="comment">// 校验正在进行套接字连接的SocketChannel是否已经完成连接</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* TODO 读写模式 */</span></span><br><span class="line">    socketChannel.configureBlocking(<span class="literal">false</span>);                     <span class="comment">// 非阻塞式模式</span></span><br><span class="line">    socketChannel1.configureBlocking(<span class="literal">true</span>);                     <span class="comment">// 阻塞式模式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer1</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">    <span class="comment">// TODO 非阻塞式模式下，会打印出 socketChannel read over !</span></span><br><span class="line">    socketChannel.read(buffer1);</span><br><span class="line">    socketChannel.close();</span><br><span class="line">    System.out.println(<span class="string">&quot; socketChannel read over ! &quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">    <span class="comment">// TODO 阻塞模式下，read方法会阻塞，控制台无法打印出 socketChannel1 read over !</span></span><br><span class="line">    socketChannel1.read(buffer2);</span><br><span class="line">    socketChannel1.close();</span><br><span class="line">    System.out.println(<span class="string">&quot; socketChannel1 read over !&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* TODO 设置和获取参数 */</span></span><br><span class="line">    socketChannel.setOption(StandardSocketOptions.SO_KEEPALIVE, Boolean.TRUE)</span><br><span class="line">        .setOption(StandardSocketOptions.TCP_NODELAY, Boolean.TRUE);                    <span class="comment">// 通过setOptions方法可以设置socket套接字的相关参数</span></span><br><span class="line">    <span class="comment">// 获取相关参数的值</span></span><br><span class="line">    System.out.println(socketChannel.getOption(StandardSocketOptions.SO_KEEPALIVE));</span><br><span class="line">    System.out.println(socketChannel.getOption(StandardSocketOptions.SO_RCVBUF));           <span class="comment">// 通过getOption获取相关参数的值。如默认的接收缓冲区大小是8192byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-DatagramChannel"><a href="#3-DatagramChannel" class="headerlink" title="3. DatagramChannel"></a>3. DatagramChannel</h4><p>正如 SocketChannel 对应 Socket，ServerSocketChannel 对应 ServerSocket，每 一个DatagramChannel 对象也有一个关联的 DatagramSocket 对象。正如 SocketChannel 模拟连接导向的流协议（如TCP/IP），DatagramChannel 则模拟包 导向的无连接协议（如 UDP/IP）。DatagramChannel 是无连接的，每个数据报 （datagram）都是一个自包含的实体，拥有它自己的目的地址及不依赖其他数据报的 数据负载。与面向流的的 socket 不同，DatagramChannel 可以发送单独的数据报给不同的目的地址。同样，DatagramChannel对象也可以接收来自任意地址的数据包。每个到达的数据报都含有关于它来自何处的信息（源地址）</p>
<h5 id="打开DatagramChannel"><a href="#打开DatagramChannel" class="headerlink" title="打开DatagramChannel"></a>打开DatagramChannel</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DatagramChannel</span> <span class="variable">server</span> <span class="operator">=</span> DatagramChannel.open();</span><br><span class="line">server.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">10010</span>));</span><br></pre></td></tr></table></figure>

<p>此例子是打开10010端口接收UDP数据包</p>
<h5 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h5><p>通过<code>receive()</code>接收UDP包</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer receiveBuffer=ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line">receiveBuffer.clear();</span><br><span class="line"><span class="type">SocketAddress</span> <span class="variable">receiveAddr</span> <span class="operator">=</span> server.receive(receiveBuffer);</span><br></pre></td></tr></table></figure>

<p>SocketAddress可以获得发包的IP，端口等信息，用toString查看，格式如下：</p>
<blockquote>
<p>/127.0.0.1:57126</p>
</blockquote>
<h5 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h5><p>通过<code>send()</code>发送UDP包</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DatagramChannel</span> <span class="variable">server</span> <span class="operator">=</span> DatagramChannel.open();</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">sendBuffer</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="string">&quot;client send&quot;</span>.getBytes());</span><br><span class="line">server.send(sendBuffer, <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">10010</span>))</span><br></pre></td></tr></table></figure>



<h5 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h5><p>UDP不存在真正意义上的连接，这里的连接是向特定服务地址用<code>read</code>和<code>write</code>接收发送数据包。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">client.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">10010</span>));</span><br><span class="line"><span class="type">int</span> <span class="variable">readSize</span> <span class="operator">=</span> client.read(sendBuffer);</span><br><span class="line">server.write(sendBuffer);</span><br></pre></td></tr></table></figure>

<p><code>read()</code>和<code>write()</code>只有在<code>connect()</code>后才能使用，不然会抛出<code>NotYetConnectedException</code>异常。用<code>read()</code>接收时，如果没有接收到包，会抛出<code>PortUnreachableException</code>异常。</p>
<h5 id="DatagramChannel示例"><a href="#DatagramChannel示例" class="headerlink" title="DatagramChannel示例"></a>DatagramChannel示例</h5><p>模拟 客户端发送，服务端接收的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.DatagramChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatagramChannelDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendDatagram</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="type">DatagramChannel</span> <span class="variable">sendChannel</span> <span class="operator">=</span> DatagramChannel.open();</span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">inetSocketAddress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9999</span>);</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="string">&quot;发送 UDP包&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            sendChannel.send(buffer,inetSocketAddress);</span><br><span class="line">            System.out.println(<span class="string">&quot;已经完成了发送！！！&quot;</span>+random.nextInt(<span class="number">1000</span>));</span><br><span class="line">            Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveDatagram</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">DatagramChannel</span> <span class="variable">receiveChannel</span> <span class="operator">=</span> DatagramChannel.open();</span><br><span class="line">        receiveChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9999</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">receiveBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            receiveBuffer.clear();</span><br><span class="line">            <span class="type">SocketAddress</span> <span class="variable">socketAddress</span> <span class="operator">=</span> receiveChannel.receive(receiveBuffer);</span><br><span class="line">            <span class="keyword">if</span>(socketAddress==<span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            receiveBuffer.flip();</span><br><span class="line">            System.out.println(socketAddress.toString());</span><br><span class="line">            System.out.println(Charset.forName(<span class="string">&quot;UTF-8&quot;</span>).decode(receiveBuffer));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>connect测试</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接 read 和 write</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connectDemo</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">DatagramChannel</span> <span class="variable">client</span> <span class="operator">=</span> DatagramChannel.open();</span><br><span class="line">    client.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9999</span>));  <span class="comment">// 绑定 用于 接收</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接</span></span><br><span class="line">    client.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">9999</span>));  <span class="comment">// 连接 用于 发送</span></span><br><span class="line">    client.write(ByteBuffer.wrap(<span class="string">&quot;发送 UDP包&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">readBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        readBuffer.clear();</span><br><span class="line">        client.read(readBuffer);</span><br><span class="line">        readBuffer.flip();</span><br><span class="line">        System.out.println(Charset.forName(<span class="string">&quot;UTF-8&quot;</span>).decode(readBuffer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Scatter-Gather"><a href="#Scatter-Gather" class="headerlink" title="Scatter/Gather"></a>Scatter/Gather</h3><p>Java NIO开始支持scatter/gather，scatter/gather用于描述从Channel中读取或者写入到Channel的操作。</p>
<ul>
<li><p><strong>分散（Scatter）读</strong></p>
<ul>
<li><blockquote>
<p><font color=green size=4px>分散（Scatter）从Channel中读取  是指在读操作时将读取的数据写入多个buffer中，因此，Channel将从Channel中读取的数据  分散Scatter 到多个Buffer中。</font></p>
</blockquote>
</li>
<li><p><img src="source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E5%88%86%E6%95%A3.png"></p>
</li>
<li><p><strong>分散读（Scatter Reads）</strong> 是指数据从一个Channel读取到多个buffer中。</p>
</li>
</ul>
</li>
<li><p><strong>聚集（Gather）写</strong></p>
<ul>
<li><blockquote>
<p><font color=green size=4px>聚集（Gather）写入Channel是指在写操作时将多个buffer的数据写入同一个Channel，因此，Channel将多个Buffer中的数据聚集（Gather）后发送到Channel。</font></p>
</blockquote>
</li>
<li><p><img src="source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E8%81%9A%E9%9B%86%E5%86%99.png"></p>
</li>
<li><p><strong>聚集写（Gathering Writes）</strong>是指数据从多个buffer写入到同一个channel。</p>
</li>
</ul>
</li>
</ul>
<p>scatter/gather经常用于需要将传输的数据分开处理的场合，例如传输一个由消息头和消息体组成的消息，你可能会将消息体和消息头分散到不同的buffer中，这样你可以方便的处理消息头和消息体。</p>
<h4 id="1-Scattering-Reads"><a href="#1-Scattering-Reads" class="headerlink" title="1. Scattering Reads"></a>1. Scattering Reads</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">header</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">body</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">ByteBuffer[] bufferArray = &#123;header, body&#125;;</span><br><span class="line">channel.read(bufferArray);</span><br></pre></td></tr></table></figure>

<p><font color=red>注意</font></p>
<p>buffer首先被插入到数组，然后再将数组作为<code>channel.read()</code>的输入参数。<code>read()</code>方法按照buffer在数组中的顺序将从channel中读取的数据写入到buffer，当一个buffer被写满后，channel紧接着向另一个buffer中写。</p>
<p>Scattering Reads在移动下一个buffer前，必须填满当前的buffer，这也意味着它不适用动态消息（消息大小不固定）。换句话说，如果存在消息头和消息体，消息头必须完成填充（例如 128byte），Scattering Reads 才能正常工作。</p>
<h4 id="2-Gathering-Writes"><a href="#2-Gathering-Writes" class="headerlink" title="2. Gathering Writes"></a>2. Gathering Writes</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">header</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">body</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">ByteBuffer[] bufferArray = &#123;header, body&#125;;</span><br><span class="line"></span><br><span class="line">channel.write(bufferArray);</span><br></pre></td></tr></table></figure>

<p>buffers数组是<code>write()</code>方法的入参，<code>write()</code>方法会按照buffer在数组中的顺序，将数据写入到channel，注意只有position和limit之间的数据才会被写入。因此，如果一个buffer的容量为128byte，但是仅仅包含58byte的数据，那么这58byte的数据将被写入到channel中。<font color=blue>因此与Scattering Reads相反, Gathering Writes能较好的处理动态消息。</font></p>
<h2 id="3-3-Buffer"><a href="#3-3-Buffer" class="headerlink" title="3.3  Buffer"></a>3.3  Buffer</h2><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="ByteBuffer-结构"><a href="#ByteBuffer-结构" class="headerlink" title="ByteBuffer 结构"></a>ByteBuffer 结构</h4><p>ByteBuffer 有以下重要属性</p>
<ul>
<li>capacity</li>
<li>position</li>
<li>limit</li>
</ul>
<p>一开始</p>
<p><img src="source/Java-IO%E4%B8%8ENIO/0021.png"></p>
<p>写模式下，position 是写入位置，limit 等于容量，下图表示写入了 4 个字节后的状态</p>
<p><img src="source/Java-IO%E4%B8%8ENIO/0018.png"></p>
<p>flip 动作发生后，position 切换为读取位置，limit 切换为读取限制</p>
<p><img src="source/Java-IO%E4%B8%8ENIO/0019.png"></p>
<p>读取 4 个字节后，状态</p>
<p><img src="source/Java-IO%E4%B8%8ENIO/0020.png"></p>
<p>clear 动作发生后，状态</p>
<p><img src="source/Java-IO%E4%B8%8ENIO/0021.png"></p>
<p>compact 方法，是把未读完的部分向前压缩，然后切换至写模式</p>
<p><img src="source/Java-IO%E4%B8%8ENIO/0022.png"></p>
<h4 id="💡-调试工具类"><a href="#💡-调试工具类" class="headerlink" title="💡 调试工具类"></a>💡 调试工具类</h4><p>需要引入netty依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io-netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.51.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>







<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteBufferUtil</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span>[] BYTE2CHAR = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span>[] HEXDUMP_TABLE = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">256</span> * <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] HEXPADDING = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] HEXDUMP_ROWPREFIXES = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">65536</span> &gt;&gt;&gt; <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] BYTE2HEX = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] BYTEPADDING = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">char</span>[] DIGITS = <span class="string">&quot;0123456789abcdef&quot;</span>.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">            HEXDUMP_TABLE[i &lt;&lt; <span class="number">1</span>] = DIGITS[i &gt;&gt;&gt; <span class="number">4</span> &amp; <span class="number">0x0F</span>];</span><br><span class="line">            HEXDUMP_TABLE[(i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>] = DIGITS[i &amp; <span class="number">0x0F</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for hex dump paddings</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HEXPADDING.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">padding</span> <span class="operator">=</span> HEXPADDING.length - i;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(padding * <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; padding; j++) &#123;</span><br><span class="line">                buf.append(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            HEXPADDING[i] = buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for the start-offset header in each row (up to 64KiB).</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HEXDUMP_ROWPREFIXES.length; i++) &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">12</span>);</span><br><span class="line">            buf.append(NEWLINE);</span><br><span class="line">            buf.append(Long.toHexString(i &lt;&lt; <span class="number">4</span> &amp; <span class="number">0xFFFFFFFFL</span> | <span class="number">0x100000000L</span>));</span><br><span class="line">            buf.setCharAt(buf.length() - <span class="number">9</span>, <span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">            buf.append(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">            HEXDUMP_ROWPREFIXES[i] = buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for byte-to-hex-dump conversion</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BYTE2HEX.length; i++) &#123;</span><br><span class="line">            BYTE2HEX[i] = <span class="string">&#x27; &#x27;</span> + StringUtil.byteToHexStringPadded(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for byte dump paddings</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BYTEPADDING.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">padding</span> <span class="operator">=</span> BYTEPADDING.length - i;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(padding);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; padding; j++) &#123;</span><br><span class="line">                buf.append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            BYTEPADDING[i] = buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for byte-to-char conversion</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BYTE2CHAR.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= <span class="number">0x1f</span> || i &gt;= <span class="number">0x7f</span>) &#123;</span><br><span class="line">                BYTE2CHAR[i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                BYTE2CHAR[i] = (<span class="type">char</span>) i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印所有内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">debugAll</span><span class="params">(ByteBuffer buffer)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldlimit</span> <span class="operator">=</span> buffer.limit();</span><br><span class="line">        buffer.limit(buffer.capacity());</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">origin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">256</span>);</span><br><span class="line">        appendPrettyHexDump(origin, buffer, <span class="number">0</span>, buffer.capacity());</span><br><span class="line">        System.out.println(<span class="string">&quot;+--------+-------------------- all ------------------------+----------------+&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;position: [%d], limit: [%d]\n&quot;</span>, buffer.position(), oldlimit);</span><br><span class="line">        System.out.println(origin);</span><br><span class="line">        buffer.limit(oldlimit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印可读取内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">debugRead</span><span class="params">(ByteBuffer buffer)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">256</span>);</span><br><span class="line">        appendPrettyHexDump(builder, buffer, buffer.position(), buffer.limit() - buffer.position());</span><br><span class="line">        System.out.println(<span class="string">&quot;+--------+-------------------- read -----------------------+----------------+&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;position: [%d], limit: [%d]\n&quot;</span>, buffer.position(), buffer.limit());</span><br><span class="line">        System.out.println(builder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">appendPrettyHexDump</span><span class="params">(StringBuilder dump, ByteBuffer buf, <span class="type">int</span> offset, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isOutOfBounds(offset, length, buf.capacity())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(</span><br><span class="line">                    <span class="string">&quot;expected: &quot;</span> + <span class="string">&quot;0 &lt;= offset(&quot;</span> + offset + <span class="string">&quot;) &lt;= offset + length(&quot;</span> + length</span><br><span class="line">                            + <span class="string">&quot;) &lt;= &quot;</span> + <span class="string">&quot;buf.capacity(&quot;</span> + buf.capacity() + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dump.append(</span><br><span class="line">                <span class="string">&quot;         +-------------------------------------------------+&quot;</span> +</span><br><span class="line">                        NEWLINE + <span class="string">&quot;         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |&quot;</span> +</span><br><span class="line">                        NEWLINE + <span class="string">&quot;+--------+-------------------------------------------------+----------------+&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> offset;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">fullRows</span> <span class="operator">=</span> length &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">remainder</span> <span class="operator">=</span> length &amp; <span class="number">0xF</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dump the rows which have 16 bytes.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; row &lt; fullRows; row++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rowStartIndex</span> <span class="operator">=</span> (row &lt;&lt; <span class="number">4</span>) + startIndex;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Per-row prefix.</span></span><br><span class="line">            appendHexDumpRowPrefix(dump, row, rowStartIndex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Hex dump</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rowEndIndex</span> <span class="operator">=</span> rowStartIndex + <span class="number">16</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(<span class="string">&quot; |&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ASCII dump</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dump the last row which has less than 16 bytes.</span></span><br><span class="line">        <span class="keyword">if</span> (remainder != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rowStartIndex</span> <span class="operator">=</span> (fullRows &lt;&lt; <span class="number">4</span>) + startIndex;</span><br><span class="line">            appendHexDumpRowPrefix(dump, fullRows, rowStartIndex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Hex dump</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rowEndIndex</span> <span class="operator">=</span> rowStartIndex + remainder;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(HEXPADDING[remainder]);</span><br><span class="line">            dump.append(<span class="string">&quot; |&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Ascii dump</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(BYTEPADDING[remainder]);</span><br><span class="line">            dump.append(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dump.append(NEWLINE +</span><br><span class="line">                <span class="string">&quot;+--------+-------------------------------------------------+----------------+&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">appendHexDumpRowPrefix</span><span class="params">(StringBuilder dump, <span class="type">int</span> row, <span class="type">int</span> rowStartIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; HEXDUMP_ROWPREFIXES.length) &#123;</span><br><span class="line">            dump.append(HEXDUMP_ROWPREFIXES[row]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dump.append(NEWLINE);</span><br><span class="line">            dump.append(Long.toHexString(rowStartIndex &amp; <span class="number">0xFFFFFFFFL</span> | <span class="number">0x100000000L</span>));</span><br><span class="line">            dump.setCharAt(dump.length() - <span class="number">9</span>, <span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">            dump.append(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">getUnsignedByte</span><span class="params">(ByteBuffer buffer, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">short</span>) (buffer.get(index) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Java NIO中的Buffer用于和NIO通道Channel进行交互。数据是从通道读入缓冲区，从缓冲区写入通道中的。</p>
<p><img src="source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/src=http%253A%252F%252Fimg.mp.itc.cn%252Fupload%252F20160527%252F94502ff22866475a8ddaa3b832de64d2.jpg&refer=http%253A%252F%252Fimg.mp.itc-16354874682132.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg" alt="img"></p>
<p>缓冲区<font color=red>本质上是一块可以写入数据，然后可以从中读取数据的内存</font>.这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便访问该块内存。缓冲区实际上是一个容器对象，更直接的说，其实就是一个<strong>数组</strong>，<font color=red>在NIO库中，所有数据都是缓冲区处理的。</font>在读取数据时，它是直接读到缓冲区中的；在写入数据时，它也是写入到缓冲区中的；任何时候访问NIO中的数据，都是将它放到缓冲区中。而在面向流IO系统中，所有数据都是直接写入或者直接将数据读取到Stream对象中。</p>
<p>在NIO中，所有的缓冲区类型都继承于抽象类<code>Buffer</code>，最常用的就是<code>ByteBuffer</code>，对于Java中的基本类型，基本都有一个具体Buffer类型与之相对应，他们之间的继承关系如下图所示：</p>
<p><img src="source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211029141706293-16354882280304.png" alt="image-20211029141706293"></p>
<h3 id="1-Buffer-的基本用法"><a href="#1-Buffer-的基本用法" class="headerlink" title="1. Buffer 的基本用法"></a>1. Buffer 的基本用法</h3><p><strong>使用Buffer读写数据，一般遵循以下四个步骤：</strong></p>
<ol>
<li>写入数据到Buffer</li>
<li>调用<code>flip()</code>方法</li>
<li>从Buffer中读取数据</li>
<li>调用<code>clear()</code>方法或者<code>compact()</code>方法</li>
</ol>
<blockquote>
<p>当向buffer写入数据是，buffer会记录下写了多少数据。一旦要读取数据，需要通过<code>flip()</code>方法将Buffer从写模式切换到读模式。在读模式下，可以读取之前写入到Buffer的所有数据。一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用<code>clear()</code>或<code>compact()</code>方法。<code>clear()</code>方法会清空整个缓冲区。<code>compact()</code>方法只会清除已经读过的数据。任何未读的数据都<br>被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。</p>
</blockquote>
<p>ByteBuffer Demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bufferTest1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;Files\\data.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> raf.getChannel();</span><br><span class="line">    <span class="comment">// 创建Buffer</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line">    <span class="comment">// 承接读取的字节数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">readBytes</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((readBytes=fileChannel.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 写读转换</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining())&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>)buffer.get());</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.compact();</span><br><span class="line">    &#125;</span><br><span class="line">    raf.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>IntBuffer Demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">intBuferTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 分配新的int缓冲区，参数为缓冲区容量</span></span><br><span class="line">    <span class="comment">// 新缓冲区的当前位置为零， 其界限（限制位置）将为其容量</span></span><br><span class="line">    <span class="comment">// 它将具有一个底层实现数组，其数组偏移量将为零</span></span><br><span class="line">    <span class="type">IntBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> IntBuffer.allocate(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;buffer.capacity();++i)&#123;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">2</span>*(i+<span class="number">1</span>);</span><br><span class="line">        buffer.put(j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置缓冲区，将限制设置为当前位置，然后将当前位置设置为0</span></span><br><span class="line">    buffer.flip();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (buffer.hasRemaining())&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> buffer.get();</span><br><span class="line">        System.out.print(j+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Buffer的capacity、position和limit</strong></p>
<p>为了理解Buffer的工作原理，需要熟悉它的三个属性：</p>
<ul>
<li>Capacity</li>
<li>Position</li>
<li>limit</li>
</ul>
<p>position和limit的含义取决于Buffer处于<strong>读模式</strong>还是<strong>写模式</strong>。不管Buffer处在什么模式，capacity的含义总是一样的。</p>
<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fdl2.iteye.com%2Fupload%2Fattachment%2F0096%2F4782%2Fb8a7bad8-ec65-36dc-bb11-4f352e00cd67.png&refer=http%3A%2F%2Fdl2.iteye.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1638086744&t=8d1f749ef4dcf004a67f97d4223aaa68" alt="img"></p>
<ol>
<li><strong>capacity</strong><ul>
<li>作为一个内存块，Buffer有一个固定的大小值，也叫“capacity”。你只能往里面写capacity个byte、long、char等类型。一旦buffer满了，需要将其清空（通过读数据或者清除数据）才能继续往里写数据。</li>
</ul>
</li>
<li><strong>position</strong><ul>
<li><strong>写数据到Buffer中时</strong>，position表示写入数据的当前位置，position的初始值为0,。当一个byte、long等数据写到buffer后，position会向下移动到下一个可插入数据的buffer单元。position最大可为capacity-1（因为position的初始值为0）</li>
<li><strong>读数据到Buffer中时</strong>，position表示读入数据的当前位置，如position=2时表示已开始读入了3个byte，或从第3个byte开始读取。通过<code>ByteBuffer.flip()</code>切换到读模式时，position会被重置为0，当Buffer从position读入数据后，position会下移到下一个可读入的数据Buffer单元。</li>
</ul>
</li>
<li><strong>limit</strong><ul>
<li>写数据时，limit表示可对Buffer最多写入多少个数据。写模式下，limit等于Buffer的capacity</li>
<li>读数据时，limit表示Buffer里有多少可读数据（not null 的数据），因此能读到之前写入的所有数据（limit被设置成已写数据的数量，这个值在写模式下就是position）</li>
</ul>
</li>
</ol>
<h3 id="2-Buffer的类型"><a href="#2-Buffer的类型" class="headerlink" title="2. Buffer的类型"></a>2. Buffer的类型</h3><p>JAVA NIO 有一下Buffer类型</p>
<ul>
<li>ByteBuffer</li>
<li>MappedByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>这些Buffer类型代表了不同的数据类型。换句话说，就是可以通过char，short，int，long，float或double类型来操作缓冲区中的字节。</p>
<h3 id="3-Buffer分配和写数据"><a href="#3-Buffer分配和写数据" class="headerlink" title="3. Buffer分配和写数据"></a>3. Buffer分配和写数据</h3><h4 id="Buffer的分配"><a href="#Buffer的分配" class="headerlink" title="Buffer的分配"></a>Buffer的分配</h4><p>想要获得一个Buffer对象首先要进行过分配。每一个Buffer类都有一个allocate方法。比如分配一个48字节capacity的ByteBuffer：</p>
<p><code>ByteBuffer buffer = ByteBuffer.allocate(48);</code></p>
<p>分配一个可存储1024个字符的CharBuffer：</p>
<p><code>CharBuffer buffer = CharBuffer.allocate(1024);</code></p>
<h4 id="向Buffer中写数据"><a href="#向Buffer中写数据" class="headerlink" title="向Buffer中写数据"></a>向Buffer中写数据</h4><p>写数据到Buffer中有两种方式：</p>
<ol>
<li>从Channel写到Buffer<ul>
<li><code>int bytesRead = inChannel.read(buffer)</code></li>
</ul>
</li>
<li>通过Buffer的<code>put()</code>方法写到Buffer中<ul>
<li><code>buffer.put(127);</code></li>
<li>put方法有很多版本，允许以不同的方式把数据写入到Buffer中。例如，写到一个指定的位置，或者把一个字节数组写入到Buffer中。</li>
</ul>
</li>
</ol>
<h3 id="4-flip-方法"><a href="#4-flip-方法" class="headerlink" title="4. flip() 方法"></a>4. flip() 方法</h3><p><code>flip()</code>方法将Buffer从写模式切换到读模式。调用<code>flip()</code>方法会将position设置为0，并将limit设置成之前position的值。换句话说，position现在用于标记读的位置，limit表示之前写进了多少个byte，char等（现在能读取多少个byte，char等）。</p>
<h3 id="5-从Buffer中读取数据"><a href="#5-从Buffer中读取数据" class="headerlink" title="5. 从Buffer中读取数据"></a>5. 从Buffer中读取数据</h3><p><strong>从Buffer中读取数据有两种方式：</strong></p>
<ol>
<li>从Buffer读取数据到Channel<ul>
<li><code>int byteWrites = inchannel.write(buffer)</code></li>
<li>读取buffer中的数据，写入到channel中</li>
</ul>
</li>
<li>使用<code>get()</code>方法从Buffer中读取数据<ul>
<li><code>byte aByte = buffer.get();</code></li>
<li>get方法有很多版本，允许你以不同的方式从Buffer中读取数据。例如，从指定position读取，或者从Buffer中读取数据到字节数组。</li>
</ul>
</li>
</ol>
<h3 id="6-Buffer的几个方法"><a href="#6-Buffer的几个方法" class="headerlink" title="6. Buffer的几个方法"></a>6. Buffer的几个方法</h3><h4 id="rewind-方法"><a href="#rewind-方法" class="headerlink" title="rewind()方法"></a>rewind()方法</h4><p><code>Buffer.rewind()</code>将position设回0，所以可以重读Buffer中的所有数据。limit保持不变，任然表示能从Buffer中读取多少个元素（byte，char等）。</p>
<h4 id="clear-与-compact-方法"><a href="#clear-与-compact-方法" class="headerlink" title="clear() 与 compact()方法"></a>clear() 与 compact()方法</h4><p>一旦读完Buffer中的数据，需要让Buffer准备好再次被写入。可以通过<code>clear()</code>或者<code>compact()</code>方法来完成。</p>
<p>如果调用的是<code>clear()</code>方法，position将被设置回0，limit被设置为capacity的值。换句话说，Buffer被清空了。Buffer中的数据并未清除，只是这些标记告诉我们可以从哪里开始往Buffer里写数据。</p>
<p>如果Buffer中有一些未读的数据，调用<code>clear()</code>方法，数据将被“<strong>遗忘</strong>”，意味着不再有任何标记会告诉你哪些数据呗读过，哪些还没有。</p>
<p>如果Buffer中仍有未读的数据，且后续还需要这些数据，但是此时想要先写些数据，那么使用<code>compact()</code>方法。</p>
<p><code>compact()</code>方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个维度元素正后面。limit属性依然像<code>clear()</code>方法一样，设置成capacity。现在Buffer准备好写数据了，但是不会覆盖未读的数据。</p>
<h4 id="mark-与reset-方法"><a href="#mark-与reset-方法" class="headerlink" title="mark()与reset()方法"></a>mark()与reset()方法</h4><p>通过调用<code>Buffer.mark()</code>方法，可以标记Buffer中的一个特定的position。之后可以通过调用<code>Buffer.reset()</code>方法恢复到这个position。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buffer.mark();</span><br><span class="line"><span class="comment">// set position back to mark</span></span><br><span class="line">buffer.reset();</span><br></pre></td></tr></table></figure>



<h3 id="7-Buffer-操作"><a href="#7-Buffer-操作" class="headerlink" title="7. Buffer 操作"></a>7. Buffer 操作</h3><h4 id="1-Buffer分片"><a href="#1-Buffer分片" class="headerlink" title="1. Buffer分片"></a>1. Buffer分片</h4><p>在NIO中，除了可以分配或者包装一个缓冲区对象外，还可以根据现有的缓冲区对象来创建一个子缓冲区，即在现有缓冲区上切出一片来作为一个新的缓冲区，但现有的缓冲区与创建的子缓冲区在底层数组层面上是<strong>数据共享</strong>的，也就是说，子缓冲区相当于是现有缓冲区的一个视图窗口。调用<code>slice()</code>方法可以创建一个子缓冲区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sliceTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buffer.capacity(); i++) &#123;</span><br><span class="line">        buffer.put((<span class="type">byte</span>)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buffer.position(<span class="number">3</span>);</span><br><span class="line">    buffer.limit(<span class="number">7</span>);</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">slice</span> <span class="operator">=</span> buffer.slice();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变子缓冲区的内容</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; slice.capacity(); i++) &#123;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> slice.get(i);</span><br><span class="line">        b*=<span class="number">10</span>;</span><br><span class="line">        slice.put(i,b);</span><br><span class="line">    &#125;</span><br><span class="line">    buffer.position(<span class="number">0</span>);</span><br><span class="line">    buffer.limit(buffer.capacity());</span><br><span class="line">    <span class="keyword">while</span> (buffer.hasRemaining())&#123;</span><br><span class="line">        System.out.print(buffer.get()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-只读缓冲区"><a href="#2-只读缓冲区" class="headerlink" title="2. 只读缓冲区"></a>2. 只读缓冲区</h4><p>只读缓冲区非常简单，可以读取他们，但是不能写入数据。可以通过调用缓冲区的<code>asReadOnlyBuffer()</code>方法，将任何常规缓冲区转换为只读缓冲区，这个方法返回一个与原缓冲区完全相同的缓冲区，并与原缓冲区共享数据，只不过它是只读的。如果原缓冲区的内容发生了变化，只读缓冲区的内容也随之发生变化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readOnlyBufferTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buffer.capacity(); i++) &#123;</span><br><span class="line">        buffer.put((<span class="type">byte</span>)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建只读缓冲区</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">readOnlyBuffer</span> <span class="operator">=</span> buffer.asReadOnlyBuffer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变原缓冲区的内容</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buffer.capacity(); i++) &#123;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> buffer.get();</span><br><span class="line">        b*=<span class="number">10</span>;</span><br><span class="line">        buffer.put(i, b);</span><br><span class="line">    &#125;</span><br><span class="line">    readOnlyBuffer.position(<span class="number">0</span>);</span><br><span class="line">    readOnlyBuffer.limit(buffer.capacity());</span><br><span class="line">    <span class="comment">//只读缓冲区的内容也随之改变</span></span><br><span class="line">    <span class="keyword">while</span>(readOnlyBuffer.remaining()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(readOnlyBuffer.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果尝试修改只读缓冲区的内容，则会报<code>ReadOnlyBufferException</code>异常。只读缓冲区对于保护数据很有用，在将缓冲区传递给某个对象的时候，无法知道这个方法是否会修改缓冲区中的数据。创建一个只读的缓冲区可以保证该缓冲区不会被修改。只可以把常规缓冲区转换为只读缓冲区，而不能将只读缓冲区转换成可写的缓冲区。</p>
<h4 id="3-直接缓冲区"><a href="#3-直接缓冲区" class="headerlink" title="3. 直接缓冲区"></a>3. 直接缓冲区</h4><p>直接缓冲区是为了加快<code>I/O</code>速度，使用一种特殊方式为其分配内存的缓冲区，JDK文档中的描述为：<font color=blue>给定一个直接缓冲区，Java虚拟机将尽最大努力直接对它执行本机I/O操作。</font></p>
<p>也就是说，它会在每次调用底层操作系统的本机I/O操作之前（或之后），尝试避免将缓冲区的内容拷贝到另一个中间缓冲区中，或者从一个中间缓冲区拷贝数据。要分配直接缓冲区，需要调用<code>allocateDirect()</code>方法，而不是<code>allocate()</code>方法，是用方式与普通缓冲区并无区别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">directBufferTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Files\\data.txt&quot;</span>);</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Files\\data4.txt&quot;</span>);</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">inChannel</span> <span class="operator">=</span> fileInputStream.getChannel();</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">oChannel</span> <span class="operator">=</span> fileOutputStream.getChannel();</span><br><span class="line">    <span class="comment">// 创建直接缓冲区</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line">    <span class="comment">// 复制文件内容</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        buffer.clear();</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> inChannel.read(buffer);</span><br><span class="line">        <span class="keyword">if</span> (r==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.flip();</span><br><span class="line">        oChannel.write(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    inChannel.close();</span><br><span class="line">    oChannel.close();</span><br><span class="line">    fileInputStream.close();</span><br><span class="line">    fileOutputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="直接缓冲区与非直接缓冲区的区别"><a href="#直接缓冲区与非直接缓冲区的区别" class="headerlink" title="直接缓冲区与非直接缓冲区的区别"></a>直接缓冲区与非直接缓冲区的区别</h5><p><img src="source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzQwMzg5Nzc1,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<p>在非直接缓冲区中读或者写数据都要在<code>操作系统</code>和<code>JVM</code>直接进行<code>copy</code>，所以它的效率不高</p>
<p><img src="https://img-blog.csdnimg.cn/20190410105333435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzQwMzg5Nzc1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>直接缓冲区建立在操作系统的物理内存中。应用程序直接面对的是物理内存。所里效率比较高，但是在应用程序中开辟一个直接缓冲区是比较耗费资源的。还有一点：应用程序将文件写入直接缓冲区后，这个文件的数据就不归应用程序所管了。至于直接缓冲区中的数据在何时写入到磁盘中，那就由操作系统决定了。在销毁的时候 需要断开应用程序和 物理内存之间的引用，然后让垃圾回收机制进行回收，这个也是比较耗资源的。</p>
<h4 id="4-内存映射文件I-O"><a href="#4-内存映射文件I-O" class="headerlink" title="4. 内存映射文件I/O"></a>4. 内存映射文件I/O</h4><p>内存映射文件I/O是一种读取和写文件数据的方法，它可以比常规的基于流或者基于通道的I/O快的多。一般来说，只有文件中实际读取或者写入的部分才会映射到内存中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mappedByteBufferTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;Files\\data.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">fc</span> <span class="operator">=</span> raf.getChannel();</span><br><span class="line">    <span class="type">MappedByteBuffer</span> <span class="variable">mbb</span> <span class="operator">=</span> fc.map(FileChannel.MapMode.READ_WRITE, start, size);</span><br><span class="line">    <span class="comment">// 在指定索引处put元素</span></span><br><span class="line">    mbb.put(<span class="number">0</span>,(<span class="type">byte</span>)<span class="number">97</span>);</span><br><span class="line">    mbb.put(<span class="number">1023</span>,(<span class="type">byte</span>)<span class="number">122</span>);</span><br><span class="line">    raf.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="8-黏包-与-半包"><a href="#8-黏包-与-半包" class="headerlink" title="8. 黏包  与  半包"></a>8. 黏包  与  半包</h3><p>通常在网络传输中，可能会出现一个长文本会被拆分成多次进行发送，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">input1</span> <span class="operator">=</span> <span class="string">&quot;Hello,World.\nI&#x27;m zhangsan\nHo&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">input2</span> <span class="operator">=</span> <span class="string">&quot;w are you?\n&quot;</span>;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        byteBuffer.put(input1.getBytes());</span><br><span class="line">        split(byteBuffer);</span><br><span class="line">        byteBuffer.put(input2.getBytes());</span><br><span class="line">        split(byteBuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(ByteBuffer source)</span>&#123;</span><br><span class="line">        source.flip();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; source.limit(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (source.get(i)==<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> i+<span class="number">1</span>-source.position();</span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">target</span> <span class="operator">=</span> ByteBuffer.allocate(length);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                    target.put(source.get());</span><br><span class="line">                &#125;</span><br><span class="line">                print(target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当buffer中的还有元素没有读取完成的时候，采用整理的方式，保留剩余元素，清除读取过的元素</span></span><br><span class="line">        <span class="comment">// 这里没有读到\n 这个buffer就会有剩余元素</span></span><br><span class="line">        source.compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(ByteBuffer target)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; target.limit(); i++) &#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>)target.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是上述<code>split</code>方法存在一个跟大的漏洞，当客户端传递过来的消息长度超过了buffer的容量就会和预期不一致。</p>
<p>解决办法详见 <strong>消息边界一节</strong></p>
<h2 id="3-4-Selector"><a href="#3-4-Selector" class="headerlink" title="3.4 Selector"></a>3.4 Selector</h2><h3 id="1-Selector简介"><a href="#1-Selector简介" class="headerlink" title="1. Selector简介"></a>1. Selector简介</h3><h4 id="Selector和Channel的关系"><a href="#Selector和Channel的关系" class="headerlink" title="Selector和Channel的关系"></a>Selector和Channel的关系</h4><p>Selector一般称为选择器，也可以翻译为 多路复用器。它是Java NIO核心组件中的一个，用于检查一个或多个NIO Channel（通道）的状态是否处于可读、可写。如此可以实现单线程管理多个channels，也就是可以管理多个网络连接。</p>
<p><img src="source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211109100448562-16364234905571.png" alt="image-20211109100448562"></p>
<p>使用Selector的好处在于：使用更少的线程就可以来处理通道了，相比使用多个线程，避免了线程上下文切换所带来的开销。</p>
<h4 id="2-可选择通道（SelectableChannel）"><a href="#2-可选择通道（SelectableChannel）" class="headerlink" title="2. 可选择通道（SelectableChannel）"></a>2. 可选择通道（SelectableChannel）</h4><ol>
<li>不是所有的 Channel 都可以被 Selector 复用的。比方说，FileChannel 就不能 被选择器复用。判断一个 Channel 能被 Selector 复用，有一个前提：判断他是否继 承了一个抽象类 <code>SelectableChannel</code>。如果继承了 <code>SelectableChannel</code>，则可以被复用，否则不能。 </li>
<li><code>SelectableChannel</code> 类提供了实现通道的可选择性所需要的公共方法。它是所有支持就绪检查的通道类的父类。所有 socket 通道，都继承了 <code>SelectableChannel</code> 类 都是可选择的，包括从管道(Pipe)对象的中获得的通道。而 FileChannel 类，没有继 承 <code>SelectableChannel</code>，因此是不是可选通道。 </li>
<li>一个通道可以被注册到多个选择器上，但对每个选择器而言只能被注册一次。通道和选择器之间的关系，使用注册的方式完成。``SelectableChannel<code>可以被注册到</code>Selector` 对象上，在注册的时候，需要指定通道的哪些操作，是 Selector 感兴趣的。</li>
</ol>
<p><img src="source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/src=http%253A%252F%252Fpic1.zhimg.com%252Fv2-805bb1b58bcc01045a6142e6e6fa1304_b.jpg&refer=http%253A%252F%252Fpic1.zhimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg" alt="img"></p>
<h4 id="3-Channel注册到Selector"><a href="#3-Channel注册到Selector" class="headerlink" title="3. Channel注册到Selector"></a>3. Channel注册到Selector</h4><ol>
<li><p>使用<code>Channel.register(Selector sel, int ops)</code>方法，将一个通道注册到一个选择器时。第一个参数，指定通道要注册的选择器。第二个参数指定选择器需要查询的通道操作。</p>
</li>
<li><p>可以供选择器查询的通道操作，从类型来分，包括以下四种：</p>
<ol>
<li>可读<code>SelectorKey.OP_READ</code></li>
<li>可写<code>SelectorKey.OP_WRITE</code></li>
<li>连接<code>SelectorKey.OP_CONNECT</code></li>
<li>接收<code>SelectorKey.OP_ACCEPT</code></li>
</ol>
<p>如果Selector对通道的多操作类型感兴趣，可以使用<code>位或</code>操作符来实现。比如：<code>int key = SelectorKey.OP_READ | SelectorKey.OP_WRITE</code>;、</p>
</li>
<li><p>选择器查询的不是通道的操作，而是通道的某个操作的一种就绪状态。什么是操作的就绪状态？</p>
<blockquote>
<p>一旦通道具备完成某个操作的条件，表示该通道的某个操作已经就绪，就可以被Selector查询到，程序可以对通道进行对应的操作。</p>
<p>比方说，某个SocketChannel通道可以连接到一个服务器，则处于“连接就绪”（OP_CONNECT）。</p>
<p>再比方说，一个ServerSocketChannel服务器通道准备好接收进入的连接，则处于“接收就绪”（OP_ACCEPT）状态，</p>
<p>还不妨说，一个有数据可读的通道，可以说是“读就绪”（OP_READ）。</p>
<p>一个等待写数据的通道可以说是“写就绪”（OP_WRITE）。</p>
</blockquote>
</li>
</ol>
<h4 id="4-选择键（SelectionKey）"><a href="#4-选择键（SelectionKey）" class="headerlink" title="4. 选择键（SelectionKey）"></a>4. 选择键（SelectionKey）</h4><ol>
<li>Channel注册后，并且一旦通道处于某种就绪的状态，就可以被选择器查询到。这个工作，使用选择器Selector的<code>select()</code>方法完成。<code>select()</code>方法的作用，对感兴趣的通道操作，进行就绪状态的查询。</li>
<li>Selector可以不断的查询Channel中发生的操作的就绪状态。并且挑选感兴趣的操作就绪状态。一旦通道有操作的就绪状态达成，并且是Selector感兴趣的操作，就会被Selector选中，放入选择键集合中。</li>
<li>一个选择键，首先是包含了注册在Selector的通道操作类型，比方说<code>SelectorKey.OP_READ</code>。也包含了特定的通道与特定的选择器之间的注册关系。</li>
</ol>
<p>​        开发应用程序时，选择键是编程的关键。NIO的编程，就是根据对应的选择键，进行不同的业务逻辑处理。</p>
<ol start="4">
<li>选择键的概念，和事件的概念比较相似，一个选择键类似监听器模式里边的一个事件。由于Selector不是事件触发的模式，而是主动去查询的模式，所以不叫事件Event，而是叫SelectorKey选择键。</li>
</ol>
<h3 id="2-Selector的使用方法"><a href="#2-Selector的使用方法" class="headerlink" title="2. Selector的使用方法"></a>2. Selector的使用方法</h3><h4 id="1-Selector的创建"><a href="#1-Selector的创建" class="headerlink" title="1. Selector的创建"></a>1. Selector的创建</h4><p>通过调用Selector.open()方法创建一个Selector对象，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 获取Selector选择器</span></span><br><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br></pre></td></tr></table></figure>

<h4 id="2-注册Channel到Selector"><a href="#2-注册Channel到Selector" class="headerlink" title="2. 注册Channel到Selector"></a>2. 注册Channel到Selector</h4><p>要实现Selector管理Channel，需要将Channel注册到相应的Selector上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 获取Selector选择器</span></span><br><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 获取通道</span></span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 设置为非阻塞</span></span><br><span class="line">serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 绑定连接</span></span><br><span class="line">serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9999</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 将通道注册到选择器上，并制定监听事件为：“接收”事件</span></span><br><span class="line">serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>

<p>上面通过调用通道的<code>register()</code>方法会将它注册到一个选择器上。</p>
<p><font color=red>首先需要注意的是：</font></p>
<ol>
<li>与Selector一起使用时，Channel必须处于<strong>非阻塞模式下</strong>，否则将抛出异常<code>IllegalBlockingModeException</code>。这意味着，FileChannel不能与Selector一起使用，因为FileChannel不能切换到非阻塞模式，而套接字相关的所有的通道都可以。</li>
<li>一个通道，并没有一定要支持所有的四种操作。比如服务器通道<code>ServerSocketChannel</code>支持<code>accept()</code>接收操作，而<code>SocketChannel</code>客户端通道则不支持。可以通过通道的<code>validOps()</code>方法，来获取特定通道下所有支持的操作集合。</li>
</ol>
<h4 id="3-轮询查询就绪操作"><a href="#3-轮询查询就绪操作" class="headerlink" title="3. 轮询查询就绪操作"></a>3. 轮询查询就绪操作</h4><ol>
<li><p>通过Selector的select()方法，可以查询出已经就绪的通道操作，这些就绪的状态集合，存到一个SelectionKey对象的Set集合中。</p>
</li>
<li><p>下面是Selector几个重载的查询select()方法：</p>
<ul>
<li><p><code>select()</code>：阻塞到至少有一个通道在你注册的事件上就绪了。</p>
<ul>
<li><blockquote>
<p>这就表明，Selector不会空转cpu，没有key发生时，是会阻塞的，不会一直占用cpu</p>
</blockquote>
<blockquote>
<p>如果select在事件未处理时，它不会阻塞，会一直重复进行未出的那一个key<strong>直至处理为止</strong> 或 <strong>取消</strong>。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>select(long timeout)</code>：和<code>select()</code>一样，但最长阻塞事件时间为timeout毫秒</p>
</li>
<li><p><code>selectNow()</code>：非阻塞，只要有通道就绪就立刻返回</p>
</li>
</ul>
</li>
</ol>
<p><code>select()</code>方法返回的int值，表示有多少通道已经就绪，更准确的说，是之前一次select方法以来到这一次select方法之间的时间段上，有多少通道变成就绪状态。</p>
<p>例如：首次调用<code>select()</code>方法，如果有一个通道变成就绪状态，返回了1，若再次调用<code>select()</code>方法，如果另一个通道就绪了，它会再次返回1.如果对第一个就绪的Channel没有任何操作，现在就有两个就绪的通道，但是每次<code>select()</code>方法调用之间，只有一个通道就绪了。</p>
<p>一旦调用select()方法，并且返回值不为0时，在Selector中有一个<code>selectedKeys()</code>方法，用来访问已选择键集合，迭代集合的每一个选择键元素，根据就绪操作的类型，完成对应的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">selectedKey</span> <span class="operator">=</span> selector.selectedKeys();</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">keyIterator</span> <span class="operator">=</span> selectedKeys.iterator();</span><br><span class="line"><span class="keyword">while</span>(keyIterator.hasNext())&#123;</span><br><span class="line">    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isConnectable())&#123;</span><br><span class="line">        <span class="comment">// a connection was eatablished with a remote server</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isWritable())&#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-停止选择的方法"><a href="#4-停止选择的方法" class="headerlink" title="4.  停止选择的方法"></a>4.  停止选择的方法</h4><p>选择器执行选择的过程，系统底层会依次询问每个通道是否已经就绪，这个过程可能会造成调用线程进行阻塞状态，那么我们有以下三种方式可以唤醒在select()方法中阻塞的线程。</p>
<p><code>wakeup()</code>方法：通过调用Selector对象的<code>wakeup()</code>方法让处于阻塞状态的<code>select()</code>方法立刻返回；该方法使得选择器上的第一个还没有返回的选择操作立即返回。如果当前没有进行中的选择操作，那么下一次对<code>select()</code>方法的一次调用将立即返回。</p>
<p><code>close()</code>方法：通过close()方法关闭Selector，该方法使得任何一个在选择操作中阻塞的线程都被唤醒（类似<code>wakeup()</code>），同时使得注册到该Selector的所有Channel被注销，所有的键将被取消，但是Channel本身并不会关闭。</p>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><p>服务端（接收 客户端的消息，返回消息给客户端）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectorDemo</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serverSelectorTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssc.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;172.16.75.240&quot;</span>,<span class="number">8000</span>));</span><br><span class="line">        ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="comment">// 注册Channel，并且指定感兴趣的事件是Accept</span></span><br><span class="line">        ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">readBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">writeBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        writeBuffer.put(<span class="string">&quot;received&quot;</span>.getBytes());</span><br><span class="line">        writeBuffer.flip();</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nReady</span> <span class="operator">=</span> selector.select();</span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; it = keys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> it.next();</span><br><span class="line">                it.remove();</span><br><span class="line">                <span class="comment">// 接收状态就绪</span></span><br><span class="line">                <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                    <span class="comment">// 创建新的连接，并且把连接注册到selector上，而且，声明这个channel只对读操作感兴趣。</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> ssc.accept();</span><br><span class="line">                    socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    socketChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                    <span class="comment">// 如果读状态就绪</span></span><br><span class="line">                    <span class="comment">// 获取读状态key下的channel</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel)key.channel();</span><br><span class="line">                    readBuffer.clear();</span><br><span class="line">                    socketChannel.read(readBuffer);</span><br><span class="line">                    readBuffer.flip();</span><br><span class="line">                    System.out.println(<span class="string">&quot;received:&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(readBuffer.array()));</span><br><span class="line">                    <span class="comment">// 设置key的感兴趣的状态为写</span></span><br><span class="line">                    key.interestOps(SelectionKey.OP_WRITE);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isWritable())&#123;</span><br><span class="line">                    writeBuffer.rewind();  <span class="comment">// 重置 writeBuffer的position</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                    socketChannel.write(writeBuffer);</span><br><span class="line">                    key.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>客户端向服务端发送消息，并接收服务端返回的消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clientSelector</span><span class="params">()</span> <span class="keyword">throws</span> IOException,InterruptedException&#123;</span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">    socketChannel.connect(<span class="keyword">new</span> <span class="title class_">InetAddress</span>(<span class="string">&quot;172.16.75.240&quot;</span>,<span class="number">8000</span>));</span><br><span class="line">    socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">readBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">32</span>);</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">writeBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">32</span>);</span><br><span class="line">    writeBuffer.put(<span class="string">&quot;hello&quot;</span>.getBytes());</span><br><span class="line">    writeBuffer.flip();</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        writeBuffer.rewind();</span><br><span class="line">        socketChannel.write(writeBuffer);</span><br><span class="line">        readBuffer.clear();</span><br><span class="line">        socketChannel.read(readBuffer);</span><br><span class="line">        System.out.println(<span class="string">&quot;server:&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(readBuffer.array()));</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="NIO编程步骤总结"><a href="#NIO编程步骤总结" class="headerlink" title="NIO编程步骤总结"></a>NIO编程步骤总结</h4><ol>
<li>创建Selector选择器</li>
<li>创建ServerSocketChannel通道，并绑定监听端口</li>
<li>设置Channel通道是非阻塞模式</li>
<li>把Channel注册到Selector选择器上，监听连接事件</li>
<li>调用Selector的select方法（循环调用），监听通道的就绪状态</li>
<li>调用selectKeys方法获取就绪channel集合</li>
<li>遍历就绪channel集合，判断就绪事件类型，实现具体的业务操作</li>
<li>根据业务，决定是否需要再次注册监听事件，重复执行第三步操作</li>
</ol>
<h4 id="为什么每次处理完一个key后，需要将这个key进行移除remove？"><a href="#为什么每次处理完一个key后，需要将这个key进行移除remove？" class="headerlink" title="为什么每次处理完一个key后，需要将这个key进行移除remove？"></a>为什么每次处理完一个key后，需要将这个key进行移除remove？</h4><p>selector内部其实会涉及到两个重要的集合<code>SelectionKey[] ks =  new SelectionKey[n];</code> 和 <code>protected Set&lt;SelectionKey&gt; selectedKeys = new HashSet();</code></p>
<p>在通道Channel往Selector上进行注册时，会对应创建一个<code>SelectionKey</code>, 这个<code>SelectionKey</code>是一个抽象类，附带了所注册的<code>Channel</code>的信息。</p>
<p>当又对应的<code>key</code>就绪时，会往<code>SelectedKeys</code>集合中添加上述注册时创建好的<code>SelectionKey</code>。<font color=red>此处需要注意的是，只要有key的状态变为就绪状态，就会被添加到SelectedKeys中，而且这个过程是单向的，即只往集合中添加相应的key，再相应的key被处理完成之后，这个key的状态会发生改变，但是并没有从集合中移除相应key的操作</font>。因此，在处理完一个就绪的key时，我们就需要及时的进行移除<code>remove</code>操作，避免重复执行。</p>
<blockquote>
<p>如果集合中的key处理完没有及时的移除掉，这就会导致这个key会再次被处理，而在处理这个key 的过程中（假设key所对应的Channel是非阻塞模式的），由于非阻塞模式没有事件发生时，就会返回null，这时就会发生空指针异常。</p>
</blockquote>
<p>使用迭代器的<code>remove()</code>方法就可以将当前的元素从集合中移除。<font color=green>这也是为什么要使用迭代器来进行key的遍历，而不是直接遍历这个集合.</font></p>
<h3 id="💡-select-何时不阻塞"><a href="#💡-select-何时不阻塞" class="headerlink" title="💡 select 何时不阻塞"></a>💡 select 何时不阻塞</h3><ul>
<li>事件发生时<ul>
<li>客户端发起连接请求，会触发accept事件</li>
<li>客户端发送数据过来，客户端正常、异常关闭时，都会触发read事件，另外如果发送的数据大于buffer缓冲区，会触发多次读取事件</li>
<li>channel可写，会触发write时间</li>
<li>在linux下nio bug发生时</li>
</ul>
</li>
<li>调用<code>selector.wakeup()</code></li>
<li>调用<code>selector.close()</code></li>
<li><code>selector</code>所在线程<code>interrupt</code></li>
</ul>
<h2 id="3-5-Pipe和FileLock"><a href="#3-5-Pipe和FileLock" class="headerlink" title="3.5 Pipe和FileLock"></a>3.5 Pipe和FileLock</h2><h3 id="1-Pipe"><a href="#1-Pipe" class="headerlink" title="1. Pipe"></a>1. Pipe</h3><p>Java NIO管道是两个线程之间的单向数据连接。Pipe有一个source通道和一个sink通道。数据会被写入sink通道，从source通道读取。</p>
<p><img src="source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211112100419343-16366826605741.png" alt="image-20211112100419343"></p>
<h4 id="创建管道"><a href="#创建管道" class="headerlink" title="创建管道"></a>创建管道</h4><p><code>Pipe pipe = Pipe.open();</code></p>
<h4 id="向管道写入管道"><a href="#向管道写入管道" class="headerlink" title="向管道写入管道"></a>向管道写入管道</h4><p>要向管道写数据，需要访问sink通道。</p>
<p><code>Pipe.SinkChannel sinkChannel = pipe.sink();</code></p>
<p>通过调用SinkChannel的<code>write()</code>方法，将数据写入SinkChannel；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">newData</span> <span class="operator">=</span> <span class="string">&quot;New String to write to file&quot;</span>+System.currentTimeMillis();</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buffer.clear();</span><br><span class="line">buffer.put(newData.getBytes());</span><br><span class="line">buffer.flip();</span><br><span class="line"><span class="keyword">while</span>(buffer.hasRemaining())&#123;</span><br><span class="line">    sinkChannel.write(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="从管道读取数据"><a href="#从管道读取数据" class="headerlink" title="从管道读取数据"></a>从管道读取数据</h4><p>从管道中读取数据，需要访问source通道。</p>
<p><code>Pipe.SourceChannel sourceChannel = pipe.source();</code></p>
<p>调用source通道的<code>read()</code>方法来读取数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">byteRead</span> <span class="operator">=</span> sourceChannel.read(buf);</span><br></pre></td></tr></table></figure>

<p><code>read()</code>方法返回的int值会告诉我们多少字节被读进了缓冲区。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Pipe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PipeDemo</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pipeDemo</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Pipe</span> <span class="variable">pipe</span> <span class="operator">=</span> Pipe.open();</span><br><span class="line">        <span class="comment">// 向通道中写入数据</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">        buffer.put(<span class="string">&quot;new String Data&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">// 转换读写模式</span></span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        Pipe.<span class="type">SinkChannel</span> <span class="variable">sinkChannel</span> <span class="operator">=</span> pipe.sink();</span><br><span class="line">        sinkChannel.write(buffer);</span><br><span class="line">        <span class="comment">// 从通道中读取数据</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">readBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">        Pipe.<span class="type">SourceChannel</span> <span class="variable">sourceChannel</span> <span class="operator">=</span> pipe.source();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> sourceChannel.read(readBuffer);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(readBuffer.array(),<span class="number">0</span>,len));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-FileLock"><a href="#2-FileLock" class="headerlink" title="2. FileLock"></a>2. FileLock</h3><h4 id="FileLock简介"><a href="#FileLock简介" class="headerlink" title="FileLock简介"></a>FileLock简介</h4><p>文件锁在OS中很常见，如果多个程序同时访问，修改同一个文件，很容易因为文件数据不同步而出现问题。给文件加一个锁，同一时间，只能有一个程序修改此文件，或者程序都只能读此文件，这就解决了同步问题。</p>
<p>文件锁是进程级别的，不是线程级别的。文件锁可以解决多个<strong>进程</strong>并发访问、修改同一个文件的问题，但不能解决多<strong>线程</strong>并发访问、修改同一文件的问题。使用文件锁时，同一进程内的多个线程，可以同时访问、修改此文件。</p>
<p>文件锁时当前程序所属的JVM实例持有的，一旦获取到文件锁（对文件加锁），需要调用<code>release()</code>，或者关闭对应的<code>FileChannel</code>对象，或者当前JVM退出，才会释放这个锁。</p>
<p>一旦某个进程（比如说JVM实例）对某个文件加锁，则在释放这个锁之前，此进程不能再对此文件加锁，就是说JVM实例在同一个文件上的文件锁是不重叠的（进程级别不能重复在同一文件上获取锁）。</p>
<h4 id="文件锁分类："><a href="#文件锁分类：" class="headerlink" title="文件锁分类："></a>文件锁分类：</h4><p><strong>排它锁</strong>：又叫<strong>独占锁</strong>。对文件加排它锁后，该进程可以对此文件进行读写，该进程独占此文件，其他进程不能读写此文件，直到该进程释放文件锁。</p>
<p><strong>共享锁</strong>：某个进程对文件加共享锁，其他进程也可以访问此文件，但这些进程都只能读此文件，不能写。线程是安全的。只要还有一个进程持有共享锁，词文件就只能读，不能写。</p>
<h4 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建FileChannel对象，文件锁只能通过FileChannel对象来使用</span></span><br><span class="line"><span class="type">FileChannel</span> <span class="variable">fileChannle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;./1.txt&quot;</span>).getChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对文件加锁</span></span><br><span class="line"><span class="type">FileLock</span> <span class="variable">lock</span> <span class="operator">=</span> fileChannel.lock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对此文件进行一些读写操作</span></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">lock.release();</span><br></pre></td></tr></table></figure>

<p>文件锁要通过<code>FileChannel</code>对象使用</p>
<h4 id="获取文件锁方法"><a href="#获取文件锁方法" class="headerlink" title="获取文件锁方法"></a>获取文件锁方法</h4><p><strong>有3中获取文件锁的方法：</strong></p>
<ol>
<li><code>lock()</code> 对整个文件加锁，默认为排它锁</li>
<li><code>lock(long position, long size, boolean shared)</code> 自定义加锁方式。前两个参数指定要加锁的部分（可以只对此文件的部分内容加锁），第三个参数指定是否是共享锁。</li>
<li><code>tryLock()</code> 对整个文件加锁，默认为排他锁</li>
<li><code>tryLock(long position, long size, boolean shared)</code> 自定义加锁方式。</li>
</ol>
<p>如果指定为共享锁，则其他进程可读此文件，所有进程均不能写此文件，如果某进程试图对此文件进行写操作，会抛出异常。</p>
<h4 id="lock和tryLock的区别"><a href="#lock和tryLock的区别" class="headerlink" title="lock和tryLock的区别"></a>lock和tryLock的区别</h4><p>lock是阻塞式的，如果为获取到文件锁，会一直阻塞当前线程，直到获取文件锁。</p>
<p>tryLock和lock的作用相同，只不过tryLock是非阻塞式的，tryLock是尝试获取文件锁，获取成功就返回锁对象，否则返回null，不会阻塞当前线程。</p>
<h4 id="FileLock两个方法"><a href="#FileLock两个方法" class="headerlink" title="FileLock两个方法"></a>FileLock两个方法</h4><p><code>boolean isShared()</code> 此文件锁是否是共享锁</p>
<p><code>boolean isValid()</code> 此文件锁是否还有效</p>
<p>在某些OS上，对某个文件加锁后，不能对此文件使用通道映射。</p>
<h4 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileLock;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.StandardOpenOption;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;input:&quot;</span>+input);</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(input.getBytes());</span><br><span class="line">        <span class="type">String</span> <span class="variable">fp</span> <span class="operator">=</span> <span class="string">&quot;Files\\data.txt&quot;</span>;</span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(fp);</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> FileChannel.open(path, StandardOpenOption.WRITE, StandardOpenOption.APPEND);</span><br><span class="line">        channel.position(channel.size()-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">FileLock</span> <span class="variable">lock</span> <span class="operator">=</span> channel.tryLock(<span class="number">0</span>,Long.MAX_VALUE, <span class="literal">false</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;共享锁 shared：&quot;</span>+lock.isShared());</span><br><span class="line"></span><br><span class="line">        channel.write(buffer);</span><br><span class="line">        channel.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;写操作完成&quot;</span>);</span><br><span class="line">        <span class="comment">// 读数据</span></span><br><span class="line">        readPrint(fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readPrint</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(path);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fileReader);</span><br><span class="line">        <span class="type">String</span> <span class="variable">tr</span> <span class="operator">=</span> bufferedReader.readLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;读取内容：&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (tr!=<span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;      &quot;</span>+tr);</span><br><span class="line">            tr = bufferedReader.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">        fileReader.close();</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="3-6-其他"><a href="#3-6-其他" class="headerlink" title="3.6 其他"></a>3.6 其他</h2><h3 id="1-Path"><a href="#1-Path" class="headerlink" title="1. Path"></a>1. Path</h3><h4 id="Path-简介"><a href="#Path-简介" class="headerlink" title="Path 简介"></a>Path 简介</h4><p>Java Path 接口是 Java NIO 更新的一部分，同 Java NIO 一起已经包括在Java6 和 Java7 中。Java Path 接口是在 Java7 中添加到 Java NIO 的。Path 接口位于 java.nio.file 包中，所以 Path 接口的完全限定名称为<code>java.nio.file.Path</code>。</p>
<p>Java Path示例表示文件系统中的路径。一个路径可以指向一个文件或一个目录。路径可以是绝对路径，也可以是相对路径。绝对路径包含从文件系统的根目录到它指向文件或目录的完整路径。相对路径包含相对于其他路径的文件或目录的路径。</p>
<p>在许多方面，<code>java.nio.file.Path</code>接口类似于<code>java.io.File</code>类，但是有一些差别。不过，在许多情况下，可以使用Path接口来替换File类的使用。</p>
<h4 id="创建Path示例"><a href="#创建Path示例" class="headerlink" title="创建Path示例"></a>创建Path示例</h4><p>使用<code>java.nio.file.Path</code>示例必须创建一个Path示例。可以使用Paths类（<code>java.nio.file.Pahts</code>）中的静态方法<code>Paths.get()</code>来创建路径示例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PathDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;D:\\Files\\data.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码，可以理解为，<code>Paths.get()</code>方法是Path示例的工厂方法。</p>
<h4 id="创建绝对路径"><a href="#创建绝对路径" class="headerlink" title="创建绝对路径"></a>创建绝对路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;D:\\Files\\data.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在Linux，MacOs机器上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;/home/Files/data.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果在Windows机器上使用了从<code>/</code>开始的路径，那么路径将被解释为相对于当前驱动器。</p>
<h4 id="创建相对路径"><a href="#创建相对路径" class="headerlink" title="创建相对路径"></a>创建相对路径</h4><p>Java NIO Path类也可以用于处理相对路径。您可以使用<code>Paths.get(basePaht, relativePath)</code>方法创建一个相对路径。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">projects</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;D:\\Files&quot;</span>, <span class="string">&quot;projects&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Path</span> <span class="variable">file</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;D:\\Files&quot;</span>, <span class="string">&quot;projects\\002.txt&quot;</span>);</span><br></pre></td></tr></table></figure>







<h4 id="Path-normalize"><a href="#Path-normalize" class="headerlink" title="Path.normalize()"></a>Path.normalize()</h4><p>Path接口的<code>normalize()</code>方法可以是路径标准化。标准化意味着它将移除所有在路径字符串的中间的.和..代码，并解析路径字符串所引用的路径。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">originalPath</span> <span class="operator">=</span> <span class="string">&quot;d:\\a\\b\\..\\demo.txt&quot;</span>;</span><br><span class="line"><span class="type">Path</span> <span class="variable">path1</span> <span class="operator">=</span> Paths.get(originalPath);</span><br><span class="line">System.out.println(<span class="string">&quot;path1:&quot;</span>path1);</span><br><span class="line"><span class="type">Path</span> <span class="variable">path2</span> <span class="operator">=</span> path1.normalize();</span><br><span class="line">System.out.println(<span class="string">&quot;path2:&quot;</span>+path2);</span><br></pre></td></tr></table></figure>

<p>上述代码会输出：</p>
<blockquote>
<p>path1:d:\a\b\..\demo.txt</p>
<p>path2:d:\a\demo.txt</p>
</blockquote>
<h3 id="2-File"><a href="#2-File" class="headerlink" title="2. File"></a>2. File</h3><h4 id="Files-createDirectory"><a href="#Files-createDirectory" class="headerlink" title="Files.createDirectory()"></a>Files.createDirectory()</h4><h4 id="Files-copy"><a href="#Files-copy" class="headerlink" title="Files.copy()"></a>Files.copy()</h4><h4 id="Files-move"><a href="#Files-move" class="headerlink" title="Files.move()"></a>Files.move()</h4><h4 id="Files-delete"><a href="#Files-delete" class="headerlink" title="Files.delete()"></a>Files.delete()</h4><h4 id="Files-walkFileTree"><a href="#Files-walkFileTree" class="headerlink" title="Files.walkFileTree()"></a>Files.walkFileTree()</h4><h3 id="3-AsynchronousFileChannel"><a href="#3-AsynchronousFileChannel" class="headerlink" title="3. AsynchronousFileChannel"></a>3. AsynchronousFileChannel</h3><h4 id="创建AsynchronousFileChannel"><a href="#创建AsynchronousFileChannel" class="headerlink" title="创建AsynchronousFileChannel"></a>创建AsynchronousFileChannel</h4><h4 id="通过Future读取数据"><a href="#通过Future读取数据" class="headerlink" title="通过Future读取数据"></a>通过Future读取数据</h4><h4 id="通过CompletionHandler读取数据"><a href="#通过CompletionHandler读取数据" class="headerlink" title="通过CompletionHandler读取数据"></a>通过CompletionHandler读取数据</h4><h4 id="通过Future写数据"><a href="#通过Future写数据" class="headerlink" title="通过Future写数据"></a>通过Future写数据</h4><h4 id="通过CompletionHandler写数据"><a href="#通过CompletionHandler写数据" class="headerlink" title="通过CompletionHandler写数据"></a>通过CompletionHandler写数据</h4><h3 id="4-字符集"><a href="#4-字符集" class="headerlink" title="4. 字符集"></a>4. 字符集</h3><p><strong>Charset 常用的静态方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过编码类型获得Charset对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Charset <span class="title function_">forName</span><span class="params">(String charsetName)</span>;</span><br><span class="line"><span class="comment">// 获得系统支持的所有编码方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SortedMap&lt;String, Charset&gt; <span class="title function_">availableCharsets</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 获得虚拟机默认的编码方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Charset <span class="title function_">defaultCharset</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 判断是否支持该编码类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSupported</span><span class="params">(String charsetName)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>Charset 常用普通方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">name</span><span class="params">()</span> <span class="comment">// 获得Charset对象的编码类型String </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> CharsetEncoder <span class="title function_">newEncoder</span><span class="params">()</span>  <span class="comment">// 获得编码器对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> CharsetDecoder <span class="title function_">newDecoder</span><span class="params">()</span>  <span class="comment">// 获得编码器对象</span></span><br></pre></td></tr></table></figure>

<h2 id="3-7-Java-NIO-综合案例"><a href="#3-7-Java-NIO-综合案例" class="headerlink" title="3.7 Java NIO 综合案例"></a>3.7 Java NIO 综合案例</h2><p>使用Java NIO 完成一个多人聊天室功能</p>
<h3 id="1-服务端"><a href="#1-服务端" class="headerlink" title="1. 服务端"></a>1. 服务端</h3><p>code大致思路</p>
<ol>
<li><p>创建Selector选择器</p>
</li>
<li><p>创建ServerSocketChannel通道</p>
</li>
<li><p>为channel通道绑定监听端口</p>
</li>
<li><p>循环，等待有新连接接入</p>
</li>
<li><p>根据就绪状态，调用对应方法实现具体业务操作</p>
<ol>
<li><p>如果是<code>accept</code>状态</p>
<p>…..</p>
</li>
<li><p>如果是可读状态</p>
<p>……</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startServer</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个选择器</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="comment">// 2. 创建一个ServerSocketChannel</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">// 3. 绑定端口号</span></span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9999</span>));</span><br><span class="line">        <span class="comment">// 4. 设置通道模式为非阻塞式模式</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 5. 将serverSocketChannel注册到Selector上,设置监听key为 accept</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器已经成功启动！&quot;</span>);</span><br><span class="line">        <span class="comment">// 循环等待有新连接接入</span></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="comment">// 获取channel的数量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">readChannels</span> <span class="operator">=</span> selector.select();</span><br><span class="line">            <span class="keyword">if</span> (readChannels == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取可用的channel</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            <span class="comment">// 遍历集合</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                <span class="comment">// 移除set集合当前selectionKey</span></span><br><span class="line">                iterator.remove();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 6. 根据就绪状态，调用对应方法实现具体业务操作</span></span><br><span class="line">                <span class="comment">//   6.1 如果监听到的key的状态是accept</span></span><br><span class="line">                <span class="keyword">if</span>(selectionKey.isAcceptable())&#123;</span><br><span class="line">                    <span class="comment">// do something for accept</span></span><br><span class="line">                    acceptOperator(serverSocketChannel, selector);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//   6.2 如果监听到的状态是可读状态</span></span><br><span class="line">                <span class="keyword">if</span>(selectionKey.isReadable())&#123;</span><br><span class="line">                    <span class="comment">// do something for read</span></span><br><span class="line">                    readOperator(selector,selectionKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理接入状态操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">acceptOperator</span><span class="params">(ServerSocketChannel serverSocketChannel, Selector selector)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1. 接入状态，创建socketChannel</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 将socketChannel 设置非阻塞模式</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 把channel注册到selector选择器上，监听可读状态</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 客户端回复消息</span></span><br><span class="line">        socketChannel.write(Charset.forName(<span class="string">&quot;UTF-8&quot;</span>).encode(<span class="string">&quot;欢迎进入聊天室，请注意隐私安全&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理可读状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readOperator</span><span class="params">(Selector selector, SelectionKey selectionKey)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="comment">// 1. 从SelectionKey获取已经就绪的通道</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel) selectionKey.channel();</span><br><span class="line">        <span class="comment">// 2. 创建buffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// 3. 循环读取客户端消息</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">readLength</span> <span class="operator">=</span> socketChannel.read(byteBuffer);</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (readLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 切换缓冲区的读写模式</span></span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            <span class="comment">// 读取内容</span></span><br><span class="line">            message += Charset.forName(<span class="string">&quot;UTF-8&quot;</span>).decode(byteBuffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4. 将channel再次注册到选择器上，监听可读状态</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 把客户端发送的消息，广播到其他客户端</span></span><br><span class="line">        <span class="keyword">if</span> (message.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 广播给其他客户端</span></span><br><span class="line">            System.out.println(message);</span><br><span class="line">            castOtherClient(message, selector, socketChannel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">castOtherClient</span><span class="params">(String message, Selector selector, SocketChannel socketChannel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 获取所有已经连入的channel</span></span><br><span class="line">        Set&lt;SelectionKey&gt; selectionKeySet = selector.keys();</span><br><span class="line">        <span class="comment">// 2. 循环向所有channel广播消息</span></span><br><span class="line">        <span class="keyword">for</span> (SelectionKey selectionKey : selectionKeySet) &#123;</span><br><span class="line">            <span class="comment">// 获取每个channel</span></span><br><span class="line">            <span class="type">SelectableChannel</span> <span class="variable">tarChannel</span> <span class="operator">=</span> selectionKey.channel();</span><br><span class="line">            <span class="comment">// 不给自己发</span></span><br><span class="line">            <span class="keyword">if</span> (tarChannel <span class="keyword">instanceof</span> SocketChannel &amp;&amp; tarChannel != socketChannel) &#123;</span><br><span class="line">                ((SocketChannel)tarChannel).write(Charset.forName(<span class="string">&quot;UTF-8&quot;</span>).encode(message));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ChatServer</span>().startServer();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h3 id="2-客户端"><a href="#2-客户端" class="headerlink" title="2. 客户端"></a>2. 客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatClient</span> &#123;</span><br><span class="line">    <span class="comment">// 启动客户端方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startClient</span><span class="params">(String name)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="comment">// 连接服务器, open方法里面直接传入服务端的ip地址和端口号</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.01&quot;</span>, <span class="number">9999</span>));</span><br><span class="line">        <span class="comment">// 接收服务端响应数据</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程, 用于接收服务端传来的消息</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ClientThread</span>(selector)).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向服务器端发送消息</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            <span class="keyword">if</span>(msg.length()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                socketChannel.write(Charset.forName(<span class="string">&quot;UTF-8&quot;</span>).encode(name+<span class="string">&quot;: &quot;</span>+msg));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-客户端接收服务端线程"><a href="#3-客户端接收服务端线程" class="headerlink" title="3. 客户端接收服务端线程"></a>3. 客户端接收服务端线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClientThread</span><span class="params">(Selector selector)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.selector = selector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">                <span class="comment">// 获取channel数量</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">readChannels</span> <span class="operator">=</span> selector.select();</span><br><span class="line">                <span class="keyword">if</span>(readChannels==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取可用的channel</span></span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                    <span class="comment">// 移除set集合当前selectionKey</span></span><br><span class="line">                    iterator.remove();</span><br><span class="line">                    <span class="comment">// 如果状态为可读状态</span></span><br><span class="line">                    <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">                        readOperator(selector,selectionKey);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readOperator</span><span class="params">(Selector selector, SelectionKey selectionKey)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="comment">// 1. 从Selectionkey获取到已经就绪的通道</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel) selectionKey.channel();</span><br><span class="line">        <span class="comment">// 2. 创建buffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// 3. 循环读取客户端消息</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">readLength</span> <span class="operator">=</span> socketChannel.read(byteBuffer);</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(readLength&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            message += Charset.forName(<span class="string">&quot;UTF-8&quot;</span>).decode(byteBuffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4. 将channel再次注册到选择器上，监听可读状态</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        <span class="keyword">if</span> (message.length()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 广播给其他客户端</span></span><br><span class="line">            System.out.println(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="模拟三个客户端A、B、C三个可客户端在聊天室进行聊天"><a href="#模拟三个客户端A、B、C三个可客户端在聊天室进行聊天" class="headerlink" title="模拟三个客户端A、B、C三个可客户端在聊天室进行聊天"></a>模拟三个客户端A、B、C三个可客户端在聊天室进行聊天</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ChatClient</span>().startClient(<span class="string">&quot;A Client&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ChatClient</span>().startClient(<span class="string">&quot;B Client&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ChatClient</span>().startClient(<span class="string">&quot;C Client&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-8-补充"><a href="#3-8-补充" class="headerlink" title="3.8 补充"></a>3.8 补充</h2><h3 id="处理accept事件"><a href="#处理accept事件" class="headerlink" title="处理accept事件"></a>处理accept事件</h3><p>客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">9090</span>))&#123;</span><br><span class="line">            System.out.println(socket);</span><br><span class="line">            socket.getOutputStream().write(<span class="string">&quot;world&quot;</span>.getBytes());</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>服务端代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelDemo6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> ServerSocketChannel.open()) &#123;</span><br><span class="line">            channel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">            System.out.println(channel);</span><br><span class="line">            <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">            channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            channel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();</span><br><span class="line"><span class="comment">//                int count = selector.selectNow();</span></span><br><span class="line">                log.debug(<span class="string">&quot;select count: &#123;&#125;&quot;</span>, count);</span><br><span class="line"><span class="comment">//                if(count &lt;= 0) &#123;</span></span><br><span class="line"><span class="comment">//                    continue;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取所有事件</span></span><br><span class="line">                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 遍历所有事件，逐一处理</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = keys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                    <span class="comment">// 判断事件类型</span></span><br><span class="line">                    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                        <span class="type">ServerSocketChannel</span> <span class="variable">c</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                        <span class="comment">// 必须处理</span></span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> c.accept();</span><br><span class="line">                        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, sc);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 处理完毕，必须将事件移除</span></span><br><span class="line">                    iter.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="💡-事件发生后能否不处理"><a href="#💡-事件发生后能否不处理" class="headerlink" title="💡 事件发生后能否不处理"></a>💡 事件发生后能否不处理</h4><p>事件发生后，要么处理，要么取消（cancel），不能什么都不做，否则下次该时间仍会触发，这是因为nio底层使用的水平触发。</p>
<h3 id="处理read事件"><a href="#处理read事件" class="headerlink" title="处理read事件"></a>处理read事件</h3><h4 id="消息边界问题-与-channel附件attachment"><a href="#消息边界问题-与-channel附件attachment" class="headerlink" title="消息边界问题  与 channel附件attachment"></a>消息边界问题  与 channel附件attachment</h4><p><img src="source/Java-IO%E4%B8%8ENIO/0023.png" alt="0023"></p>
<ul>
<li>一种思路是固定消息长度，数据包大小一样，服务器按预定长度读取，缺点是浪费贷款</li>
<li>另一种思路是按分隔符拆分，缺点是效率低</li>
<li>TLV格式，即Type类型、Length长度、Value数据，类型和长度已知的情况下，就可以方便获取消息大小，分配合适的buffer，缺点是buffer需要提前分配，如果内容过大，则会影响server的吞吐量<ul>
<li>Http1.1 是TLV格式</li>
<li>Http2.0 是LTV格式</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram </span><br><span class="line">participant c1 as 客户端1</span><br><span class="line">participant s as 服务器</span><br><span class="line">participant b1 as ByteBuffer1</span><br><span class="line">participant b2 as ByteBuffer2</span><br><span class="line">c1 -&gt;&gt; s: 发送 01234567890abcdef3333\r</span><br><span class="line">s -&gt;&gt; b1: 第一次 read 存入 01234567890abcdef</span><br><span class="line">s -&gt;&gt; b2: 扩容</span><br><span class="line">b1 -&gt;&gt; b2: 拷贝 01234567890abcdef</span><br><span class="line">s -&gt;&gt; b2: 第二次 read 存入 3333\r</span><br><span class="line">b2 -&gt;&gt; b2: 01234567890abcdef3333\r</span><br></pre></td></tr></table></figure>



<p>Server端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(ByteBuffer source)</span> &#123;</span><br><span class="line">        source.flip();</span><br><span class="line">        <span class="comment">// 如果没有读到分隔符，source就不会进行get操作，</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; source.limit(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (source.get(i) == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> i + <span class="number">1</span> - source.position();</span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">target</span> <span class="operator">=</span> ByteBuffer.allocate(length);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                    target.put(source.get());</span><br><span class="line">                &#125;</span><br><span class="line">                print(target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当buffer中的还有元素没有读取完成的时候，采用整理的方式，保留剩余元素，清除读取过的元素</span></span><br><span class="line">        <span class="comment">// 这里没有读到\n 这个buffer就会有剩余元素</span></span><br><span class="line">        source.compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(ByteBuffer target)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; target.limit(); i++) &#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>) target.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startServer</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">9999</span>));</span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> serverSocketChannel.register(selector, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        selectionKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="comment">// 循环监听</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            selector.select();  <span class="comment">// 选择阻塞</span></span><br><span class="line">            <span class="comment">// 获取就绪key的集合</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                <span class="comment">// key取出来之后及时的从集合中移除</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="comment">// 根据key的类型，处理不同的业务场景</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> ssc.accept();</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">                    <span class="comment">// TODO 每accept一次，就绑定socketChannel到selector上，并将buffer作为附件一并注册到selector</span></span><br><span class="line">                    <span class="comment">// TODO 这样每个channel就会对应一个buffer对象的附件attchment</span></span><br><span class="line">                    socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ, buffer);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> socketChannel.read(buffer);</span><br><span class="line">                    <span class="keyword">if</span> (read == -<span class="number">1</span>) &#123;  <span class="comment">// 如果read的值为-1，意味正常断开，</span></span><br><span class="line">                        key.cancel();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        split(buffer);</span><br><span class="line">                        <span class="comment">//TODO 当buffer满了，无法再添加数据的时候，需要扩容</span></span><br><span class="line">                        <span class="keyword">if</span>(buffer.position()==buffer.limit()) &#123;</span><br><span class="line">                            <span class="comment">// 扩容 </span></span><br><span class="line">                            <span class="type">ByteBuffer</span> <span class="variable">newBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(buffer.capacity() &lt;&lt; <span class="number">1</span>);</span><br><span class="line">                            <span class="comment">// 重置buffer的position，进行从头读取</span></span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            newBuffer.put(buffer);</span><br><span class="line">                            key.attach(newBuffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Server</span>().startServer();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        sc.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">9999</span>));</span><br><span class="line">        <span class="type">SocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> sc.getLocalAddress();</span><br><span class="line"><span class="comment">// sc.write(Charset.defaultCharset().encode(&quot;hello\nworld\n&quot;));</span></span><br><span class="line">        sc.write(Charset.defaultCharset().encode(<span class="string">&quot;0123\n456789abcdef&quot;</span>));</span><br><span class="line">        sc.write(Charset.defaultCharset().encode(<span class="string">&quot;0123456789abcdef3333\n&quot;</span>));</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ByteBuffer-大小分配"><a href="#ByteBuffer-大小分配" class="headerlink" title="ByteBuffer 大小分配"></a>ByteBuffer 大小分配</h4><ul>
<li><blockquote>
<p>每个channel都需要记录可能被切分的消息，因为ByteBuffer不能被多个channel共同使用，因此需要为每个channel维护一个独立的ByteBuffer</p>
</blockquote>
</li>
<li><blockquote>
<p>ByteBuffer不能太大，比如一个ByteBuffer 1Mb的话，要支持百万连接就需要1Tb内存，因此需要设计大小可变的ByteBuffer</p>
</blockquote>
<ul>
<li>一种思路是首先分配一个较小的buffer，例如4k，如果发现数据不够，再分配8k的buffer，将4kbuffer内容拷贝到8k buffer，优点是消息连续容易处理，缺点是数据拷贝耗费性能。参考实现<a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-performance/resizable-array.html">http://tutorials.jenkov.com/java-performance/resizable-array.html</a></li>
<li>另一种思路是用多个数组组成buffer，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续，解析复杂，优点是避免了拷贝引起的性能损耗。</li>
</ul>
</li>
</ul>
<h4 id="💡-为何要-iter-remove"><a href="#💡-为何要-iter-remove" class="headerlink" title="💡 为何要 iter.remove()"></a>💡 为何要 iter.remove()</h4><blockquote>
<p>因为 select 在事件发生后，就会将相关的 key 放入 selectedKeys 集合，但不会在处理完后从 selectedKeys 集合中移除，需要我们自己编码删除。例如</p>
<ul>
<li>第一次触发了 ssckey 上的 accept 事件，没有移除 ssckey </li>
<li>第二次触发了 sckey 上的 read 事件，但这时 selectedKeys 中还有上次的 ssckey ，在处理时因为没有真正的 serverSocket 连上了，就会导致空指针异常</li>
</ul>
</blockquote>
<h4 id="💡-cancel-的作用"><a href="#💡-cancel-的作用" class="headerlink" title="💡 cancel 的作用"></a>💡 cancel 的作用</h4><blockquote>
<p>cancel 会取消注册在 selector 上的 channel，并从 keys 集合中删除 key 后续不会再监听事件</p>
</blockquote>
<h3 id="处理write事件"><a href="#处理write事件" class="headerlink" title="处理write事件"></a>处理write事件</h3><h4 id="一次无法写完例子"><a href="#一次无法写完例子" class="headerlink" title="一次无法写完例子"></a>一次无法写完例子</h4><ul>
<li>非阻塞模式下，无法保证把buffer中所有数据都写入channel，因此需要追踪write方法的返回值（代表实际写入字节数）</li>
<li>用selector监听所有channel的可写事件，每个channel都需要一个key来跟踪buffer，但这样又会导致占用内存过多，就有两阶段策略<ul>
<li>当消息处理器第一次写入消息时，才将channel注册到selector上</li>
<li>selector检查channel上的可写事件，如果所有的数据写完了，就取消channel的注册<ul>
<li>如果不取消，会每次可写均会触发write事件</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>服务端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriteServer</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startServer</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>));</span><br><span class="line">        ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="comment">// 循环监听</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                <span class="comment">// 取出key，并及时移除key</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">                    socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">scKey</span> <span class="operator">=</span> socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    <span class="comment">// todo 服务端向客户端发送数据</span></span><br><span class="line">                    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">90000000</span>; i++) &#123;</span><br><span class="line">                        sb.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;UTF-8&quot;</span>).encode(sb.toString());</span><br><span class="line">                    <span class="type">int</span> <span class="variable">write</span> <span class="operator">=</span> socketChannel.write(byteBuffer);</span><br><span class="line">                    <span class="comment">// write 代表实际写入了多少字节</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;实际写入字节数：&quot;</span>+ write);</span><br><span class="line">                    <span class="keyword">if</span> (byteBuffer.hasRemaining())&#123;</span><br><span class="line">                        <span class="comment">// 如果buffer position 到 limit 还有数据, 这种情况就是一次性没有写完数据</span></span><br><span class="line">                        <span class="comment">// todo 在原有的事件上，增加 可写write 事件</span></span><br><span class="line">                        scKey.interestOps(scKey.interestOps() + SelectionKey.OP_WRITE);</span><br><span class="line">                        <span class="comment">// 由于buffer中的数据还没有全部被写入完，需要将buffer作为附件，传递给scKey</span></span><br><span class="line">                        scKey.attach(byteBuffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line"><span class="comment">//                    System.out.println(&quot;Selector 监控到可读状态&quot;);</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">write</span> <span class="operator">=</span> socketChannel.write(byteBuffer);</span><br><span class="line">                    System.out.println(<span class="string">&quot;实际写入字节数：&quot;</span>+ write);</span><br><span class="line">                    <span class="keyword">if</span>(!byteBuffer.hasRemaining())&#123;</span><br><span class="line">                        <span class="comment">// 如果buffer中的数据全部写入完成之后，就需要及时的移除 可写状态的监控杆</span></span><br><span class="line">                        key.interestOps(key.interestOps() - SelectionKey.OP_WRITE);</span><br><span class="line">                        <span class="comment">// 清除附件 buffer</span></span><br><span class="line">                        key.attach(<span class="literal">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriteClient</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>));</span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_CONNECT | SelectionKey.OP_READ);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">                    System.out.println(socketChannel.finishConnect());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">                    count += sc.read(buffer);</span><br><span class="line">                    System.out.println(count);</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="非阻塞-VS-阻塞"><a href="#非阻塞-VS-阻塞" class="headerlink" title="非阻塞 VS 阻塞"></a>非阻塞 VS 阻塞</h3><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><ul>
<li>阻塞模式下，相关方法都会导致线程暂停<ul>
<li><code>ServerSocketChannel.accept()</code>会在没有连接建立时让线程暂停</li>
<li><code>SocketChannel.read()</code>会在没有数据可读时让线程阻塞</li>
<li>阻塞的表现其实就是线程暂停了，暂停期间不会占用CPU，但是线程相当于闲置</li>
</ul>
</li>
<li>单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持</li>
<li>但在多线程下，有新的问题，体现在以下几个方面<ul>
<li>32位JVM一个线程占320K，64位JVM一个线程占1024K，如果连接数过多，必然导致OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低</li>
<li>可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接。</li>
</ul>
</li>
</ul>
<p>服务端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用nio来理解阻塞模式，单线程</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"><span class="comment">// 连接集合</span></span><br><span class="line">List&lt;SocketChannel&gt; channels = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept(); <span class="comment">// 阻塞方法，线程停止运行</span></span><br><span class="line">    channels.add(sc);</span><br><span class="line">    <span class="keyword">for</span>(SocketChannel channel : channels)&#123;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        channel.read(buffer); <span class="comment">// 阻塞方法，线程停止运行</span></span><br><span class="line">        buffer.flip();  <span class="comment">// 重置position和limit</span></span><br><span class="line">        debugRead(buffer);</span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">sc.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">8080</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;wainting ...&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h4><ul>
<li>非阻塞模式下， 相关方法都不会让线程暂停<ul>
<li><code>ServerSocketChannel.accept()</code>没有连接建立时，会返回null，继续运行</li>
<li><code>SocketChannel.read()</code>在没有数据可读时，会返回0，但线程不必阻塞，可以去执行其他<code>SocketChannel</code>的<code>read</code>或是去执行<code>ServerSocketChannel.accept</code></li>
<li>写数据时，线程只是等待数据写入Channel即可，无需等<code>Channel</code>通过网络把数据发送出去</li>
</ul>
</li>
<li>但非阻塞模式下，即使没有连接建立，和可读数据，线程仍然在不断运行，白白浪费了cpu</li>
<li>数据复制过程中，线程实际还是阻塞的(AIO改进的地方)</li>
</ul>
<p>服务器端，客户端代码不变</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用nio来理解非阻塞模式，单线程</span></span><br><span class="line"><span class="comment">// 0. ByteBuffer</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line"><span class="comment">// 1. 创建了服务器</span></span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">ssc.configureBlocking(<span class="literal">false</span>); <span class="comment">// 非阻塞模式</span></span><br><span class="line"><span class="comment">// 2. 绑定监听端口</span></span><br><span class="line">ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"><span class="comment">// 3. 连接集合</span></span><br><span class="line">List&lt;SocketChannel&gt; channels = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信</span></span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept(); <span class="comment">// 非阻塞，线程还会继续运行，如果没有连接建立，但sc是null</span></span><br><span class="line">    <span class="keyword">if</span> (sc != <span class="literal">null</span>) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;connected... &#123;&#125;&quot;</span>, sc);</span><br><span class="line">        sc.configureBlocking(<span class="literal">false</span>); <span class="comment">// 非阻塞模式</span></span><br><span class="line">        channels.add(sc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (SocketChannel channel : channels) &#123;</span><br><span class="line">        <span class="comment">// 5. 接收客户端发送的数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(buffer);<span class="comment">// 非阻塞，线程仍然会继续运行，如果没有读到数据，read 返回 0</span></span><br><span class="line">        <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            debugRead(buffer);</span><br><span class="line">            buffer.clear();</span><br><span class="line">            log.debug(<span class="string">&quot;after read...&#123;&#125;&quot;</span>, channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>单线程可以配合Selector完成对多个Channel可读写事件的监控，这称之为多路复用</p>
<ul>
<li>多路复用仅针对网络IO，普通文件IO没法利用多路复用</li>
<li>如果不用Selector的非阻塞模式，线程大部分时间都在做无用功，而Selector能够保证<ul>
<li>有可连接事件时才去连接</li>
<li>有可读事件才去读取</li>
<li>有可写事件才去写入<ul>
<li>限于网络传输能力，Channel未必时时可写，一旦Channel可写，会触发Selector的可写事件。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-9-多线程版的NIO优化"><a href="#3-9-多线程版的NIO优化" class="headerlink" title="3.9 多线程版的NIO优化"></a>3.9 多线程版的NIO优化</h2><blockquote>
<p>现在都是多核cpu，设计时要充分考虑别让cpu的力量被白白浪费</p>
</blockquote>
<p>前面的代码只有一个选择器，没有充分利用多核cpu，如何改进呢？</p>
<p>分两组选择器</p>
<ul>
<li>单线程配一个选择器，专门处理<code>accept</code>事件——Boss</li>
<li>创建cpu核心数的线程，每个线程配一个选择器，轮流处理<strong>read</strong>事件——Workers</li>
</ul>
<p><img src="source/Java-IO%E4%B8%8ENIO/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96.png"></p>
<p>假设共有四个socket客户端<code>1,2,3,4</code>，通过Boss的单线程中的Selector连监听socket的<code>accept</code>事件，然后将相应的socket注册到具体的worker上进行具体的<code>read</code>和<code>write</code>事件的处理。</p>
<p><strong>基础版Server</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> utils.ByteBufferUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiThreadServer</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startServer</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;boss&quot;</span>);</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9999</span>));</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">boss</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">bossSelectionKey</span> <span class="operator">=</span> ssc.register(boss, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// boss线程中的selector专门负责监听accept事件</span></span><br><span class="line">        bossSelectionKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;workder-0&quot;</span>);</span><br><span class="line">        worker.register();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            boss.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = boss.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="comment">// 监听到accept事件，进行处理</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">                    socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    System.out.println(String.format(<span class="string">&quot;connected...&#123;&#125;&quot;</span>+ socketChannel.getRemoteAddress()));</span><br><span class="line">                    <span class="comment">// TODO 将 boss 通过监听accept所得到的socketChannel注册到 worker的selector上</span></span><br><span class="line">                    System.out.println(String.format(<span class="string">&quot;before register...&#123;&#125;&quot;</span>+socketChannel.getRemoteAddress()));</span><br><span class="line">                    socketChannel.register(worker.selector, SelectionKey.OP_READ, <span class="literal">null</span>);</span><br><span class="line">                    System.out.println(String.format(<span class="string">&quot;after register...&#123;&#125;&quot;</span>+socketChannel.getRemoteAddress()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Thread thread;</span><br><span class="line">        <span class="keyword">private</span> Selector selector;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">start</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 用于标识 Selector和Thread是否初始化，保证初始化一次</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 初始化线程，和selector</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="comment">// 保证 在 即使调用 多次register方法，worker和thread只被初始化一次</span></span><br><span class="line">            <span class="keyword">if</span> (!start) &#123;</span><br><span class="line">                selector = Selector.open();</span><br><span class="line">                thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>, name);</span><br><span class="line">                thread.start();</span><br><span class="line">                start = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    selector.select();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">                            <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> socketChannel.read(buffer);</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            ByteBufferUtil.debugAll(buffer);</span><br><span class="line">                            System.out.println(String.format(<span class="string">&quot;read register...&#123;&#125;&quot;</span>+socketChannel.getRemoteAddress()));</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况下，worker线程中进行监控，boss线程中进行注册。但是由于worker线程先执行，导致<code>selector.select();</code>一直阻塞着，后期boss向worker的selector上注册新的事件时，该线程一直在阻塞着，无法继续执行。</p>
<p><strong>改进1Server</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> utils.ByteBufferUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiThreadServer</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startServer</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;boss&quot;</span>);</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9999</span>));</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">boss</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">bossSelectionKey</span> <span class="operator">=</span> ssc.register(boss, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// boss线程中的selector专门负责监听accept事件</span></span><br><span class="line">        bossSelectionKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;workder-0&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            boss.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = boss.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="comment">// 监听到accept事件，进行处理</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">                    socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    System.out.println(String.format(<span class="string">&quot;connected...&#123;&#125;&quot;</span>+ socketChannel.getRemoteAddress()));</span><br><span class="line">                    <span class="comment">// TODO 将 boss 通过监听accept所得到的socketChannel注册到 worker的selector上</span></span><br><span class="line">                    System.out.println(String.format(<span class="string">&quot;before register...&#123;&#125;&quot;</span>+socketChannel.getRemoteAddress()));</span><br><span class="line">                    worker.register(socketChannel);</span><br><span class="line">                    System.out.println(String.format(<span class="string">&quot;after register...&#123;&#125;&quot;</span>+socketChannel.getRemoteAddress()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Thread thread;</span><br><span class="line">        <span class="keyword">private</span> Selector selector;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">start</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 用于标识 Selector和Thread是否初始化，保证初始化一次</span></span><br><span class="line">        <span class="comment">// 两个不同的线程传递执行代码，可以通过队列的方式进行传递</span></span><br><span class="line">        <span class="keyword">private</span> ConcurrentLinkedQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 初始化线程，和selector</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="comment">// 保证 在 即使调用 多次register方法，worker和thread只被初始化一次</span></span><br><span class="line">            <span class="keyword">if</span> (!start) &#123;</span><br><span class="line">                selector = Selector.open();</span><br><span class="line">                thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>, name);</span><br><span class="line">                thread.start();</span><br><span class="line">                start = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ, <span class="literal">null</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClosedChannelException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            selector.wakeup(); <span class="comment">// 唤醒selector的阻塞等待</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// run方法是在新的线程中进行运行的</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    selector.select();</span><br><span class="line">                    <span class="comment">// 获取boss线程中的任务</span></span><br><span class="line">                    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                    <span class="keyword">if</span>(task!=<span class="literal">null</span>)&#123;</span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125;</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">                            <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> socketChannel.read(buffer);</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            ByteBufferUtil.debugAll(buffer);</span><br><span class="line">                            System.out.println(String.format(<span class="string">&quot;read register...&#123;&#125;&quot;</span>+socketChannel.getRemoteAddress()));</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>多worker版本的Server</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> utils.ByteBufferUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiThreadServer</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startServer</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;boss&quot;</span>);</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9999</span>));</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">boss</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">bossSelectionKey</span> <span class="operator">=</span> ssc.register(boss, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// boss线程中的selector专门负责监听accept事件</span></span><br><span class="line">        bossSelectionKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line"><span class="comment">//        Worker[] workers = new Worker[Runtime.getRuntime().availableProcessors()];</span></span><br><span class="line">        Worker[] workers = <span class="keyword">new</span> <span class="title class_">Worker</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; workers.length; i++) &#123;</span><br><span class="line">            workers[i] = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;worker-&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">index</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            boss.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = boss.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="comment">// 监听到accept事件，进行处理</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">                    socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    System.out.println(String.format(Thread.currentThread().getName()+<span class="string">&quot;connected...&#123;&#125;&quot;</span>+ socketChannel.getRemoteAddress()));</span><br><span class="line">                    <span class="comment">// TODO 将 boss 通过监听accept所得到的socketChannel注册到 worker的selector上</span></span><br><span class="line">                    System.out.println(String.format(Thread.currentThread().getName()+<span class="string">&quot;before register...&#123;&#125;&quot;</span>+socketChannel.getRemoteAddress()));</span><br><span class="line">                    <span class="comment">// round robin 轮询</span></span><br><span class="line">                    workers[index.getAndIncrement() % workers.length].register(socketChannel);</span><br><span class="line">                    System.out.println(String.format(Thread.currentThread().getName()+<span class="string">&quot;after register...&#123;&#125;&quot;</span>+socketChannel.getRemoteAddress()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Thread thread;</span><br><span class="line">        <span class="keyword">private</span> Selector selector;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">start</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 用于标识 Selector和Thread是否初始化，保证初始化一次</span></span><br><span class="line">        <span class="comment">// 两个不同的线程传递执行代码，可以通过队列的方式进行传递</span></span><br><span class="line">        <span class="keyword">private</span> ConcurrentLinkedQueue&lt;Runnable&gt; tasks = <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 初始化线程，和selector</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="comment">// 保证 在 即使调用 多次register方法，worker和thread只被初始化一次</span></span><br><span class="line">            <span class="keyword">if</span> (!start) &#123;</span><br><span class="line">                selector = Selector.open();</span><br><span class="line">                thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>, name);</span><br><span class="line">                thread.start();</span><br><span class="line">                start = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tasks.add(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ, <span class="literal">null</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClosedChannelException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            selector.wakeup(); <span class="comment">// 唤醒selector的阻塞等待</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// run方法是在新的线程中进行运行的</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    selector.select();</span><br><span class="line">                    <span class="comment">// 获取boss线程中的任务</span></span><br><span class="line">                    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> tasks.poll();</span><br><span class="line">                    <span class="keyword">if</span>(task!=<span class="literal">null</span>)&#123;</span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125;</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">                            <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> socketChannel.read(buffer);</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            ByteBufferUtil.debugAll(buffer);</span><br><span class="line">                            System.out.println(String.format(Thread.currentThread().getName()+<span class="string">&quot;read register...&#123;&#125;&quot;</span>+socketChannel.getRemoteAddress()));</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-0-NIO-vs-BIO"><a href="#4-0-NIO-vs-BIO" class="headerlink" title="4.0 NIO vs BIO"></a>4.0 NIO vs BIO</h2><h3 id="1-stream-vs-channel"><a href="#1-stream-vs-channel" class="headerlink" title="1. stream vs channel"></a>1. stream vs channel</h3><ul>
<li>stream不会自动缓冲数据，channel会利用系统提供的发送缓冲区、接收缓冲区（更为底层）</li>
<li>stream仅支持阻塞api，channel同时支持阻塞、非阻塞api、网络channel可配合selector实现多路复用。</li>
<li>二者均为全双工，即读写可以同时进行</li>
</ul>
<h3 id="2-IO-模型"><a href="#2-IO-模型" class="headerlink" title="2. IO 模型"></a>2. IO 模型</h3><p>同步阻塞、同步非阻塞、同步多路复用、异步阻塞（没有此情况）、异步非阻塞</p>
<ul>
<li>同步：线程自己去获取结果（一个线程）</li>
<li>异步：线程自己不去获取结果，而是由其它线程送结果（至少两个线程）</li>
</ul>
<p>当调用一次 channel.read 或 stream.read 后，会切换至操作系统内核态来完成真正数据读取，而读取又分为两个阶段，分别为：</p>
<ul>
<li>等待数据阶段</li>
<li>复制数据阶段</li>
</ul>
<p><img src="source/Java-IO%E4%B8%8ENIO/0033.png"></p>
<ul>
<li><p>阻塞 IO</p>
<p><img src="source/Java-IO%E4%B8%8ENIO/0039.png"></p>
</li>
<li><p>非阻塞  IO</p>
<p><img src="source/Java-IO%E4%B8%8ENIO/0035.png"></p>
</li>
<li><p>多路复用</p>
<p><img src="source/Java-IO%E4%B8%8ENIO/0038.png"></p>
</li>
<li><p>信号驱动</p>
</li>
<li><p>异步 IO</p>
<p><img src="source/Java-IO%E4%B8%8ENIO/0037.png"></p>
</li>
<li><p>阻塞 IO vs 多路复用</p>
<p><img src="source/Java-IO%E4%B8%8ENIO/0034.png"></p>
<p><img src="source/Java-IO%E4%B8%8ENIO/0036.png"></p>
</li>
</ul>
<h4 id="🔖-参考"><a href="#🔖-参考" class="headerlink" title="🔖 参考"></a>🔖 参考</h4><p>UNIX 网络编程 - 卷 I</p>
<h3 id="3-零拷贝"><a href="#3-零拷贝" class="headerlink" title="3. 零拷贝"></a>3. 零拷贝</h3><h4 id="3-1-传统-IO-问题"><a href="#3-1-传统-IO-问题" class="headerlink" title="3.1 传统 IO 问题"></a>3.1 传统 IO 问题</h4><p>传统的 IO 将一个文件通过 socket 写出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;helloword/data.txt&quot;</span>);</span><br><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>)f.length()];</span><br><span class="line">file.read(buf);</span><br><span class="line"></span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ...;</span><br><span class="line">socket.getOutputStream().write(buf);</span><br></pre></td></tr></table></figure>

<p>内部工作流程是这样的：</p>
<p><img src="source/Java-IO%E4%B8%8ENIO/0024.png"></p>
<ol>
<li><p>java 本身并不具备 IO 读写能力，因此 read 方法调用后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，去调用操作系统（Kernel）的读能力，将数据读入<strong>内核缓冲区</strong>。这期间用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，其间也不会使用 cpu</p>
<blockquote>
<p>DMA 也可以理解为硬件单元，用来解放 cpu 完成文件 IO</p>
</blockquote>
</li>
<li><p>从<strong>内核态</strong>切换回<strong>用户态</strong>，将数据从<strong>内核缓冲区</strong>读入<strong>用户缓冲区</strong>（即 byte[] buf），这期间 cpu 会参与拷贝，无法利用 DMA</p>
</li>
<li><p>调用 write 方法，这时将数据从<strong>用户缓冲区</strong>（byte[] buf）写入 <strong>socket 缓冲区</strong>，cpu 会参与拷贝</p>
</li>
<li><p>接下来要向网卡写数据，这项能力 java 又不具备，因此又得从<strong>用户态</strong>切换至<strong>内核态</strong>，调用操作系统的写能力，使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu</p>
</li>
</ol>
<p>可以看到中间环节较多，java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的</p>
<ul>
<li>用户态与内核态的切换发生了 3 次，这个操作比较重量级</li>
<li>数据拷贝了共 4 次</li>
</ul>
<h4 id="3-2-NIO优化"><a href="#3-2-NIO优化" class="headerlink" title="3.2 NIO优化"></a>3.2 NIO优化</h4><p>通过 DirectByteBuf </p>
<ul>
<li>ByteBuffer.allocate(10)  HeapByteBuffer 使用的还是 java 内存</li>
<li>ByteBuffer.allocateDirect(10)  DirectByteBuffer 使用的是操作系统内存</li>
</ul>
<p><img src="source/Java-IO%E4%B8%8ENIO/0025.png"></p>
<p>大部分步骤与优化前相同，不再赘述。唯有一点：java 可以使用 DirectByteBuf 将堆外内存映射到 jvm 内存中来直接访问使用</p>
<ul>
<li>这块内存不受 jvm 垃圾回收的影响，因此内存地址固定，有助于 IO 读写</li>
<li>java 中的 DirectByteBuf 对象仅维护了此内存的虚引用，内存回收分成两步<ul>
<li>DirectByteBuf 对象被垃圾回收，将虚引用加入引用队列</li>
<li>通过专门线程访问引用队列，根据虚引用释放堆外内存</li>
</ul>
</li>
<li>减少了一次数据拷贝，用户态与内核态的切换次数没有减少</li>
</ul>
<p>进一步优化（底层采用了 linux 2.1 后提供的 sendFile 方法），java 中对应着两个 channel 调用 transferTo/transferFrom 方法拷贝数据</p>
<p><img src="source/Java-IO%E4%B8%8ENIO/0026.png"></p>
<ol>
<li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 cpu</li>
<li>数据从<strong>内核缓冲区</strong>传输到 <strong>socket 缓冲区</strong>，cpu 会参与拷贝</li>
<li>最后使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu</li>
</ol>
<p>可以看到</p>
<ul>
<li>只发生了一次用户态与内核态的切换</li>
<li>数据拷贝了 3 次</li>
</ul>
<p>进一步优化（linux 2.4）</p>
<p><img src="source/Java-IO%E4%B8%8ENIO/0027.png"></p>
<ol>
<li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 cpu</li>
<li>只会将一些 offset 和 length 信息拷入 <strong>socket 缓冲区</strong>，几乎无消耗</li>
<li>使用 DMA 将 <strong>内核缓冲区</strong>的数据写入网卡，不会使用 cpu</li>
</ol>
<p>整个过程仅只发生了一次用户态与内核态的切换，数据拷贝了 2 次。所谓的【零拷贝】，并不是真正无拷贝，而是在不会拷贝重复数据到 jvm 内存中，零拷贝的优点有</p>
<ul>
<li>更少的用户态与内核态的切换</li>
<li>不利用 cpu 计算，减少 cpu 缓存伪共享</li>
<li>零拷贝适合小文件传输</li>
</ul>
<h3 id="4-文件AIO"><a href="#4-文件AIO" class="headerlink" title="4. 文件AIO"></a>4. 文件AIO</h3><p>先来看看 AsynchronousFileChannel</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AioDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">AsynchronousFileChannel</span> <span class="variable">s</span> <span class="operator">=</span> </span><br><span class="line">                AsynchronousFileChannel.open(</span><br><span class="line">                	Paths.get(<span class="string">&quot;1.txt&quot;</span>), StandardOpenOption.READ);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">2</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">            s.read(buffer, <span class="number">0</span>, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;read completed...&#123;&#125;&quot;</span>, result);</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    debug(buffer);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;read failed...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;do other things...&quot;</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - begin...</span><br><span class="line">13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - do other things...</span><br><span class="line">13:44:56 [DEBUG] [Thread-5] c.i.aio.AioDemo1 - read completed...2</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 61 0d                                           |a.              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>可以看到</p>
<ul>
<li>响应文件读取成功的是另一个线程 Thread-5</li>
<li>主线程并没有 IO 操作阻塞</li>
</ul>
<h4 id="💡-守护线程"><a href="#💡-守护线程" class="headerlink" title="💡 守护线程"></a>💡 守护线程</h4><p>默认文件 AIO 使用的线程都是守护线程，所以最后要执行 <code>System.in.read()</code> 以避免守护线程意外结束</p>
<h4 id="网络-AIO"><a href="#网络-AIO" class="headerlink" title="网络 AIO"></a>网络 AIO</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AioServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">AsynchronousServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> AsynchronousServerSocketChannel.open();</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        ssc.accept(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">AcceptHandler</span>(ssc));</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeChannel</span><span class="params">(AsynchronousSocketChannel sc)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;[%s] %s close\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());</span><br><span class="line">            sc.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReadHandler</span> <span class="keyword">implements</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AsynchronousSocketChannel sc;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ReadHandler</span><span class="params">(AsynchronousSocketChannel sc)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.sc = sc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (result == -<span class="number">1</span>) &#123;</span><br><span class="line">                    closeChannel(sc);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.printf(<span class="string">&quot;[%s] %s read\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());</span><br><span class="line">                attachment.flip();</span><br><span class="line">                System.out.println(Charset.defaultCharset().decode(attachment));</span><br><span class="line">                attachment.clear();</span><br><span class="line">                <span class="comment">// 处理完第一个 read 时，需要再次调用 read 方法来处理下一个 read 事件</span></span><br><span class="line">                sc.read(attachment, attachment, <span class="built_in">this</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class="line">            closeChannel(sc);</span><br><span class="line">            exc.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WriteHandler</span> <span class="keyword">implements</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AsynchronousSocketChannel sc;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">WriteHandler</span><span class="params">(AsynchronousSocketChannel sc)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.sc = sc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class="line">            <span class="comment">// 如果作为附件的 buffer 还有内容，需要再次 write 写出剩余内容</span></span><br><span class="line">            <span class="keyword">if</span> (attachment.hasRemaining()) &#123;</span><br><span class="line">                sc.write(attachment);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class="line">            exc.printStackTrace();</span><br><span class="line">            closeChannel(sc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AcceptHandler</span> <span class="keyword">implements</span> <span class="title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel, Object&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AsynchronousServerSocketChannel ssc;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">AcceptHandler</span><span class="params">(AsynchronousServerSocketChannel ssc)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.ssc = ssc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(AsynchronousSocketChannel sc, Object attachment)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;[%s] %s connected\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">            <span class="comment">// 读事件由 ReadHandler 处理</span></span><br><span class="line">            sc.read(buffer, buffer, <span class="keyword">new</span> <span class="title class_">ReadHandler</span>(sc));</span><br><span class="line">            <span class="comment">// 写事件由 WriteHandler 处理</span></span><br><span class="line">            sc.write(Charset.defaultCharset().encode(<span class="string">&quot;server hello!&quot;</span>), ByteBuffer.allocate(<span class="number">16</span>), <span class="keyword">new</span> <span class="title class_">WriteHandler</span>(sc));</span><br><span class="line">            <span class="comment">// 处理完第一个 accpet 时，需要再次调用 accept 方法来处理下一个 accept 事件</span></span><br><span class="line">            ssc.accept(<span class="literal">null</span>, <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, Object attachment)</span> &#123;</span><br><span class="line">            exc.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2022/06/24/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="next" title="Flink学习笔记">
      Flink学习笔记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-IO%E6%B5%81"><span class="nav-number">1.</span> <span class="nav-text">1. IO流</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-File%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 File类的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#File%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.1.1.</span> <span class="nav-text">File类的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#File%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">1.1.2.</span> <span class="nav-text">File的实例化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">构造器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">常用方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-IO%E6%B5%81%E6%A6%82%E8%BF%B0"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 IO流概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E6%96%87%E4%BB%B6%E6%B5%81"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 文件流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-1-FileReader%E8%AF%BB%E5%85%A5%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">1.3.1.</span> <span class="nav-text">1.3.1 FileReader读入数据的基本操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-2-FileWriter%E5%86%99%E5%87%BA%E6%95%B0%E6%8D%AE%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">1.3.2.</span> <span class="nav-text">1.3.2 FileWriter写出数据的操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-3-FileReader-%E5%92%8C-FileWriter%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E5%A4%8D%E5%88%B6"><span class="nav-number">1.3.3.</span> <span class="nav-text">1.3.3 FileReader 和 FileWriter实现文本复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-4-FileInputStream%E5%92%8CFileOutputStream%E4%B8%8D%E8%83%BD%E8%AF%BB%E5%8F%96%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="nav-number">1.3.4.</span> <span class="nav-text">1.3.4 FileInputStream和FileOutputStream不能读取文本文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-%E7%BC%93%E5%86%B2%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 缓冲流的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-%E8%BD%AC%E6%8D%A2%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.5.</span> <span class="nav-text">1.5 转换流的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-1-%E8%BD%AC%E6%8D%A2%E6%B5%81%E6%A6%82%E8%BF%B0%E4%B8%8EInputStreamReader%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.5.1.</span> <span class="nav-text">1.5.1 转换流概述与InputStreamReader的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-2-%E8%BD%AC%E6%8D%A2%E6%B5%81%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%85%A5%E5%92%8C%E5%86%99%E5%87%BA"><span class="nav-number">1.5.2.</span> <span class="nav-text">1.5.2 转换流实现文件的读入和写出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6-%E5%85%B6%E4%BB%96%E7%9A%84%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.6.</span> <span class="nav-text">1.6 其他的流的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-1-%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E3%80%81%E8%BE%93%E5%87%BA%E6%B5%81"><span class="nav-number">1.6.1.</span> <span class="nav-text">1.6.1 标准输入、输出流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-2-%E6%89%93%E5%8D%B0%E6%B5%81"><span class="nav-number">1.6.2.</span> <span class="nav-text">1.6.2 打印流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-3-%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="nav-number">1.6.3.</span> <span class="nav-text">1.6.3 数据流</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-7-%E5%AF%B9%E8%B1%A1%E6%B5%81"><span class="nav-number">1.7.</span> <span class="nav-text">1.7 对象流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-1-%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.7.1.</span> <span class="nav-text">1.7.1 对象序列化机制的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-2-%E5%AF%B9%E8%B1%A1%E6%B5%81%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C"><span class="nav-number">1.7.2.</span> <span class="nav-text">1.7.2 对象流序列化与反序列化字符串操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-3-serialVersionUID%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.7.3.</span> <span class="nav-text">1.7.3 serialVersionUID的理解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-8-RandomAccessFile-%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E6%96%87%E4%BB%B6%E6%B5%81-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.8.</span> <span class="nav-text">1.8 RandomAccessFile(随机存取文件流)的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-9-Path%E3%80%81Paths%E3%80%81Files%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.9.</span> <span class="nav-text">1.9 Path、Paths、Files的使用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">2. 网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="nav-number">2.0.1.</span> <span class="nav-text">2.1 网络编程概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E8%A6%81%E7%B4%A0%E6%A6%82%E8%BF%B0"><span class="nav-number">2.0.2.</span> <span class="nav-text">2.2 网络通信要素概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E9%80%9A%E4%BF%A1%E8%A6%81%E7%B4%A01%EF%BC%9AIP%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="nav-number">2.0.3.</span> <span class="nav-text">2.3 通信要素1：IP和端口号</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-IP%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8EInetAddress%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">2.0.3.1.</span> <span class="nav-text">2.3.1 IP的理解与InetAddress类的实例化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-%E7%AB%AF%E5%8F%A3%E5%8F%B7%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">2.0.3.2.</span> <span class="nav-text">2.3.2 端口号的理解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E9%80%9A%E4%BF%A1%E8%A6%81%E7%B4%A02%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.0.4.</span> <span class="nav-text">2.4 通信要素2：网络协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-TCP%E5%92%8CUDP%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">2.0.4.1.</span> <span class="nav-text">2.4.1 TCP和UDP网络通信协议的对比</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-TCP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-number">2.0.5.</span> <span class="nav-text">2.5 TCP网络编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-UDP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-number">2.0.6.</span> <span class="nav-text">2.6 UDP网络编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-URL%E7%BC%96%E7%A8%8B"><span class="nav-number">2.0.7.</span> <span class="nav-text">2.7 URL编程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-NIO"><span class="nav-number">3.</span> <span class="nav-text">3. NIO</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-Java-NIO-%E6%A6%82%E8%BF%B0"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 Java NIO 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9EIO"><span class="nav-number">3.1.1.</span> <span class="nav-text">阻塞IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9EIO%EF%BC%88NIO%EF%BC%89"><span class="nav-number">3.1.2.</span> <span class="nav-text">非阻塞IO（NIO）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-Channel"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 Channel</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Channel-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.2.1.</span> <span class="nav-text">Channel 的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FileChannel-%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">FileChannel 操作详解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#FileChannel%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%A4%BA%E4%BE%8B"><span class="nav-number">3.2.1.1.1.</span> <span class="nav-text">FileChannel介绍和示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%89%93%E5%BC%80FileChannel"><span class="nav-number">3.2.1.1.2.</span> <span class="nav-text">1.  打开FileChannel</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%BB%8EFileChannel%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="nav-number">3.2.1.1.3.</span> <span class="nav-text">2. 从FileChannel读取数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%90%91FileChannel%E5%86%99%E6%95%B0%E6%8D%AE"><span class="nav-number">3.2.1.1.4.</span> <span class="nav-text">3. 向FileChannel写数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%85%B3%E9%97%ADFileChannel"><span class="nav-number">3.2.1.1.5.</span> <span class="nav-text">4. 关闭FileChannel</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-FileChannel%E7%9A%84position%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.1.1.6.</span> <span class="nav-text">5. FileChannel的position方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-FileChannel%E7%9A%84size%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.1.1.7.</span> <span class="nav-text">6. FileChannel的size方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-FileChannel-%E7%9A%84-truncate%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.1.1.8.</span> <span class="nav-text">7. FileChannel 的 truncate方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-FileChannel%E7%9A%84force%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.1.1.9.</span> <span class="nav-text">8. FileChannel的force方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-FileChannel%E7%9A%84transferTo%E5%92%8CtransferFrom%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.1.1.10.</span> <span class="nav-text">9. FileChannel的transferTo和transferFrom方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SocketChannel%E9%80%9A%E9%81%93"><span class="nav-number">3.2.2.</span> <span class="nav-text">SocketChannel通道</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-ServerSocketChannel"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">1. ServerSocketChannel</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%93%E5%BC%80ServerSocketChannel"><span class="nav-number">3.2.2.1.1.</span> <span class="nav-text">打开ServerSocketChannel</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B3%E9%97%ADServerSocketChannel"><span class="nav-number">3.2.2.1.2.</span> <span class="nav-text">关闭ServerSocketChannel</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%91%E5%90%AC%E6%96%B0%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="nav-number">3.2.2.1.3.</span> <span class="nav-text">监听新的连接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.2.2.1.4.</span> <span class="nav-text">阻塞模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.2.2.1.5.</span> <span class="nav-text">非阻塞模式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-SocketChannel"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">2.  SocketChannel</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#SocketChannel%E4%BB%8B%E7%BB%8D"><span class="nav-number">3.2.2.2.1.</span> <span class="nav-text">SocketChannel介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SocketChannel%E7%89%B9%E5%BE%81"><span class="nav-number">3.2.2.2.2.</span> <span class="nav-text">SocketChannel特征</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SocketChannel%E4%BD%BF%E7%94%A8"><span class="nav-number">3.2.2.2.3.</span> <span class="nav-text">SocketChannel使用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-DatagramChannel"><span class="nav-number">3.2.2.3.</span> <span class="nav-text">3. DatagramChannel</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%93%E5%BC%80DatagramChannel"><span class="nav-number">3.2.2.3.1.</span> <span class="nav-text">打开DatagramChannel</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE"><span class="nav-number">3.2.2.3.2.</span> <span class="nav-text">接收数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE"><span class="nav-number">3.2.2.3.3.</span> <span class="nav-text">发送数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5"><span class="nav-number">3.2.2.3.4.</span> <span class="nav-text">连接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DatagramChannel%E7%A4%BA%E4%BE%8B"><span class="nav-number">3.2.2.3.5.</span> <span class="nav-text">DatagramChannel示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Scatter-Gather"><span class="nav-number">3.2.3.</span> <span class="nav-text">Scatter&#x2F;Gather</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Scattering-Reads"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">1. Scattering Reads</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Gathering-Writes"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">2. Gathering Writes</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-Buffer"><span class="nav-number">3.3.</span> <span class="nav-text">3.3  Buffer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A5%E5%85%85"><span class="nav-number">3.3.1.</span> <span class="nav-text">补充</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ByteBuffer-%E7%BB%93%E6%9E%84"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">ByteBuffer 结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%F0%9F%92%A1-%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">3.3.1.2.</span> <span class="nav-text">💡 调试工具类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Buffer-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">3.3.2.</span> <span class="nav-text">1. Buffer 的基本用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Buffer%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.3.3.</span> <span class="nav-text">2. Buffer的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Buffer%E5%88%86%E9%85%8D%E5%92%8C%E5%86%99%E6%95%B0%E6%8D%AE"><span class="nav-number">3.3.4.</span> <span class="nav-text">3. Buffer分配和写数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Buffer%E7%9A%84%E5%88%86%E9%85%8D"><span class="nav-number">3.3.4.1.</span> <span class="nav-text">Buffer的分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91Buffer%E4%B8%AD%E5%86%99%E6%95%B0%E6%8D%AE"><span class="nav-number">3.3.4.2.</span> <span class="nav-text">向Buffer中写数据</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-flip-%E6%96%B9%E6%B3%95"><span class="nav-number">3.3.5.</span> <span class="nav-text">4. flip() 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E4%BB%8EBuffer%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="nav-number">3.3.6.</span> <span class="nav-text">5. 从Buffer中读取数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-Buffer%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95"><span class="nav-number">3.3.7.</span> <span class="nav-text">6. Buffer的几个方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#rewind-%E6%96%B9%E6%B3%95"><span class="nav-number">3.3.7.1.</span> <span class="nav-text">rewind()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#clear-%E4%B8%8E-compact-%E6%96%B9%E6%B3%95"><span class="nav-number">3.3.7.2.</span> <span class="nav-text">clear() 与 compact()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mark-%E4%B8%8Ereset-%E6%96%B9%E6%B3%95"><span class="nav-number">3.3.7.3.</span> <span class="nav-text">mark()与reset()方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-Buffer-%E6%93%8D%E4%BD%9C"><span class="nav-number">3.3.8.</span> <span class="nav-text">7. Buffer 操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Buffer%E5%88%86%E7%89%87"><span class="nav-number">3.3.8.1.</span> <span class="nav-text">1. Buffer分片</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%8F%AA%E8%AF%BB%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">3.3.8.2.</span> <span class="nav-text">2. 只读缓冲区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">3.3.8.3.</span> <span class="nav-text">3. 直接缓冲区</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%8E%E9%9D%9E%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.3.8.3.1.</span> <span class="nav-text">直接缓冲区与非直接缓冲区的区别</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6I-O"><span class="nav-number">3.3.8.4.</span> <span class="nav-text">4. 内存映射文件I&#x2F;O</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E9%BB%8F%E5%8C%85-%E4%B8%8E-%E5%8D%8A%E5%8C%85"><span class="nav-number">3.3.9.</span> <span class="nav-text">8. 黏包  与  半包</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-Selector"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 Selector</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Selector%E7%AE%80%E4%BB%8B"><span class="nav-number">3.4.1.</span> <span class="nav-text">1. Selector简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Selector%E5%92%8CChannel%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">3.4.1.1.</span> <span class="nav-text">Selector和Channel的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%8F%AF%E9%80%89%E6%8B%A9%E9%80%9A%E9%81%93%EF%BC%88SelectableChannel%EF%BC%89"><span class="nav-number">3.4.1.2.</span> <span class="nav-text">2. 可选择通道（SelectableChannel）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Channel%E6%B3%A8%E5%86%8C%E5%88%B0Selector"><span class="nav-number">3.4.1.3.</span> <span class="nav-text">3. Channel注册到Selector</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E9%80%89%E6%8B%A9%E9%94%AE%EF%BC%88SelectionKey%EF%BC%89"><span class="nav-number">3.4.1.4.</span> <span class="nav-text">4. 选择键（SelectionKey）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Selector%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">3.4.2.</span> <span class="nav-text">2. Selector的使用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Selector%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">3.4.2.1.</span> <span class="nav-text">1. Selector的创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%B3%A8%E5%86%8CChannel%E5%88%B0Selector"><span class="nav-number">3.4.2.2.</span> <span class="nav-text">2. 注册Channel到Selector</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E8%BD%AE%E8%AF%A2%E6%9F%A5%E8%AF%A2%E5%B0%B1%E7%BB%AA%E6%93%8D%E4%BD%9C"><span class="nav-number">3.4.2.3.</span> <span class="nav-text">3. 轮询查询就绪操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%81%9C%E6%AD%A2%E9%80%89%E6%8B%A9%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">3.4.2.4.</span> <span class="nav-text">4.  停止选择的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-number">3.4.2.5.</span> <span class="nav-text">使用示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NIO%E7%BC%96%E7%A8%8B%E6%AD%A5%E9%AA%A4%E6%80%BB%E7%BB%93"><span class="nav-number">3.4.2.6.</span> <span class="nav-text">NIO编程步骤总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%8F%E6%AC%A1%E5%A4%84%E7%90%86%E5%AE%8C%E4%B8%80%E4%B8%AAkey%E5%90%8E%EF%BC%8C%E9%9C%80%E8%A6%81%E5%B0%86%E8%BF%99%E4%B8%AAkey%E8%BF%9B%E8%A1%8C%E7%A7%BB%E9%99%A4remove%EF%BC%9F"><span class="nav-number">3.4.2.7.</span> <span class="nav-text">为什么每次处理完一个key后，需要将这个key进行移除remove？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%F0%9F%92%A1-select-%E4%BD%95%E6%97%B6%E4%B8%8D%E9%98%BB%E5%A1%9E"><span class="nav-number">3.4.3.</span> <span class="nav-text">💡 select 何时不阻塞</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-Pipe%E5%92%8CFileLock"><span class="nav-number">3.5.</span> <span class="nav-text">3.5 Pipe和FileLock</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Pipe"><span class="nav-number">3.5.1.</span> <span class="nav-text">1. Pipe</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%AE%A1%E9%81%93"><span class="nav-number">3.5.1.1.</span> <span class="nav-text">创建管道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E7%AE%A1%E9%81%93%E5%86%99%E5%85%A5%E7%AE%A1%E9%81%93"><span class="nav-number">3.5.1.2.</span> <span class="nav-text">向管道写入管道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E7%AE%A1%E9%81%93%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="nav-number">3.5.1.3.</span> <span class="nav-text">从管道读取数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">3.5.1.4.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-FileLock"><span class="nav-number">3.5.2.</span> <span class="nav-text">2. FileLock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FileLock%E7%AE%80%E4%BB%8B"><span class="nav-number">3.5.2.1.</span> <span class="nav-text">FileLock简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E9%94%81%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="nav-number">3.5.2.2.</span> <span class="nav-text">文件锁分类：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">3.5.2.3.</span> <span class="nav-text">使用示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E9%94%81%E6%96%B9%E6%B3%95"><span class="nav-number">3.5.2.4.</span> <span class="nav-text">获取文件锁方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lock%E5%92%8CtryLock%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.5.2.5.</span> <span class="nav-text">lock和tryLock的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FileLock%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%B3%95"><span class="nav-number">3.5.2.6.</span> <span class="nav-text">FileLock两个方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B-2"><span class="nav-number">3.5.2.7.</span> <span class="nav-text">使用示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-%E5%85%B6%E4%BB%96"><span class="nav-number">3.6.</span> <span class="nav-text">3.6 其他</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Path"><span class="nav-number">3.6.1.</span> <span class="nav-text">1. Path</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Path-%E7%AE%80%E4%BB%8B"><span class="nav-number">3.6.1.1.</span> <span class="nav-text">Path 简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAPath%E7%A4%BA%E4%BE%8B"><span class="nav-number">3.6.1.2.</span> <span class="nav-text">创建Path示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="nav-number">3.6.1.3.</span> <span class="nav-text">创建绝对路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="nav-number">3.6.1.4.</span> <span class="nav-text">创建相对路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Path-normalize"><span class="nav-number">3.6.1.5.</span> <span class="nav-text">Path.normalize()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-File"><span class="nav-number">3.6.2.</span> <span class="nav-text">2. File</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Files-createDirectory"><span class="nav-number">3.6.2.1.</span> <span class="nav-text">Files.createDirectory()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Files-copy"><span class="nav-number">3.6.2.2.</span> <span class="nav-text">Files.copy()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Files-move"><span class="nav-number">3.6.2.3.</span> <span class="nav-text">Files.move()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Files-delete"><span class="nav-number">3.6.2.4.</span> <span class="nav-text">Files.delete()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Files-walkFileTree"><span class="nav-number">3.6.2.5.</span> <span class="nav-text">Files.walkFileTree()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-AsynchronousFileChannel"><span class="nav-number">3.6.3.</span> <span class="nav-text">3. AsynchronousFileChannel</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAAsynchronousFileChannel"><span class="nav-number">3.6.3.1.</span> <span class="nav-text">创建AsynchronousFileChannel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87Future%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="nav-number">3.6.3.2.</span> <span class="nav-text">通过Future读取数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87CompletionHandler%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="nav-number">3.6.3.3.</span> <span class="nav-text">通过CompletionHandler读取数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87Future%E5%86%99%E6%95%B0%E6%8D%AE"><span class="nav-number">3.6.3.4.</span> <span class="nav-text">通过Future写数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87CompletionHandler%E5%86%99%E6%95%B0%E6%8D%AE"><span class="nav-number">3.6.3.5.</span> <span class="nav-text">通过CompletionHandler写数据</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="nav-number">3.6.4.</span> <span class="nav-text">4. 字符集</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-7-Java-NIO-%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B"><span class="nav-number">3.7.</span> <span class="nav-text">3.7 Java NIO 综合案例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="nav-number">3.7.1.</span> <span class="nav-text">1. 服务端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">3.7.2.</span> <span class="nav-text">2. 客户端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8E%A5%E6%94%B6%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.7.3.</span> <span class="nav-text">3. 客户端接收服务端线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E4%B8%89%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AFA%E3%80%81B%E3%80%81C%E4%B8%89%E4%B8%AA%E5%8F%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9C%A8%E8%81%8A%E5%A4%A9%E5%AE%A4%E8%BF%9B%E8%A1%8C%E8%81%8A%E5%A4%A9"><span class="nav-number">3.7.4.</span> <span class="nav-text">模拟三个客户端A、B、C三个可客户端在聊天室进行聊天</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-8-%E8%A1%A5%E5%85%85"><span class="nav-number">3.8.</span> <span class="nav-text">3.8 补充</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86accept%E4%BA%8B%E4%BB%B6"><span class="nav-number">3.8.1.</span> <span class="nav-text">处理accept事件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%F0%9F%92%A1-%E4%BA%8B%E4%BB%B6%E5%8F%91%E7%94%9F%E5%90%8E%E8%83%BD%E5%90%A6%E4%B8%8D%E5%A4%84%E7%90%86"><span class="nav-number">3.8.1.1.</span> <span class="nav-text">💡 事件发生后能否不处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86read%E4%BA%8B%E4%BB%B6"><span class="nav-number">3.8.2.</span> <span class="nav-text">处理read事件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E8%BE%B9%E7%95%8C%E9%97%AE%E9%A2%98-%E4%B8%8E-channel%E9%99%84%E4%BB%B6attachment"><span class="nav-number">3.8.2.1.</span> <span class="nav-text">消息边界问题  与 channel附件attachment</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ByteBuffer-%E5%A4%A7%E5%B0%8F%E5%88%86%E9%85%8D"><span class="nav-number">3.8.2.2.</span> <span class="nav-text">ByteBuffer 大小分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%F0%9F%92%A1-%E4%B8%BA%E4%BD%95%E8%A6%81-iter-remove"><span class="nav-number">3.8.2.3.</span> <span class="nav-text">💡 为何要 iter.remove()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%F0%9F%92%A1-cancel-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">3.8.2.4.</span> <span class="nav-text">💡 cancel 的作用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86write%E4%BA%8B%E4%BB%B6"><span class="nav-number">3.8.3.</span> <span class="nav-text">处理write事件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E6%AC%A1%E6%97%A0%E6%B3%95%E5%86%99%E5%AE%8C%E4%BE%8B%E5%AD%90"><span class="nav-number">3.8.3.1.</span> <span class="nav-text">一次无法写完例子</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E-VS-%E9%98%BB%E5%A1%9E"><span class="nav-number">3.8.4.</span> <span class="nav-text">非阻塞 VS 阻塞</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E"><span class="nav-number">3.8.4.1.</span> <span class="nav-text">阻塞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="nav-number">3.8.4.2.</span> <span class="nav-text">非阻塞</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">3.8.5.</span> <span class="nav-text">多路复用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-9-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%89%88%E7%9A%84NIO%E4%BC%98%E5%8C%96"><span class="nav-number">3.9.</span> <span class="nav-text">3.9 多线程版的NIO优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-0-NIO-vs-BIO"><span class="nav-number">3.10.</span> <span class="nav-text">4.0 NIO vs BIO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-stream-vs-channel"><span class="nav-number">3.10.1.</span> <span class="nav-text">1. stream vs channel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-IO-%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.10.2.</span> <span class="nav-text">2. IO 模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%F0%9F%94%96-%E5%8F%82%E8%80%83"><span class="nav-number">3.10.2.1.</span> <span class="nav-text">🔖 参考</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="nav-number">3.10.3.</span> <span class="nav-text">3. 零拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-%E4%BC%A0%E7%BB%9F-IO-%E9%97%AE%E9%A2%98"><span class="nav-number">3.10.3.1.</span> <span class="nav-text">3.1 传统 IO 问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-NIO%E4%BC%98%E5%8C%96"><span class="nav-number">3.10.3.2.</span> <span class="nav-text">3.2 NIO优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%96%87%E4%BB%B6AIO"><span class="nav-number">3.10.4.</span> <span class="nav-text">4. 文件AIO</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%F0%9F%92%A1-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.10.4.1.</span> <span class="nav-text">💡 守护线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C-AIO"><span class="nav-number">3.10.4.2.</span> <span class="nav-text">网络 AIO</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
