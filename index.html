<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xiaowodi.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://xiaowodi.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://xiaowodi.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://xiaowodi.github.io/2022/06/24/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/24/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/" class="post-title-link" itemprop="url">大数据学习之路</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-24 08:12:10" itemprop="dateCreated datePublished" datetime="2022-06-24T08:12:10+00:00">2022-06-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h1 id="Java基础复习（JDK1-8）"><a href="#Java基础复习（JDK1-8）" class="headerlink" title="Java基础复习（JDK1.8）"></a>Java基础复习（JDK1.8）</h1><h2 id="容器篇"><a href="#容器篇" class="headerlink" title="容器篇"></a>容器篇</h2><h3 id="1-ArrayList"><a href="#1-ArrayList" class="headerlink" title="1.ArrayList"></a>1.ArrayList</h3><p>关键源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Default initial capacity.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">// 默认初识容量为10</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Shared empty array instance used for empty instances.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment">   * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span></span><br><span class="line"><span class="comment">   * first element is added.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用空参数构造方法之后，列表还是一个空的列表</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The maximum size of array to allocate.</span></span><br><span class="line"><span class="comment">   * Some VMs reserve some header words in an array.</span></span><br><span class="line"><span class="comment">   * Attempts to allocate larger arrays may result in</span></span><br><span class="line"><span class="comment">   * OutOfMemoryError: Requested array size exceeds VM limit</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">// 最大可库容的容量阈值， 当容量超过这个值的时候，ArrayList的最大容量为Integer.MAX_VALUE</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">      ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">      elementData[size++] = e;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">      ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">          <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> minCapacity;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">      modCount++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// overflow-conscious code</span></span><br><span class="line">      <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">          grow(minCapacity);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 扩容关键性代码</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">      <span class="comment">// overflow-conscious code</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">      <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);  <span class="comment">// 每次扩容为原来的1.5倍</span></span><br><span class="line">      <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">          newCapacity = minCapacity; <span class="comment">//扩容后如果不够，那么就直接扩容为当前容量+1</span></span><br><span class="line">      <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">          newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">      <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">      elementData = Arrays.copyOf(elementData, newCapacity);  <span class="comment">// 通过拷贝数据中的元素到新的数组，进行扩容</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 判断是否超过最大的扩容阈值</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">      <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">          Integer.MAX_VALUE :</span><br><span class="line">          MAX_ARRAY_SIZE;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li>ArrayList底层是通过数组实现的</li>
<li>ArrayList的默认容量为10；</li>
<li>ArrayList为懒加载，只有在添加了第一个元素之后才会真正分配空间</li>
<li>扩容时，每次扩容为原来容量的1.5倍：原来的容量值+容量值&gt;&gt;1</li>
<li>如果扩容后容量超过Integer.MAX_VALUE-8，ArrayList的容量就为Integer的最大值</li>
<li>每次扩容时，是通过将旧的数组中的元素拷贝到扩容后的新的数组中</li>
<li>查询、更新元素效率高</li>
</ul>
<h3 id="2-LinkedList"><a href="#2-LinkedList" class="headerlink" title="2.LinkedList"></a>2.LinkedList</h3><ul>
<li>LinkedList底层是通过双向链表实现的</li>
<li>可以当成Stack与Queue来实现</li>
<li>插入，删除元素效率高</li>
</ul>
<h3 id="3-HashMap"><a href="#3-HashMap" class="headerlink" title="3.HashMap"></a>3.HashMap</h3><p><a target="_blank" rel="noopener" href="https://editor.csdn.net/md/?articleId=113561579">HashMap原理</a></p>
<p>小总结：</p>
<ul>
<li>初识主数组长度：16（1&lt;&lt;4）</li>
<li>主数组最大长度：2^30</li>
<li>默认的负载因子0.75</li>
<li>链表树化阈值1：8</li>
<li>链表树化阈值2：主数组table长度超过64</li>
<li>红黑树退化成链表阈值：树节点少于6</li>
</ul>
<blockquote>
<p>HashMap的主数组长度需要满足2的幂次方</p>
<p>比如输入为1，table长度为2</p>
<p>输入长度为15，table长度为16</p>
</blockquote>
<h4 id="HashMap插入元素底层原理"><a href="#HashMap插入元素底层原理" class="headerlink" title="HashMap插入元素底层原理"></a>HashMap插入元素底层原理</h4><ol>
<li><p>插入元素前对key的HashCode进行扰动函数hash()计算</p>
<ol>
<li><blockquote>
<p>现获取key的hashCode的值h，然后将h与h的高16位进行异或运算</p>
<p>其目的是在进行路由寻址的时候，能够保证在元素个数较少的情况下，路由地址会同时保持高16位和低16位的共同特征</p>
</blockquote>
</li>
</ol>
</li>
<li><p>插入元素</p>
<ol>
<li><blockquote>
<p><strong>路由公式： i=hash &amp; (table.length - 1)</strong></p>
<p>为什么是table.length - 1，而不是table.length呢？</p>
<p>因为table.length为2的幂次方计算出来（1000000000），0多1少</p>
<p>直接与hash进行&amp;运算的时候，都会变为0，更容易发生hash冲突</p>
<p>-1的目的就是将众多的0变为1，<em>与运算之后的值更不容易相同，缓解hash冲突。</em></p>
</blockquote>
</li>
<li><blockquote>
<p>路由地址计算出来后，就要插入元素</p>
<p><strong>插入情景1</strong>：主数组i位置为null（没有冲突），直接插入元素</p>
<p><strong>插入情景2</strong>：主数组i位置存在元素，且key值相同，就新的value值覆盖旧的value值</p>
<p><strong>插入情景3</strong>：主数组i位置存在元素，且没有树化，尾插法插入链表</p>
<p>​                      如果链表长度超过8，同时主数组长度打到64， 才开始树化</p>
<p><strong>插入情景4</strong>：主数组i位置存在元素，且已经树化成红黑树，向红黑树中插入元素</p>
</blockquote>
</li>
</ol>
</li>
<li><p>元素插入达到阈值，进行扩容</p>
<ol>
<li><blockquote>
<p>阈值计算：当前主数组长度 * 负载因子</p>
<p>当map中的元素个数size大于这个阈值的时候，触发扩容</p>
</blockquote>
</li>
<li><p>主数组每次扩容原来的一倍：通过向左移位来实现（避免经过乘法器，耗性能）</p>
</li>
<li><p>扩容情景：</p>
<ol>
<li><p>主数组对应的slot内没有元素（null），不做处理</p>
</li>
<li><p>主数组对应的slot内有元素，但是没有链化，直接用改元素的扰动值hash直接与（新的数组长度-1）进行&amp;运算，计算出新的位置</p>
</li>
<li><p>主数组对应的slot内有元素，但是已经链化了</p>
<ol>
<li><blockquote>
<p>这时就需要进行高低链分链</p>
<p>用key的hash值（扰动后的）与扩容前的旧容量进行&amp;运算，如果为0，即为低链；不为0,即为高链</p>
<p>低链的元素扩容后还在<strong>原索引</strong>位置；高链的元素扩容后在<strong>原索引+旧容量</strong>处</p>
</blockquote>
</li>
<li><p>如果是红黑树进行分链的时候，可能元素会少于6个，这个时候就需要退化成链表</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><font color=red>HashMap在高并发的情况下，链表会出现环形链表</font></p>
<p><font color=green>这里提及一道经典面试题：如何判断一个链表是否有环？？？</font></p>
<p>使用快慢指针（double pointer）</p>
<p>slow和fast：slow每次走一步，fast每次走两步；如果两个指针能相遇，一定存在环儿；</p>
<p>（<font color=blue>生活中的例子：两个人跑圈，快的人在第二圈的时候一定会遇到慢的那个人</font>）</p>
<h3 id="4-线程安全的容器"><a href="#4-线程安全的容器" class="headerlink" title="4.线程安全的容器"></a>4.线程安全的容器</h3><p>上述提及的容器类都是线程不安全的容器类，在并发环境下应该避免使用</p>
<h4 id="线程安全的List"><a href="#线程安全的List" class="headerlink" title="线程安全的List"></a>线程安全的List</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 效率高，不支持并发</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;(); <span class="comment">// 线程安全，但是效率低</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">vector 在添加元素的一些操作的方法，添加了synchronized关键，进行上锁，效率比较低</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()); <span class="comment">// 线程安全，小数量完全可以</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">synchronizedList内部是通过在具体的操作上包裹synchronized关键字，而不是粗暴的同步整个方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;(); <span class="comment">// 线程安全，JUC包下的类（写时复制）,适用于多线程环境</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">每次添加元素的时候，先将集合中的元素复制到一个长度+1的新的数组中，然后将新增的元素添加到新的数组中，然后再将数组引用指向新的数组中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这就保证了：读和写是在不同的对象上进行的，所以不存在资源竞争关系，不需要加锁</span></span><br><span class="line"><span class="comment">					读写分离思想</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="线程安全的HashMap"><a href="#线程安全的HashMap" class="headerlink" title="线程安全的HashMap"></a>线程安全的HashMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Collections.synchronizedMap</span></span><br><span class="line">Map&lt;Object, Object&gt; synchronizedMap = Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcurrentHashMap</span></span><br><span class="line">ConcurrentHashMap&lt;Object, Object&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h5 id="ConCurrentHashMap"><a href="#ConCurrentHashMap" class="headerlink" title="ConCurrentHashMap"></a>ConCurrentHashMap</h5><p>1.7 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/31614308">ConCurrentHashMap小灰漫画</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ZOKEKAI/article/details/90051567%EF%BC%9AConcurrentHashMap%E8%AF%A6%E8%A7%A3">https://blog.csdn.net/ZOKEKAI/article/details/90051567：ConcurrentHashMap详解</a></p>
<p><code>sizeCtl</code>:</p>
<blockquote>
<p>默认值为0；</p>
<p> -1:表示table正在初始化；通过CAS赋值sizeCtl为-1，然后控制只有一个线程来完成初始化操作，其他线程都需要让出CPU<code>Thread.yield</code></p>
<p>-N:表示有N-1个线程正在扩容；</p>
<p>其它情况：</p>
<ul>
<li>如果table未初始化，表示table需要初始化的大小</li>
<li>如果table初始化完成，表示table的容量，默认是table大小的0.75倍；</li>
</ul>
</blockquote>
<p>扩容时，是从后向前进行元素的<strong>迁移</strong></p>
<p>多线程扩容，每个线程负责主数组16个slot，小于16的使用单线程即可</p>
<p><strong>什么是lastRun节点？</strong></p>
<p>lastRun是在迁移一个链表的数据时，保证后面的节点与自己的取余值相同，避免后面没有必要的循环。</p>
<p>其本质就是作为<strong>低位链</strong>或者<strong>高位链</strong>的头结点，这个节点后边的元素可以不进行循环计算，而前面的节点需要挨个进行hash&amp;运算，如果是<strong>低位链</strong>或者<strong>高位链</strong>的节点，就采用<font color=green>头插法</font>将其节点插入到链表中。剩余的元素就是<strong>高位链</strong>或者<strong>低位链</strong>的元素。</p>
<h2 id="JVM篇"><a href="#JVM篇" class="headerlink" title="JVM篇"></a>JVM篇</h2><p>JVM：java虚拟机，能够识别.class文件，能够将class文件中的字节码指令进行识别并调用操作系统向上的API完成动作。</p>
<p>JRE：Java运行时环境。主要包括两个部分：JVM的标准实现和java的一些基本类库。相对于jvm来说，jre多出来一部分java类库</p>
<p>JDK：Java开发工具包。是整个Java开发的核心，继承了jre和一些好用的小工具。</p>
<h3 id="1-JVM的内存构成"><a href="#1-JVM的内存构成" class="headerlink" title="1.JVM的内存构成"></a>1.JVM的内存构成</h3><p>JAVA内存构成包括：<strong>堆、java栈</strong>、本地方法栈、程序计数器</p>
<p>jdk1.8之后，方法区（元空间并不在jvm中了，而是使用本地内存）</p>
<h4 id="1-1-程序计数器（PC寄存器）"><a href="#1-1-程序计数器（PC寄存器）" class="headerlink" title="1.1 程序计数器（PC寄存器）"></a>1.1 程序计数器（PC寄存器）</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul>
<li>字节码解释器通过改变程序计数器来一次读取指令，从而实现代码的流程控制</li>
<li>在多线程情况下，程序计数器记录的是当前线程执行的位置，从而当线程切换回来时，就知道上次执行到哪了。</li>
</ul>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul>
<li>是一块较小的内存空间</li>
<li>线程私有，每条线程都有自己的程序计数器</li>
<li>生命周期：随着线程的创建而创建，随着线程的结束而销毁</li>
<li>是唯一一个不会出现OutOfMemroyError的内存区域</li>
</ul>
<h4 id="1-2-Java虚拟机栈（Java栈）"><a href="#1-2-Java虚拟机栈（Java栈）" class="headerlink" title="1.2 Java虚拟机栈（Java栈）"></a>1.2 Java虚拟机栈（Java栈）</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>Java虚拟机栈是描述Java方法运行过程的内存模型</p>
<p>Java虚拟机栈会为每一个即将运行的Java方法创建一块叫做“栈帧”的区域，用于存放该方法运行过程中的一些信息，如：</p>
<ul>
<li>局部变量表</li>
<li>操作数栈</li>
<li>动态链接</li>
<li>方法出口信息</li>
<li>…….</li>
</ul>
<p><img src="https://github.com/wangzhiwubigdata/God-Of-BigData/raw/master/JVM/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.resources/6F3902DB-275A-4FC6-8E3A-754DE6F987BA.jpg" alt="875223b19a3ea457678d5a09acb950e0"></p>
<h5 id="压栈出栈过程"><a href="#压栈出栈过程" class="headerlink" title="压栈出栈过程"></a>压栈出栈过程</h5><p>当方法运行过程中需要创建局部变量时，就将局部变量的值存入栈帧中的局部变量表中。</p>
<p>Java虚拟机栈的栈顶的栈帧是当前正在执行的活动栈，也就是当前正在执行的方法，PC寄存器也会指向这个地址。只有这个活动的栈帧的本地变量可以被操作数栈使用，当在这个栈帧中调用另一个方法，与之对应的栈帧又会被创建，新创建的栈帧压入栈顶，变为当前的活动栈帧。</p>
<p>方法结束之后，当前栈帧被移除，栈帧的返回值变成新的活动栈帧中操作数栈的一个操作数。如果没有返回值，那么新的活动栈帧中操作数栈的操作数没有变化。</p>
<blockquote>
<p>由于Java虚拟机栈是线程对应的，数据不是线程共享的，因此不同关系数据一致性问题，也不会存在同步锁的问题。</p>
</blockquote>
<h5 id="Java栈的特点"><a href="#Java栈的特点" class="headerlink" title="Java栈的特点"></a>Java栈的特点</h5><ul>
<li>局部变量表随着栈帧的创建而创建，它的大小在编译时确定，创建时只需分配事先规定的大小即可。在方法运行过程中，局部变量表的大小不会发生改变。</li>
<li>Java栈会出现两种异常：<code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code><ul>
<li>StackOverFlowError若Java虚拟机栈的大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度时，抛出StackOverFlowError异常</li>
<li>OutOfMemoryError若允许动态扩展，那么当线程请求栈时内存用完了，无法再动态扩展时，抛出OutOfMemoryError异常。</li>
</ul>
</li>
<li>Java栈也是线程私有的，随着线程的创建而创建，随着线程的结束而销毁。</li>
</ul>
<blockquote>
<p>出现StackOverFlowError时，内存空间可能还有很多。</p>
</blockquote>
<h4 id="1-3-本地方法栈（C栈）"><a href="#1-3-本地方法栈（C栈）" class="headerlink" title="1.3 本地方法栈（C栈）"></a>1.3 本地方法栈（C栈）</h4><h5 id="本地方法栈的定义："><a href="#本地方法栈的定义：" class="headerlink" title="本地方法栈的定义："></a>本地方法栈的定义：</h5><p>本地方法栈是为JVM运行Native方法准备的空间，由于很多Native方法都是用C语言实现的，所以它通常又叫做C栈。它与Java虚拟机栈实现的功能类似，只不过本地方法栈是描述本地方法运行过程的内存模型。</p>
<h5 id="栈帧变化过程"><a href="#栈帧变化过程" class="headerlink" title="栈帧变化过程"></a>栈帧变化过程</h5><p>本地方法被执行时，在本地方法栈也会创建一块栈帧，用于存放该方法的局部变量表、操作数栈、动态链接、方法出口信息等。</p>
<p>方法执行结束后，相应的栈帧也会出栈，并释放本地内存空间。也会抛出<code>StackOverFlowError</code>和<code>OutOfMemoryError</code>异常。</p>
<blockquote>
<p>如果Java虚拟机本身不支持Native方法，或者本身不依赖与传统栈，那么可以不提供本地方法栈。如果本地支持方法栈，那么这个栈一般会在线程创建的时候按线程分配。</p>
</blockquote>
<h4 id="1-4-Java堆Heap"><a href="#1-4-Java堆Heap" class="headerlink" title="1.4 Java堆Heap"></a>1.4 Java堆Heap</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>堆是用来存放对象的内存空间，几乎所有的对象都存储在堆中</p>
<h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><ul>
<li>线程共享，整个Java虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java栈、本地方法栈都是一个线程对应一个。</li>
<li>在虚拟机启动时创建。</li>
<li>是垃圾回收的主要场所</li>
<li>进一步可分为：新生代（Eden区， From Survivor、To Survivor）、老年代</li>
</ul>
<p>不同的区域存放不同生命周期的对象，这样可以根据不同的区域使用不同的垃圾回收算法，更具有针对性。</p>
<p>堆的大小既可以固定也可以扩展，但对于主流的虚拟机，堆的大小是可扩展的，因为当线程请求分配内存，但堆已满，且内存已无法再扩展时，就抛出<code>OutOfMemoryError</code></p>
<blockquote>
<p>Java堆所使用的内存不需要保证是连续的。而由于堆是被所有线程共享的，所以对它的访问需要注意同步问题，方法和对应的属性都需要保证一致性。</p>
</blockquote>
<h5 id="堆的划分"><a href="#堆的划分" class="headerlink" title="堆的划分"></a>堆的划分</h5><p><img src="https://img-blog.csdnimg.cn/20200824152328561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Mjc2ODM1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>逻辑上：</strong></p>
<ul>
<li>新生代（Young）<ul>
<li>Eden</li>
<li>幸存区：From 和To</li>
</ul>
</li>
<li>老年代（Old）</li>
<li>元空间</li>
</ul>
<p><strong>物理上：</strong></p>
<p>物理上分为 <strong>新生代+老年代</strong>，而元空间使用的是直接内存</p>
<h5 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h5><h6 id="1-对象优先分配在Eden区"><a href="#1-对象优先分配在Eden区" class="headerlink" title="1. 对象优先分配在Eden区"></a>1. 对象优先分配在Eden区</h6><p>大多数情况下，对象在新生代Eden区中分配。当Eden去没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p>
<p>👇<strong>Minior GC vs Major GC</strong></p>
<ul>
<li>Minior GC：回收新生代（包括Eden和Survivor区域），因为Java对象大多都具备朝生夕灭的特性，所以Minior GC非常频繁，一般回收速度也比较快。</li>
<li>Major GC：回收老年代，Major GC的速度一般会比Minor GC慢10倍以上。</li>
</ul>
<h6 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2.大对象直接进入老年代"></a>2.大对象直接进入老年代</h6><p>大对象是指需要大量连续内存空间的Java对象，如很长的字符串或数据。</p>
<p>虚拟机提供了一个<code>-XX:PretenureSizeThreshold</code>参数，令大于这个设置值的对象直接在老年代分配，这样做的目的是避免在Eden以及两个Survivor区之间发生大量的内存复制。</p>
<blockquote>
<p>只要分配的对象的内存大小大于这个参数的时候就会直接分配到老年代</p>
</blockquote>
<h6 id="3-长期存活的对象将进入老年代（默认15）"><a href="#3-长期存活的对象将进入老年代（默认15）" class="headerlink" title="3. 长期存活的对象将进入老年代（默认15）"></a>3. 长期存活的对象将进入老年代（默认15）</h6><p>JVM给每个对象定义了一个对象年龄计数器。当新生代发生一次Minor GC后，存活下来的对象年龄+1，当年龄超过<code>-XX:MaxTenuringThreshold, 默认为15</code>设置的值时，就将超过该值的所有对象转移到老年代中。</p>
<h6 id="4-动态年龄判定"><a href="#4-动态年龄判定" class="headerlink" title="4. 动态年龄判定"></a>4. 动态年龄判定</h6><p>Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半</p>
<p>（<code>-XX:TargetSurvivorRatio 默认值为50， 意味Survivor区对象使用率阈值为50%</code> ），年龄大于或等于该年龄的对象直接进入老年代。</p>
<h5 id="老年代空间分配担保"><a href="#老年代空间分配担保" class="headerlink" title="老年代空间分配担保"></a>老年代空间分配担保</h5><p>什么是空间分配担保？</p>
<blockquote>
<p>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间：</p>
<p>​    如果大于，则此次Minor GC是安全的</p>
<p>​    如果小于, 则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。</p>
<p>​            如果<code>HandlePromotionFailure=true</code>，那么会继续检查老年代最大可用连续空间是否大于<code>历次晋升到老年代的对象的平均大小</code>，如果大于，则尝试进行一次Minor GC，但是这次Minor GC 依然是有风险的（<font color=green>因为Minor Gc之后，再次进入到老年代的对象的总大小有可能超过老年代最大可用连续空间</font>）</p>
<p>​            如果小于或者<code>HandlePromotionFailure=false</code>则改为进行一次Full GC</p>
</blockquote>
<p>为什么要进行空间担保？</p>
<blockquote>
<p>是因为新生代采用<strong>复制收集算法</strong>，假如大量对象在Minor GC后仍然存活（最极端情况为内存回收后新生代中所有对象均存活），而Survivor空间是比较小的，这时就需要老年代进行分配担保，把Survivor无法容纳的对象放到老年代。<strong>老年代要进行空间分配担保，前提是老年代得有足够空间来容纳这些对象</strong>，但一共有多少对象在内存回收后存活下来是不可预知的，<strong>因此只好取之前每次垃圾回收后晋升到老年代的对象大小的平均值作为参考</strong>。使用这个平均值与老年代剩余空间进行比较，来决定是否进行Full GC来让老年代腾出更多空间。</p>
</blockquote>
<p>总结起来：新生代存在大量存活的对象，Survivor无法容纳这些对象，老年代要进行空间分配担保；担保前要判断自生有没有能力，如果没有能力就需要触发Full GC。</p>
<h4 id="1-5-方法区"><a href="#1-5-方法区" class="headerlink" title="1.5 方法区"></a>1.5 方法区</h4><h5 id="方法区定义"><a href="#方法区定义" class="headerlink" title="方法区定义"></a>方法区定义</h5><p>Java虚拟机规范中定义方法区是堆的一个逻辑部分。方法区存放一下信息：</p>
<ul>
<li>已经被虚拟机加载的类信息</li>
<li>常量</li>
<li>静态变量</li>
<li>即时编译器编译后的代码</li>
</ul>
<h5 id="方法区的特点"><a href="#方法区的特点" class="headerlink" title="方法区的特点"></a>方法区的特点</h5><ul>
<li>线程共享。方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。</li>
<li>内存回收效率低。方法区中的信息一般需要长期存在，回收一遍之后可能只有少量信息无效。主要回收目标是：对常量池的回收；对类型的卸载</li>
</ul>
<h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p>方法区中存放：<strong>类信息、常量、静态变量、即时编译器编译后的代码</strong>。常量就存放在运行时常量池中</p>
<h3 id="2-垃圾收集策略-amp-算法"><a href="#2-垃圾收集策略-amp-算法" class="headerlink" title="2. 垃圾收集策略&amp;算法"></a>2. 垃圾收集策略&amp;算法</h3><h4 id="2-1-判断对象是否存活"><a href="#2-1-判断对象是否存活" class="headerlink" title="2.1 判断对象是否存活"></a>2.1 判断对象是否存活</h4><ol>
<li><strong>引用计数法</strong></li>
</ol>
<blockquote>
<p>在对象头维护着一个counter计数器，对象被引用一次则计数器+1；若引用失效则计数器-1.当计数器为0时，就认为该对象无效了。</p>
<p>引用计数算法的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法。但是主流的 Java 虚拟机里没有选用引用计数算法来管理内存，主要是因为它很难解决对象之间循环引用的问题。</p>
<blockquote>
<p>举个栗子👉对象 objA 和 objB 都有字段 instance，令 objA.instance = objB 并且 objB.instance = objA，由于它们互相引用着对方，导致它们的引用计数都不为 0，于是引用计数算法无法通知 GC 收集器回收它们。</p>
</blockquote>
</blockquote>
<ol start="2">
<li><strong>可达性分析（GC Roots）</strong></li>
</ol>
<p>基本思路就是通过一些列名为”GC Roots“的对象作为起始点，开始向下搜索，如果一个对象到GCRoots没有任何引用链，就说明这个对象已经没有引用了，就可以作为垃圾。</p>
<p>也即给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可达到的）对象就被判定为存活，没有被遍历到的就自然判定为死亡对象。</p>
<h6 id="哪些对象可以作为GC-Roots"><a href="#哪些对象可以作为GC-Roots" class="headerlink" title="哪些对象可以作为GC Roots"></a>哪些对象可以作为GC Roots</h6><ul>
<li><strong>虚拟机栈中的引用的对象</strong></li>
<li><strong>方法区中的类静态属性引用的对象</strong></li>
<li><strong>方法区中的常量引用的对象</strong></li>
<li><strong>synchronized同步的对象</strong></li>
</ul>
<p><strong>GC Roots并不包括堆中对象引用的对象，这样就不会有循环引用的问题。</strong></p>
<h4 id="2-1-垃圾收集算法"><a href="#2-1-垃圾收集算法" class="headerlink" title="2.1 垃圾收集算法"></a>2.1 垃圾收集算法</h4><h6 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h6><p><img src="https://img-blog.csdnimg.cn/20200824152623936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Mjc2ODM1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>缺点：内存会产生碎片化</p>
<h6 id="标记-复制"><a href="#标记-复制" class="headerlink" title="标记-复制"></a>标记-复制</h6><p><img src="https://img-blog.csdnimg.cn/20200824152644220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Mjc2ODM1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>缺点：预留一半的内存区域；整个内存空间只有一半可以使用</p>
<h6 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h6><p><img src="https://img-blog.csdnimg.cn/20200824152724174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Mjc2ODM1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>缺点：标记整理虽然可以解决内存碎片化问题，也不存在内存空间浪费，但是需要移动存活的对象，但是，当内存中存活对象多，并且都是一些微小对象，而且垃圾对象较少时，要移动大量的存活对象才能换取少量的内存空间。</p>
<h6 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h6><p>一块独立的内存区域只能使用一种垃圾回收算法，根据对象生命周期特征，将其划分到不同的区域，再对特定区域使用特定的垃圾回收算法，只有这样才能将垃圾回收算法的优点发挥到极致，这种组合的垃圾回收算法称之为：分代收集算法（分代回收算法）</p>
<p>根据对象存活周期的不同，将内存划分为几块。一般是把 Java 堆分为新生代和老年代，针对各个年代的特点采用最适当的收集算法。</p>
<ul>
<li>新生代：复制算法</li>
<li>老年代：标记-清除算法、标记-整理算法</li>
</ul>
<h3 id="3-HotSpot垃圾收集器（7种）"><a href="#3-HotSpot垃圾收集器（7种）" class="headerlink" title="3. HotSpot垃圾收集器（7种）"></a>3. HotSpot垃圾收集器（7种）</h3><h4 id="3-1-新生代垃圾收集器"><a href="#3-1-新生代垃圾收集器" class="headerlink" title="3.1 新生代垃圾收集器"></a>3.1 新生代垃圾收集器</h4><h5 id="1-Serial-GC收集器"><a href="#1-Serial-GC收集器" class="headerlink" title="1. Serial GC收集器"></a>1. Serial GC收集器</h5><p><img src="https://img-blog.csdnimg.cn/img_convert/1c13b8e41120caccd15369497355b588.png" alt="1c13b8e41120caccd15369497355b588.png"></p>
<blockquote>
<p>单线程，只会使用一个cpu或一条线程去完成垃圾收集工作，这也意味着在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束为止（<font color=red>臭名昭著的Stop The World</font>）</p>
<p><strong>收集算法</strong>：复制算法</p>
<p>与用户线程串行执行，单线程地好处就是减少上下文切换，减少系统资源的开销。但这种方式的缺点也很明显，在GC的过程中，会暂停程序的执行。若GC不是频繁发生，这或许是一个不错的选择，否则将会影响程序的执行性能。 对于新生代来说，区域比较小，停顿时间短，所以比较使用。</p>
<p><strong>参数</strong>：<code>-XX:+UseSerialGC</code> </p>
<p>在JDK Client模式，不指定JVM参数，默认是串行垃圾收集器</p>
</blockquote>
<h5 id="2-ParNew收集器"><a href="#2-ParNew收集器" class="headerlink" title="2. ParNew收集器"></a>2. ParNew收集器</h5><p>ParNew收集器是Serial GC的多线程版本，除了使用多线程进行垃圾收集外，其余行为包括Serial收集器可用的所有控制参数、收集算法(复制算法)、Stop The World、对象分配规则、回收策略等与Serial收集器完全相同，两者共用了相当多的代码。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/111fbad04e83f6fc486c78406621ae05.png" alt="111fbad04e83f6fc486c78406621ae05.png"></p>
<p>ParNew收集器除了使用了多线程收集外，其他与Serial收集器相比并无太多创新之外，但是它是许多运行在Server模式下的虚拟机首选的新生代收集器，其中有一个与性能无关的重要原因是，除了Serial收集器外，目前只有它能和CMS收集器配合工作。</p>
<blockquote>
<p><strong>算法</strong>：复制算法</p>
<p>用于新生代</p>
<p>GC时需要暂停所有用户线程，直到GC结束</p>
<p><strong>参数</strong>：</p>
<p>​    <code>-XX:+UseConcMarkSweepGC</code>：指定使用CMS后，会默认使用ParNew作为新生代收集器</p>
<p>​    <code>-XX:+UseParNewGC</code>：强制指定使用ParNew</p>
<p>​    <code>-XX:ParallelGCThreads</code>：指定垃圾收集的线程数量，ParNew默认开启的收集线程与CPU的数量相同</p>
</blockquote>
<h5 id="3-Parallel-Scavenge收集器（吞吐量优先）"><a href="#3-Parallel-Scavenge收集器（吞吐量优先）" class="headerlink" title="3. Parallel Scavenge收集器（吞吐量优先）"></a>3. Parallel Scavenge收集器（吞吐量优先）</h5><p>Parallel收集器同样也采用了复制算法，并行回收和STW机制；和ParNew不同之处在于，Parallel收集器的目标则是达到一个可控制的吞吐量，也被称为吞吐量优先的垃圾收集器。</p>
<p><img src="https://img-blog.csdnimg.cn/20210128165345527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3c3MzM1MTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>参数：</p>
<p><code>-XX:MaxGCPauseMillis</code> 设置最大停顿时间STW，这参数设置的越小，停顿时间可能会缩短，但也会导致吞吐量下降，当值垃圾收集发生的更频繁。</p>
<p><code>-XX:GCtimeRatio</code> 垃圾收集时间占时间总比   用于衡量吞吐量</p>
<p>​    垃圾收集执行时间占应用程序执行时间的比例计算方法：<code>1/(n+1)</code></p>
<p>​    例如<code>-XX:GCTimeRatio=19</code>,那么设置了垃圾收集时间占总时间的5% = 1/(19+1);</p>
<p>​    默认值是99，即1%；</p>
<p><code>-XX:UseAdaptiveSizePolicy</code> 设置Parallel收集器具有自适应调节功能；开启这个参数后，就不用手工指定一些细节参数了，如<code>新生代大小 -Xmn</code>、<code>Eden与Survivor区的比例 -XX:SurvivorRation</code>、<code>晋升老年代的对象年龄 -XX:MaxTenuringThreshold</code></p>
</blockquote>
<p>JVM会根据当前系统运行情况收集性能监控信息，动态调整这些参数，以提供最合适的停顿时间或最大的吞吐量，这种调节方式称为GC自适应的调节策略(GC Ergonomiscs)；</p>
<p>另外值得注意的一点是，Parallel Scavenge收集器无法与CMS收集器配合使用，所以在JDK 1.6推出Parallel Old之前，如果新生代选择Parallel Scavenge收集器，老年代只有Serial Old收集器能与之配合使用。</p>
<h4 id="3-2-老年代垃圾收集器"><a href="#3-2-老年代垃圾收集器" class="headerlink" title="3.2 老年代垃圾收集器"></a>3.2 老年代垃圾收集器</h4><h5 id="1-Serial-Old收集器"><a href="#1-Serial-Old收集器" class="headerlink" title="1. Serial Old收集器"></a>1. Serial Old收集器</h5><p><img src="https://img-blog.csdnimg.cn/img_convert/abdedea73525f71775a338dbceeedd2a.png" alt="abdedea73525f71775a338dbceeedd2a.png"></p>
<blockquote>
<p><strong>算法</strong>：标记-整理</p>
<p>可作为CMS收集器的后备预案，并在CMS发生”Concurrent Mode Failure“ 时使用。</p>
</blockquote>
<h5 id="2-Parallel-Old"><a href="#2-Parallel-Old" class="headerlink" title="2. Parallel Old"></a>2. Parallel Old</h5><p><img src="https://img-blog.csdnimg.cn/img_convert/e1b908c08120b3323a3d5ca408bc569b.png" alt="e1b908c08120b3323a3d5ca408bc569b.png"></p>
<p>Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先</p>
<blockquote>
<p><strong>算法</strong>：标记-整理</p>
<p><strong>参数</strong>：<code>-XX:UseparallelOldGC</code> 指定使用Parallel Old收集器</p>
</blockquote>
<h5 id="3-CMS并发清除（Concurrent-Mark-Sweep）"><a href="#3-CMS并发清除（Concurrent-Mark-Sweep）" class="headerlink" title="3. CMS并发清除（Concurrent Mark Sweep）"></a>3. CMS并发清除（Concurrent Mark Sweep）</h5><p>这个收集器有与工作线程执行<strong>并发</strong>的能力。</p>
<blockquote>
<p><strong>算法</strong>：标记-清除</p>
<p><strong>特点</strong>：收集过程中不需要暂停用户线程，以获取最短回收停顿时间为目标</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ae5a11b458e117b8f30fdc064821647c.png" alt="ae5a11b458e117b8f30fdc064821647c.png"></p>
<p>CMS GC过程分四步：</p>
<ol>
<li><p><strong>初始标记</strong>（initial mark）</p>
<blockquote>
<p>单线程执行， 需要STW，但仅仅把GC Roots的直接关联可达的对象给标记一下，由于直接关联对象比较小，所以这里的速度非常快。</p>
</blockquote>
</li>
<li><p><strong>并发标记</strong>（Concurrent mark）</p>
<blockquote>
<p>对于初识标记过程所标记的初识标记对象，进行并发跟踪标记</p>
<p>此时其他线程仍可以继续工作。此处时间较长，但不停顿，并不能保证可以标记出所有的存活对象；</p>
<p><strong>与用户线程并发执行</strong></p>
</blockquote>
</li>
<li><p><strong>重新标记</strong>（remark）</p>
<blockquote>
<p>在并发标记的过程中，由于可能还会产生新的垃圾，所以此时需要重新标记新产生的垃圾。</p>
<p>此处执行<strong>并行标记</strong>，与用户线程不并发，所以依然是STW</p>
<p>且停顿时间比初识标记稍长，但远比并发标记短。</p>
</blockquote>
</li>
<li><p><strong>并发清除</strong>（Concurrent sweep）</p>
<blockquote>
<p> 并发清除之前所有标记的垃圾；</p>
<p> 其他用户线程仍可以工作，不需要停顿。</p>
<p> <strong>与用户线程并发执行</strong></p>
</blockquote>
</li>
</ol>
<p>Tips：初始标记和重新标记仍然需要STW</p>
<blockquote>
<p>并发的意思是指与用户线程是否是并发执行的</p>
</blockquote>
<p><strong>初始标记</strong>仅仅标记一下GC Roots能直接关联到的对象，速度很快；</p>
<p><strong>并发标记</strong>就是进行GC Roots Tracing的过程；</p>
<p>而<strong>重新标记</strong>阶段则是为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段长，但远比并发标记的时间短。</p>
<p>由于整个过程中耗时最长的并发标记和并发清除过程，收集器线程都可以与用户线程一起工作，所以整体上说，CMS收集器的内存回收过程是与用户线程一共并发执行的。</p>
<blockquote>
<p><strong>参数</strong>：</p>
<p><code>-XX:+UseConcMarkSweepGC</code>：使用CMS收集器</p>
<p><code>-XX:+UseCMSCompactAtFullCollection</code>：Full GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长。</p>
<p><code>-XX:+CMSFullGCsBeforeCompaction</code>：设置进行几次Full GC后，进行一次碎片整理</p>
<p><code>-XX:ParallelCMSThreads</code>：设置CMS的线程数量（一般情况约等于可用CPU数量）</p>
</blockquote>
<p><strong>优点</strong>：</p>
<p>总体来说，与Parallel Old垃圾收集器相比，CMS减少了执行老年代垃圾收集时应用暂停的时间；但却增加了新生代垃圾收集时应用暂停的时间，降低了吞吐量而且需要占用更大的堆空间；</p>
<p>由于耗时的<strong>并发标记</strong>和<strong>并发清除</strong>阶段都不需要暂停工作，所以整体的回收是低停顿的。</p>
<p>由于CMS以上特性，缺点也是比较明显的。</p>
<p><strong>缺点</strong>：</p>
<ol>
<li><p>对CPU资源非常敏感</p>
</li>
<li><p>浮动垃圾</p>
<p>由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。</p>
<p>由于在垃圾收集阶段用户线程还需要运行，那就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，也可以认为CMS所需要的空间比其他垃圾收集器大；</p>
<p><code>-XX:CMSInitiatingOccupancyFraction</code>: 设置CMS预留内存空间</p>
</li>
<li><p>”Concurrent Mode Failure“失败</p>
<p>如果如果CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样会导致另一次Full GC的产生。这样停顿时间就更长了，代价会更大，所以 <code>-XX:CMSInitiatingOccupancyFraction</code>不能设置得太大。</p>
</li>
<li><p>产生大量内存碎片</p>
<p>这个问题并不是CMS的问题，而是算法的问题。由于CMS基于”标记-清除”算法，清除后不进行压缩操作，所以会产生碎片</p>
<p>“标记-清除”算法介绍时曾说过：</p>
<p>产生大量不连续的内存碎片会导致分配大内存对象时，无法找到足够的连续内存，从而需要提前触发另一次Full GC动作。</p>
<p><strong>碎片解决方法：</strong></p>
<ul>
<li><p> <code>-XX:+UseCMSCompactAtFullCollection</code></p>
</li>
<li><p>使得CMS出现上面这种情况时不进行Full GC，而开启内存碎片的合并整理过程；但合并整理过程无法并发，停顿时间会变长；</p>
</li>
<li><p><code>-XX:+CMSFullGCsBeforeCompation</code></p>
<ul>
<li><p>设置执行多少次不压缩的Full GC后，来一次压缩整理</p>
</li>
<li><p>为减少合并整理过程的停顿时间；</p>
<p>默认为0，也就是说每次都执行Full GC，不会进行压缩整理；</p>
<p>由于空间不再连续，CMS需要使用可用”空闲列表”内存分配方式，这比简单使用”碰撞指针”分配内存消耗大；</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="3-3-G1收集器"><a href="#3-3-G1收集器" class="headerlink" title="3.3 G1收集器"></a>3.3 G1收集器</h4><p>G1(Garbage - First)名称的由来是G1跟踪各个Region里面的垃圾堆的价值大小(回收所获得的空间大小以及回收所需时间的经验值)，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</p>
<p>注意：G1与前面的垃圾收集器有很大不同，它把新生代、老年代的划分取消了！</p>
<p>这样我们再也不用单独的空间对每个代进行设置了，不用担心每个代内存是否足够。</p>
<p>取而代之的是，G1算法将堆划分为若干个区域(Region)，它仍然属于分代收集器。不过，这些区域的一部分包含新生代，新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间。老年代也分成很多区域，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。这就意味着，在正常的处理过程中，G1完成了堆的压缩(至少是部分堆的压缩)，这样也就不会有CMS内存碎片问题的存在了。<br><img src="https://img-blog.csdnimg.cn/img_convert/d278aed530716ea4981a02fb8590c946.png" alt="d278aed530716ea4981a02fb8590c946.png"></p>
<p>G1收集器运作过程</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b03dfc84f0de89fe474936cbd70aef32.png" alt="b03dfc84f0de89fe474936cbd70aef32.png"></p>
<ol>
<li><p>初识标记</p>
<ul>
<li>初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快</li>
</ul>
</li>
<li><p>并发标记</p>
<ul>
<li><p>进行GC Roots Tracing的过程，从刚才产生的集合中标记出存活对象；(也就是从GC Roots 开始对堆进行可达性分析，找出存活对象。)</p>
<p>耗时较长，但应用程序也在运行；</p>
<p>并不能保证可以标记出所有的存活对象；</p>
</li>
</ul>
</li>
<li><p>最终标记</p>
<ul>
<li><p>最终标记和CMS的重新标记阶段一样，也是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，</p>
<p>这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短，</p>
<p>也需要“Stop The World”。(修正Remebered Set)</p>
</li>
</ul>
</li>
<li><p>筛选回收</p>
<ul>
<li>首先排序各个Region的回收价值和成本</li>
<li>然后根据用户期望的GC停顿时间来制定回收计划；</li>
<li>最后按计划回收一些价值高的Region中垃圾对象</li>
</ul>
<p>回收时采用”复制算法“，从一个或多个Region复制存活对象到堆上的另一个空间Region，并且在此过程中压缩和释放内存；</p>
<p>可以并发进行，降低停顿时间，并增加吞吐量</p>
<blockquote>
<p><strong>参数</strong>：</p>
<p><code>-XX:+UseG1GC</code>：指定使用G1收集器</p>
<p><code>-XX:InitiatingHeapOccupancyPercent</code>: 当整个Java堆的占用率达到参数值时，开始并发标记阶段；默认为45；</p>
<p><code>-XX:MaxGCPauseMillis</code>： 为G1设置暂停时间目标，默认值为200毫秒；</p>
<p><code>-XX:G1HeapRegionSize</code>：设置每个Region大小，范围1MB到32MB；目标是在最小Java堆时可以拥有约2048个</p>
</blockquote>
</li>
</ol>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/8d9b5b42d191a4ad452074f204507378.png" alt="8d9b5b42d191a4ad452074f204507378.png"></p>
<h3 id="2-类加载过程"><a href="#2-类加载过程" class="headerlink" title="2.类加载过程"></a>2.类加载过程</h3><p>类从被加载到虚拟机内存中开始，到卸载出内存位置，他的整个生命周期如下如：</p>
<p><img src="https://img-blog.csdnimg.cn/20200810150148636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E2NDY3MDU4MTY=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol>
<li><strong>加载</strong><ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区数据的访问入口</li>
</ul>
</li>
<li><strong>验证</strong><ul>
<li>验证阶段作用是保证Class文件的字节流包含的信息是否符合JVM规范，不会给JVM造成危害。如果验证失败，就会抛出一个java.lang.VerifyError异常或子类异常。验证过程分为四个阶段：<ul>
<li>文件格式验证：验证字节流文件是否符合Class文件格式的规范，并且能被当前虚拟机正确的处理</li>
<li>元数据验证：是对字节码描述的信息进行语义分析，以保证其描述信息符合Java语言的规范</li>
<li>字节码验证：主要是进行数据流和控制流的分析，保证被校验类的方法在运行时不会危害JVM</li>
<li>符号引用验证：符号引用验证发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在解析阶段中发生。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><font color=green>符号引用（Symbolic References）说明</font></p>
<blockquote>
<p>符号引用以一组符号来描述所引用的目标，符号引用与虚拟机的内存布局无关，引用的目标不一定加载到内存中。</p>
<p><font color=blue>在java中，一个java类将会编译成一个class文件。在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替</font></p>
<p>比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language（假设是这个，当然实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示Language类的地址。各种虚拟机实现的内存布局可能有所不同，但是它们能接受的符号引用都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。</p>
</blockquote>
<ol start="3">
<li><p><strong>准备</strong></p>
<ul>
<li><p>准备阶段为变量分配内存并设置类变量的初始化。在这个阶段分配的仅为类的变量（static修饰的变量），而不包括类的实例变量（实例变量在new 的时候初始化）。对已非final的变量，JVM会将其设置成”零值“，而不是其赋值语句的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">12</span>;</span><br></pre></td></tr></table></figure>

<p>那么这个阶段，size的值为0，而不是12。final修饰的类变量将会赋值成真实的值。</p>
</li>
</ul>
</li>
<li><p><strong>解析</strong></p>
<ul>
<li>解析过程是将常量池内的<strong>符号引用</strong>替换成<strong>直接引用</strong>。主要包括四种类型引用的解析。<strong>类或接口的解析</strong>、<strong>字段解析</strong>、<strong>方法解析</strong>、<strong>接口方法解析</strong>。</li>
</ul>
</li>
<li><p><strong>初始化</strong></p>
<ul>
<li>在准备阶段，类变量已经经过一次初始化了，在这个阶段，则是根据程序员通过程序制定的计划去初始化类的变量和其他资源。这些资源有static{}块，构造函数，父类的初始化等。</li>
</ul>
</li>
<li><p><strong>使用</strong></p>
</li>
<li><p><strong>卸载</strong></p>
</li>
</ol>
<h3 id="3-双亲委派机制"><a href="#3-双亲委派机制" class="headerlink" title="3. 双亲委派机制"></a>3. 双亲委派机制</h3><p><strong>java中的四种类加载器</strong></p>
<ol>
<li><p>启动（Bootstrap）类加载器</p>
<blockquote>
<p>启动类加载器是本地代码实现的类加载器，它负责将<JavaRuntimeHome>/lib下面的类库加载到内存中。由于启动类加载器涉及到虚拟机本地实现细节，开发者无法直接取到启动类加载器的引用。</p>
</blockquote>
</li>
<li><p>标准扩展（Extension）类加载器</p>
<blockquote>
<p>扩展类加载器负责将<JavaRuntimeHome>/lib/ext或者系统变量java.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器</p>
</blockquote>
</li>
<li><p>应用程序（Application）类加载器</p>
<blockquote>
<p>应用程序类加载器负责加载用户路径（classpath）上的类库</p>
</blockquote>
</li>
</ol>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDIwLmNuYmxvZ3MuY29tL2Jsb2cvMjAwNDkzNC8yMDIwMDcvMjAwNDkzNC0yMDIwMDcyOTEyNDgyNjk0MC0xMDQyODAzODI0LnBuZw?x-oss-process=image/format,png#pic_center" alt="在这里插入图片描述"></p>
<p><strong>双亲委派机制</strong></p>
<blockquote>
<p>当一个类收到类加载请求时，它首先不会尝试自己去加载这个类，而是把这个请求<code>委派给父类加载器</code>去完成，每一层的类加载器都是如此，因此所有的加载请求都应该传送到启动类加载器中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class）（从最顶层的BootStrap -》Extension-》Application-》自己定义的类加载器），子类加载器才会尝试自己加载。</p>
</blockquote>
<p><strong>双亲委派机制的作用</strong></p>
<blockquote>
<p>为了保证自己写的代码不污染java出厂自带的源代码。如果有人想替换系统级别的类：如String.java.篡改它的实现，但是在这种机制下这些系统的类已经被Bootstrap ClassLoader加载过了，所以并不会再去加载，从一定程度上<strong>防止了危险代码的植入</strong>。</p>
<ol>
<li><strong>防止重复加载用一个.class。通过委托去上层，加载过了，就不用再加载一遍</strong>。保证数据安全</li>
<li>保证了使用不同的类加载器最终得到的都是同一个Object对象。</li>
</ol>
</blockquote>
<h3 id="3-创建（new）对象的过程"><a href="#3-创建（new）对象的过程" class="headerlink" title="3.创建（new）对象的过程"></a>3.创建（new）对象的过程</h3><ol>
<li><strong>检查类是否已经被加载</strong><ul>
<li>当JVM遇到一条字节码new指令时，首先检查该引用指向的类是否能够在常量池中被找到（也就是检查方法区中有没有该类的信息），如果没有，先加载这个类；有的话就执行下一步，为对象分配内存</li>
</ul>
</li>
<li><strong>为对象分配内存空间</strong><ul>
<li>类加载检查通过后，接下来虚拟机会为对象分配内存。对象需要多大的内存在类加载完成后便可完全确定，为对象分配内存就是把一块确定大小的内存块从堆上划分出来。</li>
</ul>
</li>
<li><strong>为对象字段设置零值</strong><ul>
<li>分配完内存后，需要对对象的字段进行零值初始化，（也就是对象的实例数据部分，对象的内存布局被分为三个部分：<strong>对象头</strong>、<strong>实例数据</strong>、<strong>对齐填充</strong>），对象头除外，零值初始化意思就是对对象的字段赋0值，或者null值。</li>
</ul>
</li>
<li><strong>设置对象头</strong><ul>
<li>虚拟机需要对这个将要创建出来的对象，进行信息标记，包括是否为新生代/老年代，对象的hash码，元数据信息，这些标记存放在对象头信息中。</li>
</ul>
</li>
<li><strong>执行构造方法</strong><ul>
<li>执行对象的构造方法，初始化对象，这样一个对象才算被成功创建。</li>
</ul>
</li>
</ol>
<h3 id="4-对象的内存布局"><a href="#4-对象的内存布局" class="headerlink" title="4.对象的内存布局"></a>4.对象的内存布局</h3><blockquote>
<p>提问：<code>Object o = new Object();</code> 请问一个object对象占多少内存空间？</p>
</blockquote>
<p>Java对象的内存布局：<strong>对象头（Header）</strong>、<strong>实例数据（Instance Data）</strong>和<strong>对齐填充（Padding）</strong>，<strong>8字节对齐</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20201221191858529.png" alt="在这里插入图片描述"></p>
<ul>
<li><strong>Mark Word</strong><ul>
<li>存储对象的hashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳</li>
</ul>
</li>
<li><strong>Class Pointer</strong><ul>
<li>指向对象对应的Class对象（类对象）的内存地址</li>
</ul>
</li>
<li><strong>Instance Date</strong><ul>
<li>具体的数据大小，如对象含有一个int成员变量，即为4字节</li>
</ul>
</li>
<li><strong>Padding</strong><ul>
<li>8字节对齐</li>
</ul>
</li>
</ul>
<p>在64bit的JVM中，MarkWord为64bit-8字节，这样一个<code>Object</code>对象占有<strong>16个字节</strong></p>
<h3 id="5-四大引用类型"><a href="#5-四大引用类型" class="headerlink" title="5. 四大引用类型"></a>5. 四大引用类型</h3><h4 id="1-强引用"><a href="#1-强引用" class="headerlink" title="1. 强引用"></a>1. 强引用</h4><p><code>StrongReference</code>是java的默认引用形式，使用时不需要显示定义。任何通过强引用所使用的对象，不管jvm内存是否充足，Java GC都不会主动回收具有强引用的对象。</p>
<blockquote>
<p>如果一个对象具有强引用，那么垃圾收集器不会回收它</p>
<p>当JVM内存空间不足时，Java虚拟机宁愿抛出OurOfMemoryError错误，使程序异常终止，也不会回收强引用对象。</p>
</blockquote>
<h4 id="2-软引用"><a href="#2-软引用" class="headerlink" title="2. 软引用"></a>2. 软引用</h4><p><code>SoftReference&lt;String[]&gt; softArr = new SoftReference&lt;String[]&gt;(new String[] &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;);</code></p>
<p>软引用在内存充足时，GC不会回收；如果内存不足时，GC会回收这个对象。</p>
<p><strong>应用场景</strong></p>
<blockquote>
<p>实现内存敏感的高速缓存，比如网页缓存，图片缓存等。使用软引用能防止内存泄漏</p>
</blockquote>
<h4 id="3-弱引用"><a href="#3-弱引用" class="headerlink" title="3. 弱引用"></a>3. 弱引用</h4><p><code>WeakReference&lt;String[]&gt; weakArr=new WeakReference&lt;String[]&gt;(new String[]&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;);</code></p>
<p>如果一个对象只具有弱引用，无论内存充足与否，Java GC后对象都会被回收。</p>
<p><strong>应用场景</strong></p>
<blockquote>
<p>ThreadLocal</p>
</blockquote>
<h5 id="ThreadLocal-弱引用造成的数据泄漏问题"><a href="#ThreadLocal-弱引用造成的数据泄漏问题" class="headerlink" title="ThreadLocal 弱引用造成的数据泄漏问题"></a>ThreadLocal 弱引用造成的数据泄漏问题</h5><p><code>ThreadLocalMap</code>内部Entry类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">  <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">  Object value;</span><br><span class="line"></span><br><span class="line">  Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">    <span class="built_in">super</span>(k);</span><br><span class="line">    value = v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，ThreadLocal内部每个线程维护的本地变量map中的Entry的<font color=red>key是弱引用类型<code>WeakReference</code>,不管JVM内存空间是否充足，在GC的时候，都会回收里面的key</font>。</p>
<p><font color=red>但是value依然是强引用类型</font>，这就会造成这种情况：GC回收的时候，把key进行了回收，变为了<code>null</code>,但是其对应的value还有值存在，但是无法被引用到了，这就造成了**<code>内存泄漏</code>**,因此，在实际使用ThreadLocal的过程中，使用完毕后需要及时调用<code>remove()</code>方法，避免造成数据泄漏。</p>
<h4 id="4-虚引用"><a href="#4-虚引用" class="headerlink" title="4. 虚引用"></a>4. 虚引用</h4><p>虚引用需要配合引用队列<code>ReferenceQueue</code>联合使用。当执行Java GC时如果一个对象只有虚引用，就会把这个对象加入到与之关联的<code>ReferenceQueue</code>中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//虚引用PhantomReference</span></span><br><span class="line">    <span class="comment">//必须和引用队列联合使用</span></span><br><span class="line">    ReferenceQueue&lt;String[]&gt; rqueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">    PhantomReference&lt;String[]&gt; phanArr = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;String[]&gt;(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>&#125;,rqueue);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 应用场景：</span></span><br><span class="line"><span class="comment">     *大多被用于引用销毁前的处理工作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<p>当垃圾回收期准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p>
<p>程序可以通过判断引用队列中是否已经加入了虚引用，来了解引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列中，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>
<h3 id="6-JVM常用调优参数"><a href="#6-JVM常用调优参数" class="headerlink" title="6. JVM常用调优参数"></a>6. JVM常用调优参数</h3><p><a target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html">Oracle关于JVM参数配置参考表</a></p>
<table>
<thead>
<tr>
<th>配置参数</th>
<th>功能</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>-Xms</code></td>
<td>初始堆大小。如<code>-Xms256m</code></td>
<td></td>
</tr>
<tr>
<td><code>-Xmx</code></td>
<td>最大堆大小。如<code>-Xmx1024m</code></td>
<td></td>
</tr>
<tr>
<td><code>-Xmn</code></td>
<td>新生代大小。通常为<code>Xmx</code>的1/3或1/4.<br />新生代=Eden+2个Survivor空间。<br />实际可用空间为=Eden+1个Survivor，即90%</td>
<td></td>
</tr>
<tr>
<td><code>-Xss</code></td>
<td>每个线程堆栈大小，默认为1M</td>
<td></td>
</tr>
<tr>
<td><code>-XX:NewRatio</code></td>
<td>老年代/新生代的比例，默认<code>-XX:NewRatio=2</code>,代表老年代：新生代=2：1</td>
<td></td>
</tr>
<tr>
<td><code>-XX:SurvivorRatio</code></td>
<td>新生代中Eden与Survivor的比值。默认值为8  <code>-XX:SurvivorRatio=8</code></td>
<td></td>
</tr>
<tr>
<td><code>java -XX:+PrintFlagsFinal -version</code></td>
<td>查看jvm所有参数选项的值</td>
<td></td>
</tr>
<tr>
<td><code>-XX:MaxTenuringThreshold</code></td>
<td>新生代晋升老年的的年龄<br />默认值<code>-XX:MaxTenuringThreshold=15</code></td>
<td></td>
</tr>
<tr>
<td><code>-XX:MetaspaceSize</code></td>
<td>元空间大小</td>
<td></td>
</tr>
<tr>
<td><code>-XX:MaxMetaspaceSize</code></td>
<td>元空间最大空间大小</td>
<td></td>
</tr>
<tr>
<td><code>-XX:PretenureSizeThreshold</code></td>
<td>大对象所占空间超过这个阈值，直接分配到老年代</td>
<td></td>
</tr>
<tr>
<td><code>-XX:+PrintGCDetails</code></td>
<td>打印GC信息</td>
<td></td>
</tr>
<tr>
<td><code>关于设置垃圾收集器</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>-XX:+UseSerialGC</code></td>
<td>新生代使用Serial GC， 老年代使用Serial old</td>
<td></td>
</tr>
<tr>
<td><code>-XX:+UseParNewGC</code></td>
<td>新生代使用ParNew收集器，老年代使用Serial Old</td>
<td></td>
</tr>
<tr>
<td><code>-XX:+UseConcMarkSweepGC</code></td>
<td>新生代使用ParNew收集器，老年代使用CMS</td>
<td></td>
</tr>
<tr>
<td><code>-XX:ParallelGCThreads=8</code></td>
<td>这个参数指定并行GC线程的数量，<br />一般最好和cpu核心数相当。</td>
<td></td>
</tr>
<tr>
<td><code>-XX:+UseParallelOldGC</code></td>
<td>新生代使用ParallelGC收集器，<br />老年代使用ParallelOldGC收集器</td>
<td></td>
</tr>
<tr>
<td><code>-XX:ConcGCThreads</code></td>
<td>设置CMS并发线程数</td>
<td></td>
</tr>
<tr>
<td><code>-XX:+UseG1GC</code></td>
<td>开启G1收集器</td>
<td></td>
</tr>
<tr>
<td><code>关于锁</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>-XX:+UseSpinning</code></td>
<td>启用自旋锁优化，jdk1.6之后默认开启</td>
<td></td>
</tr>
<tr>
<td><code>-XX:PreBlockSpin</code></td>
<td>设置自旋多少次后升级为重量级锁；默认<code>-XX:PreBlockSpin=10</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="并发与多线程篇"><a href="#并发与多线程篇" class="headerlink" title="并发与多线程篇"></a>并发与多线程篇</h2><h3 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1. 进程与线程"></a>1. 进程与线程</h3><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，输入输出设备的使用权等等。</p>
<p><strong>进程与进程之间的通信方式</strong></p>
<ol>
<li><strong>管道pipe</strong><ul>
<li>通常指无名管道，<strong>unix</strong>系统IPC最古老的形式</li>
<li>只能用于具有亲缘关系的进程之间的通信（父子进程，兄弟进程）</li>
</ul>
</li>
<li><strong>命名管道FIFO</strong><ul>
<li>在磁盘上有对应的节点，但是没有数据块。一旦建立，任何进程都可以通过文件名将其打开和进行读写，而不局限于父子进程，当然前提是进程对FIFO有适当的访问权。当不再被进程使用时，FIFO在内存中释放，但磁盘节点仍然存在。</li>
</ul>
</li>
<li><strong>消息队列MessageQueue</strong><ul>
<li>消息队列，就是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以从消息队列读取消息。</li>
<li>消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。</li>
<li>进程间通过消息队列通信，主要是：创建或打开消息队列，添加消息，读取消息和控制消息队列</li>
</ul>
</li>
<li><strong>共享存储SharedMemory</strong><ul>
<li>共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取策略读出，从而实现了进程间的通信。</li>
<li>采用共享内存进行通信的一个主要好处是<strong>效率高</strong>，因为进程可以直接读写内存，而不需要任何数据的拷贝，对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次：<code> 一次从输入文件到共享内存</code>和 <code>一次从共享内存输出文件</code></li>
</ul>
</li>
<li><strong>信号量Semaphore</strong><ul>
<li>信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</li>
</ul>
</li>
<li><strong>套接字Socket</strong><ul>
<li>适合同一主机的不同进程间和不同主机的进程间进行全双工网络通信</li>
</ul>
</li>
<li>信号（sinal）</li>
</ol>
<h4 id="线程的几种状态"><a href="#线程的几种状态" class="headerlink" title="线程的几种状态"></a>线程的几种状态</h4><p><code>Thread.State</code>枚举类查看线程的各种状态</p>
<ol>
<li><strong>NEW（新建）</strong></li>
<li><strong>RUNNABLE（就绪）</strong></li>
<li><strong>BLOCKED（阻塞）</strong></li>
<li><strong>WAITING（等待）</strong></li>
<li><strong>TIMED_WAITING（超时等待）</strong></li>
<li><strong>TERMINATED（终止）</strong></li>
</ol>
<p><strong>wait/sleep都会导致线程的阻塞，有什么区别？</strong></p>
<ul>
<li><strong>wait</strong>放开手去睡，放开手里的锁</li>
<li><strong>sleep</strong>握紧手去睡，醒了手里还有锁</li>
</ul>
<h4 id="Java中实现多线的方式"><a href="#Java中实现多线的方式" class="headerlink" title="Java中实现多线的方式"></a>Java中实现多线的方式</h4><ol>
<li>继承Thread类，实现run方法</li>
<li>实现Runnable接口，实现run方法</li>
<li>实现Callable接口，实现call方法。注意：新建Thread的时候，Thread的构造方法中没有接收Callable的。（中间商赚差价！！！）所有我们需要找到一个既可以联系Runnable接口又联系Callable接口的类（FutureTask））<ul>
<li><code>FutureTask</code>中的<code>get()</code>方法会阻塞线程，一直等待线程计算完成后才执行下面的后续代码。一般放在最后。</li>
<li>同一个futureTask对象只能被线程调用一次，当有新的线程调用了已经被调用过的futuretask对象时，这次只会复用上一次的结果，不会再执行一次。</li>
</ul>
</li>
<li>线程池<code>ExecutorService</code>(ThreadPoolExecutor类)</li>
</ol>
<h3 id="2-JUC"><a href="#2-JUC" class="headerlink" title="2. JUC"></a>2. JUC</h3><h4 id="JUC强大的辅助类："><a href="#JUC强大的辅助类：" class="headerlink" title="JUC强大的辅助类："></a>JUC强大的辅助类：</h4><h5 id="1-CountDownLatch类"><a href="#1-CountDownLatch类" class="headerlink" title="1. CountDownLatch类"></a>1. CountDownLatch类</h5><p>计数器不为0，<code>countDownLatch.await(); </code>方法后面的代码都被一直阻塞</p>
<p>每调用一个线程，就需要执行<code>countDownLatch.countDown()</code>,将其计数器减一</p>
<h5 id="2-CyclicBarrier"><a href="#2-CyclicBarrier" class="headerlink" title="2. CyclicBarrier"></a>2. CyclicBarrier</h5><p>一句话：集齐七颗龙，召唤神龙。</p>
<p>没调用一个线程，就需要执行<code>cyclicBarrier.await()</code>,将计数器加1</p>
<p><strong>CyclicBarrier类与CountDownLatch类的区别</strong></p>
<table>
<thead>
<tr>
<th>CountDownLatch</th>
<th>CyclicBarrier</th>
</tr>
</thead>
<tbody><tr>
<td>减计数方式</td>
<td>加计数方式</td>
</tr>
<tr>
<td>计算为0时释放所有等待的线程</td>
<td>计数达到指定值时释放所有等待线程</td>
</tr>
<tr>
<td>计数为0时，无法重置</td>
<td>计数达到指定值时，计数置为0重新开始</td>
</tr>
<tr>
<td>调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响</td>
<td>调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞</td>
</tr>
<tr>
<td>不可重复利用</td>
<td>可重复利用</td>
</tr>
</tbody></table>
<h5 id="信号量：Semaphore类（类似于PV操作）"><a href="#信号量：Semaphore类（类似于PV操作）" class="headerlink" title="信号量：Semaphore类（类似于PV操作）"></a>信号量：Semaphore类（类似于PV操作）</h5><p>两个关键性操作：</p>
<ol>
<li><code>semaphore.acquire()</code> 请求资源</li>
<li><code>semaphore.release() </code> 释放资源</li>
</ol>
<blockquote>
<p>acquire：当一个线程调用acquire操作时，它要么成功，获取信号量（信号量-1）；要么一直等待下去，直到有线程释放了信号量，或者超时</p>
<p>release：实际上会将信号量的值加1，然后唤醒等待的线程。</p>
</blockquote>
<p>信号量的主要作用：</p>
<blockquote>
<p>用于<strong>对多个共享资源的互斥使用</strong></p>
<p>用于<strong>并发线程数的控制</strong></p>
</blockquote>
<h3 id="阻塞队列（BlockingQueue）"><a href="#阻塞队列（BlockingQueue）" class="headerlink" title="阻塞队列（BlockingQueue）"></a>阻塞队列（BlockingQueue）</h3><p><img src="https://img-blog.csdnimg.cn/20200823081540511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Mjc2ODM1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>线程1往阻塞队列中生产元素，线程2 从阻塞队列中消费元素。</p>
<p>阻塞队列满了，生产线程阻塞；</p>
<p>阻塞队列空了，消费线程阻塞。</p>
<p><em><strong>阻塞队列的用处</strong></em></p>
<blockquote>
<p>在多线程领域：所谓阻塞，在某些情况下会 挂起 线程（即阻塞），一旦满足条件，被挂起的线程又会被自动唤醒。<br>为什么需要BlockingQueue，好处是我们不需要关心什么时候 需要阻塞线程，什么时候需要唤醒线程因为这一切BlockingQueue都给你一手包办了</p>
</blockquote>
<table>
<thead>
<tr>
<th>实现类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><font color=red>ArrayBlockingQueue</font></td>
<td>由数组结构组成的有界阻塞队列</td>
</tr>
<tr>
<td><font color=red>LinkedBlockingQueue</font></td>
<td>由链表结构组成的有界（但大小默认值为integer.MAX_VALUE）阻塞队列</td>
</tr>
<tr>
<td><font color=red>SynchrousQueue</font></td>
<td>不存储元素的阻塞队列，也即单个元素的阻塞队列</td>
</tr>
<tr>
<td>PriorityBlockingQueue</td>
<td>支持优先级排序的无界阻塞队列</td>
</tr>
<tr>
<td>DelayQueue</td>
<td>使用优先级队列实现的延迟无界阻塞队列</td>
</tr>
<tr>
<td>LinkedTransferQueue</td>
<td>由链表组成的无界阻塞队列</td>
</tr>
<tr>
<td>LinkedBlockingDeque</td>
<td>由链表组成的双向阻塞队列</td>
</tr>
</tbody></table>
<h3 id="3-线程池"><a href="#3-线程池" class="headerlink" title="3. 线程池"></a>3. 线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(</span></span><br><span class="line"><span class="params">  												// 常驻核心线程数</span></span><br><span class="line"><span class="params">  												<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">  												// 最大线程数</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">  												// 空闲线程的存活时间，</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">  												// 时间单位</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">  												// 阻塞队列：用于存放被提交但尚未被执行的任务，类似于银行的候客区：窗口已经满了，需要排队等待</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">  												// 线程池中工作线程的线程工厂，用于创建线程。</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">  												// 拒绝策略（阻塞队列满了，无法再容纳更多的线程任务）</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">      maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">      maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">      keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">  <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">  <span class="built_in">this</span>.acc = System.getSecurityManager() == <span class="literal">null</span> ?</span><br><span class="line">    <span class="literal">null</span> :</span><br><span class="line">  AccessController.getContext();</span><br><span class="line">  <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">  <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">  <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">  <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">  <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">  <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="线程池拒绝策略"><a href="#线程池拒绝策略" class="headerlink" title="线程池拒绝策略"></a>线程池拒绝策略</h4><table>
<thead>
<tr>
<th>拒绝策略</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>ThreadPoolExecutor.AbortPolicy(默认)</code></strong></td>
<td>直接抛出RejectedExecutionException异常阻止系统正常运行</td>
<td></td>
</tr>
<tr>
<td><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code></strong></td>
<td><strong>调用者运行</strong>机制：该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量（谁让你找我的，你回去找谁去）</td>
<td></td>
</tr>
<tr>
<td><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code></strong></td>
<td>抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务。</td>
<td></td>
</tr>
<tr>
<td><strong><code>ThreadPoolExecutor.DiscardPolicy</code></strong></td>
<td>该策略默默地丢弃无法处理的任务，不予任何处理也不抛出异常。如果任务允许丢失，这是最好的一种策略。</td>
<td></td>
</tr>
</tbody></table>
<h3 id="4-volatile-amp-JMM内存模型"><a href="#4-volatile-amp-JMM内存模型" class="headerlink" title="4. volatile&amp;JMM内存模型"></a>4. volatile&amp;JMM内存模型</h3><h4 id="JMM内存模型"><a href="#JMM内存模型" class="headerlink" title="JMM内存模型"></a>JMM内存模型</h4><img src="https://img-blog.csdnimg.cn/20200824153251847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Mjc2ODM1,size_16,color_FFFFFF,t_70#pic_center#" alt="在这里插入图片描述" style="zoom:50%;" />

<blockquote>
<p>JMM是java的内存模型，JMM定义了程序中各个共享变量的访问规则，即在虚拟机中奖变量存储到内存和从内存读取变量这样的底层细节。</p>
<p>设计JMM主要的目的是：屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。</p>
<p>由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（有些地方成为栈空间），工作内存是每个线程私有的数据区域，而Java内存模型中规定所有变量都存储在主存中，主存是共享内存区域，所有线程都可以访问。</p>
<p>但是线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量先从主存拷贝到线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主存。</p>
<p>不能直接操作主存中的变量，各个线程中的工作内存中存储着主存中的变量副本，因此不同线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主存来完成。</p>
</blockquote>
<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><h5 id="volatile特性："><a href="#volatile特性：" class="headerlink" title="volatile特性："></a>volatile特性：</h5><ol>
<li><p><strong>可见性</strong></p>
<ul>
<li><p>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的</p>
</li>
<li><blockquote>
<p><strong>volatile底层实现可见性的原理</strong></p>
<p>以两核CPU为例（双核）</p>
<p>由于cpu的速度要比内存快的多，为了弥补这个性能差异，cpu内核都会有自己的高速缓冲区，当内核运行线程执行一段代码时，首先将这段代码的指令集进行缓存行填充到高速缓存，如果非volatile变量，当CPU执行修改了此变量之后，会将修改后的值回写到高速缓存，然后再刷新到内存中。如果刷新回内存之前，由于是共享变量，那么core2中的线程执行的代码也用到了这个变量，这时变量的值依然是旧的。</p>
<p>volatile关键字就会解决这个问题</p>
<blockquote>
<p>首先被volatile关键字修饰的共享变量在转换成汇编语言时，会加上一个lock为前缀的指令，当cpu发现这个指令时，立即做两件事：</p>
<ol>
<li><font color=green>将当前内核高速缓存行的数据立刻回写到内存；</font></li>
<li><font color=green>使其他内核里缓存了该内存地址的高速缓存中的数据无效。重写从主存中读取该数据</font></li>
</ol>
</blockquote>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>禁止指令重排</strong></p>
<ul>
<li>volatile内存区的读写，通过加屏障来禁止指令重排列</li>
<li>LoadLoad屏障：对于这样的语句<code>Load1; LoadLoad; Load2</code>, 在<code>Load2</code>以及后续读取操作要读取的数据被访问前，要保证<code>Load1</code>要读取的数据被读取完毕。</li>
<li>StoreStore屏障：对于这样的语句<code>Store1;StoreStore;Store2</code>, 在<code>Store2</code>以及后续写入操作执行前，保证<code>Store1</code>的写入操作对其它处理器可见。</li>
<li>LoadStore屏障：对于这样的语句<code>Load1;LoadStore;Store2</code>,在<code>Store2</code>以及后续写入操作被刷出前，保证<code>Load1</code>要读取的数据被读取完毕</li>
<li>StoreLoad屏障：对于这样的语句<code>Store1;StoreLoad;Load2</code>,在<code>Load2</code>以及后续所有读取操作执行前，保证<code>Store1</code>的写入对所有处理器可见。</li>
</ul>
</li>
<li><p><strong>不保证原子性</strong></p>
</li>
</ol>
<h3 id="5-synchronized原理"><a href="#5-synchronized原理" class="headerlink" title="5. synchronized原理"></a>5. synchronized原理</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/aspirant/p/11470858.html">深入分析Synchronized原理</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            System.out.println(</span><br><span class="line">                    <span class="string">&quot;Synchronized Demo&quot;</span></span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码通过 <code>javap -c -l -p .class</code>反编译成字节码结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">&quot;SynchronizedDemo.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SynchronizedDemo</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">1</span>: <span class="number">0</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   LSynchronizedDemo;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: dup</span><br><span class="line">       <span class="number">2</span>: astore_1</span><br><span class="line">       <span class="number">3</span>: monitorenter			<span class="comment">// 一次 monitorenter</span></span><br><span class="line">       <span class="number">4</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">7</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String Synchronized Demo</span></span><br><span class="line">       <span class="number">9</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">12</span>: aload_1</span><br><span class="line">      <span class="number">13</span>: monitorexit			<span class="comment">// 两次monitorexit</span></span><br><span class="line">      <span class="number">14</span>: goto          <span class="number">22</span></span><br><span class="line">      <span class="number">17</span>: astore_2</span><br><span class="line">      <span class="number">18</span>: aload_1	</span><br><span class="line">      <span class="number">19</span>: monitorexit			<span class="comment">// 两次monitorexit</span></span><br><span class="line">      <span class="number">20</span>: aload_2</span><br><span class="line">      <span class="number">21</span>: athrow</span><br><span class="line">      <span class="number">22</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">4</span>    <span class="number">14</span>    <span class="number">17</span>   any</span><br><span class="line">          <span class="number">17</span>    <span class="number">20</span>    <span class="number">17</span>   any</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">4</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">5</span>: <span class="number">4</span></span><br><span class="line">      line <span class="number">8</span>: <span class="number">12</span></span><br><span class="line">      line <span class="number">9</span>: <span class="number">22</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>      <span class="number">23</span>     <span class="number">0</span>  <span class="built_in">this</span>   LSynchronizedDemo;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>       <span class="number">1</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li><code>monitorenter</code>：每个对象都是一个监视器锁（<strong>monitor</strong>）。当<strong>monitor</strong>被占用时就会处于锁定状态，线程执行<code>monitorenter</code>指令时，尝试获取<strong>monitor</strong>的所有权，过程如下：</li>
</ol>
<blockquote>
<ol>
<li>如果<strong>monitor</strong>的进入数为0，则该线程进入<strong>monitor</strong>，然后将进入数设置为1，该线程即为<strong>monitor</strong>的所有者；</li>
<li>如果线程已经占有该<strong>monitor</strong>，只是重新进入，则进入<strong>monitor</strong>的进入数加1；</li>
<li>如果其他线程已经占用了<strong>monitor</strong>，则该线程进入阻塞状态，直到<strong>monitor</strong>的进入数为0，再重新尝试获取<strong>monitor</strong>的所有权</li>
</ol>
</blockquote>
<ol start="2">
<li><code>monitorexit</code>:执行<code>monitorexit</code>的线程必须是<code>objectref</code>所对应的<code>monitor</code>的所有者。指令执行时，<code>monitor</code>的进入数减1，如果减1后进入数为0，那线程退出<code>monitor</code>，不再是这个<code>monitor</code>的所有者。其他被这个<code>monitor</code>阻塞的线程可以尝试去获取这个<code>monitor</code>的所有权</li>
</ol>
<blockquote>
<p><font color=red>monitorexit指令出现了两次，第1次为同步正常退出释放锁；第2次为发生异常退出释放锁；</font></p>
</blockquote>
<p><strong>Synchronized</strong>的语义底层是通过一个monitor的对象来完成的。</p>
<h3 id="6-锁-amp-锁升级"><a href="#6-锁-amp-锁升级" class="headerlink" title="6.锁&amp;锁升级"></a>6.锁&amp;锁升级</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/36eedeb3f912">浅谈偏向锁、轻量级锁、重量级锁</a></p>
<p>Synchronized加锁时，进程会从<strong>用户态</strong>转换成<strong>内核态</strong>，让操作系统帮忙调度。用户态与内核态的转换是非常耗时的，所以说Synchronized是重要级的锁。</p>
<p><strong>关于Synchronized的升级</strong></p>
<p>参考文献<a target="_blank" rel="noopener" href="https://blog.csdn.net/steven2xupt/article/details/108047270">https://blog.csdn.net/steven2xupt/article/details/108047270</a></p>
<p>由于synchronized性能问题在JDK1.6前饱受诟病，同时和@author Doug Lea大神写的目前在JUC下的AQS实现的锁差距太大，synchronized开发人员感觉脸上挂不住，所以在1.6版本进行了大幅改造升级，于是就出现了现在常通说的锁升级或锁膨胀的概念,整体思路就是能不打扰操作系统大哥就不打扰大哥，能在用户态解决的就不经过内核。</p>
<p><img src="https://img-blog.csdnimg.cn/2020081722362322.png?type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbjJ4dXB0,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p><strong>升级过程</strong></p>
<ol>
<li>无锁态</li>
<li>偏向锁</li>
<li>轻量级锁（自旋锁：CAS）</li>
<li>重量级锁</li>
</ol>
<p><strong>MarkWord</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200817001540364.png?type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZXZlbjJ4dXB0,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p>简单来说：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>标志位</th>
<th>存储内容</th>
</tr>
</thead>
<tbody><tr>
<td>未锁定</td>
<td>01</td>
<td>对象哈希码、对象分代年龄</td>
</tr>
<tr>
<td>轻量级锁定</td>
<td>00</td>
<td>指向锁记录的指针</td>
</tr>
<tr>
<td>重量级锁定</td>
<td>10</td>
<td>执行重量级锁定的指针</td>
</tr>
<tr>
<td>GC标记</td>
<td>11</td>
<td>空(不需要记录信息)</td>
</tr>
<tr>
<td>偏向锁</td>
<td>01</td>
<td>偏向线程ID、偏向时间戳、对象分代年龄</td>
</tr>
</tbody></table>
<p><img src="https://upload-images.jianshu.io/upload_images/4491294-e3bcefb2bacea224.png" alt="img"></p>
<p>对象内存布局中的markWord会记录当前只有锁的线程id，如果一个线程获取到锁，那么这个线程线程的id会被记录到markword中。</p>
<p><strong>锁升级的大致过程：</strong></p>
<blockquote>
<p>从<strong>无锁态</strong>，如果有对象尝试获取锁，则进入<strong>偏向锁状态</strong>（这时只有一个线程在使用资源）；</p>
<p>如果下一次还是这个线程使用资源，（尝试获取锁），先会比较markword中的线程id是否为这个线程，如果是，直接获得<strong>偏向锁</strong>。</p>
<p>如果有竞争（就是不同线程争抢锁），就会升级到<strong>轻量级锁</strong>（自旋锁CAS）；</p>
<p>如果竞争激烈，自旋了好久（<strong>默认10次</strong>）都没有竞争到锁，那么就会升级为<strong>重量级锁</strong>，然后<strong>挂起此线程</strong>，等待资源的释放后<strong>重新竞争锁</strong></p>
</blockquote>
<blockquote>
<p> JDK1.6引入了自适应自旋锁，所谓自适应自旋锁，就意味着自旋的次数不再是固定的，具体规则如下：</p>
<p>自旋次数通常由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定。如果线程【T1】自旋成功，自旋次数为17次，那么等到下一个线程【T2】自旋时，也会默认认为【T2】自旋17次成功，</p>
<p>如果【T2】自旋了5次就成功了，那么此时这个自旋次数就会缩减到5次。</p>
<p>自适应自旋锁随着程序运行和性能监控信息，从而使得虚拟机可以预判出每个线程大约需要的自旋次数</p>
</blockquote>
<h3 id="7-AQS（AbstractQueuedSynchronizer）：抽象队列同步器"><a href="#7-AQS（AbstractQueuedSynchronizer）：抽象队列同步器" class="headerlink" title="7.AQS（AbstractQueuedSynchronizer）：抽象队列同步器"></a>7.AQS（AbstractQueuedSynchronizer）：抽象队列同步器</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_21040559/article/details/112388069">AQS参考贴子</a></p>
<p>AQS是用来构建锁或者其他同步器组件的<strong>重量级基础框架及整个JUC体系的基石</strong>，通过内置的FIFO队列来完成资源获取线程的排队工作，并通过一个<strong>int类型的变量</strong>表示<strong>持有锁的状态</strong>。</p>
<p><strong>锁</strong>：面向锁的使用者</p>
<p><strong>同步器</strong>：面向锁的实现者</p>
<h4 id="CLH"><a href="#CLH" class="headerlink" title="CLH"></a>CLH</h4><p>AQS是JUC的核心，而CLH锁又是AQS的基础，说核心也不为过，因为AQS就是用了变种的CLH锁。如果要学好Java并发编程，那么必定要学好JUC；学好JUC，必定要先学好AQS；学好AQS，那么必定先学好CLH。因此，这就是我们为什么要学习CLH的原因。</p>
<img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/CLH%E9%98%9F%E5%88%97-9358587-9358590.png" alt="CLH队列" style="zoom:67%;" />

<p>CLH：AQS中的队列是CLH变体的虚拟双向队列FIFO。</p>
<p>相关说明：</p>
<blockquote>
<p>抢到资源的线程直接使用处理业务逻辑，抢不到资源的必然涉及一种排队等候机制。抢占资源失败的线程继续去等待（类似于银行业务办理窗口都满了，暂时没有受理窗口的顾客只能去候客区排队等待），但等待线程仍然保留获取锁的可能且获取锁流程仍在继续（候客区的顾客也在等着叫号，轮到了再去受理窗口办理业务）。</p>
<p>既然说到了<font color=red>排队等候机制</font>,那么就一定会有某种队列来管理，这个队列就是我们所说的<strong>CLH</strong></p>
<p>如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁的分配。这个机制主要用的是CLH队列的变体实现的。将暂时获取不到锁🔐的线程加入到队列中，这个队列就是AQS的抽象表现。它将请求共享资源的线程封装成队列的节点（Node），通过CAS，自旋以及<code>LockSupport.park()</code>方式，维护state变量的状态，使并发达到同步的控制效果。</p>
<p><font color=green>Node</font>有两种模式：<strong>SHARED</strong>：共享模式；<strong>EXCLUSIVE</strong>：排他模式</p>
<p>队列中的每个节点<font color=green>Node</font>中有一个字段<code>waitStatus</code>代表当前节点在CLH中的状态：</p>
<ul>
<li><strong>0</strong>：当前一个Node被初始化的时候的默认值</li>
<li><strong>CANCELLED</strong>（1）：表示线程获取锁的请求已经取消了，不想等了，直接取消了</li>
<li><strong>CONDITION</strong>（-2）：表示节点在等待队列中，节点线程等待唤醒（等待Condition唤醒）</li>
<li><strong>PROPAGATE</strong>（-3）：当前线程处在SHARED情况下，该字段才会使用</li>
<li><strong>SIGNAL</strong>（-1）：表示线程已经准备好了，等待资源释放</li>
</ul>
</blockquote>
<h4 id="AQS初步"><a href="#AQS初步" class="headerlink" title="AQS初步"></a>AQS初步</h4><h5 id="AQS初识"><a href="#AQS初识" class="headerlink" title="AQS初识"></a>AQS初识</h5><p>AQS使用一个<code>volatile</code>的<code>int</code>类型的成员变量来表示同步状态，通过内置的<code>FIFO</code>队列来完成资源获取的排队工作将每条要去抢占资源的线程封装成一个Node节点来实现锁的分配，通过CAS来完成对<code>State</code>值的修改。</p>
<h5 id="AQS内部体系架构"><a href="#AQS内部体系架构" class="headerlink" title="AQS内部体系架构"></a>AQS内部体系架构</h5><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210819193357918-9372839.png" alt="image-20210819193357918" style="zoom:50%;" />



<p><strong>相关说明</strong></p>
<p>当AQS中的状态为State为0的时候，说明此时没有资源竞争，那么当前线程占用当前资源，同时State状态位+1;如果State大于等于1时（大于1时表示重入锁🔐），就说明当前资源又线程被占用，其它线程需要进行等待，其它线程会被封装成Node节点，然后放入到CLH中。</p>
<p>在CLH中，双向链表中的第一个节点时一个<font color=red>傀儡节点</font>, 起到站位的作用，其实际并不存储任何信息。真正存储数据的节点是从第二个开始的。因此**<code>傀儡节点（哨兵节点）中的Thread=null</code>**.</p>
<p>没到CLH中的线程节点争抢到资源的时候，那么之前的<font color=red>傀儡节点</font>将会被断开引用，然后挣抢到资源的线程所在节点的<code>Thread字段置为空</code>,然后这个节点成为新的<font color=red>傀儡节点</font></p>
<p><strong>AQS = CLH + State</strong></p>
<p><strong>串插一个面试题</strong></p>
<p>智力题-找机器<br>十个机器，其中九个机器生产的货物是5g，只有一个机器生产的货物是4g，给你一个称，如何一次找出那个生产4g货物的机器。</p>
<p>解题：<br>将10个机器依次进行编号，分别为1-10。1号机器生产1个货物，2号机器生产2个货物，以此类推，10号机器生产10个货物，共计55个货物。<br>假设每个机器生产的货物都是5g，则这55个货物的总重量为275g。因此，275g - 实际的重量 = 机器的编号。<br>原因：假设是n号机器生产的货物为4g，则n号机器总共生产n个货物，即重量减少了ng。</p>
<h2 id="常用设计模式"><a href="#常用设计模式" class="headerlink" title="常用设计模式"></a>常用设计模式</h2><h3 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a>1.单例模式</h3><h3 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2.工厂模式"></a>2.工厂模式</h3><h3 id="3-模板模式"><a href="#3-模板模式" class="headerlink" title="3.模板模式"></a>3.模板模式</h3><h3 id="4-代理模式"><a href="#4-代理模式" class="headerlink" title="4.代理模式"></a>4.代理模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Proxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>();</span><br><span class="line">        proxy.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象主题</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">Request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真实主题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Request</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题方法...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> RealSubject realSubject;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Request</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (realSubject == <span class="literal">null</span>) &#123;</span><br><span class="line">            realSubject = <span class="keyword">new</span> <span class="title class_">RealSubject</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        preRequest();</span><br><span class="line">        realSubject.Request();</span><br><span class="line">        postRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题之前的预处理。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;访问真实主题之后的后续处理。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="5-建造者模式"><a href="#5-建造者模式" class="headerlink" title="5.建造者模式"></a>5.建造者模式</h3><h3 id="6-观察者模式"><a href="#6-观察者模式" class="headerlink" title="6.观察者模式"></a>6.观察者模式</h3><h3 id="7-原型设计模式"><a href="#7-原型设计模式" class="headerlink" title="7. 原型设计模式"></a>7. 原型设计模式</h3><p>原型（Prototype）模式的定义如下：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。例如，Windows 操作系统的安装通常较耗时，如果复制就快了很多。在生活中复制的例子非常多，这里不一一列举了。</p>
<h4 id="原型模式的优点："><a href="#原型模式的优点：" class="headerlink" title="原型模式的优点："></a>原型模式的优点：</h4><ul>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/java/">Java</a> 自带的原型模式基于内存二进制流的复制，在性能上比直接 new 一个对象更加优良。</li>
<li>可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如恢复到历史某一状态），可辅助实现撤销操作。</li>
</ul>
<h4 id="原型模式的缺点："><a href="#原型模式的缺点：" class="headerlink" title="原型模式的缺点："></a>原型模式的缺点：</h4><ul>
<li>需要为每一个类都配置一个 clone 方法</li>
<li>clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。</li>
<li>当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。</li>
</ul>
<h4 id="原型模式的实现"><a href="#原型模式的实现" class="headerlink" title="原型模式的实现"></a>原型模式的实现</h4><p><img src="http://c.biancheng.net/uploads/allimg/181114/3-1Q114101Fa22.gif" alt="原型模式的结构图"></p>
<p>由于 Java 提供了对象的 clone() 方法，所以用 Java 实现原型模式很简单。</p>
<p>原型模式包含以下主要角色。</p>
<ol>
<li>抽象原型类：规定了具体原型对象必须实现的接口。</li>
<li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li>
<li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体原型类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Realizetype</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    Realizetype() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体原型创建成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体原型复制成功！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (Realizetype) <span class="built_in">super</span>.clone(); <span class="comment">// 浅拷贝</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原型模式的测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrototypeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Realizetype</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Realizetype</span>();</span><br><span class="line">        <span class="type">Realizetype</span> <span class="variable">obj2</span> <span class="operator">=</span> (Realizetype) obj1.clone();</span><br><span class="line">        System.out.println(<span class="string">&quot;obj1==obj2?&quot;</span> + (obj1 == obj2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xzwblog/p/7230788.html">Java中的深浅拷贝（clone）</a></p>
<h2 id="列举Java几个异常"><a href="#列举Java几个异常" class="headerlink" title="列举Java几个异常"></a>列举Java几个异常</h2><ol>
<li><code> java.lang.OutOfMemoryError</code><ul>
<li>当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。</li>
</ul>
</li>
<li><code> java.lang.StackOverflowError</code><ul>
<li>当一个应用递归调用的层次太深而导致堆栈溢出或者陷入死循环时抛出该错误</li>
</ul>
</li>
<li><code>java.lang.CloneNotSupportedException</code><ul>
<li>clone方法所在类没有继承Cloneable接口</li>
</ul>
</li>
<li><code>java.util.ConcurrentModificationException</code> </li>
</ol>
<h1 id="Linux-复习"><a href="#Linux-复习" class="headerlink" title="Linux 复习"></a>Linux 复习</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看磁盘情况</span></span><br><span class="line"><span class="built_in">df</span> -h </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看目录，或文件使用磁盘情况</span></span><br><span class="line"><span class="built_in">du</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内存使用情况</span></span><br><span class="line">free -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># http 工具</span></span><br><span class="line"></span><br><span class="line">curl URL</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进程</span></span><br><span class="line">ps -ef</span><br><span class="line"></span><br><span class="line">top</span><br><span class="line"></span><br><span class="line">htop 交互式top命令</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程同步</span></span><br><span class="line">scp</span><br><span class="line"></span><br><span class="line">rsync   <span class="comment"># 同步，同步之间会比较之前的文件，只会同步更改的内容</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较两个文件的差异</span></span><br><span class="line">diff 文件1 文件2 -y -W</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看历史命令</span></span><br><span class="line"><span class="built_in">history</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务管理命令</span></span><br><span class="line"></span><br><span class="line">service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 管理systemd的资源Unit</span></span><br><span class="line">systemctl</span><br><span class="line"></span><br><span class="line">xargs</span><br><span class="line"><span class="comment"># 例如：</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;11@22@33&#x27;</span> | xargs -d <span class="string">&#x27;@&#x27;</span> <span class="built_in">echo</span></span><br><span class="line">11 22 33</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计文件行数</span></span><br><span class="line"><span class="built_in">wc</span> -l test1.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">脚本同步命令</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">获取输入参数个数，如果没有参数，直接退出</span></span><br><span class="line">pcount=$#</span><br><span class="line">if((pcount==0)); then</span><br><span class="line">        echo no args...;</span><br><span class="line">        exit;</span><br><span class="line">fi</span><br><span class="line"><span class="meta"># </span><span class="language-bash">获取文件名称</span></span><br><span class="line">p1=$1</span><br><span class="line">fname=`basename $p1`</span><br><span class="line">echo fname=$fname</span><br><span class="line"><span class="meta"># </span><span class="language-bash">获取上级目录到绝对路径</span></span><br><span class="line">pdir=`cd -P $(dirname $p1); pwd`</span><br><span class="line">echo pdir=$pdir</span><br><span class="line"><span class="meta"># </span><span class="language-bash">获取当前用户名称</span></span><br><span class="line">user=`whoami`</span><br><span class="line"><span class="meta"># </span><span class="language-bash">循环</span></span><br><span class="line">for((host=2; host&lt;=10; host++)); do</span><br><span class="line">        echo $pdir/$fname $user@slave$host:$pdir</span><br><span class="line">        echo ==================slave$host==================</span><br><span class="line">        rsync -rvl $pdir/$fname $user@slave$host:$pdir</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="language-bash">Note:这里的slave对应自己主机名，需要做相应修改。另外，<span class="keyword">for</span>循环中的host的边界值</span></span><br></pre></td></tr></table></figure>







<h3 id="top详解"><a href="#top详解" class="headerlink" title="top详解"></a>top详解</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">当前时间、系统已运行时间、当前登录用户的数量、最近5、10、15分钟内的平均负载</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了</span></span><br><span class="line">top - 15:56:34 up 46 days, 20:13,  0 users,  load average: 8.20, 9.77, 10.36</span><br><span class="line"><span class="meta"># </span><span class="language-bash">tasks 统计，系统现在共有34个任务，1个正在运行，33</span></span><br><span class="line">Tasks:  34 total,   1 running,  33 sleeping,   0 stopped,   0 zombie</span><br><span class="line"><span class="meta"># </span><span class="language-bash">CPU 使用情况</span> </span><br><span class="line"><span class="meta"># </span><span class="language-bash">us：用户空间占用情况</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">sy：内核空间占用情况</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">ni：改变过优先级的进程占用CPU的百分比</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">id</span>：空闲CPU百分比</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">wa：IO等待占用CPU的百分比</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">hi：硬中断占用cpu百分比</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">si：软中断占用cpu百分比</span></span><br><span class="line"><span class="meta">%</span><span class="language-bash">Cpu(s):  5.2 us,  5.1 sy,  0.6 ni, 89.0 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span></span><br><span class="line">KiB Mem : 26390454+total, 18626068 free, 18532243+used, 59956032 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used. 47536756 avail Mem </span><br></pre></td></tr></table></figure>



<h1 id="MySql复习"><a href="#MySql复习" class="headerlink" title="MySql复习"></a>MySql复习</h1><h2 id="1-数据库三范式"><a href="#1-数据库三范式" class="headerlink" title="1. 数据库三范式"></a>1. 数据库三范式</h2><ol>
<li><strong>第一范式：每个列不可再分</strong></li>
<li><strong>第二范式：不存在部分函数依赖</strong></li>
<li><strong>第三范式：不存在传递函数依赖</strong></li>
</ol>
<h2 id="2-MySql存储引擎"><a href="#2-MySql存储引擎" class="headerlink" title="2.MySql存储引擎"></a>2.MySql存储引擎</h2><p>MySql中的数据，索引以及其他对象是如何存储的，是一套文件系统实现的（Storage Engine）</p>
<p>MY_SQL存储引擎有以下几种：</p>
<ul>
<li>MRG_MYISAM</li>
<li>MyISM</li>
<li>BLACKHOLE</li>
<li>CSV</li>
<li>MEMORY</li>
<li>ARCHIVE</li>
<li>InnoDB</li>
<li>PERFORMANCE_SCHEMA</li>
</ul>
<p><strong>InnoDB引擎</strong>：InnoDB引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。</p>
<p><strong>MyISAM引擎</strong>：不提供事务的支持，也不支持行级锁和外键</p>
<p><strong>Memory引擎</strong>：所有的数据都在内存中，数据的处理速度快，但是安全性不搞。</p>
<p><strong>常见的<em>MyISAM</em>与<em>InnoDB</em>的比较</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>MyISAM</th>
<th>InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td>存储结构</td>
<td>每张表被存放在三个文件：<br />frm-表格定义<br />MYD（MYData）-数据文件<br />MYI（MYIndex）-索引文件</td>
<td>所有的表都保存在同一个数据文件中<br />（也可能是多个文件，或者是独立的表空间文件）<br />InnoDB表的大小只受限于操作系统文件的大小，<br />一般为2GB</td>
</tr>
<tr>
<td>存储空间</td>
<td>MyISAM可被压缩，存储空间较小</td>
<td>InnoDB的表需要更多的内存和存储，<br />它会在主内存中建立专用的缓冲池<br />用于高速缓冲数据和索引</td>
</tr>
<tr>
<td>可移植性、备份及恢复</td>
<td>由于MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。<br />在备份和恢复时可单独针对某个表进行操作。</td>
<td>数据和索引都是集中存储的</td>
</tr>
<tr>
<td>记录存储顺序</td>
<td>按记录插入顺序保存</td>
<td>按主键大小有序插入</td>
</tr>
<tr>
<td>外键</td>
<td><strong>不支持</strong></td>
<td><strong>支持</strong></td>
</tr>
<tr>
<td>事务</td>
<td><strong>不支持</strong></td>
<td><strong>支持</strong></td>
</tr>
<tr>
<td>锁支持（锁是避免资源争用的一个机制，MySql锁对用户几乎是透明的）</td>
<td><strong>表级锁定</strong></td>
<td><strong>行级锁定</strong>，<strong>表级锁定</strong>，锁定粒度小并发能力高</td>
</tr>
<tr>
<td>SELECT</td>
<td>MyIsam更有</td>
<td></td>
</tr>
<tr>
<td>INSERT、UPDATE、DELETE</td>
<td></td>
<td>InnoDB更优</td>
</tr>
<tr>
<td>索引的实现方式</td>
<td>B+树索引，myisam是堆表</td>
<td>B+树索引，InnoDB是索引组织表</td>
</tr>
<tr>
<td>哈希索引</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>全文索引</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<p><strong>MyISAM索引与InnoDB索引的区别</strong></p>
<ul>
<li>InnoDB索引是聚簇索引（索引的存储顺序与实际的数据物理存储顺序保持一致），MyIsam索引是非聚簇索引</li>
<li>InnoDB的主键索引的叶子结点存储着行数据，因此主键索引非常高效</li>
<li>MyISAM索引的叶子结点存储的是行数据地址，需要再寻址一次才能得到数据</li>
<li>InnoDB非主键索引的叶子结点存储的是主键和其他索引的列数据，因此查询时做到覆盖索引会非常高效。</li>
</ul>
<h2 id="3-索引"><a href="#3-索引" class="headerlink" title="3. 索引"></a>3. 索引</h2><h3 id="3-1-什么是索引？"><a href="#3-1-什么是索引？" class="headerlink" title="3.1 什么是索引？"></a>3.1 什么是索引？</h3><p>索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</p>
<p><strong>B树与B+树的却别</strong></p>
<blockquote>
<p>B树中每个关键字都保存着数据；而B+树中只有叶子节点存储实际的数据，其余节点只存储关键字信息。这使得B+查找数据必须查询到叶子节点，而B树只要匹配即可（不管元素的具体位置），因此B+树查找更稳定</p>
<p>对于范围查找来说，B+树只需遍历叶子结点链表即可，b树却需要重复地中序遍历。</p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MDI1NTkx,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
</blockquote>
<h3 id="3-2-索引的优点"><a href="#3-2-索引的优点" class="headerlink" title="3.2 索引的优点"></a>3.2 索引的优点</h3><ul>
<li>可以大大加快数据的检索速度，这就是创建索引的最主要的原因</li>
<li>通过使用索引，可以在查询的过程中，使用优化器，提高系统的性能</li>
</ul>
<h3 id="3-3-索引的缺点"><a href="#3-3-索引的缺点" class="headerlink" title="3.3 索引的缺点"></a>3.3 索引的缺点</h3><ul>
<li>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加，删除和修改的时候，索引也要动态的维护，会降低增删改的执行效率。</li>
<li>空间方面：索引需要占物理空间</li>
</ul>
<h3 id="3-4-索引使用注意事项"><a href="#3-4-索引使用注意事项" class="headerlink" title="3.4 索引使用注意事项"></a>3.4 索引使用注意事项</h3><p>索引虽好，但是索引使用不恰当就会造成索引失效</p>
<p><strong>索引使用口诀：</strong></p>
<ol>
<li><strong>全值匹配我最爱</strong><ul>
<li>就是查询的列都是索引（覆盖索引，这中情况不需要查询实际的物理数据，只需要查询索引树即可）</li>
</ul>
</li>
<li><strong>最佳左前缀法则</strong><ul>
<li>如果索引了多列，在使用时就要遵守最左前缀法则（mysql会经过优化器去优化字段的顺序，使得查询顺序与所以创建的顺序保持一致）<ul>
<li>带头大哥不能死</li>
<li>中间兄弟不能断</li>
</ul>
</li>
</ul>
</li>
<li><strong>索引列上不计算</strong><ul>
<li>使用sum，avg等计算或者 自动(手动)类型转换，都会导致索引失效</li>
</ul>
</li>
<li><strong>范围之后全失效</strong></li>
<li><strong>like语句%加在右边</strong></li>
<li><strong>字符串里有引号</strong><ul>
<li>字符串不加单引号，会导致索引失效</li>
</ul>
</li>
<li>其他<ul>
<li>使用**!=，&lt;&gt;, is null； is not null ；or**都会导致索引失效</li>
</ul>
</li>
</ol>
<p><strong>非聚簇索引一定会产生回表吗？</strong></p>
<p>不一定。如果查询语句中的的列全部命中索引(<strong>覆盖索引</strong>)，那就不必再进行回表查询了。</p>
<h2 id="4-MySql日志"><a href="#4-MySql日志" class="headerlink" title="4. MySql日志"></a>4. MySql日志</h2><p>MariaDB/MySql中日志包括：</p>
<ol>
<li>错误日志（<strong>Error log</strong>）：记录mysql服务启动时正确和错误的信息，还记录启动、停止、运行过程中的错误信息</li>
<li>查询日志（<strong>General log</strong>）：记录建立的客户端连接和执行的语句。</li>
<li>二进制日志（<strong>binlog</strong>）：记录所有更改数据的语句，可用于数据复制</li>
<li>慢查询日志（<strong>show log</strong>）：记录所有执行时间超过long_query_time的所有查询或不使用索引的查询</li>
<li>中继日志（<strong>relay log</strong>）：主从复制时使用的日志。</li>
<li>InnoDB引擎还有事务日志</li>
</ol>
<h3 id="4-1-二进制日志"><a href="#4-1-二进制日志" class="headerlink" title="4.1 二进制日志"></a>4.1 二进制日志</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html">事务日志详解</a></p>
<p>MySql支持statement、row、mixed三种形式的<strong>binlog</strong>记录方式。</p>
<ul>
<li>statement<ul>
<li>将所有的相关操作记录为SQL语句的形式</li>
<li>这样的记录方式对某些特殊信息无法同步记录，例如uuid，now()等这样的动态变化的值。</li>
</ul>
</li>
<li>row<ul>
<li>基于行来记录，将相关行的每一列的值都在日志中保存下来</li>
<li>这样的结果会导致日志文件变得非常大，但是保证了动态值的确定性。</li>
</ul>
</li>
<li>mixed<ul>
<li>statement与row混合形式</li>
<li>默认采用statement的方式记录，只有以下几种情况会采用row的形式来记录日志<ul>
<li>表的存储引擎为NDB，这是对表的DML操作都会以row的格式记录</li>
<li>使用了uuid(), user(), current_user(), found_rows(), row_cuount()等不确定函数。但是测试发现对now()函数仍然会以statement格式记录，而sysdate()函数会以row格式记录。</li>
<li>使用了insert delay语句</li>
<li>使用了临时表</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-2-事务日志"><a href="#4-2-事务日志" class="headerlink" title="4.2 事务日志"></a>4.2 事务日志</h3><p>InnoDB存储引擎的事务日志包括：undo log 和 redo log</p>
<p>redo log 通常是物理日志，记录的是数据页的物理页修改，而不是某一行或某几行修改成怎么样，它用来恢复提交后的物理数据页（恢复数据页，且只能恢复到最后一次提交的位置）</p>
<p>undo用来回滚行记录到某个版本。undo log一般是逻辑日志，根据每行记录进行记录。</p>
<h4 id="1-redo-log"><a href="#1-redo-log" class="headerlink" title="1. redo log"></a>1. redo log</h4><p>redo log不是二进制日志。虽然二进制日志也记录了innodb表的很多操作，也能实现重做的功能，但是他们之间有很大区别。</p>
<ol>
<li>二进制日志是在<strong>存储引擎的上层</strong>产生的，不管是什么存储引擎，对数据库进行了修改都会产生二进制日志。而redo log是innodb层产生的，只记录该存储引擎中表的修改。<strong>并且二进制日志先于redo log被记录</strong>。具体的见后文group commit小结。</li>
<li>二进制日志记录操作的方法是逻辑性的语句。即便它是基于行格式的记录方式，其本质也还是逻辑的SQL设置，如该行记录的每列的值是多少。而redo log是在物理格式上的日志，它记录的是数据库中每个页的修改。</li>
<li><font color=green>二进制日志只在每次事务提交的时候一次性写入缓存中的日志”文件”(对于非事务表的操作，则是每次执行语句成功后就直接写入)</font>。而redo log在数据准备修改前写入缓存中的redo log中，然后才对缓存中的数据执行修改操作；而且保证在发出事务提交指令时，先向缓存中的redo log写入日志，写入完成后才执行提交动作。</li>
<li>因为二进制日志只在提交的时候一次性写入，所以二进制日志中的记录方式和提交顺序有关，且一次提交对应一次记录。而redo log中是记录的物理页的修改，redo log文件中同一个事务可能多次记录，最后一个提交的事务记录会覆盖所有未提交的事务记录。例如事务T1，可能在redo log中记录了 T1-1,T1-2,T1-3，T1* 共4个操作，其中 T1* 表示最后提交时的日志记录，所以对应的数据页最终状态是 T1* 对应的操作结果。而且redo log是并发写入的，不同事务之间的不同版本的记录会穿插写入到redo log文件中，例如可能redo log的记录方式如下：<code>T1-1,T1-2,T2-1,T2-2,T2*,T1-3,T1*</code>。</li>
<li>事务日志记录的是物理页的情况，它具有幂等性，因此记录日志的方式极其简练。幂等性的意思是多次操作前后状态是一样的，例如新插入一行后又删除该行，前后状态没有变化。而二进制日志记录的是所有影响数据的操作，记录的内容较多。例如插入一行记录一次，删除该行又记录一次。</li>
</ol>
<p><strong>Redo log的基本概念</strong></p>
<p>redo log包括两部分：一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。</p>
<p>在概念上，innodb通过***force log at commit***机制实现事务的持久性，即在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的redo log file和undo log file中进行持久化。</p>
<p>为了确保每次日志都能写入到事务日志文件中，在每次将log buffer中的日志写入日志文件的过程中都会调用一次操作系统的fsync操作(即fsync()系统调用)。因为MariaDB/MySQL是工作在用户空间的，MariaDB/MySQL的log buffer处于用户空间的内存中。要写入到磁盘上的log file中(redo:ib_logfileN文件,undo:share tablespace或.ibd文件)，中间还要经过操作系统内核空间的os buffer，调用fsync()的作用就是将OS buffer中的日志刷到磁盘上的log file中。</p>
<p><strong>redo log的格式</strong></p>
<p>因为InnoDB存储引擎数据的单元是页，所以redo log也是基于页的格式来记录的。InnoDB的页大小是16kb，一个页可以存放非常多的log blcok（512字节），而log block中记录的有时数据页的变化。</p>
<p><strong>InnoDB的恢复行为</strong></p>
<p>在启动InnoDB的时候，不管上次是正常关闭还是异常关闭，总是会进行恢复操作。</p>
<p>因为redo log记录的是数据页的物理变化，因此恢复的时候速度比逻辑日志（比如binlog）要快很多。而且，InnoDB自身也做了一定程度的优化，让恢复速度变得更快。</p>
<h4 id="2-undo-log"><a href="#2-undo-log" class="headerlink" title="2. undo log"></a>2. undo log</h4><p>undo log有两个作用：提供回滚和多个行版本控制（MVCC）</p>
<p>在数据修改的时候，不仅记录了<strong>redo</strong>，还记录了相应的<strong>undo</strong>，如果因为某些原因导致事务失败或回滚，可以借助该undo进行回滚。</p>
<p>undo log 和 redo log记录物理日志不一样，它是逻辑日志。<font color=red>可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。</font>但是实际并不是这样记录的。</p>
<p>当执行rollback时，就可以从undo log中的逻辑读取到相应的内容并进行回滚。有时候应用到行版本控制的时候，也是通过undo log来实现的：当读取的某一行被其他事务锁定时，它可以从undo log中分析出该行记录以前的数据是什么，从而提供该行版本信息，让用户实现非锁定一致性读取。</p>
<p><font color=red>undo log 是采用段（segment）的方式来记录的，每个undo操作在记录的时候占用一个undo log segment。</font></p>
<p>另外，undo log也会产生redo log，因为undo log也要实现持久性保护。</p>
<p><strong>undo log 的存储方式</strong></p>
<p>InnoDB存储引擎对undo 的管理采用段的方式。rollback segment称为回滚段，每个混滚段中有1024个undo log segment。</p>
<p>另一篇帖子中的介绍：<a target="_blank" rel="noopener" href="http://www.llbiancheng.com/5623.html">http://www.llbiancheng.com/5623.html</a></p>
<p><strong>Undo</strong>：意为取消，以撤销操作为目的，返回指定某个状态的操作。</p>
<p><strong>Undo Log</strong>：数据库事务提交之前，会将事务修改数据的镜像（即修改前的旧版本）存放到 undo 日志里，当事务回滚时，或者数据库奔溃时，可以利用 undo 日志，即旧版本数据，撤销未提交事务对数据库产生的影响。。</p>
<ul>
<li>对于 insert 操作，undo 日志记录新数据的 PK(ROW_ID)，回滚时直接删除；</li>
<li>对于 delete/update 操作，undo 日志记录旧数据 row，回滚时直接恢复；</li>
<li>他们分别存放在不同的buffer里。</li>
</ul>
<p><strong>Undo Log 是为了实现事务的原子性而出现的产物。</strong></p>
<p><strong>Undo Log 实现事务原子性</strong>：事务处理过程中，如果出现了错误或者用户执行了 ROLLBACK 语句，MySQL 可以利用 Undo Log 中的备份将数据恢复到事务开始之前的状态。</p>
<p>InnoDB 发现可以基于 Undo Log 来实现多版本并发控制。</p>
<p><strong>Undo Log 在 MySQL InnoDB 存储引擎中用来实现多版本并发控制。</strong></p>
<p><strong>Undo Log 实现多版本并发控制</strong>：事务未提交之前，Undo Log 保存了未提交之前的版本数据，Undo Log 中的数据可作为数据旧版本快照供其他并发事务进行快照读。</p>
<p>关于Undo log是怎么实现MVCC的，请参考上篇文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u013277209/article/details/114360409">吃透MySQL（九）：MVCC多版本并发控制</a></p>
<p><strong>Redo</strong>：顾名思义就是重做。以恢复操作为目的，重现操作。</p>
<p><strong>Redo Log</strong>：指事务中操作的任何数据，将最新的数据备份到一个地方（Redo Log）。</p>
<p><strong>Redo Log 的持久化</strong>：不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入 Redo Log 中，具体的落盘策略可以进行配置。</p>
<p><strong>Redo Log 是为了实现事务的持久性而出现的产物。</strong></p>
<p><strong>Redo Log 实现事务持久性</strong>：防止在发生故障的时间点，缓冲池（buffer pool）尚有脏页未写入表的 IBD 文件中，在重启 MySQL 服务的时候，根据 Redo Log 进行重做，从而达到事务的未入磁盘数据进行持久化这一特性。</p>
<p>一旦事务成功提交且数据从缓冲池（buffer pool）持久化到表的 IBD 文件中之后，此时 Redo Log 中的对应事务数据记录就失去了意义，所 以 Redo Log 的写入是日志文件循环写入的过程，也就是覆盖写的过程。</p>
<h3 id="4-事务"><a href="#4-事务" class="headerlink" title="4. 事务"></a>4. 事务</h3><h4 id="4-1-什么是事务？"><a href="#4-1-什么是事务？" class="headerlink" title="4.1 什么是事务？"></a>4.1 什么是事务？</h4><p>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>
<h4 id="4-2-事务的四大特性（ACID）"><a href="#4-2-事务的四大特性（ACID）" class="headerlink" title="4.2 事务的四大特性（ACID）"></a>4.2 事务的四大特性（ACID）</h4><ul>
<li><strong>原子性</strong>（Atomicity）</li>
<li><strong>一致性</strong>（Consistency）</li>
<li><strong>隔离性</strong>（Isolation）</li>
<li><strong>持久性</strong>（Durability）</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kismetv/p/10331633.html">参考文章</a></p>
<h5 id="4-2-1-原子性"><a href="#4-2-1-原子性" class="headerlink" title="4.2.1 原子性"></a>4.2.1 原子性</h5><p>原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做；如果事务中一个sql语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态。</p>
<ul>
<li><strong>实现原理：undo log</strong></li>
</ul>
<h5 id="4-2-2-持久性"><a href="#4-2-2-持久性" class="headerlink" title="4.2.2 持久性"></a>4.2.2 持久性</h5><p>持久性是指事务一旦提交，它对数据库的改变就应该是永久性的。就下来的其他操作或故障不应该对其有任何影响。</p>
<ul>
<li><strong>实现原理：redo log</strong></li>
</ul>
<h5 id="4-2-3-隔离性"><a href="#4-2-3-隔离性" class="headerlink" title="4.2.3 隔离性"></a>4.2.3 隔离性</h5><p>与原子性、持久性侧重于研究事务本身有所不同，隔离性研究的是不同事务之间的相互影响。隔离性是指，事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
<p>隔离性追求的是并发情形下事务之间互不干扰。</p>
<p>隔离性探讨的问题主要分为两方面：</p>
<ul>
<li>（一个事务）写操作对（另一个事务）写操作的影响：锁机制保证隔离性</li>
<li>（一个事务）写操作对（另一个事务）读操作的影响：MVCC保证隔离性</li>
</ul>
<p>首先来看两个事务的写操作之间的相互影响。隔离性要求同一时刻只能有一个事务对数据进行写操作，InnoDB通过锁机制来保证这一点。</p>
<p>锁机制的基本原理可以概括为：事务在修改数据之前，需要先获得相应的锁；获得锁之后，事务便可以修改数据；该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。</p>
<p><strong>行锁与表锁</strong></p>
<p>按照粒度，锁可以分为表锁、行锁以及其他位于二者之间的锁。表锁在操作数据时会锁定整张表，并发性能较差；行锁则只锁定需要操作的数据，并发性能好。但是由于加锁本身需要消耗资源(获得锁、检查锁、释放锁等都需要消耗资源)，因此在锁定数据较多情况下使用表锁可以节省大量资源。MySQL中不同的存储引擎支持的锁是不一样的，例如MyIsam只支持表锁，而InnoDB同时支持表锁和行锁，且出于性能考虑，绝大多数情况下使用的都是行锁。</p>
<p><strong>脏读、不可重复读和幻读</strong></p>
<p>并发情况下，读操作可能存在的三类问题：</p>
<ol>
<li><p>脏读：当前事务A可以读到其他事务B未提交的数据（脏数据），这种现象为脏读</p>
<blockquote>
<p><img src="https://img2018.cnblogs.com/blog/1174710/201901/1174710-20190128201003630-2050662608.png" alt="img"></p>
</blockquote>
</li>
<li><p>不可重复读：在事务A中先后两次读取同一个数据，两次读取的结果不一样，这种现象称为不可重复读。</p>
<ul>
<li>脏读与不可重复读的区别在于：前者读到的是其他事务未提交的数据，后者读到的是其他事务已提交的数据</li>
</ul>
<blockquote>
<p><img src="https://img2018.cnblogs.com/blog/1174710/201901/1174710-20190128201011603-1317894910.png" alt="img"></p>
</blockquote>
</li>
<li><p>幻读：在事务A中按照某个条件先后两次查询数据库，两次查询结果的条数不同，这种现象称为幻读。</p>
<ul>
<li>不可重复读与幻读的区别在于：前者是数据变了，后者是数据的行变了</li>
</ul>
<blockquote>
<p><img src="https://img2018.cnblogs.com/blog/1174710/201901/1174710-20190128201021606-1089980279.png" alt="img"></p>
</blockquote>
</li>
</ol>
<p><strong>事务的隔离级别</strong></p>
<p>SQL标准中定义了四种隔离级别，并规定了每种隔离级别下上述几个问题是否存在。一般来说，隔离级别越低，系统开销越低，可支持的并发越高，但隔离性也越差。隔离级别与读问题的关系如下：</p>
<p><img src="https://img2018.cnblogs.com/blog/1174710/201901/1174710-20190128201034603-681355962.png" alt="img"></p>
<ul>
<li>Read UnCommitted 读取未提交内容<ul>
<li>在这个隔离级别，所有事务都可以“看到”为提交事务的执行结果。（会造成脏读、不可重复读、幻读）</li>
</ul>
</li>
<li>Read Committed 读取提交内容<ul>
<li>一个事务从开始到提交前，所做的任何数据改变都是不可见的，除非已经提交了。（解决了脏读，但是没有解决不可重复读  和 幻读）</li>
</ul>
</li>
<li>Repeatable Read 可重复读<ul>
<li>MySql数据库默认的隔离级别</li>
<li>它保证同一事务的多个实例在并发读取事务时，会“看到同样的”数据行。（解决了 脏读 和 不可重复读，但是没有解决  幻读）</li>
</ul>
</li>
<li>Serializable 可串行化<ul>
<li>该级别是最高级别的隔离级。它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简而言之，SERIALIZABLE是在每个读的数据行上加锁。在这个级别，可能导致大量的超时<code>Timeout</code>和锁竞争<code>Lock Contention</code>现象，实际应用中很少使用到这个级别，但如果用户的应用为了数据的稳定性，需要强制减少并发的话，也可以选择这种隔离级</li>
</ul>
</li>
</ul>
<p><strong>MVCC多版本并发控制</strong></p>
<p>MVCC可以解决幻读</p>
<p><font color=green>InnoDB的MVCC实现机制</font></p>
<ul>
<li>InnoDB的MVCC实现，是通过保存数据在某个时间点的快照实现的。</li>
<li>一个事务，不管其执行多长时间，其内部看到的数据是一致的。事务在执行过程中不会相互影响</li>
</ul>
<p>MySql中，每条实际的行数据除了我们定义的字段外，还有几个隐藏的列，其中有关于MVCC的重要字段有两个：<strong>DATA_TRX_ID</strong>和<strong>DELETE_BIT</strong></p>
<ul>
<li><p><font color=red>DATA_TRX_ID</font> 标记了最新更新这条行记录的transaction id，每处理一个事务，其值自动+1</p>
</li>
<li><p><font color=red>DELETE_BIT </font>用于标识该记录是否被删除，这里的不是真正的删除数据，而是标志出来的删除。真正意义的删除是在commit的时候。</p>
</li>
</ul>
<p>下面分别以select、delete、insert、update语句来说明：</p>
<ul>
<li><strong>INSERT</strong><ul>
<li>InnoDB为每个新增行记录当前系统版本号（事务ID）作为创建ID（DATA_TRX_ID）</li>
</ul>
</li>
<li><strong>DELETE</strong><ul>
<li>InnoDB为每个删除行记录当前系统版本号（事务ID）作为删除ID（DELETE_BIT）</li>
</ul>
</li>
<li><strong>UPDATE</strong><ul>
<li>InnoDB复制了一行。这个新行的版本号使用了系统版本号。它也把系统版本号作为了删除行的版本。</li>
</ul>
</li>
<li><strong>SELECT</strong><ul>
<li>InnoDB检查每行数据，确保他们符合两个标准<ul>
<li>InnoDB只查找早于当前事务版本的数据行（也就是数据行的版本必须小于等于事务的版本），这确保当前事务读取的行都是事务之前已经存才的，或者是由当前事务创建或修改的行。</li>
<li>行的删除操作的版本一定是未定义的或者大于当前事务版本号，确定了当前事务开始之前，行没有被删除</li>
</ul>
</li>
<li>符合了以上两点则返回查询结果</li>
</ul>
</li>
</ul>
<p>InnoDB中的MVCC实现方式：</p>
<ul>
<li>事务以排它锁的形式修改原始数据</li>
<li>把修改前的数据存放于undo log，通过回滚指针与主数据关联</li>
<li>修改成功（commit）啥都不做，失败则恢复undo log中的数据（rollback）</li>
</ul>
<p>二者最本质的区别是，当修改数据时是否要排他锁定，如果锁定了还算不算是MVCC？ </p>
<p>Innodb的实现真算不上MVCC，因为并没有实现核心的多版本共存，undo log中的内容只是串行化的结果，记录了多个事务的过程，不属于多版本共存。但理想的MVCC是难以实现的，当事务仅修改一行记录使用理想的MVCC模式是没有问题的，可以通过比较版本号进行回滚；但当事务影响到多行数据时，理想的MVCC据无能为力了。</p>
<p>比如，如果Transaciton1执行理想的MVCC，修改Row1成功，而修改Row2失败，此时需要回滚Row1，但因为Row1没有被锁定，其数据可能又被Transaction2所修改，如果此时回滚Row1的内容，则会破坏Transaction2的修改结果，导致Transaction2违反ACID。</p>
<p>理想MVCC难以实现的根本原因在于企图通过乐观锁代替二段提交。修改两行数据，但为了保证其一致性，与修改两个分布式系统中的数据并无区别，而二提交是目前这种场景保证一致性的唯一手段。二段提交的本质是锁定，乐观锁的本质是消除锁定，二者矛盾，故理想的MVCC难以真正在实际中被应用，Innodb只是借了MVCC这个名字，提供了读的非阻塞而已。</p>
<h5 id="4-2-4-一致性"><a href="#4-2-4-一致性" class="headerlink" title="4.2.4 一致性"></a>4.2.4 一致性</h5><p>一致性是指事务执行结束后，<strong>数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态</strong>。数据库的完整性约束包括但不限于：实体完整性（比如行的主键存在且唯一）、列完整性（如字段的类型，大小，长度要符合要求）、外键约束、用户自定义完整性。</p>
<p>可以说，一致性是事务追求的最终目标：前面提到的原子性，持久性和隔离性，都是为了保证数据库状态的一致性。此外，除了数据库层面的保障，一致性的实现也需要应用层面进行保障。</p>
<p>实现一致性的措施：</p>
<ul>
<li>保证原子性、持久性和隔离，如果这些特性无法保证，事务的一致性也无法保证。</li>
<li>数据库本身提供保障，例如不允许向整型列插入字符串值，字符串长度不能超过列的限制等</li>
<li>应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接受者的余额，无论数据库实现的多么完美，也无法保证状态的一致性。</li>
</ul>
<p>​            </p>
<h2 id="5-锁"><a href="#5-锁" class="headerlink" title="5. 锁"></a>5. 锁</h2><p>MySQL里面的锁大致可以分成 <strong>全局锁</strong>、<strong>表级锁</strong>和<strong>行级锁</strong>这三类。</p>
<h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>全局锁就是对整个数据库实例加锁。</p>
<p><strong>全局锁的典型使用场景：做全库逻辑备份</strong>，也就是把整库每个表都select出来存成文本。</p>
<p>但是全局锁会导致整个库进入只读状态，在实际的线上任务中，这很危险。</p>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>Mysql中的表级别的锁有两种：</p>
<ul>
<li><p>表锁</p>
<ul>
<li>MyISAM引擎<ul>
<li><strong>表共享读锁</strong><ul>
<li>不会阻塞其他线程对同一个表的读操作请求，但会阻塞其他线程的写操作请求；</li>
</ul>
</li>
<li><strong>表独占写锁</strong><ul>
<li>一旦表被加上独占写锁，那么无论其他线程是读操作还是写操作，都会被阻塞。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>默认情况下，写锁比读锁具有更高的优先级；当一个锁释放后，那么它会优先相应写锁等待队列中的请求，然后再是读锁中等待的获取锁的请求。</p>
<ul>
<li>InnoDB引擎<ul>
<li>表锁———<strong>-意向锁</strong><ul>
<li>由于表锁和行锁虽然作用范围不同，但是会相互冲突。当你要加表锁时，势必要先遍历表的所有记录，判断是否有<strong>排它锁</strong>。这种遍历检查的方式显然是一种低效的方式。InnoDB引入了<strong>意向锁</strong>，来检测表锁和行锁的冲突。</li>
<li>意向锁也是表级锁，分为**读意向锁(IS)<strong>，和</strong>写意向锁(IX)**。当事务要在记录上加行锁时，要首先在表上加意向锁。这样判断表中是否有记录正在加锁就很简单了，只要看下表上是否有意向锁就行了。从而就能提升效率。</li>
<li>意向锁之间不会产生冲突，它只会阻塞表级读锁或写锁。意向锁不与行锁发生冲突。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>元数据锁（MDL）</p>
<ul>
<li>元数据锁MDL是系统默认加的</li>
<li>当表的结构发生变化时，这个锁就会生效</li>
</ul>
</li>
</ul>
<blockquote>
<p>表锁不会出现死锁，发生锁的冲突几率高，并发低</p>
<p>MyISAM在执行查询语句（select）前，会自动给涉及的所有表加读锁，在执行insert、delete和update前，会自动给涉及的表加写锁。</p>
<p>读锁会阻塞写，写锁会阻塞读和写</p>
<ul>
<li>MyISAM表的读操作，不会阻塞其他线程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其他进程的写操作。</li>
<li>对MyISAM表的写操作，会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其他进程的读写操作。</li>
</ul>
<p>MyISAM引擎不适合做写为主表的引擎，因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。</p>
</blockquote>
<h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p><strong>InnoDB中的行锁</strong></p>
<p>InnoDB实现了一下两种类型的行锁：</p>
<ul>
<li>共享锁（S）：加了锁的记录，所有事务都能去读取但不能修改，同时阻止其他事务获得相同数据集的排它锁</li>
<li>排它锁（X）：允许已经获得排它锁的事务去更新数据，阻止其他事务获得相同数据集的共享锁和排它锁。</li>
</ul>
<p><strong>锁模式的兼容矩阵</strong></p>
<p>下面表显示了了各种锁之间的兼容情况：</p>
<table>
<thead>
<tr>
<th></th>
<th>X</th>
<th>IX</th>
<th>S</th>
<th>IS</th>
</tr>
</thead>
<tbody><tr>
<td>X</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>IX</td>
<td></td>
<td>兼容</td>
<td></td>
<td>兼容</td>
</tr>
<tr>
<td>S</td>
<td></td>
<td></td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>IS</td>
<td></td>
<td>兼容</td>
<td>兼容</td>
<td>兼容</td>
</tr>
</tbody></table>
<p>（注意上面的X与S是说表级的X锁和S锁，意向锁不和行级锁发生冲突）</p>
<p>如果一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；如果两者不兼容，那么该事务就需要等待锁的释放。</p>
<p><font color=red>注意：</font></p>
<p><font color=green>InnoDB的行锁是作用在索引上的，哪怕建表的时候没有定义一个索引，InnoDB也会创建一个聚簇索引并将其作为锁作用的索引。</font></p>
<p><font color=green>行锁必须有索引才能实现，否则会自动锁全表。</font></p>
<ul>
<li>两个事务不能锁同一个索引</li>
<li>insert，delete，update在事务中都会自动默认加上排它锁</li>
</ul>
<h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><h2 id="6-性能分析与优化"><a href="#6-性能分析与优化" class="headerlink" title="6. 性能分析与优化"></a>6. 性能分析与优化</h2><h3 id="Exlain查询执行计划"><a href="#Exlain查询执行计划" class="headerlink" title="Exlain查询执行计划"></a>Exlain查询执行计划</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> </span><br><span class="line">								id</span><br><span class="line">								,name</span><br><span class="line">								,addr</span><br><span class="line">				<span class="keyword">from</span>		t1</span><br><span class="line">        <span class="keyword">where</span>		t1.id <span class="operator">=</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>通过在sql前面添加explain关键字即可查询sql的执行计划</p>
<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com%2Fjpg%2F6dd68b173df7809bc8dc27a30937a22d.jpg%3Fx-oss-process%3Dimage%2Fresize%2Cp_100%2Fauto-orient%2C1%2Fquality%2Cq_90%2Fformat%2Cjpg%2Fwatermark%2Cimage_eXVuY2VzaGk%3D%2Ct_100&refer=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1630634532&t=cc5ce4c5d99be9f2529373c3cd481029" alt="img"></p>
<p>如上图，sql的执行计划共有10个字段</p>
<ol>
<li><p><strong>id</strong></p>
<blockquote>
<p>表的查询顺序，需要越大表就越先被查询，相同id，表从上之下依次执行</p>
</blockquote>
</li>
<li><p><strong>select_type</strong></p>
<blockquote>
<p>查询类型：</p>
<p><strong>SIMPLE</strong>：不带有任何复杂查询</p>
<p><strong>PRIMARY</strong>：查询中若包含任何复杂的子部分，最外层查询则被标记为PRIMARY</p>
<p><strong>SUBQUERY</strong>：在select或where列表中包含了子查询</p>
<p><strong>DERIVED</strong>衍生：在from列表中包含的子查询标记为DERIVEN（MySql会递归执行这些子查询，把结果放在临时表里）</p>
<p><strong>UNION</strong>：若第二个select出现在union之后，则被标记为UNION</p>
<p>​                若UNION包含在from子句的子查询中，外层select将被标记为：DERIVED</p>
<p><strong>UNION RESULT</strong>：从UNION表获取结果的select</p>
</blockquote>
</li>
<li><p><strong>table</strong></p>
<ul>
<li>显示这一行数据是关于哪张表的</li>
</ul>
</li>
<li><p><strong>type</strong></p>
<blockquote>
<p><strong>查询的访问类型</strong></p>
<p>常见的访问类型：system–const–eq_ref–ref–range–index–ALL</p>
<ol>
<li><strong>System</strong>:表中只有一行记录，这是const类型的特例</li>
<li><strong>const</strong>：表示通过索引一次就找到了，const用于比较primary key 或者unique索引，因为只匹配一行数据，所以很快</li>
<li><strong>eq_ref</strong>：唯一性索引扫描，对于每个索引键，表中只用一条记录与之匹配。常见于主键或唯一性索引</li>
<li><strong>ref</strong>：非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问。</li>
<li><strong>range</strong>：指索引给定范围的行，使用一个索引来选择行；between、&lt;、&gt;和in等的查询</li>
<li><strong>index</strong>：出现index是sql使用了索引但是没有通过索引进行过滤，一般是使用了覆盖索引或者利用索引进行排序，分组等。</li>
<li><strong>ALL</strong>：全表扫描</li>
</ol>
<p>index 与 ALL的区别：都是全表扫描，但是index遍历的只有索引树，而ALL是从硬盘中读取全部的表数据，前者的速度要快于后者。</p>
</blockquote>
<p>一般情况下，查询至少达到range级别，最好达到ref级别</p>
<ol start="5">
<li><p><strong>possible_keys</strong></p>
<blockquote>
<p>显示可能应用在这张表中的索引，一个或者多个</p>
<p>查询涉及到的字段若存在索引，该索引将被列出</p>
<p><strong>但是不一定被查询实际使用</strong></p>
</blockquote>
</li>
<li><p><strong>key</strong></p>
<blockquote>
<p>实际使用的索引。如果为NULL，则没有使用索引</p>
<p>查询中若使用了覆盖索引，则该索引仅出现在key列表中</p>
</blockquote>
</li>
<li><p><strong>key_len</strong></p>
<blockquote>
<p>表示索引中使用的字节数，通过该列计算查询中使用的索引长度，在不损失精确性的情况下，长度越短越好。</p>
<p>key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的。</p>
</blockquote>
</li>
<li><p><strong>ref</strong></p>
<blockquote>
<p>显示索引的哪一列被使用了，如果可能的话，是一个常数，哪些列或常量被用于查找索引列上的值</p>
</blockquote>
</li>
<li><p><strong>rows</strong></p>
<blockquote>
<p>根据表统计信息即索引选取情况，大致估算出找到所需的记录所需要读取的行数</p>
</blockquote>
</li>
<li><p><strong>Extra</strong></p>
<ol>
<li><strong>using filesort</strong><ul>
<li>说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取</li>
<li>mysql中无法利用索引完成的排序操作称为：“文件排序”</li>
</ul>
</li>
<li><strong>using temporary</strong><ul>
<li>使用了临时表保存中间结果，mysql在对查询结果排序时，使用临时表。常见于排序order by和分组查询group by</li>
</ul>
</li>
<li><strong>using index</strong><ul>
<li>using index表示相应的select操作中使用了覆盖索引，避免访问了表的数据行，效率不错！</li>
<li>如果同时出现using where，表名索引被用来执行索引键值的查找；如果没有同时出现using where，表名索引只是用来读取数据而非利用索引执行查找</li>
<li>利用索引进行了排序或者查找</li>
</ul>
</li>
<li><strong>using where</strong></li>
<li><strong>using join buffer</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="7-Mysql主从复制-amp-集群"><a href="#7-Mysql主从复制-amp-集群" class="headerlink" title="7. Mysql主从复制 &amp; 集群"></a>7. Mysql主从复制 &amp; 集群</h2><h3 id="7-1-MySql主从复制"><a href="#7-1-MySql主从复制" class="headerlink" title="7.1 MySql主从复制"></a>7.1 MySql主从复制</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44617722/article/details/111996883">docker 搭建mysql主从复制</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/felix-h/p/11072743.html">mysql授权用户</a></p>
<p>MySQL主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点。</p>
<p>MySQL主从复制默认采用异步复制方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据，或者特定的表。</p>
<p><strong>Mysql主从复制原理</strong></p>
<ol>
<li>master服务器将数据的改变记录到二进制日志binlog日志，当master上的数据发生改变时，则将其改变写入二进制日志中；</li>
<li>slave服务器会在一定时间间隔内对master二进制日志进行探测其是否发生改变，如果发生改变，则开始一个I/O Thread请求master二进制事件。</li>
<li>同时主节点为每个I/O线程启动一个dump线程，用于向其发送二进制事件，并保存至从节点本地的<strong>中继日志中（relay log）</strong>，从节点将启动SQL线程从中继日志中读取二进制日志，在本地重放，似的其数据和主节点的保持一致，最后I/O Thread和SQL Thread将进入睡眠，等待下一下被唤醒。</li>
</ol>
<ul>
<li>从库会生成两个线程：一个I/O线程，一个SQL线程</li>
<li>I/O线程会去请求主库的binlog，并将得到的binlog写到本地的relay-log（中继日志）文件中</li>
<li>主库会生成一个log dump线程，用来给从库I/O线程传binlog；</li>
<li>SQL线程会读取relay log文件中的日志，并解析成sql语句逐一执行；</li>
</ul>
<p><strong>注意</strong></p>
<ol>
<li>master将操作语句记录到binlog日志中，然后授予slave远程连接的权限（master一定要开启binlog二进制日志功能；通常为了数据安全考虑，slave也开启binlog功能）。</li>
<li>slave开启两个线程：IO线程和SQL线程。其中：IO线程负责读取master的binlog内容到中继日志relay log里；SQL线程负责从relay log日志里读出binlog内容，并更新到slave的数据库里，这样就能保证slave数据和master数据保持一致了。 </li>
<li>Mysql复制至少需要两个Mysql的服务，当然Mysql服务可以分布在不同的服务器上，也可以在一台服务器上启动多个服务。</li>
<li>Mysql复制最好确保master和slave服务器上的Mysql版本相同（如果不能满足版本一致，那么要保证master主节点的版本低于slave从节点的版本）</li>
<li>master和slave两节点间时间需同步</li>
</ol>
<p><img src="https://pic3.zhimg.com/80/v2-cf37bafd8a121454b5488c53ff2e0b2e_1440w.jpg" alt="img"></p>
<p>具体细节</p>
<ol>
<li>从库通过手工执行change master to 语句连接主库，提供了连接的用户一切条件（user 、password、port、ip），并且让从库知道，二进制日志的起点位置（file名 position 号）； start slave</li>
<li>从库的IO线程和主库的dump线程建立连接。</li>
<li>从库根据change master to 语句提供的file名和position号，IO线程向主库发起binlog的请求。</li>
<li>主库dump线程根据从库的请求，将本地binlog以events的方式发给从库IO线程。</li>
<li>从库IO线程接收binlog events，并存放到本地relay-log中，传送过来的信息，会记录到<a href="https://link.zhihu.com/?target=http://master.info">master.info</a>中</li>
<li>从库SQL线程应用relay-log，并且把应用过的记录到<a href="https://link.zhihu.com/?target=http://relay-log.info">relay-log.info</a>中，默认情况下，已经应用过的relay 会自动被清理purge</li>
</ol>
<p><strong>主从复制优缺点</strong></p>
<ul>
<li>读写分离：一主多从，主写，从读，分散压力。</li>
<li>缺点<ul>
<li>数据库服务存在单点故障（主库所在机器可能宕机）</li>
<li>数据库服务器资源无法满足增长的读写请求</li>
<li>高峰时数据库连接数经常超过上线</li>
<li>同步机制为<strong>异步</strong></li>
</ul>
</li>
</ul>
<h3 id="7-2-Mysql集群"><a href="#7-2-Mysql集群" class="headerlink" title="7.2 Mysql集群"></a>7.2 Mysql集群</h3><h2 id="8-补充"><a href="#8-补充" class="headerlink" title="8. 补充"></a>8. 补充</h2><h3 id="8-1-SQL的生命周期"><a href="#8-1-SQL的生命周期" class="headerlink" title="8.1 SQL的生命周期"></a>8.1 SQL的生命周期</h3><img src="https://github.com/xiaowodi/Resources/blob/main/images/gitImages/Mysql%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84.png?raw=true" alt="Mysql基本架构.png" style="zoom:30%;" />





<ol>
<li><p>首先客户端向服务器提交要执行的SQL；</p>
<p>客户端需要通过<strong>连接器</strong>连接到<strong>Server</strong>，并验证这个客户端的权限等</p>
</li>
<li><p>连接建立完成后，就可以执行sql，执行逻辑的第二步就是要<strong>查询缓存</strong>，如果缓存中有之前查询的结果，就直接返回给客户端。（缓存中类似于Key-Value的形式）</p>
</li>
<li><p>如果缓存没有命中，接下来就需要<strong>分析器</strong>，经过<em>词法分析</em>，<em>语法分析</em>，来分析这个sql语句是否符合sql语法规范。</p>
</li>
<li><p>对于可以执行的sql要经过<strong>优化器</strong>进行优化</p>
</li>
<li><p>优化后的sql就会到<strong>执行器</strong>中，执行这个sql逻辑</p>
<ul>
<li>开始执行的时候，要先判断一下客户端对这个表有没有执行查询的权限，如果没有，就会返回权限错误。</li>
<li>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</li>
</ul>
</li>
</ol>
<h1 id="Hadoop复习"><a href="#Hadoop复习" class="headerlink" title="Hadoop复习"></a>Hadoop复习</h1><h2 id="1-分布式文件存储系统HDFS"><a href="#1-分布式文件存储系统HDFS" class="headerlink" title="1. 分布式文件存储系统HDFS"></a>1. 分布式文件存储系统HDFS</h2><h3 id="1-1-HDFS的机架感知策略"><a href="#1-1-HDFS的机架感知策略" class="headerlink" title="1.1 HDFS的机架感知策略"></a>1.1 HDFS的机架感知策略</h3><ul>
<li>机架：存放服务器的架子，也叫机柜。一般来说一个机房有很多机柜，每个机柜有很多服务器</li>
</ul>
<p><strong>副本存放策略</strong></p>
<p>HDFS分布式文件系统的内部有一个副本存放策略：以默认的副本数=3为例：</p>
<ol>
<li>第一个副本块存本机</li>
<li>第二个副本块存放在跟本机同机架内的其他服务器节点</li>
<li>第三个副本块存放在不同于本机架的一个服务器节点上</li>
</ol>
<p>==好处：==</p>
<ol>
<li>如果本机数据损坏或者丢失，那么客户端可以从同机架的相邻节点获取数据，速度肯定要比跨机架获取数据要快。</li>
<li>如果本机所在的机架出现问题，那么之前在存储的时候没有把所有副本都放在一个机架内，这就能保证数据的安全性，此种情况出现，就能保证客户端也能取到数据。</li>
</ol>
<p>HDFS为了降低整体的网络带宽消耗和读取延时，HDFS集群一定会让客户端尽量去读取近的副本，那么按照以上解释的副本存放策略：</p>
<ol>
<li>如果在本机有数据，那么直接读取；</li>
<li>如果在跟本机同机架的服务器节点中有该数据块，则直接读取</li>
<li>如果该HDFS集群跨多个数据中心，那么客户端也一定会优先读取本数据中心的数据。</li>
</ol>
<p>但是HDFS是如何确定两个节点是否属于同一个机架，如何确定不同服务器跟客户端的远近呢？那就是<strong>机架感知</strong></p>
<h3 id="1-2-NameNode-amp-DataNode-amp-Secondary-NameNode"><a href="#1-2-NameNode-amp-DataNode-amp-Secondary-NameNode" class="headerlink" title="1.2 NameNode &amp; DataNode &amp; Secondary NameNode"></a>1.2 <strong>NameNode &amp; DataNode &amp; Secondary NameNode</strong></h3><p>整个HDFS集群由Namenode和Datanode构成master-worker（主从）模式。Namenode负责构建命名空间，管理文件的元数据等，而Datanode负责实际存储数据，负责读写工作。</p>
<h4 id="NameNode"><a href="#NameNode" class="headerlink" title="NameNode"></a><strong>NameNode</strong></h4><p>NameNode存放文件系统树以及所有文件、目录的元数据。</p>
<p>元数据持久化为2种形式：</p>
<ul>
<li>namespace image</li>
<li>edit log</li>
</ul>
<p>在HDFS中，Namenode可能成为集群的单点故障，Namenode不可用时，整个文件系统是不可用的。HDFS针对单点故障提供了2种解决机制：<br>1）<strong>备份持久化元数据</strong><br>将文件系统的元数据同时写到多个文件系统， 例如同时将元数据写到本地文件系统及NFS。这些备份操作都是同步的、原子的。</p>
<p>2）<strong>Secondary Namenode</strong><br>Secondary节点定期合并主Namenode的namespace image和edit log， 避免edit log过大，通过创建检查点checkpoint来合并。它会维护一个合并后的namespace image副本， 可用于在Namenode完全崩溃时恢复数据。</p>
<p>Secondary Namenode通常运行在另一台机器，因为合并操作需要耗费大量的CPU和内存。其数据落后于Namenode，因此当Namenode完全崩溃时，会出现数据丢失。 通常做法是拷贝NFS中的备份元数据到Second，将其作为新的主Namenode。<br>在HA（High Availability高可用性）中可以运行一个Hot Standby，作为热备份，在Active Namenode故障之后，替代原有Namenode成为Active Namenode。</p>
<h4 id="1-3-SecondaryNameNode工作原理"><a href="#1-3-SecondaryNameNode工作原理" class="headerlink" title="1.3 SecondaryNameNode工作原理"></a>1.3 <strong>SecondaryNameNode工作原理</strong></h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010848845/article/details/118491365">别扯了，Secondary NameNode工作原理就看这家</a></p>
<p><img src="https://img-blog.csdnimg.cn/20210705153740561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA4NDg4NDU=,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>1 ）<strong>第一阶段： NameNode 启动</strong></p>
<p>（ 1 ）第一次启动 NameNode 格式化后，创建 Fsimage 和 Edits 文件。如果不是第一次启动，直接加载编辑日志和镜像文件到内存。<br>（ 2 ）客户端对元数据进行增删改的请求。<br>（ 3 ） NameNode 记录操作日志，更新滚动日志。<br>（ 4 ） NameNode 在内存中对元数据进行增删改。</p>
<p>2 ）<strong>第二阶段： Secondary NameNode 工作</strong></p>
<p>（ 1 ） Secondary NameNode 询问 NameNode 是否需要 CheckPoint 。直接带回 NameNode<br>是否检查结果。<br>（ 2 ） Secondary NameNode 请求执行 CheckPoint 。<br>（ 3 ） NameNode 滚动正在写的 Edits 日志。<br>（ 4 ）将滚动前的编辑日志和镜像文件拷贝到 Secondary NameNode 。<br>（ 5 ） Secondary NameNode 加载编辑日志和镜像文件到内存，并合并。<br>（ 6 ）生成新的镜像文件 fsimage.chkpoint 。<br>（ 7 ）拷贝 fsimage.chkpoint 到 NameNode 。<br>（ 8 ） NameNode 将 fsimage.chkpoint 重新命名成 fsimage 。</p>
<h3 id="1-4-DataNode"><a href="#1-4-DataNode" class="headerlink" title="1.4 DataNode"></a>1.4 DataNode</h3><p>数据节点负责存储和提取Block，读写请求可能来自nameNode，也可能直接来自客户端。数据节点周期性向NameNode汇报自己节点上所有存储的BLock相关信息。</p>
<h3 id="1-5-HDFS-设计目标"><a href="#1-5-HDFS-设计目标" class="headerlink" title="1.5 HDFS 设计目标"></a>1.5 HDFS 设计目标</h3><ul>
<li>存储非常大的文件</li>
<li>采用流式的数据访问方式</li>
</ul>
<p><strong>不适合的应用类型：</strong></p>
<ul>
<li>低延时的数据访问<ul>
<li>对延时要求在毫秒级别的应用，不适合采用HDFS。</li>
</ul>
</li>
<li>大量小文件<ul>
<li>文件的元数据（如目录结构，文件block的节点列表，block-node mapping）保存在NameNode的内存中，整个文件系统的文件数量会受限于NameNode的内存大小。</li>
</ul>
</li>
<li>多方读写，需要任意的文件修改<ul>
<li>HDFS采用追加的方法写入数据，不支持文件任意offset修改。不支持多个写入器。</li>
</ul>
</li>
</ul>
<h3 id="1-6-HDFS的文件存储格式"><a href="#1-6-HDFS的文件存储格式" class="headerlink" title="1.6 HDFS的文件存储格式"></a>1.6 HDFS的文件存储格式</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wqbin/p/14635480.html">HDFS的文件存储格式</a></p>
<p>可分为<strong>行式存储</strong>和<strong>列式存储</strong>两大类。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6450093-0c5b3f7a2eceaaef.jpg" alt="img"></p>
<h4 id="行式存储"><a href="#行式存储" class="headerlink" title="行式存储"></a>行式存储</h4><p>同一行的数据存储在一起，即连续存储。例如：<code>SequenceFile</code>,  <code>MapFile</code>, <code>Avro</code>, <code>Datafile</code>等格式都是使用行式存储的。</p>
<p>如果只需要访问行的一小部分列数据，也需要将整行的数据读入内存。举个例子：一行中有十列的数据，取数的时候只需要取两列的数据，那么就需要把整个行中的所有数据都需要读取出来。</p>
<ul>
<li><strong>SequenceFile</strong></li>
<li><strong>MapFile</strong></li>
<li><strong>Avro</strong></li>
<li><strong>DataFile</strong></li>
</ul>
<h4 id="列式存储"><a href="#列式存储" class="headerlink" title="列式存储"></a>列式存储</h4><p>整个文件被切割为若干列数据，每一列数据一起存储。<code>Parquet</code>, <code>RCFile</code>, <code>ORCFile</code>.面对列式存储的数据，可以跳过不需要的列，适合于只处理行的一小部分字段的情况。但是这种格式的读写需要更多的内存空间，因为需要缓存行在内存中（为了获取多行中的某一列）。</p>
<p>同时不适合流失写入，因为一旦写入失败，当前文件无法恢复，而面对行的数据在写入失败时，可以重新同步到最后一个同步点。</p>
<ul>
<li><strong>Parquet</strong></li>
<li><strong>RCFile</strong></li>
<li><strong>ORCFile</strong></li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/6450093-dbe2595ee1e293b1.png" alt="img"></p>
<p>一般情况下，离线处理中的宽表会有很多的字段，而在进行分析的时候，只需要一小部分字段即可，所以实际生产中，列式存储的情况比较多。</p>
<p><strong>Parquet与ORC的对比</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly95cWZpbGUuYWxpY2RuLmNvbS9lOGI3ODEzNzIyMGM4OTUyOGVjZDA0NDY0NjJiZDI3Y2FmNGRmNTRkLnBuZw?x-oss-process=image/format,png" alt="image"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly95cWZpbGUuYWxpY2RuLmNvbS9iZTU0N2YxNGY3YmZhZGZlNGQyMjJkOTFhNDIyMTk4NmJkNzU3ZDk2LnBuZw?x-oss-process=image/format,png" alt="image"></p>
<p>小总结：ORC的压缩能力强，支持ACID，支持更新，删除等操作。但是嵌套式结构实现比较复杂。</p>
<h3 id="1-7-HDFS的读写流程"><a href="#1-7-HDFS的读写流程" class="headerlink" title="1.7 HDFS的读写流程"></a>1.7 HDFS的读写流程</h3><h4 id="1-7-1-HDFS-的-写流程"><a href="#1-7-1-HDFS-的-写流程" class="headerlink" title="1.7.1 HDFS 的 写流程"></a>1.7.1 HDFS 的 写流程</h4><p><img src="https://www.pianshen.com/images/782/2d5555fa9bb1b9bda4614b97abcc7d0e.png" alt="img"></p>
<p>客户端发起写请求到NameNode，NameNode返回可用的资源，客户端根据资源使用情况对要写入的数据分块，逐一上传块到DataNode，DataNode获取上传块数据并写入磁盘，完成后报告给NameNode块信息，同时也告诉客户端写入成功，客户端继续后续块的写入，在此期间NameNode接受到DataNode块写入完成信息之后备份数直到满。</p>
<ol>
<li>首先客户端发起写请求到NameNode，NameNode检查目录是否存在，父目录是否存在。</li>
<li>NameNode通知客户端是否可以上传</li>
<li>client长传时，先对文件进行分块，默认block为128M。client向NameNode请求第一个block需要传输到哪个DataNode上。</li>
<li>NameNode接受到请求，返回可用的DataNode。假设备份副本数为3，那么就返回三个可用的DataNode。（client同机器d1,同机架的另一台服务器的d2， 不同机架的另一台服务器的d3）</li>
<li>client请求一台DataNode建立block传输管道，第一个datanode接受到请求后会继续调用第二个datanode，然后第二个datanode调用第三个datanode，将整个pipeline建立完成，逐级返回客户端（这个过程是串联的）</li>
<li>三个datanode逐级应答客户端。</li>
<li>客户端开始往d1节点上传第一个block，然后上传到d2，接下来是d3</li>
<li>当第一个block传输完后，客户端再次请求namenode上传第二个接收的block的datanode节点，直到最后一个block上传完成为止。</li>
</ol>
<h4 id="1-7-2-HDFS-的-读流程"><a href="#1-7-2-HDFS-的-读流程" class="headerlink" title="1.7.2 HDFS 的 读流程"></a>1.7.2 HDFS 的 读流程</h4><p><img src="https://www.pianshen.com/images/955/28906ddfe55a52f88180366de7c6b3bb.png" alt="img"></p>
<p>客户端发起读请求到NameNode，NameNode返回可使用的DataNode，客户端根据返回的资源到对应的DataNode上读取块数据，客户端合并文件数据。</p>
<ol>
<li>client和namenode通信查询元数据（block所在的datanode节点），找到所在的datanode服务器</li>
<li>挑选一台datanode（就近原则，然后随机）服务器请求建立socket流</li>
<li>datanode发送数据，从磁盘读取数据放入流，以packet为单位来做校验。</li>
<li>客户端以packet为单位接收，先在本地缓存，然后写入目标文件，最后合并文件。</li>
</ol>
<h2 id="2-分布式计算框架MapReduce"><a href="#2-分布式计算框架MapReduce" class="headerlink" title="2. 分布式计算框架MapReduce"></a>2. 分布式计算框架MapReduce</h2><h3 id="2-1-MapReduce工作流程"><a href="#2-1-MapReduce工作流程" class="headerlink" title="2.1 MapReduce工作流程"></a>2.1 MapReduce工作流程</h3><h4 id="2-1-1-MapTask工作机制"><a href="#2-1-1-MapTask工作机制" class="headerlink" title="2.1.1 MapTask工作机制"></a>2.1.1 MapTask工作机制</h4><p><img src="https://img2020.cnblogs.com/blog/1748663/202007/1748663-20200726181803473-2052825806.png" alt="img"></p>
<ol>
<li><p><strong>MapTask</strong>收集Mapper中的map()方法每次输出的key-value值，放入到环形缓冲区中。</p>
<p>环形缓冲区默认大小<strong>100M</strong></p>
<p>环形缓冲区双向写入，一侧记录索引值，一侧记录真是的数据</p>
</li>
<li><p>环形缓冲区中的数据达到80%的时候，开始进行反向溢写</p>
</li>
<li><p>从缓冲区溢写出来的数据会根据<strong>分区器</strong>进行分区，且每个分区内，会通过<strong>快速排序</strong>，对key排序，保证每个分区中的数据是有序的。</p>
</li>
<li><p>接下来将缓冲区本次溢写出来的且分区内有序的数据落盘（多临时小文件），待数据都处理完后，多个溢出文件会被合并成大的溢出文件（这个过程通过<strong>归并排序</strong>，使得这个大的溢出文件内部也是有序的）。</p>
</li>
<li><p>如果MapTask开启了<strong>Combiner</strong>预聚合功能，那么在缓冲区溢出数据分区排序完之后，每个分区内会做一次预聚合的操作，将相同key的记录按照一定的规则进行聚合，然后落盘，合并。（开启预聚合功能可在一定程度上缓解数据倾斜带来的问题）</p>
</li>
<li><p>每个MapTask所在机器上都会输出对应的Map阶段的结果。</p>
</li>
</ol>
<h4 id="2-1-2-ReduceTask工作机制"><a href="#2-1-2-ReduceTask工作机制" class="headerlink" title="2.1.2 ReduceTask工作机制"></a>2.1.2 ReduceTask工作机制</h4><p><img src="https://img2020.cnblogs.com/blog/1748663/202007/1748663-20200726181824985-212928464.png" alt="img"></p>
<ol>
<li>每个<strong>ReduceTask</strong>从上阶段的各个MapTask所在机器上拷贝<strong>当前ReduceTask负责的分区数据</strong>到自己的缓冲区中（如果数据超过缓存区大小，则写到磁盘上）</li>
<li>对于来自多个MapTask上的数据进行<strong>归并排序</strong>，合并成一个文件，将具有相同key的数据排列在一起，这样就实现了按照key进行分组，也可称之为局部排序。</li>
<li>每组数据经过reduce()方法进行处理。</li>
<li>最终将计算结果写到HDFS上。</li>
</ol>
<h3 id="2-2-Shuffle机制"><a href="#2-2-Shuffle机制" class="headerlink" title="2.2 Shuffle机制"></a>2.2 Shuffle机制</h3><p><img src="https://img2020.cnblogs.com/blog/1748663/202007/1748663-20200726181459479-554913934.png" alt="img"></p>
<p>MapReduce整个Shuffle阶段横跨了MapTask和ReduceTask这两个任务阶段。</p>
<h2 id="3-集群资源管理器Yarn"><a href="#3-集群资源管理器Yarn" class="headerlink" title="3. 集群资源管理器Yarn"></a>3. 集群资源管理器Yarn</h2><h3 id="Yarn的基本架构"><a href="#Yarn的基本架构" class="headerlink" title="Yarn的基本架构"></a>Yarn的基本架构</h3><p><img src="https://img2020.cnblogs.com/blog/1748663/202007/1748663-20200726183159871-354972654.png" alt="img"></p>
<p>Yarn主要有ResourceManager、NodeManager、ApplicationMaster和Container等组件</p>
<ol>
<li><strong>ResourceManager</strong><ul>
<li>处理客户端请求</li>
<li>监控NodeManager</li>
<li>启动或监控ApplicationMaster</li>
<li>资源的分配与调度</li>
</ul>
</li>
<li><strong>NodeManager</strong><ul>
<li>管理单个节点上的资源</li>
<li>处理来自ResourceManager的命令</li>
<li>处理来自ApplicationMaster的命令</li>
</ul>
</li>
<li><strong>ApplicationMaster</strong><ul>
<li>负责数据的切分</li>
<li>为应用程序申请资源并分配给内部的任务</li>
<li>任务的监控与容错</li>
</ul>
</li>
<li><strong>Container</strong><ul>
<li>Container是Yarn中的资源抽象，它封装了某个节点上的多维资源，如内存，CPU，磁盘，网络等。</li>
</ul>
</li>
</ol>
<h3 id="Yarn工作机制"><a href="#Yarn工作机制" class="headerlink" title="Yarn工作机制"></a>Yarn工作机制</h3><p><img src="https://img2020.cnblogs.com/blog/1748663/202007/1748663-20200726183647821-1922505507.png" alt="img"></p>
<ol>
<li><font color=gree>作业提交</font><ol>
<li>Client调用job.waitForCompletion方法，向整个集群提交MapReduce作业。</li>
<li>Client会向RM申请一个<strong>Application</strong></li>
<li>RM给Client返回该job<strong>资源的提交路径</strong>和<strong>作业id</strong></li>
<li>Client提交<strong>jar包</strong>，<strong>切片信息</strong>和<strong>配置文件</strong>到指定的资源提交路径上。</li>
<li>Client提交完资源后，向RM申请运行<strong>ApplicationMaster</strong>。ApplicationMaster运行在刚刚申请的Container中。</li>
</ol>
</li>
<li><font color=gree>作业初始化</font><ol start="6">
<li>当RM收到Client的请求后，将请求封装成<strong>task</strong>，将该job添加到<strong>容量调度器中</strong></li>
<li>某个空闲的NM领取到该Job，创建Container，并产生<strong>ApplicationMaster</strong></li>
<li>下载Client提交的资源到NM本地</li>
</ol>
</li>
<li><font color=gree>任务分配</font><ol start="9">
<li><strong>ApplicationMaster</strong>向RM申请运行多个<strong>MapTask</strong>任务资源。</li>
<li>RM将运行<strong>MapTask</strong>任务分配给另外两个<strong>NodeManager</strong>，另外两个<strong>NodeManager</strong>分别领取到任务并创建容器。</li>
</ol>
</li>
<li><font color=gree>任务运行</font><ol start="11">
<li>AM向接收到任务的<strong>NodeManager</strong>发送程序启动脚本，这两个<strong>NodeManager</strong>分别启动<strong>MapTask</strong>，<strong>MapTask</strong>对数据分区排序。</li>
<li><strong>ApplicationMaster</strong>等待所有<strong>MapTask</strong>运行完毕后，向RM申请容器，运行ReduceTask</li>
<li><strong>ReduceTask</strong>向<strong>MapTask</strong>获取相应分区的数据。</li>
<li>程序运行完毕后，MR会向RM申请注销自己。</li>
</ol>
</li>
<li><font color=gree>进度和状态更新</font><ol start="15">
<li>Yarn中的任务将其进度和状态（包括counter）返回给应用管理器，客户端每秒向应用管理器请求进度更新，展示给用户。</li>
</ol>
</li>
<li><font color=gree>作业完成</font><ol start="16">
<li>除了向应用管理器请求作业进度外, 客户端每5秒都会通过调用waitForCompletion()来检查作业是否完成。时间间隔可以通过mapreduce.client.completion.pollinterval来设置。作业完成之后, 应用管理器和Container会清理工作状态。作业的信息会被作业历史服务器存储以备之后用户核查。</li>
</ol>
</li>
</ol>
<h2 id="4-补充"><a href="#4-补充" class="headerlink" title="4. 补充"></a>4. 补充</h2><h3 id="4-1-Hadoop中的常用端口号"><a href="#4-1-Hadoop中的常用端口号" class="headerlink" title="4.1 Hadoop中的常用端口号"></a>4.1 Hadoop中的常用端口号</h3><table>
<thead>
<tr>
<th>服务</th>
<th>节点名</th>
<th>默认端口</th>
<th>配置</th>
<th>说明</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>HDFS</td>
<td>NameNode</td>
<td>50070</td>
<td>dfs.namenode.http-address</td>
<td>NameNode Web UI端口</td>
<td></td>
</tr>
<tr>
<td>HDFS</td>
<td>NameNode</td>
<td>8020</td>
<td>fs.defaultFS</td>
<td>NameNode API连接默认端口</td>
<td></td>
</tr>
<tr>
<td>HDFS</td>
<td>NameNode</td>
<td>9870</td>
<td>fs.defaultFS</td>
<td>3.0版本后8020==&gt;9870</td>
<td></td>
</tr>
<tr>
<td>HDFS</td>
<td>DataNode</td>
<td>50010</td>
<td>dfs.datanode.address</td>
<td>DAataNode初始化时向NameNode发送心跳</td>
<td></td>
</tr>
<tr>
<td>HDFS</td>
<td>DataNode</td>
<td>50020</td>
<td>dfs.datanode.ipc.address</td>
<td>DataNode ipc服务器地址和端口</td>
<td></td>
</tr>
<tr>
<td>HDFS</td>
<td>DataNode</td>
<td>50075</td>
<td>dfs.datanode.http.address</td>
<td>DataNode http服务器地址和端口</td>
<td></td>
</tr>
<tr>
<td>HDFS</td>
<td>DataNode</td>
<td>50475</td>
<td>dfs.datanode.https.address</td>
<td>DataNode https服务器地址和端口</td>
<td></td>
</tr>
<tr>
<td>Yarn</td>
<td>ResourceManager</td>
<td>8088</td>
<td>yarn.resourcemanager.webapp.address</td>
<td>RM Web应用程序的http地址和端口</td>
<td></td>
</tr>
<tr>
<td>YARN</td>
<td>JobHistory Server</td>
<td>19888</td>
<td>mapreduce.jobhistory.webapp.address</td>
<td>MapReduce JobHistory服务器WebUI的IP和端口</td>
<td></td>
</tr>
</tbody></table>
<h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><h1 id="Spark复习"><a href="#Spark复习" class="headerlink" title="Spark复习"></a>Spark复习</h1><h2 id="1-Spark-Core"><a href="#1-Spark-Core" class="headerlink" title="1. Spark Core"></a>1. Spark Core</h2><h3 id="1-1-转换算子"><a href="#1-1-转换算子" class="headerlink" title="1.1 转换算子"></a>1.1 转换算子</h3><ol>
<li><p><code>map()</code></p>
<ul>
<li>一进一出，每来一个元素执行一次map中的逻辑</li>
</ul>
</li>
<li><p><code>mapPartitions()</code></p>
<ul>
<li>每个分区调用一次，会把每个分区中的元素包装成Iterator</li>
</ul>
</li>
<li><p><code>mapPartitionsWithIndex()</code></p>
<ul>
<li>带有分区信息的<code>mapPartitions()</code></li>
</ul>
</li>
<li><p><code>flatMap()</code></p>
<ul>
<li>功能与 map类似，但是可以将集合进行 扁平化，可实现一进多出的或者不出的map</li>
</ul>
</li>
<li><p><code>glom()</code></p>
<ul>
<li>将每个分区内的元素合并成一个数组</li>
</ul>
</li>
<li><p><code>groupBy(func)</code></p>
<ul>
<li>按照func返回的值进行分组，将对应的值放入一个迭代器中Iterable；</li>
</ul>
</li>
<li><p><code>filter(func)</code></p>
<ul>
<li>根据func返回的布尔值进行过滤</li>
</ul>
</li>
<li><p><code>sample(withReplacement, fraction, seed)</code></p>
<ul>
<li>以指定的随机种子抽样出比例为<code>fraction</code>的数据（抽取到的数是<code>size*fraction</code>）, 需要注意的是得到的结果并不能保证准确的比例。</li>
<li><code>withReplacement</code>表示时抽出的数据是否放回，（<code>true  or  false</code>）</li>
<li><code>seed</code>用于指定随机数生成器 种子。一般用默认的，或者传入的当前的时间戳。</li>
</ul>
</li>
<li><p><code>distinct()</code></p>
<ul>
<li> 对RDD中的元素执行去重操作。</li>
</ul>
</li>
<li><p><code>coalesce(numPartitions)</code></p>
<ul>
<li>缩减分区数到执行的数量，用哦关于大数据集过滤后，提高小数据集的执行效率</li>
</ul>
</li>
<li><p><code>replacePartition(numPartitions)</code></p>
<ul>
<li>重新分区，底层调用coalesce，但是会指定shuffle，而coalesce默认不会进行shuflle。</li>
</ul>
</li>
<li><p><code>sortBy(func,[ascending], [numTasks])</code></p>
<ul>
<li><p>使用func先对数据进行处理，按照处理后的结果进行排序，默认为升序。</p>
</li>
<li><p>```scala<br>rdd1.sortBy(x=&gt;x, false) # 按照x进行降序排序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">13. `pipe(command)`</span><br><span class="line"></span><br><span class="line">    - 把RDD中的每个元素通过管道的方式传递给shell脚本或命令。一个分区执行一次这个命令。</span><br><span class="line">    - `rdd1.pipe(&quot;/pipe&quot;)`</span><br><span class="line"></span><br><span class="line">14. 双Value型转换算则</span><br><span class="line"></span><br><span class="line">    1. 并集`union`</span><br><span class="line"></span><br><span class="line">       - rdd1.union(rdd2)</span><br><span class="line"></span><br><span class="line">    2. 差集`subtract(otherDataSet)`</span><br><span class="line"></span><br><span class="line">    3. 交集`intersection(otherDataset)`</span><br><span class="line"></span><br><span class="line">    4. 笛卡尔积`cartesian(otherDataset)`</span><br><span class="line"></span><br><span class="line">    5. 拉链`zip(otherDataSet)`</span><br><span class="line"></span><br><span class="line">       - 拉链操作，需要注意的是，在Spark中，两个RDD的元素的数量和分区数都必须相同，否则会抛出异常，其实质上就是要求每个分区的元素的数量相同。</span><br><span class="line"></span><br><span class="line">       - ```scala</span><br><span class="line">         scala&gt; val rdd1 = sc.parallelize(1 to 5)</span><br><span class="line">         rdd1: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[34] at parallelize at &lt;console&gt;:24</span><br><span class="line">         </span><br><span class="line">         scala&gt; val rdd2 = sc.parallelize(11 to 15)</span><br><span class="line">         rdd2: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[35] at parallelize at &lt;console&gt;:24</span><br><span class="line">         </span><br><span class="line">         scala&gt; rdd1.zip(rdd2).collect</span><br><span class="line">         res17: Array[(Int, Int)] = Array((1,11), (2,12), (3,13), (4,14), (5,15))</span><br><span class="line">         </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><strong>key-value型转换算子</strong></p>
<ol>
<li><code>reduceByKey(func, [numTasks])</code><ul>
<li>按照key进行聚合运算</li>
</ul>
</li>
<li><code>groupByKey()</code><ul>
<li>按照key进行分组</li>
</ul>
</li>
</ol>
<p><code>reduceByKey 与 groupByKey</code>的区别</p>
<ul>
<li>reduceByKey按照key进行聚合，在shuffle之前有combine（预聚合的操作），结果是RDD[K, V]</li>
<li>groupByKey按照key进行分组，直接进行shuffle，没有预聚合的操作。</li>
</ul>
<ol start="3">
<li><code>foldByKey</code>(默认为left)<ul>
<li>可以指定初始值的聚合操作</li>
<li>返回值的RDD类型与初始值类型保持一致</li>
</ul>
</li>
</ol>
<p>reduceByKey与foldByKey的聚合逻辑（分区内的聚合逻辑和分区间的聚合逻辑都是一致的）</p>
<ol start="4">
<li><p><code>aggregateByKey(zero)(seqOP, combOp,[numTasks])</code></p>
<ul>
<li>可以指定初始值，指定分区内的聚合逻辑和分区间的聚合逻辑</li>
<li><strong>但是初始值还是需要人为来指定，</strong></li>
</ul>
</li>
<li><p><code>combineByKey</code></p>
<ul>
<li><p>既可以动态指定零值，还可以指定分区内的聚合逻辑和分区间的聚合逻辑。</p>
</li>
<li><p>```scala<br>  /**</p>
<ul>
<li>Simplified version of combineByKeyWithClassTag that hash-partitions the resulting RDD using the</li>
<li>existing partitioner/parallelism level. This method is here for backward compatibility. It</li>
<li>does not provide combiner classtag information to the shuffle.</li>
<li></li>
<li>@see [[combineByKeyWithClassTag]]</li>
<li>/<br>def combineByKey[C](<br>  createCombiner: V =&gt; C,<br>  mergeValue: (C, V) =&gt; C,<br>  mergeCombiners: (C, C) =&gt; C): RDD[(K, C)] = self.withScope {<br>combineByKeyWithClassTag(createCombiner, mergeValue, mergeCombiners)(null)<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   - 一个函数是 根据第一个 元素的value的值进行初始值的设定；</span><br><span class="line"></span><br><span class="line">   - 一个函数是，定义分区内元素聚合逻辑；</span><br><span class="line"></span><br><span class="line">   - 一个函数是，定义分区间元素聚合逻辑。</span><br><span class="line"></span><br><span class="line">6. `sortByKey()`</span><br><span class="line">   </span><br><span class="line">   - 按照key值进行排序</span><br><span class="line">7. `cogroup`算子</span><br><span class="line">   </span><br><span class="line">   - cogroup算子 操作两个Key-Value形式的RDD， 最后将两个RDD合并成一个RDD，这个RDD的形式：RDD[(K, (Iterable[V], Iterable[W]))]</span><br><span class="line">   </span><br><span class="line">8. `join`</span><br><span class="line"></span><br><span class="line">   ```scala</span><br><span class="line">   import org.apache.spark.rdd.RDD</span><br><span class="line">   import org.apache.spark.&#123;SparkConf, SparkContext&#125;</span><br><span class="line">   </span><br><span class="line">   object Join &#123;</span><br><span class="line">   	def main(args: Array[String]): Unit = &#123;</span><br><span class="line">   		val conf = new SparkConf().setMaster(&quot;local[*]&quot;).setAppName(&quot;AggregateByKey&quot;)</span><br><span class="line">   		val sc = new SparkContext(conf)</span><br><span class="line">   		val rdd1: RDD[(Int, String)] = sc.parallelize(Array((1, &quot;a&quot;), (1, &quot;b&quot;), (2, &quot;c&quot;), (4, &quot;d&quot;)))</span><br><span class="line">   		val rdd2: RDD[(Int, String)] = sc.parallelize(Array((1, &quot;aa&quot;), (1, &quot;dd&quot;), (3, &quot;bb&quot;), (2, &quot;cc&quot;)))</span><br><span class="line">   		//TODO 1.内连接</span><br><span class="line">   		val rdd_join: RDD[(Int, (String, String))] = rdd1.join(rdd2)</span><br><span class="line">   		//TODO 2.左外连接</span><br><span class="line">   		val rdd_leftOuterJoin: RDD[(Int, (String, Option[String]))] = rdd1.leftOuterJoin(rdd2)</span><br><span class="line">   		//TODO 3.右外连接</span><br><span class="line">   		val rdd_rightOuterJoin: RDD[(Int, (Option[String], String))] = rdd1.rightOuterJoin(rdd2)</span><br><span class="line">   		//TODO 4.全外连接</span><br><span class="line">   		val rdd_fullOuterJoin: RDD[(Int, (Option[String], Option[String]))] = rdd1.fullOuterJoin(rdd2)</span><br><span class="line">   		println(rdd_join.collect().toList)</span><br><span class="line">   		println(rdd_leftOuterJoin.collect().toList)</span><br><span class="line">   		println(rdd_rightOuterJoin.collect().toList)</span><br><span class="line">   		println(rdd_fullOuterJoin.collect().toList)</span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   结果：</span><br><span class="line">   内连接：</span><br><span class="line">   List((1,(a,aa)), (1,(a,dd)), (1,(b,aa)), (1,(b,dd)), (2,(c,cc)))</span><br><span class="line">   左外连接：</span><br><span class="line">   List((1,(a,Some(aa))), (1,(a,Some(dd))), (1,(b,Some(aa))), (1,(b,Some(dd))), (2,(c,Some(cc))), (4,(d,None)))</span><br><span class="line">   右外连接：</span><br><span class="line">   List((1,(Some(a),aa)), (1,(Some(a),dd)), (1,(Some(b),aa)), (1,(Some(b),dd)), (2,(Some(c),cc)), (3,(None,bb)))</span><br><span class="line">   外连接（全外连接）：</span><br><span class="line">   List((1,(Some(a),Some(aa))), (1,(Some(a),Some(dd))), (1,(Some(b),Some(aa))), (1,(Some(b),Some(dd))), (2,(Some(c),Some(cc))), (3,(None,Some(bb))), (4,(Some(d),None)))</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="1-2-行动算子"><a href="#1-2-行动算子" class="headerlink" title="1.2 行动算子"></a>1.2 行动算子</h3><ol>
<li><code>collect()</code><ul>
<li>以数组的形式返回RDD中所有的元素</li>
</ul>
</li>
<li><code>count()</code><ul>
<li>n返回RDD中元素的个数</li>
</ul>
</li>
<li><code>take(n)</code><ul>
<li>返回RDD中前n个元素组成的数组</li>
</ul>
</li>
<li><code>first</code><ul>
<li>返回RDD中的第一个元素，类似于<code>take(1)</code></li>
</ul>
</li>
<li><code>takeOrder(n, [ordering])</code><ul>
<li>返回排序后的前n个元素，默认是升序排列</li>
</ul>
</li>
<li><code>foreach</code>与<code>foreachPartition</code><ul>
<li>foreach用一般用于与外部存储进行通讯， 这里的foreach与scala中的foreach函数是不同的，Spark中的foreach是在Executor中进行遍历的， 而不是Driver端。</li>
</ul>
</li>
<li><code>countByKey()</code><ul>
<li>统计每个key 的个数，底层是将key转换成(key,1)的形式</li>
</ul>
</li>
<li><code>reduce(func)</code><ul>
<li>通过func函数聚集RDD中的所有元素，先聚集分区内数据，再聚合分区间数据。</li>
</ul>
</li>
<li><code>fold(zero)(func)</code></li>
<li><code>aggregate(zero)(分区内逻辑，分区间逻辑)</code><ul>
<li>行动算子aggregate与转换算子aggregateByKey最大的区别在于，aggregate中的零值参与计算的次数不同，分区内会参与一次，分区间也会参与一次。</li>
</ul>
</li>
<li>各种saveAs…</li>
</ol>
<h2 id="2-RDD的依赖关系"><a href="#2-RDD的依赖关系" class="headerlink" title="2. RDD的依赖关系"></a>2. RDD的依赖关系</h2><ol>
<li>窄依赖</li>
<li>宽依赖</li>
</ol>
<h3 id="1-窄依赖"><a href="#1-窄依赖" class="headerlink" title="1. 窄依赖"></a>1. 窄依赖</h3><p><img src="https://img2.baidu.com/it/u=1912645117,1546810615&fm=15&fmt=auto&gp=0.jpg" alt="img"></p>
<p>父RDD中的一个分区，至多只有一个子RDD的分区使用。</p>
<h3 id="2-宽依赖"><a href="#2-宽依赖" class="headerlink" title="2. 宽依赖"></a>2. 宽依赖</h3><p><img src="https://img1.baidu.com/it/u=3492215315,2225793381&fm=26&fmt=auto&gp=0.jpg" alt="img"></p>
<p>父RDD中的一个分区，被子RDD的多个分区使用，这种依赖关系称为宽依赖。</p>
<p>会引起宽依赖的算子:<code>groupByKey</code>, <code>reduceByKey</code>, <code>join</code>,  <code>sortByKey</code></p>
<h3 id="3-Spark-Job的划分"><a href="#3-Spark-Job的划分" class="headerlink" title="3. Spark Job的划分"></a>3. Spark Job的划分</h3><p>Spark的应用程序都是懒加载的，每调用一个action算子之后，调度器就创建一个执行图和启动一个Spark Job，每个job由多个stage组成。每个stage由多个tasks组成。而task就表示每个并行计算，并且会在多个执行器上执行。</p>
<h4 id="job"><a href="#job" class="headerlink" title="job"></a>job</h4><p>Spark job 处于 Spark 执行层级结构中的最高层. 每个 Spark job 对应一个 action, 每个 action 被 Spark 应用中的驱动所程序调用.</p>
<p>可以把 Action 理解成把数据从 RDD 的数据带到其他存储系统的组件(通常是带到驱动程序所在的位置或者写到稳定的存储系统中)</p>
<p>只要一个 action 被调用, Spark 就不会再向这个 job 增加新的东西.</p>
<h4 id="stages"><a href="#stages" class="headerlink" title="stages"></a>stages</h4><p>从整体来看, 一个 stage 可以任务是“计算(task)”的集合, 这些每个“计算”在各自的 Executor 中进行运算, 而不需要同其他的执行器或者驱动进行网络通讯. 换句话说, 当任何两个 workers 之间开始需要网络通讯的时候, 这时候一个新的 stage 就产生了, 例如: shuffle 的时候.</p>
<p>这些创建 stage 边界的依赖称为 <em>ShuffleDependencies</em>. shuffle 是由宽依赖所引起的, 比如: sort, groupBy, 因为他们需要在分区中重新分发数据. 那些窄依赖的转换会被分到同一个 stage 中.</p>
<h4 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a>Tasks</h4><p>stage 由 tasks 组成. 在执行层级中, task 是最小的执行单位. 每一个 task 表现为一个本地计算.</p>
<p><strong>一个 stage 中的所有 tasks 会对不同的数据执行相同的代码.(程序代码一样, 只是作用在了不同的数据上)</strong></p>
<p>一个 task 不能被多个执行器来执行, 但是, 每个执行器会动态的分配多个 slots 来执行 tasks, 并且在整个生命周期内会并行的运行多个 task. 每个 stage 的 task 的数量对应着分区的数量, 即每个 Partition 都被分配一个 Task .</p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210808112547253.png" alt="image-20210808112547253"></p>
<p>在大多数情况下，每个stage的所有task在下一个stage开启之前必须全部完成。</p>
<h3 id="4-RDD的持久化"><a href="#4-RDD的持久化" class="headerlink" title="4. RDD的持久化"></a>4. RDD的持久化</h3><p>每碰到一个Action就会产生一个job，每个job开始计算的时候，总是从这个job最开始的RDD开始计算。</p>
<p>每个job总是从它血缘的开始计算，难免会有计算过程重复执行的情况。比如（中间过程产生了一些列的RDD，最终有两个action的时候，这两个action依赖同一个RDD，这样每次执行action的时候，就会重复计算）</p>
<p>如果整个RDD依赖的DAG图的血缘关系过长，就很可能出现分区数据损坏或丢失，则又要从头开始计算来达到容错的目的。</p>
<p><font color=red>每个 job 都会重新进行计算, 在有些情况下是没有必要, 如何解决这个问题呢?</font></p>
<p>Spark 一个重要能力就是可以持久化数据集在内存中. 当我们持久化一个 RDD 时, 每个节点都会存储它在内存中计算的那些分区, 然后在其他的 action 中可以重用这些数据. 这个特性会让将来的 action 计算起来更快(通常快 10 倍). 对于迭代算法和快速交互式查询来说, 缓存(<strong>Caching</strong>)是一个关键工具.</p>
<p>可以使用方法<code>persist()</code>或者<code>cache()</code>来持久化一个 RDD. 在第一个 action 会计算这个 RDD, 然后把结果的存储到他的节点的内存中. Spark 的 <code>Cache</code> 也是容错: 如果 RDD 的任何一个分区的数据丢失了, Spark 会自动的重新计算.</p>
<p>RDD 的各个 <code>Partition</code> 是相对独立的, 因此只需要计算丢失的部分即可, 并不需要重算全部 Partition</p>
<p>另外, 允许我们对持久化的 RDD 使用不同的存储级别.</p>
<p>例如: 可以存在磁盘上, 存储在内存中(堆内存中), 跨节点做复本.</p>
<p>可以给<code>persist()</code>来传递存储级别. <code>cache()</code>方法是使用默认存储级别(<code>StorageLevel.MEMORY_ONLY</code>)的简写方法.</p>
<p><strong>RDD的持久化级别</strong></p>
<table>
<thead>
<tr>
<th>Storage Level</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td><code>MEMORY_ONLY</code></td>
<td>Store RDD as  deserialized Java objects in the JVM. If the RDD does not fit in memory, some  partitions will not be cached and will be recomputed on the fly each time  they’re needed. This is the default level.</td>
</tr>
<tr>
<td><code>MEMORY_AND_DISK</code></td>
<td>Store RDD as  deserialized Java objects in the JVM. If the RDD does not fit in memory,  store the partitions that don’t fit on disk, and read them from there when  they’re needed.</td>
</tr>
<tr>
<td><code>MEMORY_ONLY_SER  </code>(Java and Scala)</td>
<td>Store RDD as <em>serialized</em> Java objects (one byte  array per partition). This is generally more space-efficient than  deserialized objects, especially when using a <a target="_blank" rel="noopener" href="http://spark.apache.org/docs/2.1.1/tuning.html">fast serializer</a>,  but more CPU-intensive to read.</td>
</tr>
<tr>
<td><code>MEMORY_AND_DISK_SER</code>  (Java and Scala)</td>
<td>Similar to  MEMORY_ONLY_SER, but spill partitions that don’t fit in memory to disk  instead of recomputing them on the fly each time they’re needed.</td>
</tr>
<tr>
<td><code>DISK_ONLY</code></td>
<td>Store the RDD  partitions only on disk.</td>
</tr>
<tr>
<td><code>MEMORY_ONLY_2</code>,  <code>MEMORY_AND_DISK_2</code>, etc.</td>
<td>Same as the  levels above, but replicate each partition on two cluster nodes.</td>
</tr>
<tr>
<td><code>OFF_HEAP</code>(experimental)</td>
<td>Similar to  MEMORY_ONLY_SER, but store the data in <a target="_blank" rel="noopener" href="http://spark.apache.org/docs/2.1.1/configuration.html#memory-management">off-heap   memory</a>. This requires off-heap memory to be enabled.</td>
</tr>
</tbody></table>
<p>有一点需要说明的是, 即使我们不手动设置持久化, Spark 也会自动的对一些 shuffle 操作的中间数据做持久化操作(比如: <code>reduceByKey</code>). 这样做的目的是为了当一个节点 <code>shuffle</code> 失败了避免重新计算整个输入. 当时, 在实际使用的时候, 如果想重用数据, 仍然建议调用 <code>persist</code> 或 <code>cache</code></p>
<h4 id="检查点checkpoint"><a href="#检查点checkpoint" class="headerlink" title="检查点checkpoint"></a>检查点checkpoint</h4><p>Spark 中对于数据的保存除了持久化操作之外，还提供了一种检查点的机制,检查点（本质是通过将RDD写入Disk做检查点）是为了通过 Lineage 做容错的辅助</p>
<p><strong>Lineage 过长会造成容错成本过高</strong>，这样就不如在中间阶段做检查点容错，如果之后有节点出现问题而丢失分区，从做检查点的 RDD 开始重做 Lineage，就会减少开销。</p>
<p>检查点通过将数据写入到 HDFS 文件系统实现了 RDD 的检查点功能。</p>
<p>为当前 RDD 设置检查点。该函数将会创建一个二进制的文件，并存储到 checkpoint 目录中，该目录是用 SparkContext.setCheckpointDir()设置的。在 checkpoint 的过程中，该RDD 的所有依赖于父 RDD中 的信息将全部被移除。</p>
<p>对 RDD 进行 checkpoint 操作并不会马上被执行，必须执行 Action 操作才能触发, 在触发的时候需要对这个 RDD 重新计算.</p>
<h4 id="持久化与checkpoint的区别"><a href="#持久化与checkpoint的区别" class="headerlink" title="持久化与checkpoint的区别"></a>持久化与checkpoint的区别</h4><ol>
<li>持久化只是将数据保存在BlockManager中，而RDD的Lineage是不变的。但是<code>checkpoint</code>执行完后，RDD已经没有之前所谓的依赖RDD了，而只有一个强行为其设置的<code>checkpoint</code>，RDD的Lineage改变了。</li>
<li>持久化的数据丢失可能性更大，磁盘，内存都有可能存在数据丢失的情况。但是<code>checkpoint</code>的数据通常是存储在如<strong>HDFS等容错、高可用的文件系统，数据丢失的可能性较小。</strong></li>
<li> <strong>注意:</strong> 默认情况下，如果某个 RDD 没有持久化，但是设置了checkpoint，会存在问题. 本来这个 job 都执行结束了，但是由于中间 RDD 没有持久化，checkpoint job 想要将 RDD 的数据写入外部文件系统的话，需要全部重新计算一次，再将计算出来的 RDD 数据 checkpoint到外部文件系统。 所以，<strong>建议对 checkpoint()的 RDD 使用持久化, 这样 RDD 只需要计算一次就可以了</strong>.</li>
</ol>
<h2 id="3-Key-Value类型RDD的数据分区器"><a href="#3-Key-Value类型RDD的数据分区器" class="headerlink" title="3. Key-Value类型RDD的数据分区器"></a>3. Key-Value类型RDD的数据分区器</h2><h3 id="3-1-HashPartitioner"><a href="#3-1-HashPartitioner" class="headerlink" title="3.1 HashPartitioner"></a>3.1 HashPartitioner</h3><p>对于给定的key，计算key的hashCode，并除以分区的个数取余，最后返回值就是这个key所属的分区的ID</p>
<p><strong>HashPartitioner的弊端</strong>： 可能导致每个分区中的数据量不均匀。容易出现数据倾斜。</p>
<h3 id="3-2-RangePartitioner范围分区器"><a href="#3-2-RangePartitioner范围分区器" class="headerlink" title="3.2 RangePartitioner范围分区器"></a>3.2 RangePartitioner范围分区器</h3><p>是将一定范围内的数据映射到某一个分区内，尽量保证每个分区中数据量的均匀，而且分区与分区之间是有序的，一个分区中的元素肯定都是比另一个分区内的元素小或者大。但是分区内的元素是不能保证顺序的。简单的说就是将一定范围内的数映射到某一个分区内。实现过程为：</p>
<ol>
<li>先从整个RDD中抽取样本数据（每个分区都要进行抽样），将样本数据排序，计算出每个分区的最大key值，形成一个Array[KEY]类型的数组变量rangeBounds（边界数组）。</li>
<li>判断key在rangeBounds中所处的范围，给出该key值在下一个RDD中的分区id的下标；该分区器要求RDD中的KEY类型必须是可以排序的。</li>
</ol>
<p><strong>范围分区器的核心</strong>：</p>
<ul>
<li>蓄水池抽样算法</li>
<li>边界数组</li>
<li>分区号的计算</li>
</ul>
<p><strong>蓄水池抽样算法：</strong></p>
<p>给定一个数据流，数据流长度N很大，且N知道处理完所有数据之前都不可知，请问如何在只遍历一遍数据（O(N)）的情况下，能够随机选取出m个不重复的数据。</p>
<p>核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] reservoir = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line"><span class="comment">//init, 先读取前m个数据</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">    reservoir[i] = dataStream[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接下来处理剩余数据</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=m;i&lt;dataStream.length;i++)&#123;</span><br><span class="line">    <span class="comment">// 先获取一个[0,i]内的随机整数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> rand.nextInt(i+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//如果随机整数落在了[0, m-1]范围内，则替换蓄水池中的元素</span></span><br><span class="line">    <span class="keyword">if</span>(d&lt;m)&#123;</span><br><span class="line">        reservoir[d] = dataStream[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>边界数组RangeBounds</strong></p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Mjc2ODM1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>假设一个数组中有4个元素，且有序。例如上图中的10,30,50,70。<br>那么根据这个数组中的4个元素，我们可以划分出5个区间：</p>
<blockquote>
<p>0：小于10<br>        1：10-30<br>        2：30-50<br>        3：50-70<br>        4：大于70</p>
</blockquote>
<p>这样，我们就分出了5个相应的分区。这样的数组我们就叫它为边界数组。<br>一个边界数组中的元素<strong>必须是有序的</strong>，因此在RangePartitioner范围分区内需要对边界数组进行排序。<br>其 <strong>边界数组长度+1 = 最后的分区数</strong></p>
<p><strong>分区号的计算</strong></p>
<ol>
<li>边界数组的长度小于等于128<ul>
<li>这个时候，每来一个key，轮询的方式遍历数组中的每个元素，然后确定分区号</li>
</ul>
</li>
<li>边界数组的长度大于128的时候<ul>
<li>通过<strong>二分查找</strong>来快速定位分区号。</li>
</ul>
</li>
</ol>
<h2 id="4-共享变量"><a href="#4-共享变量" class="headerlink" title="4. 共享变量"></a>4. 共享变量</h2><p>正常情况下，传递给spark算子的（比如map，reduce等）的函数都是在远程的集群节点上执行，函数中用到的所有变量都是独立的拷贝。这些变量被拷贝到集群上的每个节点上 ，这些变量的更改不会传递回驱动程序。</p>
<p>但是Spark提供了两个可以跨task的共享变量：</p>
<ul>
<li>累加器</li>
<li>广播变量</li>
</ul>
<h4 id="累加器"><a href="#累加器" class="headerlink" title="累加器"></a>累加器</h4><p>累加器用来对信息进行聚合，通常在向 Spark 传递函数时，比如使用 map() 函数或者用 filter() 传条件时，可以使用驱动器程序中定义的变量，但是集群中运行的每个任务都会得到这些变量的一份新的副本，所以更新这些副本的值不会影响驱动器中的对应变量。</p>
<p>如果我们想实现所有分片处理时更新共享变量的功能，那么累加器可以实现我们想要的效果。</p>
<p>累加器是一种变量, 仅仅支持“add”, 支持并发. 累加器用于去实现计数器或者求和. Spark 内部已经支持数字类型的累加器, 开发者可以添加其他类型的支持.</p>
<ol>
<li>内置累加器<code>sc.LongAccumulator</code></li>
<li>自定义累加器<code>继承AccumulatorV2</code></li>
</ol>
<h4 id="广播变量"><a href="#广播变量" class="headerlink" title="广播变量"></a>广播变量</h4><p>广播变量是在每个节点上保存一个只读的变量缓存，而不用给每个task来传一个copy。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> broadcastVar = sc.broadcast(<span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">broadcastVar: org.apache.spark.broadcast.<span class="type">Broadcast</span>[<span class="type">Array</span>[<span class="type">Int</span>]] = <span class="type">Broadcast</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; broadcastVar.value</span><br><span class="line">res0: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li><p>通过对一个类型T的对象调用SparkContext.broadcast创建出一个Broadcast[T]对象。任何可序列化的类型都可以这么实现。</p>
</li>
<li><p>通过value属性访问该对象的值(在Java中为value()方法)。</p>
</li>
<li><p>变量只会被发到各个节点一次，应作为只读值处理(修改这个值不会影响到别的节点)</p>
</li>
</ol>
<h2 id="2-SparkSQL"><a href="#2-SparkSQL" class="headerlink" title="2. SparkSQL"></a>2. SparkSQL</h2><p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Mjc2ODM1,size_16,color_FFFFFF,t_70#pic_center-16284015946612" alt="在这里插入图片描述"></p>
<h3 id="RDD，-DataFrame和DataSet之间的关系"><a href="#RDD，-DataFrame和DataSet之间的关系" class="headerlink" title="RDD， DataFrame和DataSet之间的关系"></a>RDD， DataFrame和DataSet之间的关系</h3><p>在SparkSQL中，Spark为我们提供了两个新的抽象，分别是DataFrame和DataSet。</p>
<p>RDD (Spark1.0) —&gt; Dataframe(Spark1.3) —&gt; Dataset(Spark1.6)</p>
<p>同样的数据得到这三种不同的数据结构，经过计算得到的结果相同，但是执行效率和执行方式不同。</p>
<h4 id="RDD，DataFrame和DataSet三者的共性"><a href="#RDD，DataFrame和DataSet三者的共性" class="headerlink" title="RDD，DataFrame和DataSet三者的共性"></a>RDD，DataFrame和DataSet三者的共性</h4><ol>
<li>RDD、DataFrame、DataSet全都是Spark平台下的分布式弹性数据集，为处理超大型数据提供便利。</li>
<li>三者都是惰性机制，在进行创建、转换，如map方法时，不会立即执行，只有在遇到Action如foreach时，三者才会开始遍历运算。</li>
<li>三者都会根据Spark的内存情况自动缓存运算，这样即使数据量跟大，也不会担心内存溢出。</li>
<li>三者都有partition的概念</li>
<li>三者有许多共同的函数，如map，filter，排序等。</li>
<li>在对Dataframe和DataSet进行操作许多操作都需要**<code>import spark.implicits._</code>**这个包的支持</li>
<li>DataFrame和DataSet均可使用模式匹配获取各个字段的值和类型。</li>
</ol>
<h4 id="三者的区别"><a href="#三者的区别" class="headerlink" title="三者的区别"></a>三者的区别</h4><p><strong>RDD</strong></p>
<ol>
<li>RDD一般和spark mlib同时使用</li>
<li>RDD不支持sparkSql操作</li>
</ol>
<p><strong>DataFrame</strong></p>
<ol>
<li>与RDD和DataSet不同，DataFrame每一行的类型固定为Row，每一列的值没法直接访问，只有通过解析才能获取各个字段的值。</li>
<li>DataFrame与DataSet一般不与spark mlib同时使用</li>
<li>DataFrame与DataSet均支持SparkSql的操作，比如select， groupby之类，还能注册临时表/视图，进行sql语句操作</li>
<li>DataFrame与DataSet支持一些特别方便的保存方式，比如保存csv，可以带上表头，这样每一列的字段名一目了然</li>
</ol>
<p><strong>DataSet</strong></p>
<p>DataSet和DataFrame拥有完全相同的成员函数，区别只是每一行的数据类型不同。DataFrame其实是DataSet的一个特例。<br>DataFrame也可以叫DataSet[Row]，每一行的类型都是Row，不解析，每一行究竟有哪些字段，各个字段又是什么类型都无从得知，只能用上面的getAs方法或者模式匹配拿住特定的字段。而DataSet中，每一行是什么类型是不一定的，在自定义了case class之后可以很自由的获得每一行的信息。</p>
<h3 id="Spark-on-Hive-与-Hive-on-Spark"><a href="#Spark-on-Hive-与-Hive-on-Spark" class="headerlink" title="Spark on Hive 与 Hive on Spark"></a><strong>Spark on Hive 与 Hive on Spark</strong></h3><ul>
<li>Spark on Hive通过Spark-SQL使用hive语句，操作hive，底层运行的还是spark rdd</li>
<li>Hive on Spark是把hive查询从mapreduce 的mr (Hadoop计算引擎)操作替换为spark rdd（spark 执行引擎） 操作。</li>
</ul>
<h3 id="Spark-SQL-Text-转化为实际的物理任务的流程"><a href="#Spark-SQL-Text-转化为实际的物理任务的流程" class="headerlink" title="Spark SQL Text 转化为实际的物理任务的流程"></a>Spark SQL Text 转化为实际的物理任务的流程</h3><p><img src="https://img-blog.csdnimg.cn/20200518170149838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E1Njg1MjYz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ol>
<li>SQL语句经过<strong>SqlParse（解析器）</strong>解析成<strong>Unresolved LogicalPlan</strong></li>
<li><strong>分析器Analyzer</strong>结合<strong>数据字典Catalog</strong>进行绑定，生成<strong>Resolved LogicalPlan</strong></li>
<li><strong>优化器Optimizer</strong>对<strong>Resolved LogicalPlan</strong>进行优化，生成优化后的<strong>Optimizer LogicalPlan</strong></li>
<li><strong>SparkPlan</strong>将上述的<strong>Optimizer LogicalPlan</strong>转换成<strong>PhysicPlan</strong></li>
<li>使用<strong>prepareForExecption</strong>将<strong>PhysicPlan</strong>转换成可执行的物理计划</li>
<li>使用<strong>execute()<strong>执行可执行的物理计划，生成</strong>DataFrame</strong></li>
</ol>
<h3 id="Spark-SQL-源码分析（version：Spark2-amp-amp-Spark3-1-2）"><a href="#Spark-SQL-源码分析（version：Spark2-amp-amp-Spark3-1-2）" class="headerlink" title="Spark SQL 源码分析（version：Spark2 &amp;&amp; Spark3.1.2）"></a>Spark SQL 源码分析（version：Spark2 &amp;&amp; Spark3.1.2）</h3><blockquote>
<p>补充时间：2022年4月30日</p>
<p>备注： 详细了解一下Spark SQL的部分关键源码，明白一条 SQL 语句是如何一步步转换成最终的RDD任务</p>
</blockquote>
<h4 id="前置知识：Antlr4-语法生成器工具"><a href="#前置知识：Antlr4-语法生成器工具" class="headerlink" title="前置知识：Antlr4 语法生成器工具"></a>前置知识：Antlr4 语法生成器工具</h4><p>Spark SQL内部是通过第三方插件Antlr进行SQL语句的语法分析的。在了解Spark SQL源码之前，首先要了解Antlr的相关知识。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/antlr/antlr4/blob/master/doc/index.md">Antlr4 GitHub doc地址</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/apache/spark/tree/master/sql/catalyst/src/main/antlr4/org/apache/spark/sql/catalyst/parser">Spark SQL中使用的SQL语法文件：sqlBase.g4文件</a></p>
<h4 id="Spark2源码分析"><a href="#Spark2源码分析" class="headerlink" title="Spark2源码分析"></a>Spark2源码分析</h4><p>Spark SQL模块在处理SQL时，内部是通过一个名为<code>Catalyst</code>的优化器（我更喜欢称之为：处理器）将SQL转换成最终的逻辑执行计划。</p>
<h2 id="3-Spark-内核"><a href="#3-Spark-内核" class="headerlink" title="3. Spark 内核"></a>3. Spark 内核</h2><h3 id="Spark提交任务流程"><a href="#Spark提交任务流程" class="headerlink" title="Spark提交任务流程"></a>Spark提交任务流程</h3><h4 id="1-Yarn-Cluster-模式"><a href="#1-Yarn-Cluster-模式" class="headerlink" title="1. Yarn Cluster 模式"></a>1. Yarn Cluster 模式</h4><p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210808163959670-16284120015104.png" alt="image-20210808163959670"></p>
<ol>
<li>执行<code>spark-submit</code>脚本提交任务，实际是启动一个SparkSubmit的JVM进程；</li>
<li>SparkSubmit类中的main方法反射调用Client的main方法；</li>
<li>Client创建Yarn客户端，然后想Yarn发送执行指令<code>bin/java ApplicationMaster</code> 请求启动一个AM；</li>
<li>Yarn框架收到指令后，RM会选择一台可用的NM，并在其中启动ApplicationMaster（进程）；</li>
<li><code>ApplicationMaster进程运行(此时RM还不知道AM启动与否，所以AM需要向RM注册)</code>，同时会启动一个<code>Driver子线程</code>，用于执行用户的作业（执行代码，初始化sc，任务切分）；</li>
<li>AM向RM进行注册（证明AM已经启动了），AM还要向RM申请资源<code>Container</code></li>
<li>获取到资源后，AM会向资源所在的NM（获取到的资源，可能在不同的机器上）发送指令<code>bin/java CoarseGrainedExecutorBackend</code>,启动一个粗粒度的ExecutorBackend</li>
<li>相应的NodeManager上会启动相应的<code>ExecutorBackend进程</code>, 并向<code>Driver</code>进行反向注册</li>
<li><code>Driver</code>上注册成功后，会向相应的NM返回注册成功信息，然后<code>ExecutorBackend</code>进程会创建一个<code>Executor</code>对象。</li>
<li>Driver内部指定用户提交作业的main方法，初始化sc，并进行任务的切分，然后分配给ExecutorBackend任务，并监控任务的执行。</li>
</ol>
<h4 id="Yarn-Client模式"><a href="#Yarn-Client模式" class="headerlink" title="Yarn Client模式"></a>Yarn Client模式</h4><p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210808171159136-16284139206945.png" alt="image-20210808171159136"></p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><ol>
<li>执行spark-submit脚本提交任务，实际启动一个SparkSubmit的JVM进程</li>
<li>SparkSubmit伴生对象中的main方法反射调用用户代码（就是我们自己所编写的代码）的main方法。</li>
<li>启动Driver（在SparkSubmit进程的main线程中运行，此时的Driver就不是一个子线程了），执行用户的作业，并创建<code>ScheduleBackend</code>与Yarn进行通信。</li>
<li><code>YarnClientScheduleBackend</code>向RM发送指令<code>bin/java ExecutorLauncher</code>(底层本质就是<code>ApplicationMaster</code>)启动ExecutorLauncher进程</li>
<li>RM收到指令后会在指定的NM中启动ExecutorLauncher，实质上还是调用的ApplicationMaster的main方法。</li>
<li>ExecutorLauncher向AM注册，申请资源</li>
<li>获取资源后ExecutorLauncher向相应的NM发送指令<code>bin/java CoarseGrainedExecutorBackend</code>启动一个粗粒度的ExecutorBackend；</li>
<li>后面和cluster模式一致</li>
</ol>
<p><strong>注意：</strong></p>
<p>driver不是一个子线程了，而是直接运行在SparkSubmit进程的main线程中，所以sparkSubmit进程不能退出。</p>
<p>而Cluster模式下，Driver是运行在远程集群上的，SparkSubmit进程提交完作业后即可以关闭。</p>
<h2 id="4-Spark任务调度机制"><a href="#4-Spark任务调度机制" class="headerlink" title="4. Spark任务调度机制"></a>4. Spark任务调度机制</h2><h3 id="4-1-Spark-任务调度概述"><a href="#4-1-Spark-任务调度概述" class="headerlink" title="4.1 Spark 任务调度概述"></a>4.1 Spark 任务调度概述</h3><p>在介绍任务调度之前，先来明确一下Spark中几个重要的概念。</p>
<ul>
<li><strong>Job</strong><ul>
<li>Job是以Action算子为界限，遇到一个Action算子则触发一个Job</li>
</ul>
</li>
<li><strong>Stage</strong><ul>
<li>Stage是Job的子集，以RDD宽依赖（即Shuffle）为界限，遇到Shuffle做一次划分</li>
</ul>
</li>
<li><strong>Task</strong><ul>
<li>Task是Stage的子集，以并行度（分区数）来衡量，这个Stage的分区数有多少，则这个Stage就有多少个Task，每个Stage中的多个Task运行同样的逻辑，但是作用在不同的数据上。</li>
</ul>
</li>
</ul>
<p>Spark的任务调度总体来说分为两路进行：一路是Stage级别的调度；一路是Task级别的调度。</p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210809095832482-8474331.png" alt="image-20210809095832482"></p>
<p>Spark RDD通过其Transactions操作，形成了RDD血缘关系图DAG，最后通过Action的调用，发出Job并调执行。</p>
<p><code>DAGScheduler</code>负责Stage级别的调度，主要是将Job切分成若干<code>Stages</code>，并将每个Stage打包成<code>TaskSet</code>交给<code>TaskScheduler</code>调度。</p>
<p><code>TaskScheduler</code>负责Task级别的调度，将DAGScheduler传过来的<code>TaskSet</code>按照指定的调度策略分发到<code>Executor</code>上执行，调度过程中<code>SchedulerBackend</code>负责提供可用资源，其中<code>SchedulerBackend</code>有多种实现，分别对接不同的资源管理系统。</p>
<p><code>Driver</code>初始化<code>SparkContext</code>过程中，会分别初始化<code>DAGScheduler</code>、<code>TaskScheduler</code>、<code>SchedulerBackend</code>以及<code>HeartbeatReceiver</code>，并启动<code>SchedulerBackend</code>以及<code>HeartbeatReceiver</code>。</p>
<p><code>SchedulerBackend</code>通过<code>ApplicationMaster</code>申请资源，并不断从<code>TaskScheduler</code>中拿到合适的Task分发到<code>Executor</code>执行。</p>
<p><code>HeartBeatReceiver</code>负责接收<code>Executor</code>的心跳信息，监控<code>Executor</code>的存活状态，并通知到<code>TaskScheduler</code>。</p>
<h3 id="4-2-Spark-Stage级别的调度"><a href="#4-2-Spark-Stage级别的调度" class="headerlink" title="4.2 Spark Stage级别的调度"></a>4.2 Spark Stage级别的调度</h3><p>Spark的任务调度是从DAG切割开始，主要是由<code>DAGScheduler</code>来完成。当遇到一个Action操作后就会触发一个Job的计算，并交给<code>DAGScheduler</code>来提交。</p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210809102313917-8475795.png" alt="image-20210809102313917"></p>
<ol>
<li><p>Job由最终的RDD和Action方法封装而成；</p>
</li>
<li><p><code>SparkContext</code>将Job交给<code>DAGScheduler</code>提交，它会根据RDD的血缘关系构成的DAG进行切分，将一个Job划分为若干Stages；</p>
<ul>
<li>具体划分策略是：由最终的RDD不断通过依赖回溯判断父依赖是否是<strong>宽依赖</strong>，即以<code>Shuffle</code>为界，划分Stage，窄依赖的RDD之间被划分到同一个Stage中，可以进行pipeline式的计算。</li>
<li><strong>划分的Stages分两类</strong>：<ul>
<li>一类叫做<code>ResultStage</code>，为DAG最下游的Stage，由Action方法决定；</li>
<li>一类叫做<code>ShuffleMapStage</code>，为下游的Stage准备数据。</li>
</ul>
</li>
</ul>
</li>
<li><p>Submit stage 提交阶段</p>
<ul>
<li><code>DAGScheduler.handleJobSubmitted</code>方法创建好<code>ResultStage</code>后会提交这个stage（submitStage方法），在提交一个<code>stage</code>的时候，会要先提交它的<code>parent stage</code>，也是通过递归的形式，直到一个<code>stage</code>的所有父阶段-<code>parent stage</code>都被提交了，才会提交本阶段，如果一个stage的parent还没有完成，则会把这个stage加入到<code>waitingStages</code>。也就是说，DAG图中前面的stage会被先提交。当一个stage的parent都准备好了，也就是执行完毕之后，它才会进入<code>submitMissingTasks</code>的环节。</li>
<li>stage的划分是<font color=green>从后向前</font>进行划分的，而真正的任务执行是<font color=green>从前向后</font>执行的。</li>
</ul>
</li>
<li><p>Subimit task</p>
<ul>
<li><p><code>Stage</code>中的<code>Task</code>是在<code>DAGScheduler</code>（不是TaskScheduler）的<code>submitMissingTasks</code>方法中创建的，包括<code>ShuffleMapTask</code>和<code>ResultTask</code>，与<code>Stage</code>对应。归属于同一个stage的这批Task组成一个<code>TaskSet集合</code>,最后提交给<code>TaskScheduler</code>的就是这个<code>TaskSet</code>。</p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/webp" alt="img"></p>
</li>
</ul>
</li>
</ol>
<p>Stage级调度的整体流程：</p>
<p><img src="./source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/DAGScheduler.png" alt="DAGScheduler.png"></p>
<p><font color=red>注意:</font></p>
<p>task的创建是在DAGScheduler的submitMissingTasks方法中创建的，而<code>TaskScheduler</code>负责Task的调度，不负责Task 的创建。</p>
<h3 id="4-3-Spark-Task级别的调度"><a href="#4-3-Spark-Task级别的调度" class="headerlink" title="4.3 Spark Task级别的调度"></a>4.3 Spark Task级别的调度</h3><p>Task的调度是由<code>TaskScheduler</code>与<code>SchedulerBackend</code>紧密合作，共同完成的。</p>
<p><code>TaskScheduler</code>是task级别的调度器，主要作用是管理task的调度和提交，是Spark底层的调度器。</p>
<p><code>SchedulerBackend</code>是<code>TaskScheduler</code>的后端服务，有独立的线程，所有的<code>Executor</code>都会注册到<code>SchedulerBackend</code>，主要作用是进行资源的分配、将<code>Task</code>分配给<code>Executor</code>等。</p>
<p><img src="./source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/TaskScheduler.png" alt="TaskScheduler.png"></p>
<p><strong>TaskSetManager</strong>负责监控管理同一个stage中的Tasks，TaskScheduler就是以TaskSetManager为单元来调度任务。包括<strong>任务推断</strong>、<strong>Task本地化调度</strong>，并对<strong>Task进行资源分配</strong>。</p>
<p><strong>具体工作流程</strong></p>
<p><img src="./source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/TaskScheduler%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="TaskScheduler.png"></p>
<ol>
<li><p><code>DAGScheduler</code>(<code>submitMissingTasks</code>方法中)调用<code>TaskScheduler.submitTask()</code>创建并TaskSet给<code>TaskScheduler</code>；</p>
</li>
<li><p><code>TaskScheduler</code>拿到<code>TaskSet</code>后会创建一个<code>TaskSetManager</code>来管理它，并且把<code>TaskSetManager</code>添加到<strong>rootPool</strong>调度池中；</p>
</li>
<li><p>调用<code>SchedulerBackend.revivieOffers()</code>方法</p>
</li>
<li><p><code>SchedulerBackend</code>发送<code>ReviveOffers</code>消息给<code>DriverEndPoint</code>；</p>
</li>
<li><p><code>DriverEndPoint</code>接收到<code>ReviveOffers</code>消息后，会调用<code>makeOffers()方法</code>创建<code>WorkerOffer</code>，并通过<code>TaskScheduler.resourceOffer()</code>返回Offer；</p>
</li>
<li><p><strong>TaskScheduler</strong>会从<strong>rootPool</strong>资源调度池中按照特定的调度算法取出一个<strong>TaskSetManager</strong>，逐个给<strong>TaskSet</strong>的<strong>Task</strong>分配<strong>WorkerOffer</strong>，并将其封装成<strong>TaskDescription</strong>（包含Offer信息）</p>
</li>
<li><p>调用<code>SchedulerBackend.DriverEndPoint</code>的<strong>launchTasks</strong>方法，将<strong>TaskDescription</strong>序列化并封装在<strong>LaunchTask</strong>消息中，发送给<strong>Offer</strong>指定的<strong>Executor</strong>。</p>
<p><strong>LaunchTask</strong>消息被<strong>ExecutorBackend</strong>接收到后，会将<strong>Task</strong>信息反序列化，传给<code>Executor.launTask()</code>,最后使用<strong>Executor的线程池</strong>中的线程来执行这个<strong>Task</strong>。</p>
</li>
</ol>
<h3 id="4-4-调度策略"><a href="#4-4-调度策略" class="headerlink" title="4.4 调度策略"></a>4.4 调度策略</h3><p>TaskScheduler支持两种调度策略：<strong>FIFO</strong>和<strong>FAIR</strong></p>
<ul>
<li><p><strong>FIFO</strong>:先进入到rooPool资源池中的TaskSetManager优先被调度</p>
</li>
<li><p><strong>FAIR</strong>：公平调度</p>
</li>
</ul>
<h3 id="4-5-本地化调度"><a href="#4-5-本地化调度" class="headerlink" title="4.5 本地化调度"></a>4.5 本地化调度</h3><p>因为每个Stage中的task负责处理不同分区的数据，所以在task被分配到Executor上时，尽量保证Task与处理的数据保持较近的距离，这样可以避免一定的数据传输开销。</p>
<p><strong>TaskScheduler</strong>从调度队列中拿到<strong>TaskSetManager</strong>后，那么接下来的工作就是<strong>TaskSetManager</strong>按照一定的规则一个个取出task给<strong>TaskScheduler</strong>，<strong>TaskScheduler</strong>再交给<strong>SchedulerBackend</strong>去发到<strong>Executor</strong>上执行。</p>
<p><strong>TaskSetManager</strong>会根据每个Task的优先位置，确定<code>Task的本地化调度级别：Locality</code>， Locality一共有五种，优先级由高到低顺序：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>名称</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>PROCESS_LOCAL</td>
<td>进程本地化</td>
<td>task和数据在同一个Executor中，性能最好。</td>
</tr>
<tr>
<td>NODE_LOCAL</td>
<td>节点本地化</td>
<td>task和数据在同一个节点中，但是task和数据不在同一个Executor中，数据需要在进程间进行传输</td>
</tr>
<tr>
<td>RACK_LOCAL</td>
<td>机架本地化</td>
<td>task和数据在同一个机架的两个不同的节点上，数据需要通过网络在节点之间进行传输。</td>
</tr>
<tr>
<td>NO_PREF</td>
<td></td>
<td>对于task来说，从哪里获取数据都一样，没有好坏之分</td>
</tr>
<tr>
<td>ANY</td>
<td></td>
<td>task和数据可以在集群的任何地方，而且不在一个机架中，性能最差</td>
</tr>
</tbody></table>
<p>在调度执行时，Spark调度总是会尽量让每个task以最高的本地级别来启动，当一个task以本地性级别启动，但是该本地性级别对应的所有节点都没有空闲资源而启动失败，此时并不会立马降低本地性级别启动，而是在某个时间长度内再次以本地性级别来启动该task，若超过限时时间则降级启动，去尝试下一个本地性级别。</p>
<p>可以通过调大每个类别的最大容忍延迟时间，在等待阶段对应的Executor可能就会有相应的资源去执行次task，这就在一定程度上提升了运行性能。</p>
<p><strong>失败重试和黑名单</strong></p>
<p>除了选择合适的Task调度运行外，还需要监控Task的执行状态，前面也提到，与外部打交道的是SchedulerBackend，Task被提交到Executor启动执行后，Executor会将执行状态上报给SchedulerBackend，SchedulerBackend则告诉TaskScheduler，TaskScheduler找到该Task对应的TaskSetManager，并通知到该TaskSetManager，这样TaskSetManager就知道Task的失败与成功状态，对于失败的Task，会记录它失败的次数，如果失败次数还没有超过最大重试次数，那么就把它放回待调度的Task池子中，否则整个Application失败。</p>
<p>在记录Task失败次数过程中，会记录它上一次失败所在的Executor Id和Host，这样下次再调度这个Task时，会使用黑名单机制，避免它被调度到上一次失败的节点上，起到一定的容错作用。黑名单记录Task上一次失败所在的Executor Id和Host，以及其对应的“拉黑”时间，</p>
<p>“拉黑”时间是指这段时间内不要再往这个节点上调度这个Task了。</p>
<h2 id="5-Spark-Shuffle解析"><a href="#5-Spark-Shuffle解析" class="headerlink" title="5. Spark Shuffle解析"></a>5. Spark Shuffle解析</h2><p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/format,png.png" alt="ShuffleMapStage与ResultStage"></p>
<p>Spark中会根据俄宽依赖来划分Stage。</p>
<p>在划分Stage时，最后一个Stage称为<code>ResultStage</code>, 前面所有的Stage被称为<code>ShuffleMapStage</code></p>
<p><strong>ShuffleMapStage</strong>的结束伴随着shuffle文件的写磁盘（<strong>ShuffleWrite</strong>）</p>
<p><strong>ResultStage</strong>的开始会先进行shuffle文件的读磁盘（<strong>ShuffleRead</strong>）</p>
<p>（在MapReduce计算框架中，只要发生Shuffle就会伴随着数据落盘，而在Spark中，只有ShuffleMapStage结束时才会伴随着数据落盘）</p>
<h3 id="5-1-HashShuffle"><a href="#5-1-HashShuffle" class="headerlink" title="5.1 HashShuffle"></a>5.1 HashShuffle</h3><p>在spark-1.6之前默认的shuffle方式是hash，在spark-1.6版本之后使用sort-BaseShuflle，因为HashShuffle存在不足所以就替换了HashShuffle。Spark2.0之后，从源码中完全移除了HashShuffle。</p>
<h4 id="5-1-1-未优化的HashShuffle"><a href="#5-1-1-未优化的HashShuffle" class="headerlink" title="5.1.1 未优化的HashShuffle"></a>5.1.1 未优化的HashShuffle</h4><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9C%AA%E4%BC%98%E5%8C%96%E7%9A%84HashShuffle.jpeg" alt="img" style="zoom:80%;" />

<p>如上图所示：假设共有三个ReduceTask在等待MapTask落盘的数据文件。</p>
<p>每个MapTask处理完后的数据，会根据key的hash被分到不同的缓冲区中，进行将数据落盘。</p>
<p>如果采用未优化的HashShuffle，那么每个MapTask都会产生相应ReduceTask数据量的小文件。</p>
<p><strong>缺点</strong></p>
<ol>
<li>map任务的中间结果首先存入内存（缓存），然后才写入磁盘，这对于内存的开销很大，当一个节点上的Map任务的输出结果集很大时，很容易导致内存紧张，发生OOM；</li>
<li>生成很多的小文件。假设有M个MapTask，有N个ReduceTask，则会创建M*N个小文件，磁盘I/O将成为性能的瓶颈。</li>
</ol>
<h4 id="5-1-2-优化后的HashShuffle"><a href="#5-1-2-优化后的HashShuffle" class="headerlink" title="5.1.2 优化后的HashShuffle"></a>5.1.2 优化后的HashShuffle</h4><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/优化的HashShuffle.png" alt="img" style="zoom:60%;" />



<p>优化的HashShuffle过程就是启用合并机制，合并机制就是复用Buffer。在同一个进程中（一个core中），无论是有多少个task，都只会有相应ReduceTask数量的一份数据（例如上述就是3个）</p>
<p>每一个MapTask所在的进程中，分别写入共同进程中的3分本地文件，上述图中有4个Task，但是只有两个Core，所以总共输出是 <code>2个Core * 3个分类文件 = 6 个本地小文件</code></p>
<h3 id="5-2-SortShuffle"><a href="#5-2-SortShuffle" class="headerlink" title="5.2 SortShuffle"></a>5.2 SortShuffle</h3><h4 id="5-2-1-普通的SortShuffle"><a href="#5-2-1-普通的SortShuffle" class="headerlink" title="5.2.1 普通的SortShuffle"></a>5.2.1 普通的SortShuffle</h4><p>每个进程中只有一块缓冲区</p>
<img src="./source/2021年8月份秋招复习笔记/普通SortShuffle.png" alt="img" style="zoom:80%;" />







<p>在该模式下，数据会先写入一个数据结构，reduceByKey写入Map，一边通过Map局部聚合，一边写入内存。</p>
<p>如果内存中的数据达到<strong>阈值</strong>，就会将内存中的数据结构写入到磁盘，清空内存数据结构。</p>
<p>在<strong>溢写磁盘</strong>前，现根据<strong>key进行排序</strong>，排序过后的数据，会分批写入到磁盘文件中。默认批次为10000条，数据会以每批一万条写入到磁盘文件。写入磁盘文件通过缓冲区溢写的方式，每次溢写都会产生一个磁盘文件，也就是说一个Task过程会产生多个临时文件。</p>
<p>最后在每个Task中，将<strong>所有的临时文件合并</strong>，这就是<strong>merge</strong>过程，此过程将所有临时文件读取出来，一次写入到最终文件。意味着一个<strong>Task</strong>的所有数据都在这一个文件中。同时单独写一份索引文件，标识下游各个Task的数据在文件中的索引，Start offset和End offset。</p>
<h4 id="5-2-2-bypassSortShuffle"><a href="#5-2-2-bypassSortShuffle" class="headerlink" title="5.2.2 bypassSortShuffle"></a>5.2.2 bypassSortShuffle</h4><p>每个进程中有多个缓冲区</p>
<img src="./source/2021年8月份秋招复习笔记/byPassSortShuffle.png" alt="img" style="zoom:80%;" />

<p>bypass运行机制的出发条件（<font color=red>必须同时满足</font>）：</p>
<ol>
<li>shuffle map task数量小于<code>spark.shuffle.sort.bypassMergeThreshold=200</code>参数的值，默认为200；</li>
<li>不是聚合类的<code>shuffle</code>算子（<font color=red>没有预聚合功能的</font>，比如：groupByKey）</li>
</ol>
<p>该过程的磁盘写机制其实跟未经优化的<code>HashShuffleManager</code>是一模一样的，因为都要创建数据量惊人的磁盘文件，只是在最后一次溢写，进行了一次磁盘文件的合并而已。因此少量的最终磁盘文件，也让该机制相对未经优化的HashShuffleManager来说，Shuffle read的性能会更好。（<strong>同时也是采用缓冲区溢写的方法落盘小文件，解决了HashShuffle中内存的问题</strong>）</p>
<p>而该机制与普通的SortShuffleManager运行机制的不同在于：不会进行排序。也就是说，启动该机制的最大好处在于，shuffle write过程中，不需要进行数据的排序操作，也就节省掉了这部分的性能开</p>
<h2 id="6-Spark内存管理"><a href="#6-Spark内存管理" class="headerlink" title="6. Spark内存管理"></a>6. Spark内存管理</h2><p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/src=http%253A%252F%252Fwx1.sinaimg.cn%252Fmw690%252F63918611gy1fe7btgzmz8j20le0fidhc.jpg&refer=http%253A%252F%252Fwx1.sinaimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg" alt="img"></p>
<p>Spark将内存从逻辑上区分为堆内内存和堆外内存，称为内存模型（MemoryMode）</p>
<ul>
<li>这里的堆内内存不能与JVM中的Java堆直接画等号，它只是JVM堆内存的一部分，由JVM统一管理。</li>
<li>堆外内存则是Spark使用<code>sun.misc.Unsafe</code>的API直接在工作节点（Executor）的系统内存中开辟的空间。</li>
</ul>
<p>内存池：对上述两种内存进行资源管理</p>
<p><strong>堆外内存</strong>：为了进一步优化内存的使用以及提高Shuffle时排序的效率，Spark引入了堆外（Off-heap）内存，使之可以直接在工作节点的系统内存中开辟空间，存储经过序列化的二进制数据。</p>
<p>堆外内存意味着把 内存对象分配在Java虚拟机以外的内存，这些内存直接受操作系统管理（而不是虚拟机）。这样做的结果就是能保持一个较小的堆，以减少垃圾收集对应用的影响。</p>
<p>利用 JDK Unsafe API，Spark 可以直接操作系统堆外内存，减少了不必要的内存开销，以及频繁的 GC 扫描和回收，提升了处理性能。</p>
<p>堆外内存可以被精确地申请和释放（堆外内存之所以能够被精确的申请和释放，是由于内存的申请和释放不再通过JVM机制，而是直接向操作系统申请，JVM对于内存的清理是无法准确指定时间点的，因此无法实现精确的释放），而且序列化的数据占用的空间可以被精确计算，所以相比堆内内存来说降低了管理的难度，也降低了误差。</p>
<h3 id="内存空间分配"><a href="#内存空间分配" class="headerlink" title="内存空间分配"></a>内存空间分配</h3><h4 id="1-静态内存管理"><a href="#1-静态内存管理" class="headerlink" title="1.  静态内存管理"></a>1.  静态内存管理</h4><p>在 Spark1.6之前采用的静态内存管理机制下，存储内存、执行内存和其他内存的大小在 Spark 应用程序运行期间均为固定的，但用户可以在应用程序启动前进行配置.</p>
<h5 id="1-1-堆内内存管理"><a href="#1-1-堆内内存管理" class="headerlink" title="1.1 堆内内存管理"></a>1.1 堆内内存管理</h5><p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/src=http%253A%252F%252Fupload-images.jianshu.io%252Fupload_images%252F9175374-a2a527f62646d62b.png&refer=http%253A%252F%252Fupload-images.jianshu.io&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg" alt="img"></p>
<ul>
<li><p><strong>Storage内存</strong>（存储内存）：主要用于存储Spark的cache数据，例如RDD的缓存、Broadcast变量，Unroll数据等。（**默认占用系统内存的60%**）</p>
</li>
<li><p><strong>Execution内存</strong>（执行内存）：主要用于存放Shuffle、Join、Sort、Aggregation等计算过程中的临时数据。（**默认占用系统内存的20%**）</p>
</li>
<li><p><strong>Other</strong>（有时也叫做用户内存）：主要用于存储RDD转换操作所需的数据，例如RDD依赖等信息。（**默认占用系统内存的20%**）</p>
</li>
<li><p><strong>预留内存</strong>（Reserved Memory）：系统预留内存，会用来存储Spark内部对象，防止OO</p>
</li>
</ul>
<h5 id="1-2-堆外内存管理"><a href="#1-2-堆外内存管理" class="headerlink" title="1.2 堆外内存管理"></a>1.2 堆外内存管理</h5><p>堆外的空间分配较为简单，只有存储内存和执行内存。</p>
<p>可用的执行内存和存储内存占用的空间大小直接由参数 spark.memory.storageFraction 决定，由于堆外内存占用的空间可以被精确计算，所以无需再设定保险区域。</p>
<img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210809202402983-8511844.png" alt="image-20210809202402983" style="zoom:50%;" />

<p>静态内存管理机制实现起来较为简单，但如果用户不熟悉 Spark 的存储机制，或没有根据具体的数据规模和计算任务或做相应的配置，很容易造成“一半海水，一半火焰”的局面，即存储内存和执行内存中的一方剩余大量的空间，而另一方却早早被占满，不得不淘汰或移出旧的内容以存储新的内容。</p>
<p>由于新的内存管理机制的出现，这种方式目前已经很少有开发者使用，出于兼容旧版本的应用程序的目的，Spark 仍然保留了它的实现。</p>
<h4 id="2-统一内存管理"><a href="#2-统一内存管理" class="headerlink" title="2. 统一内存管理"></a>2. 统一内存管理</h4><p>Spark 1.6 之后引入的统一内存管理机制，与静态内存管理的区别在于存储内存和执行内存共享同一块空间，可以动态占用对方的空闲区域.</p>
<h5 id="2-1-统一堆内内存管理"><a href="#2-1-统一堆内内存管理" class="headerlink" title="2.1 统一堆内内存管理"></a>2.1 统一堆内内存管理</h5><p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%9F%E4%B8%80%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.jpeg"></p>
<p><strong>存储内存</strong>与<strong>执行内存</strong>共占系统内存的<strong>60%<strong>，Other（用户内存占</strong>40%<strong>），预留内存：</strong>300M</strong></p>
<p>统一内存管理最重要的优化在于<strong>动态占用机制</strong>，其规则如此下：</p>
<ol>
<li>设定基本的存储内存和执行内存区域<code>spark.storage.storageFraction</code>,该设定确定了双方各自拥有的空间的范围。</li>
<li>双方空间都不足时，则存储到硬盘。若己方内存空间不足而对方空余时，可借用对方的空间。</li>
<li>执行内存的空间被存储内存占用后，可让存储内存将占用的部分数据转存到硬盘，然后“归还”借用的空间。</li>
<li>存储内存的空间被执行内存占用后，无法让运行内存“归还”，因为需要考虑Shuffle过程中的诸多因素，实现起来比较复杂。（<font color=red>执行优先，不能执行一半就把内存还回去了，得等此次执行完后才可返还内存</font>）</li>
</ol>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/1228818-20180426212853794-858627420.png" alt="img"></p>
<h5 id="2-2-统一堆外内存管理"><a href="#2-2-统一堆外内存管理" class="headerlink" title="2.2 统一堆外内存管理"></a>2.2 统一堆外内存管理</h5><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210809202631142-8511994.png" alt="image-20210809202631142" style="zoom:50%;" />

<h3 id="存储内存管理"><a href="#存储内存管理" class="headerlink" title="存储内存管理"></a>存储内存管理</h3><p>RDD 作为 Spark 最基本的数据抽象, 是分区记录(partition)的只读集合, 只能基于在稳定物理存储中的数据集上创建, 或者在其他已有的 RDD 上执行转换(Transformation)操作产生一个新的 RDD.</p>
<p>转换后的 RDD 与原始的 RDD 之间产生的依赖关系, 构成了血统(Lineage). 凭借血统, Spark 可以保证每一个 RDD 都可以被重新恢复.</p>
<p>但 RDD 的所有转换都是惰性的, 即只有当行动(Action)发生时, Spark 才会创建任务读取 RDD, 然后才会真正的执行转换操作.</p>
<p>Task 在启动之初读取一个分区的时, 会先判断这个分区是否已经被持久化, 如果没有则需要检查 Checkpoint 或按照血统重新计算.</p>
<p>如果要在一个 RDD 上执行多次行动, 可以在第一次行动中使用 persis 或 cache 方法, 在内存或磁盘中持久化或缓存这个 RDD, 从而在后面的Action 时提示计算速度.</p>
<p>事实上, cache 方法是使用默认的 MEMORY_ONLY的存储级别将 RDD 持久化到内存, 所以缓存是一种特殊的持久化.</p>
<p>堆内内存和堆外内存的设计, 便可以对缓存 RDD 时使用的内存做统一的规划和管理。</p>
<h2 id="7-Spark性能优化"><a href="#7-Spark性能优化" class="headerlink" title="7. Spark性能优化"></a>7. Spark性能优化</h2><h3 id="7-1-Spark-常用配置参数"><a href="#7-1-Spark-常用配置参数" class="headerlink" title="7.1 Spark 常用配置参数"></a>7.1 Spark 常用配置参数</h3><p>执行<code>submit</code>脚本的时候，可以指定一些配置参数，</p>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/spark/bin/spark-submit\</span><br><span class="line">--class spark.WordCount \</span><br><span class="line">--num-executor 80 \</span><br><span class="line">...</span><br><span class="line">/usr/locla/spark/spark.jar</span><br></pre></td></tr></table></figure>



<p>下面列举几个常用的参数：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>num-executors</code></td>
<td>设置executor的数量</td>
</tr>
<tr>
<td><code>driver-memory</code></td>
<td>设置driver端的内存大小</td>
</tr>
<tr>
<td><code>executor-memory</code></td>
<td>设置每个executor的内存大小</td>
</tr>
<tr>
<td><code>executor-cores</code></td>
<td>设置每个executor的cpu核心数</td>
</tr>
<tr>
<td><code>master yarn</code></td>
<td>设置集群模式为Yarn</td>
</tr>
<tr>
<td><code>deploy-mode cluster</code></td>
<td>设置yarn的部署模式为cluster（client）</td>
</tr>
</tbody></table>
<h3 id="7-2-常规性能调优一：RDD复用"><a href="#7-2-常规性能调优一：RDD复用" class="headerlink" title="7.2 常规性能调优一：RDD复用"></a>7.2 常规性能调优一：RDD复用</h3><ul>
<li><p>在对RDD进行算子时，要避免相同的算子和计算逻辑之下对 RDD 进行重复的计算:</p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210810095712565-8560634-8561548.png" alt="image-20210810095712565">                               </p>
<p>对上图中的RDD计算架构进行修改:</p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210810095721948-8560643-8561543.png" alt="image-20210810095721948"></p>
</li>
</ul>
<h3 id="7-2-常规性能调优二：RDD持久化"><a href="#7-2-常规性能调优二：RDD持久化" class="headerlink" title="7.2 常规性能调优二：RDD持久化"></a>7.2 常规性能调优二：RDD持久化</h3><ul>
<li><ul>
<li>在Spark中，当多次对同一个 RDD 执行算子操作时，每一次都会对这个 RDD 的祖先 RDD 重新计算一次，这种情况是必须要避免的，对同一个RDD的重复计算是对资源的极大浪费，因此，必须对多次使用的RDD进行持久化，通过持久化将公共RDD的数据缓存到内存/磁盘中，之后对于公共RDD的计算都会从内存/磁盘中直接获取RDD数据。 对于RDD的持久化，有两点需要说明： </li>
<li>RDD的持久化是可以进行序列化的，当内存无法将RDD的数据完整的进行存放的时候，可以考虑使用序列化的方式减小数据体积，将数据完整存储在内存中。</li>
<li>如果对于数据的可靠性要求很高，并且内存充足，可以使用副本机制，对RDD数据进行持久化。当持久化启用了复本机制时，对于持久化的每个数据单元都存储一个副本，放在其他节点上面，由此实现数据的容错，一旦一个副本数据丢失，不需要重新计算，还可以使用另外一个副本。</li>
</ul>
</li>
<li><strong>RDD尽可能尽早的filter操作</strong></li>
</ul>
<h3 id="7-3-常规性能调优三：并行度调节"><a href="#7-3-常规性能调优三：并行度调节" class="headerlink" title="7.3 常规性能调优三：并行度调节"></a>7.3 常规性能调优三：并行度调节</h3><p><code>set spark.default.parallelism=500;</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> conf=<span class="keyword">new</span> <span class="type">SparkConf</span>().set(<span class="string">&quot;spark.default.parallelism&quot;</span>, <span class="string">&quot;500&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><font color=green>一般情况下，task数量应该设置为Spark作业总CPU Core数量的2~3倍。</font></p>
<p>之所以没有推荐task数量与CPU core总数相等，是因为task的执行时间不同，有的task执行速度快而有的task执行速度慢，如果task数量与CPU core总数相等，那么执行快的task执行完成后，会出现CPU core空闲的情况。如果task数量设置为CPU core总数的2~3倍，那么一个task执行完毕后，CPU core会立刻执行下一个task，降低了资源的浪费，同时提升了Spark作业运行的效率。</p>
<h3 id="7-4-常规性能调优四：广播大变量"><a href="#7-4-常规性能调优四：广播大变量" class="headerlink" title="7.4 常规性能调优四：广播大变量"></a>7.4 常规性能调优四：广播大变量</h3><p>默认情况下，task 中的算子中如果使用了外部的变量，每个 task 都会获取一份变量的复本，这就造成了内存的极大消耗。 - 一方面，如果后续对 RDD 进行持久化，可能就无法将 RDD 数据存入内存，只能写入磁盘，磁盘IO将会严重消耗性能； - 另一方面，task在创建对象的时候，也许会发现堆内存无法存放新创建的对象，这就会导致频繁的GC，GC会导致工作线程停止，进而导致Spark暂停工作一段时间，严重影响Spark性能。</p>
<p>假设当前任务配置了20个Executor，指定500个task，有一个20M的变量被所有task共用，此时会在500个task中产生500个副本，耗费集群10G的内存，如果使用了广播变量， 那么每个Executor保存一个副本，一共消耗400M内存，内存消耗减少了5倍。</p>
<p>广播变量在每个Executor保存一个副本，此Executor的所有task共用此广播变量，这让变量产生的副本数量大大减少。</p>
<p>在初始阶段，广播变量只在Driver中有一份副本。task在运行的时候，想要使用广播变量中的数据，此时首先会在自己本地的Executor对应的BlockManager中尝试获取变量，如果本地没有，BlockManager就会从Driver或者其他节点的BlockManager上远程拉取变量的复本，并由本地的BlockManager进行管理；之后此Executor的所有task都会直接从本地的BlockManager中获取变量。</p>
<h3 id="7-5-算子调优"><a href="#7-5-算子调优" class="headerlink" title="7.5 算子调优"></a>7.5 算子调优</h3><h4 id="1-mapPartitions"><a href="#1-mapPartitions" class="headerlink" title="1. mapPartitions"></a>1. mapPartitions</h4><p>普通的 map 算子对 RDD 中的每一个元素进行操作，而 mapPartitions 算子对 RDD 中每一个分区进行操作。</p>
<p>如果是普通的map算子，假设一个 partition 有 1 万条数据，那么 map 算子中的 function 要执行1万次，也就是对每个元素进行操作。</p>
<p>如果是 mapPartition 算子，由于一个 task 处理一个 RDD 的partition，那么一个task只会执行一次function，function一次接收所有的partition数据，效率比较高。</p>
<p>mapPartitions算子也存在一些缺点：对于普通的map操作，一次处理一条数据，如果在处理了2000条数据后内存不足，那么可以将已经处理完的2000条数据从内存中垃圾回收掉；但是如果使用mapPartitions算子，但数据量非常大时，function一次处理一个分区的数据，如果一旦内存不足，此时无法回收内存，就可能会OOM，即内存溢出。</p>
<p>因此，mapPartitions算子适用于数据量不是特别大的时候，此时使用mapPartitions算子对性能的提升效果还是不错的。（当数据量很大的时候，一旦使用mapPartitions算子，就会直接OOM） 在项目中，应该首先估算一下RDD的数据量、每个partition的数据量，以及分配给每个Executor的内存资源，如果资源允许，可以考虑使用mapPartitions算子代替map。</p>
<h4 id="2-foreachPartition优化数据库操作"><a href="#2-foreachPartition优化数据库操作" class="headerlink" title="2. foreachPartition优化数据库操作"></a>2. foreachPartition优化数据库操作</h4><p>使用了foreachPartition算子后，可以获得以下的性能提升：</p>
<ol>
<li>对于我们写的function函数，一次处理一整个分区的数据</li>
<li>对于一个分区的数据，创建唯一的数据库连接</li>
<li>只需要向数据发送一次SQL语句和多组参数</li>
</ol>
<p>在生产环境中，全部都会使用foreachPartition算子完成数据库操作。foreachPartition算子存在一个问题，与mapPartitions算子类似，如果一个分区的数据量特别大，可能会造成OOM，即内存溢出。</p>
<h4 id="3-filter与coalesce的配合使用"><a href="#3-filter与coalesce的配合使用" class="headerlink" title="3. filter与coalesce的配合使用"></a>3. filter与coalesce的配合使用</h4><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210810102102079-8562063.png" alt="image-20210810102102079" style="zoom:50%;" />

<p>在Spark任务中我们经常会使用filter算子完成RDD中数据的过滤，在任务初始阶段，从各个分区中加载到的数据量是相近的，但是一旦进过filter过滤后，每个分区的数据量有可能会存在较大差异。</p>
<p>在上图中, 第二个分区的数据过滤后只剩100条，而第三个分区的数据过滤后剩下800条，在相同的处理逻辑下，第二个分区对应的task处理的数据量与第三个分区对应的task处理的数据量差距达到了8倍，这也会导致运行速度可能存在数倍的差距，这也就是<strong>数据倾斜问题</strong>。</p>
<p>可以通过repartition与coalesce都可以进行重分区，其中repartition只是coalesce接口中shuffle为true的简易实现，coalesce默认情况下不进行shuffle。</p>
<blockquote>
<p>可以在filter操作之后，使用coalesce算子针对每个partition的数据量各不相同的情况，压缩partition的数量，而且让每个partition的数据量尽量均匀紧凑，以便于后面的task进行计算操作，在某种程度上能够在一定程度上提升性能。</p>
</blockquote>
<h4 id="4-repartition-解决SparkSQL低并行度问题"><a href="#4-repartition-解决SparkSQL低并行度问题" class="headerlink" title="4. repartition 解决SparkSQL低并行度问题"></a>4. repartition 解决SparkSQL低并行度问题</h4><p><code>set spark.default.parallelism=500;</code>对于SparkSQL是不生效的，用户设置的并行度只对于SparkSQL以外的所有Spark的stage生效。</p>
<p>Spark SQL的并行度不允许用户自己指定，Spark SQL自己会默认根据 hive 表对应的 HDFS 文件的 split 个数自动设置 Spark SQL 所在的那个 stage 的并行度，用户自己通spark.default.parallelism参数指定的并行度，只会在没Spark SQL的stage中生效。</p>
<p>由于Spark SQL所在stage的并行度无法手动设置，如果数据量较大，并且此stage中后续的transformation操作有着复杂的业务逻辑，而Spark SQL自动设置的task数量很少，这就意味着每个task要处理为数不少的数据量，然后还要执行非常复杂的处理逻辑，这就可能表现为第一个有 Spark SQL 的 stage 速度很慢，而后续的没有 Spark SQL 的 stage 运行速度非常快。</p>
<p>为了解决SparkSQL无法设置并行度和task数量的问题，可以使用repartition算子。</p>
<img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210810102807976-8562489.png" alt="image-20210810102807976" style="zoom:50%;" />

<p>Spark SQL这一步的并行度和task数量肯定是没有办法去改变了，但是，对于Spark SQL查询出来的RDD，立即使用repartition算子，去重新进行分区，这样可以重新分区为多个partition，从repartition之后的RDD操作，由于不再涉及 Spark SQL，因此 stage 的并行度就会等于你手动设置的值，这样就避免了 Spark SQL 所在的 stage 只能用少量的 task 去处理大量数据并执行复杂的算法逻辑。</p>
<h4 id="5-reduceByKey预聚合"><a href="#5-reduceByKey预聚合" class="headerlink" title="5. reduceByKey预聚合"></a>5. reduceByKey预聚合</h4><p>实际生产中，尽量使用带有预聚合的算子，而避免使用（groupByKey这类没有预聚合的算子）</p>
<p>所谓预聚合：就是在map端就进行一次combine操作。</p>
<h3 id="7-6-Shuffle调优"><a href="#7-6-Shuffle调优" class="headerlink" title="7.6 Shuffle调优"></a>7.6 Shuffle调优</h3><h4 id="1-调节map端缓冲区大小"><a href="#1-调节map端缓冲区大小" class="headerlink" title="1. 调节map端缓冲区大小"></a>1. 调节map端缓冲区大小</h4><p>在 Spark 任务运行过程中，如果 shuffle 的map端处理的数据量比较大，但是map端缓冲的大小是固定的，可能会出现map端缓冲数据频繁<strong>spill溢写到磁盘</strong>文件中的情况，使得性能非常低下，通过调节map端缓冲的大小，可以避免频繁的磁盘 IO 操作，进而提升 Spark 任务的整体性能。</p>
<p>map端缓冲的默认配置是<code>32KB</code>, 如果每个task处理640KB的数据，那么会发生640/32 = 20次溢写，如果每个task处理64000KB的数据，机会发生64000/32=2000此溢写，这对于性能的影响是非常严重的。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().set(<span class="string">&quot;spark.shuffle.file.buffer&quot;</span>, <span class="string">&quot;64&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="2-调节reduce端缓冲区大小"><a href="#2-调节reduce端缓冲区大小" class="headerlink" title="2. 调节reduce端缓冲区大小"></a>2. 调节reduce端缓冲区大小</h4><p>Spark Shuffle 过程中，shuffle reduce task 的 buffer缓冲区大小决定了reduce task 每次能够缓冲的数据量，也就是每次能够拉取的数据量，如果内存资源较为充足，<strong>适当增加拉取数据缓冲区的大小，可以减少拉取数据的次数，也就可以减少网络传输的次数，进而提升性能。</strong></p>
<p>reduce端数据拉取缓冲区的大小可以通过spark.reducer.maxSizeInFlight参数进行设置，默认为48MB</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> conf=<span class="keyword">new</span> <span class="type">SparkConf</span>().set(<span class="string">&quot;spark.reducer.maxSizeInFlight&quot;</span>, <span class="string">&quot;96&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="3-调节reduce端拉取数据重试次数"><a href="#3-调节reduce端拉取数据重试次数" class="headerlink" title="3. 调节reduce端拉取数据重试次数"></a>3. 调节reduce端拉取数据重试次数</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().set(<span class="string">&quot;spark.shuffle.io.maxRetries&quot;</span>, <span class="string">&quot;6&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>Spark Shuffle 过程中，reduce task 拉取属于自己的数据时，如果因为网络异常等原因导致失败会自动进行重试。对于那些包含了特别耗时的 shuffle 操作的作业，建议增加重试最大次数（比如60次），以避免由于 JVM 的full gc 或者网络不稳定等因素导致的数据拉取失败。在实践中发现，对于针对超大数据量（数十亿~上百亿）的shuffle 过程，调节该参数可以大幅度提升稳定性。</p>
<p>reduce 端拉取数据重试次数可以通过spark.shuffle.io.maxRetries参数进行设置，该参数就代表了可以重试的最大次数。如果在指定次数之内拉取还是没有成功，就可能会导致作业执行失败，默认为3，</p>
<h4 id="4-调节reduce端拉取数据等待间隔"><a href="#4-调节reduce端拉取数据等待间隔" class="headerlink" title="4. 调节reduce端拉取数据等待间隔"></a>4. 调节reduce端拉取数据等待间隔</h4><p>Spark Shuffle 过程中，reduce task 拉取属于自己的数据时，如果因为网络异常等原因导致失败会自动进行重试，在一次失败后，会等待一定的时间间隔再进行重试，可以通过加大间隔时长（比如60s），以增加shuffle操作的稳定性。</p>
<p>reduce端拉取数据等待间隔可以通过spark.shuffle.io.retryWait参数进行设置，默认值为5s，</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line">  .set(<span class="string">&quot;spark.shuffle.io.retryWait&quot;</span>, <span class="string">&quot;60s&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="5-调节SortShuffle排序操作阈值"><a href="#5-调节SortShuffle排序操作阈值" class="headerlink" title="5. 调节SortShuffle排序操作阈值"></a>5. 调节SortShuffle排序操作阈值</h4><p>对于SortShuffleManager，如果shuffle reduce task的数量小于某一阈值则shuffle write过程中不会进行排序操作，而是直接按照未经优化的HashShuffleManager的方式去写数据，但是最后会将每个task产生的所有临时磁盘文件都合并成一个文件，并会创建单独的索引文件。</p>
<p>当你使用SortShuffleManager时，如果的确不需要排序操作，那么建议将这个参数调大一些，大于shuffle read task的数量，那么此时map-side就不会进行排序了，减少了排序的性能开销，但是这种方式下，依然会产生大量的磁盘文件，因此shuffle write性能有待提高。 SortShuffleManager排序操作阈值的设置可以通过spark.shuffle.sort. bypassMergeThreshold这一参数进行设置，默认值为200，</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> conf=<span class="keyword">new</span> <span class="type">SparkConf</span>().set(<span class="string">&quot;spark.shuffle.sort.bypassMergeThreshold&quot;</span>, <span class="string">&quot;400&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="7-7-内存调优"><a href="#7-7-内存调优" class="headerlink" title="7.7 内存调优"></a>7.7 内存调优</h3><p>增大堆外内存<code>--conf spark.executor.memoryOverhead=2048;</code></p>
<h2 id="8-Spark数据倾斜解决方案"><a href="#8-Spark数据倾斜解决方案" class="headerlink" title="8. Spark数据倾斜解决方案"></a>8. Spark数据倾斜解决方案</h2><p>Spark 中的数据倾斜问题主要指shuffle过程中出现的数据倾斜问题，是由于不同的key对应的数据量不同导致的不同task所处理的数据量不同的问题。</p>
<p>例如，reduce点一共要处理100万条数据，第一个和第二个task分别被分配到了1万条数据，计算5分钟内完成，第三个task分配到了98万数据，此时第三个task可能需要10个小时完成，这使得整个Spark作业需要10个小时才能运行完成，这就是数据倾斜所带来的后果。</p>
<p>注意，要区分开数据倾斜与数据量过量这两种情况，数据倾斜是指少数task被分配了绝大多数的数据，因此少数task运行缓慢；数据过量是指所有task被分配的数据量都很大，相差不多，所有task都运行缓慢。</p>
<p>数据倾斜的表现：</p>
<ol>
<li><p>Spark 作业的大部分 task 都执行迅速，只有有限的几个task执行的非常慢，此时可能出现了数据倾斜，作业可以运行，但是运行得非常慢；</p>
</li>
<li><p>Spark 作业的大部分task都执行迅速，但是有的task在运行过程中会突然报出OOM，反复执行几次都在某一个task报出OOM错误，此时可能出现了数据倾斜，作业无法正常运行。</p>
</li>
</ol>
<h3 id="8-1-聚合原数据"><a href="#8-1-聚合原数据" class="headerlink" title="8.1 聚合原数据"></a>8.1 聚合原数据</h3><ol>
<li>避免shuffle过程<ul>
<li>可以在hive端直接将每个key对应的数据拼接成一个大大的字符串，避免shuffle</li>
</ul>
</li>
<li>缩小key的粒度（增大数据倾斜的可能性，降低每个task的数据量）</li>
<li>增大key的粒度（减少数据倾斜的可能性，增大每个task的数据量）</li>
</ol>
<h3 id="8-2-过滤掉导致倾斜的key"><a href="#8-2-过滤掉导致倾斜的key" class="headerlink" title="8.2 过滤掉导致倾斜的key"></a>8.2 过滤掉导致倾斜的key</h3><p>有些时候，导致数据倾斜的key可能为null，提前将这个无用的导致的倾斜的key过滤掉。</p>
<p>如果有真实的key导致了数据倾斜，我们可以单独抽取出来这个key，通过拼接随机数后缀，将key进行打散，进而可以在一定程度上缓解数据倾斜所带来的问题。</p>
<h3 id="8-3-提高shuffle操作中的reduce并行度"><a href="#8-3-提高shuffle操作中的reduce并行度" class="headerlink" title="8.3 提高shuffle操作中的reduce并行度"></a>8.3 提高shuffle操作中的reduce并行度</h3><p>当方案一和方案二对于数据倾斜的处理没有很好的效果时，可以考虑提高shuffle过程中的reduce端并行度，reduce端并行度的提高就增加了reduce端task的数量，那么每个task分配到的数据量就会相应减少，由此缓解数据倾斜问题。</p>
<p>对于Spark SQL中的shuffle类语句，比如group by、join等，需要设置一个参数，即<code>spark.sql.shuffle.partitions</code>，该参数代表了shuffle read task的并行度，该值默认是200，对于很多场景来说都有点过小。</p>
<p>提高reduce端并行度并没有从根本上改变数据倾斜的本质和问题（方案一和方案二从根本上避免了数据倾斜的发生），只是尽可能地去缓解和减轻shuffle reduce task的数据压力，以及数据倾斜的问题，适用于有较多key对应的数据量都比较大的情况。</p>
<p>该方案通常无法彻底解决数据倾斜，因为如果出现一些极端情况，比如某个key对应的数据量有100万，那么无论你的task数量增加到多少，这个对应着100万数据的key肯定还是会分配到一个task中去处理，因此注定还是会发生数据倾斜的。所以这种方案只能说是在发现数据倾斜时尝试使用的第一种手段，尝试去用最简单的方法缓解数据倾斜而已，或者是和其他方案结合起来使用。</p>
<p>在理想情况下，reduce端并行度提升后，会在一定程度上减轻数据倾斜的问题，甚至基本消除数据倾斜；但是，在一些情况下，只会让原来由于数据倾斜而运行缓慢的task运行速度稍有提升，或者避免了某些task的OOM问题，但是，仍然运行缓慢，此时，要及时放弃方案三，开始尝试后面的方案。</p>
<h3 id="8-4-使用随机key实现双重聚合"><a href="#8-4-使用随机key实现双重聚合" class="headerlink" title="8.4 使用随机key实现双重聚合"></a>8.4 使用随机key实现双重聚合</h3><p>当使用了类似于groupByKey、reduceByKey这样的算子时，可以考虑使用随机key实现双重聚合</p>
<img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210810111030982-8565032.png" alt="image-20210810111030982" style="zoom:50%;" />



<p>首先，通过map算子给每个数据的key添加随机数前缀，对key进行打散，将原先一样的key变成不一样的key，然后进行第一次聚合，这样就可以让原本被一个task处理的数据分散到多个task上去做局部聚合；</p>
<p>随后，去除掉每个key的前缀，再次进行聚合。</p>
<p>此方法对于有<code>groupByKey,reduceByKey</code>这类算子造成的数据倾斜有比较好的效果，仅仅适用于聚合类的shuffle操作，使用范围相对较窄。</p>
<h3 id="8-5-将reduce-join-转换成map-join"><a href="#8-5-将reduce-join-转换成map-join" class="headerlink" title="8.5 将reduce join 转换成map join"></a>8.5 将reduce join 转换成map join</h3><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210810111500233-8565301.png" alt="image-20210810111500233" style="zoom:50%;" />

<p>正常情况下，join操作都会执行shuffle过程，并且执行的是reduce join，也就是先将所有相同的key和对应的value汇聚到一个reduce task中，然后再进行join。</p>
<p>普通的join是会走shuffle过程的，而一旦shuffle，就相当于会将相同key的数据拉取到一个shuffle read task中再进行join，此时就是reduce join。</p>
<p>但是一个数据量特别大，一个数据量特别小，这两个数据进行join，就很有可能产生数据倾斜，导致大量的数据key都会聚集到一小部分reduce task中。</p>
<p><strong>解决办法</strong></p>
<p>通过将小数据量RDD中的数据 broadcast广播出去，然后通过map join的方式实现与reduce join相同的效果。此时就不会发生shuffle操作，也就不会发生数据倾斜了。</p>
<img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210810111914642-8565556.png" alt="image-20210810111914642" style="zoom:50%;" />

<h3 id="8-6-sample采样对倾斜key单独进行join"><a href="#8-6-sample采样对倾斜key单独进行join" class="headerlink" title="8.6 sample采样对倾斜key单独进行join"></a>8.6 sample采样对倾斜key单独进行join</h3><h3 id="8-7-使用随机数以及扩容进行join"><a href="#8-7-使用随机数以及扩容进行join" class="headerlink" title="8.7 使用随机数以及扩容进行join"></a>8.7 使用随机数以及扩容进行join</h3><p>如果在进行join操作时，RDD中有大量的key导致数据倾斜，那么进行分拆key也没什么意义，此时就只能使用最后一种方案来解决问题了，对于join操作，我们可以考虑对其中一个RDD数据进行扩容，另一个RDD进行稀释后再join。</p>
<p>我们会将原先一样的key通过附加随机前缀变成不一样的key，然后就可以将这些处理后的“不同key”分散到多个task中去处理，而不是让一个task处理大量的相同key。</p>
<p>这一种方案是针对有大量倾斜key的情况，没法将部分key拆分出来进行单独处理，需要对整个RDD进行数据扩容，对内存资源要求很高。</p>
<p><strong>核心思想</strong></p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210810153402154-8580843.png" alt="image-20210810153402154"></p>
<p>选择一个RDD，使用flatMap进行扩容，对每条数据的key添加数值前缀（1~N的数值），将一条数据映射为多条数据；（扩容）</p>
<p>选择另外一个RDD，进行map映射操作，每条数据的key都打上一个随机数作为前缀（1~N的随机数）；（稀释）</p>
<h3 id="8-8-更换分区器（RangePartitioner）"><a href="#8-8-更换分区器（RangePartitioner）" class="headerlink" title="8.8 更换分区器（RangePartitioner）"></a>8.8 更换分区器（RangePartitioner）</h3><h3 id="8-9-两张大的表进行join（无法广播），产生数据倾斜"><a href="#8-9-两张大的表进行join（无法广播），产生数据倾斜" class="headerlink" title="8.9 两张大的表进行join（无法广播），产生数据倾斜"></a>8.9 两张大的表进行join（无法广播），产生数据倾斜</h3><p>两个RDD进行join的时候，如果数据量都比较大，那么此时可以sample看下两个RDD中的key分布情况。如果出现数据倾斜，是因为其中某一个RDD中的少数几个key的数据量过大，而另一个RDD中的所有key都分布比较均匀，此时可以考虑采用本解决方案。</p>
<p><strong><font color=red>解决方案</font></strong></p>
<ol>
<li><strong>对数据倾斜的那个RDD，使用sample算子采样出一份样本数据，统计下每个key的数量，看看导致数据倾斜的数据量最大的是哪几个key。</strong></li>
<li>然后将这几个key对应的数据从原来的RDD中拆分出来，形成一个单独的RDD，并给<strong>每个key</strong>都打上<code>0~n</code>以内的随机前缀；不会导致数据倾斜的大部分key形成另外一个RDD。</li>
<li>接着将join的另一个RDD过滤出来2中所提取出来的那些导致数据倾斜的key，也单独形成一个RDD。这个RDD中的key是少量的，将每条数据膨胀成n倍，这n条数据都按照顺序添加一个<code>0~1</code>的前缀；那些不会导致数据倾斜的key单独形成另外一个RDD。</li>
<li>再将随机附加了随机前缀的RDD与另一个膨胀了n倍的RDD进行join，这样就可以将原先相同的key打散成n分，分散到多个task中去进行join</li>
<li>而另外两个普通的RDD就照常join即可</li>
<li>最后将两次join的结果使用union算子合并起来即可，最终得到join的结果。</li>
</ol>
<blockquote>
<p>方案优点</p>
</blockquote>
<p>对于两个大RDD进行join时的数据倾斜，如果只是某一个key导致了数据倾斜，采用该方式可以用最有效的方式打散key进行join。而且只需要针对少数倾斜key对应的数据进行扩容n倍，不需要对全量数据进行扩容，避免了占用过多内存。</p>
<blockquote>
<p>方法局限性</p>
</blockquote>
<p>如果导致倾斜的key特别多的话，比如成千上万个key都导致数据倾斜了，就不能使用本解决方案了。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/meihao5/article/details/81084876">Spark数据倾斜的解决方案：参考</a></p>
<h3 id="8-10-增大并行度，增大资源"><a href="#8-10-增大并行度，增大资源" class="headerlink" title="8.10 增大并行度，增大资源"></a>8.10 增大并行度，增大资源</h3><h2 id="9-Spark中涉及到的join"><a href="#9-Spark中涉及到的join" class="headerlink" title="9. Spark中涉及到的join"></a>9. Spark中涉及到的join</h2><p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210917191421213-16318772632891.png" alt="image-20210917191421213"></p>
<h3 id="Hash-Join"><a href="#Hash-Join" class="headerlink" title="Hash Join"></a>Hash Join</h3><p>以一个简单的SQL语句为例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">		t1.<span class="operator">*</span></span><br><span class="line">		,t2.<span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">select</span></span><br><span class="line">                    <span class="operator">*</span></span><br><span class="line">            <span class="keyword">from</span>	<span class="keyword">order</span></span><br><span class="line">        ) t1</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">select</span></span><br><span class="line">                    <span class="operator">*</span></span><br><span class="line">            <span class="keyword">from</span>	item</span><br><span class="line">        ) t2</span><br><span class="line"><span class="keyword">on</span> t1.id<span class="operator">=</span>t2.id;</span><br></pre></td></tr></table></figure>

<p>参与join的两张表是<code>item</code>和<code>order</code>，join key分别是<code>item.id</code>以及<code>order.id</code>，假设这个Join采用的是Hash Join算法，整个过程会经历三步：</p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/webp-16318778783212-16318778797984.webp" alt="img"></p>
<ol>
<li>确定<strong>Build Table</strong>（映射表、小表）以及<strong>Probe Table</strong>（探查表、大表）。其中<strong>Build Table</strong>用于构建<strong>Hash Table</strong>，而<strong>Probe</strong>会遍历自身所有<strong>Key</strong>，映射到所生成的<strong>Hash Table</strong>上去匹配。</li>
<li><strong>Build Table</strong>构建<strong>Hash Table</strong>。依次读取<strong>Build Table</strong>（Item）的数据，对于每一行数据根据Join的<strong>key</strong>（item.id）进行<strong>hash</strong>，<strong>hash</strong>到对应的<strong>Bucket</strong>，生成<strong>hash table</strong>中的一条记录。数据缓存在内存中，如果内存放不下需要<strong>dump</strong>到外存。</li>
<li><strong>Probe Table</strong>探测。依次扫描<strong>Probe Table</strong>（order）的数据，使用相同的<strong>hash函数</strong>进行映射，如果成功<strong>映射到Hash Table</strong>之后，再<strong>检查join条件</strong>（item.id=order.id），如果匹配成功就可以将两者join在一起。</li>
</ol>
<p><strong>补充点</strong></p>
<blockquote>
<ol>
<li>Hash Join 的性能。从上面的原理图可以看出，hash join对两张表基本只扫描依次，**算法效率是O(a+b)*<em>，比起蛮力的笛卡尔积算法的a</em>b快了很多数量级。</li>
<li>Build Table要尽量选择小表：<ul>
<li>从原理上可以看出，构建的Hash Table是需要被频繁访问的，所以<strong>Hash Table最好能全部加载到内存中</strong></li>
<li>这也决定了Hash Table只适合至少一个小表join的场景</li>
</ul>
</li>
</ol>
</blockquote>
<p>上述介绍的Hash join 是在单机版中运行的join算法，而在大数据分布式情况下，目前成熟的有两套Hash Join算法：``broadcast hash join<code>和</code>shuffle hash join`</p>
<h4 id="Broadcast-Hash-Join"><a href="#Broadcast-Hash-Join" class="headerlink" title="Broadcast Hash Join"></a>Broadcast Hash Join</h4><p><code>broadcast hash join</code>是将其中一张小表广播分发到另一张大表所在的分区节点上，分别并发地与上的分区记录进行<code>hash join</code>。broadcast适用于小表很小，可以直接广播的场景。</p>
<p>需要注意的是，Spark中对于可以广播的小表，默认限制是10M以下。（参数是<code>spark.sql.autoBroadcastJoinThreshold</code>）</p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/webp-16318798352397-16318798366029.webp" alt="img"></p>
<p>在执行上，主要可以分为以下两步：</p>
<ol>
<li>broadcast阶段：将小表广播分发到大表所在的所有主机。分发方式可以是driver分发，或者是p2p的方式。</li>
<li>hash join阶段：在每个executor上执行单机版的hash join，<strong>小表映射，大表试探</strong></li>
</ol>
<h4 id="Shuffle-Hash-Join"><a href="#Shuffle-Hash-Join" class="headerlink" title="Shuffle Hash Join"></a>Shuffle Hash Join</h4><p>当join的一张表很小的时候，使用broadcast hash join，无疑效率最高。但是随着小表逐渐变大，广播所需内存，带宽等资源必然就会太大，所以才会有默认10M的资源限制。</p>
<p>所以，当小表逐渐变大时，就需要采用另一种Hash Join来处理：<code>Shuffle Hash Join</code>。</p>
<p><code>Shuffle Hash Join</code>按照join key进行分区，根据<strong>key相同必然分区相同的原理</strong>，将大表join分而治之，划分为小表的join，充分利用集群资源并行化执行。</p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/webp-163188039067910-163188039254812.webp" alt="img"></p>
<ol>
<li><strong>Shuffle阶段</strong><ul>
<li>分别将两个表按照join key进行分区，将相同join key的记录重分布到同一节点，两张表的数据会被分布到集群中所有节点。这个过程称为shuffle</li>
</ul>
</li>
<li><strong>Hash Join阶段</strong><ul>
<li>每个分区节点上的数据单独执行单机hash join算法</li>
</ul>
</li>
</ol>
<p>如果两张小表join，可以直接使用单机版的hash join；如果一张大表join一张极小表，可以选择broadcast hash join算法；而如果是一张大表join一张小表，小表不能广播超过10M了，则可以选择shuffle hash join算法；</p>
<p><strong>如果两张大表进行join呢？</strong></p>
<h3 id="Sort-Merge-Join"><a href="#Sort-Merge-Join" class="headerlink" title="Sort-Merge Join"></a>Sort-Merge Join</h3><p><strong>没有使用HashJoin，即单机join的时候，没有HashTable的生成。</strong></p>
<p>Spark SQL对两张大表join采用了全新的算法：Sort-Merge Join，整个过程分为三步步骤：</p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/webp-16319326499621-16319326513313.webp" alt="img"></p>
<ol>
<li><strong>Shuffle阶段</strong><ul>
<li>将两张大表根据join key进行重新分区，两张表数据会分布到整个集群，以便分布式并行处理</li>
</ul>
</li>
<li><strong>Sort阶段</strong><ul>
<li>对单个分区节点的两表数据，分别进行排序</li>
</ul>
</li>
<li><strong>Merge阶段</strong><ul>
<li>对排好序的两张分区表数据执行join操作。join操作很简单，分别遍历两个有序序列，碰到相同join key就merge输出，否则取更小一边，（<font color=red>类似于双指针合并两个有序序列</font>）,如下图所示：</li>
<li><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/webp-16319328669854-16319328684116.webp" alt="img"></li>
</ul>
</li>
</ol>
<p>仔细分析可以发现，Sort-Merge Join的单价并不比Shuffle hash join小，反而是多了排序。<strong>那么为什么SparkSQL还会在两张大表的场景下选择使用Sort-Merge Join算法呢？</strong></p>
<p>当Spark采用<strong>Sort Shuffle</strong>时，在经过Shuffle之后，Partition的数据都是按照key排序的，因此理论上可以认为数据经过Shuffle之后是不需要Sort的，可以直接Merge。</p>
<h3 id="Join时通过BloomFilter布隆过滤器进行-进行谓词下推"><a href="#Join时通过BloomFilter布隆过滤器进行-进行谓词下推" class="headerlink" title="Join时通过BloomFilter布隆过滤器进行 进行谓词下推"></a>Join时通过BloomFilter布隆过滤器进行 进行谓词下推</h3><p>谓词下推是将过滤条件从计算进程下推到存储进程先行执行，注意这里有两种类型进程：计算进程以及存储进程。计算与存储分离思想，这在大数据领域相当常见，比如最常见的计算进程有SparkSQL、Hive、impala等，负责SQL解析优化、数据计算聚合等，存储进程有HDFS（DataNode）、Kudu、HBase，负责数据存储。正常情况下应该是将所有数据从存储进程加载到计算进程，再进行过滤计算。谓词下推是说将一些过滤条件下推到存储进程，直接让存储进程将数据过滤掉。这样的好处显而易见，过滤的越早，数据量越少，序列化开销、网络开销、计算开销这一系列都会减少，性能自然会提高。</p>
<blockquote>
<p>在逻辑执行计划优化层面，比如SQL语句：select * from order ,item where item.id = order.item_id and item.category = ‘book’，正常情况语法解析之后应该是先执行Join操作，再执行Filter操作。通过谓词下推，可以将Filter操作下推到Join操作之前执行。即将where item.category = ‘book’下推到 item.id = order.item_id之前先行执行。</p>
</blockquote>
<h2 id="10-Spark源码分析"><a href="#10-Spark源码分析" class="headerlink" title="10. Spark源码分析"></a>10. Spark源码分析</h2><h3 id="1-环境准备（Yarn-集群）"><a href="#1-环境准备（Yarn-集群）" class="headerlink" title="1. 环境准备（Yarn 集群）"></a>1. 环境准备（Yarn 集群）</h3><p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210922152340903-16322954231991.png" alt="image-20210922152340903"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spark-submit.cmd脚本下最终会执行一个指令</span><br><span class="line"></span><br><span class="line">java org.apache.spark.deploy.SparkSubmit 执行</span><br></pre></td></tr></table></figure>

<p><strong>SparkSubmit.scala</strong></p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210922155639198-16322974007352.png" alt="image-20210922155639198"></p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210922155810394-16322974914213.png" alt="image-20210922155810394"></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doSubmit</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="comment">// Initialize logging if it hasn&#x27;t been done yet. Keep track of whether logging needs to</span></span><br><span class="line">  <span class="comment">// be reset before the application starts.</span></span><br><span class="line">  <span class="keyword">val</span> uninitLog = initializeLogIfNecessary(<span class="literal">true</span>, silent = <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> appArgs = parseArguments(args)   <span class="comment">// 解析参数</span></span><br><span class="line">  <span class="keyword">if</span> (appArgs.verbose) &#123;</span><br><span class="line">    logInfo(appArgs.toString)</span><br><span class="line">  &#125;</span><br><span class="line">  appArgs.action <span class="keyword">match</span> &#123;  <span class="comment">// 根据解析好的参数对象的action属性值，匹配具体的动作：是submit，还是kill，还是requestStatus，还是printVersion</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">SparkSubmitAction</span>.<span class="type">SUBMIT</span> =&gt; submit(appArgs, uninitLog)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">SparkSubmitAction</span>.<span class="type">KILL</span> =&gt; kill(appArgs)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">SparkSubmitAction</span>.<span class="type">REQUEST_STATUS</span> =&gt; requestStatus(appArgs)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">SparkSubmitAction</span>.<span class="type">PRINT_VERSION</span> =&gt; printVersion()</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// action的默认动作为SUBMIT</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210922160232506-16322977552994.png" alt="image-20210922160232506"></p>
<p>parse方法具体解析<code>spark-sumbit</code>脚本传过来的参数</p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210922160803410-16322980847205.png" alt="image-20210922160803410"></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@tailrec</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">submit</span></span>(args: <span class="type">SparkSubmitArguments</span>, uninitLog: <span class="type">Boolean</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">doRunMain</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.proxyUser != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> proxyUser = <span class="type">UserGroupInformation</span>.createProxyUser(args.proxyUser,</span><br><span class="line">                                                                 <span class="type">UserGroupInformation</span>.getCurrentUser())</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                proxyUser.doAs(<span class="keyword">new</span> <span class="type">PrivilegedExceptionAction</span>[<span class="type">Unit</span>]() &#123;</span><br><span class="line">                    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">                        runMain(args, uninitLog)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt;</span><br><span class="line">                <span class="comment">// Hadoop&#x27;s AuthorizationException suppresses the exception&#x27;s stack trace, which</span></span><br><span class="line">                <span class="comment">// makes the message printed to the output by the JVM not very helpful. Instead,</span></span><br><span class="line">                <span class="comment">// detect exceptions with empty stack traces here, and treat them differently.</span></span><br><span class="line">                <span class="keyword">if</span> (e.getStackTrace().length == <span class="number">0</span>) &#123;</span><br><span class="line">                    error(<span class="string">s&quot;ERROR: <span class="subst">$&#123;e.getClass().getName()&#125;</span>: <span class="subst">$&#123;e.getMessage()&#125;</span>&quot;</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            runMain(args, uninitLog)   <span class="comment">// 执行主程序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">runMain</span></span>(args: <span class="type">SparkSubmitArguments</span>, uninitLog: <span class="type">Boolean</span>): <span class="type">Unit</span> = </span><br><span class="line">    	<span class="comment">// 通过准备提交环境方法，模式匹配，返回四个参数，其中重要的是childMainClass</span></span><br><span class="line">        <span class="keyword">val</span> (childArgs, childClasspath, sparkConf, childMainClass) = prepareSubmitEnvironment(args)</span><br><span class="line">        <span class="comment">// Let the main class re-initialize the logging system once it starts.</span></span><br><span class="line">        <span class="keyword">if</span> (uninitLog) &#123;</span><br><span class="line">            <span class="type">Logging</span>.uninitialize()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (args.verbose) &#123;</span><br><span class="line">            logInfo(<span class="string">s&quot;Main class:\n<span class="subst">$childMainClass</span>&quot;</span>)</span><br><span class="line">            logInfo(<span class="string">s&quot;Arguments:\n<span class="subst">$&#123;childArgs.mkString(&quot;\n&quot;)&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="comment">// sysProps may contain sensitive information, so redact before printing</span></span><br><span class="line">            logInfo(<span class="string">s&quot;Spark config:\n<span class="subst">$&#123;Utils.redact(sparkConf.getAll.toMap).mkString(&quot;\n&quot;)&#125;</span>&quot;</span>)</span><br><span class="line">            logInfo(<span class="string">s&quot;Classpath elements:\n<span class="subst">$&#123;childClasspath.mkString(&quot;\n&quot;)&#125;</span>&quot;</span>)</span><br><span class="line">            logInfo(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> loader = getSubmitClassLoader(sparkConf)</span><br><span class="line">        <span class="keyword">for</span> (jar &lt;- childClasspath) &#123;</span><br><span class="line">            addJarToClasspath(jar, loader)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> mainClass: <span class="type">Class</span>[_] = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过上述返回的childMainClass，反射出具体的类</span></span><br><span class="line">            mainClass = <span class="type">Utils</span>.classForName(childMainClass)</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> e: <span class="type">ClassNotFoundException</span> =&gt;</span><br><span class="line">            logError(<span class="string">s&quot;Failed to load class <span class="subst">$childMainClass</span>.&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> (childMainClass.contains(<span class="string">&quot;thriftserver&quot;</span>)) &#123;</span><br><span class="line">                logInfo(<span class="string">s&quot;Failed to load main class <span class="subst">$childMainClass</span>.&quot;</span>)</span><br><span class="line">                logInfo(<span class="string">&quot;You need to build Spark with -Phive and -Phive-thriftserver.&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkUserAppException</span>(<span class="type">CLASS_NOT_FOUND_EXIT_STATUS</span>)</span><br><span class="line">            <span class="keyword">case</span> e: <span class="type">NoClassDefFoundError</span> =&gt;</span><br><span class="line">            logError(<span class="string">s&quot;Failed to load <span class="subst">$childMainClass</span>: <span class="subst">$&#123;e.getMessage()&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> (e.getMessage.contains(<span class="string">&quot;org/apache/hadoop/hive&quot;</span>)) &#123;</span><br><span class="line">                logInfo(<span class="string">s&quot;Failed to load hive class.&quot;</span>)</span><br><span class="line">                logInfo(<span class="string">&quot;You need to build Spark with -Phive and -Phive-thriftserver.&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkUserAppException</span>(<span class="type">CLASS_NOT_FOUND_EXIT_STATUS</span>)</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 判断childMainClass反射出的类是否继承了SparkApplication类，如果继承了直接返回该类的示例，如果没有继承，直接创建mainClass</span></span><br><span class="line">        <span class="keyword">val</span> app: <span class="type">SparkApplication</span> = <span class="keyword">if</span> (classOf[<span class="type">SparkApplication</span>].isAssignableFrom(mainClass)) &#123;</span><br><span class="line">            mainClass.getConstructor().newInstance().asInstanceOf[<span class="type">SparkApplication</span>]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="type">JavaMainApplication</span>(mainClass)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Following constants are visible for testing.</span></span><br><span class="line">  <span class="keyword">private</span>[deploy] <span class="keyword">val</span> <span class="type">YARN_CLUSTER_SUBMIT_CLASS</span> =</span><br><span class="line">    <span class="string">&quot;org.apache.spark.deploy.yarn.YarnClusterApplication&quot;</span>    </span><br><span class="line"></span><br><span class="line"><span class="comment">// In yarn-cluster mode, use yarn.Client as a wrapper around the user class</span></span><br><span class="line">    <span class="keyword">if</span> (isYarnCluster) &#123;</span><br><span class="line">      childMainClass = <span class="type">YARN_CLUSTER_SUBMIT_CLASS</span></span><br><span class="line">      <span class="keyword">if</span> (args.isPython) &#123;</span><br><span class="line">        childArgs += (<span class="string">&quot;--primary-py-file&quot;</span>, args.primaryResource)</span><br><span class="line">        childArgs += (<span class="string">&quot;--class&quot;</span>, <span class="string">&quot;org.apache.spark.deploy.PythonRunner&quot;</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (args.isR) &#123;</span><br><span class="line">        <span class="keyword">val</span> mainFile = <span class="keyword">new</span> <span class="type">Path</span>(args.primaryResource).getName</span><br><span class="line">        childArgs += (<span class="string">&quot;--primary-r-file&quot;</span>, mainFile)</span><br><span class="line">        childArgs += (<span class="string">&quot;--class&quot;</span>, <span class="string">&quot;org.apache.spark.deploy.RRunner&quot;</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.primaryResource != <span class="type">SparkLauncher</span>.<span class="type">NO_RESOURCE</span>) &#123;</span><br><span class="line">          childArgs += (<span class="string">&quot;--jar&quot;</span>, args.primaryResource)</span><br><span class="line">        &#125;</span><br><span class="line">        childArgs += (<span class="string">&quot;--class&quot;</span>, args.mainClass)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (args.childArgs != <span class="literal">null</span>) &#123;</span><br><span class="line">        args.childArgs.foreach &#123; arg =&gt; childArgs += (<span class="string">&quot;--arg&quot;</span>, arg) &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      app.start(childArgs.toArray, sparkConf)  <span class="comment">// org.apache.spark.deploy.yarn.YarnClusterApplication的start方法</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> t: <span class="type">Throwable</span> =&gt;</span><br><span class="line">        <span class="keyword">throw</span> findCause(t)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码中可以看出，最终<code>childMainClass=org.apache.spark.deploy.yarn.YarnClusterApplication</code></p>
<p><strong>Client类中</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[spark] <span class="class"><span class="keyword">class</span> <span class="title">YarnClusterApplication</span> <span class="keyword">extends</span> <span class="title">SparkApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">start</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>], conf: <span class="type">SparkConf</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// SparkSubmit would use yarn cache to distribute files &amp; jars in yarn mode,</span></span><br><span class="line">    <span class="comment">// so remove them from sparkConf here for yarn mode.</span></span><br><span class="line">    conf.remove(<span class="type">JARS</span>)</span><br><span class="line">    conf.remove(<span class="type">FILES</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="type">Client</span>(<span class="keyword">new</span> <span class="type">ClientArguments</span>(args), conf, <span class="literal">null</span>).run() <span class="comment">// 创建一个Client，并执行run方法</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">	<span class="comment">// amClass集群模式和Client模式下具体的取值</span></span><br><span class="line">    <span class="keyword">val</span> amClass =</span><br><span class="line">      <span class="keyword">if</span> (isClusterMode) &#123;</span><br><span class="line">        <span class="type">Utils</span>.classForName(<span class="string">&quot;org.apache.spark.deploy.yarn.ApplicationMaster&quot;</span>).getName</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Utils</span>.classForName(<span class="string">&quot;org.apache.spark.deploy.yarn.ExecutorLauncher&quot;</span>).getName</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> amArgs =</span><br><span class="line">      <span class="type">Seq</span>(amClass) ++ userClass ++ userJar ++ primaryPyFile ++ primaryRFile ++ userArgs ++</span><br><span class="line">      <span class="type">Seq</span>(<span class="string">&quot;--properties-file&quot;</span>,</span><br><span class="line">        buildPath(<span class="type">Environment</span>.<span class="type">PWD</span>.$$(), <span class="type">LOCALIZED_CONF_DIR</span>, <span class="type">SPARK_CONF_FILE</span>)) ++</span><br><span class="line">      <span class="type">Seq</span>(<span class="string">&quot;--dist-cache-conf&quot;</span>,</span><br><span class="line">        buildPath(<span class="type">Environment</span>.<span class="type">PWD</span>.$$(), <span class="type">LOCALIZED_CONF_DIR</span>, <span class="type">DIST_CACHE_CONF_FILE</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Command for the ApplicationMaster</span></span><br><span class="line">    <span class="keyword">val</span> commands = prefixEnv ++</span><br><span class="line">      <span class="type">Seq</span>(<span class="type">Environment</span>.<span class="type">JAVA_HOME</span>.$$() + <span class="string">&quot;/bin/java&quot;</span>, <span class="string">&quot;-server&quot;</span>) ++</span><br><span class="line">      javaOpts ++ amArgs ++</span><br><span class="line">      <span class="type">Seq</span>(</span><br><span class="line">        <span class="string">&quot;1&gt;&quot;</span>, <span class="type">ApplicationConstants</span>.<span class="type">LOG_DIR_EXPANSION_VAR</span> + <span class="string">&quot;/stdout&quot;</span>,</span><br><span class="line">        <span class="string">&quot;2&gt;&quot;</span>, <span class="type">ApplicationConstants</span>.<span class="type">LOG_DIR_EXPANSION_VAR</span> + <span class="string">&quot;/stderr&quot;</span>)</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> it would be nicer to just make sure there are no null commands here</span></span><br><span class="line">    <span class="keyword">val</span> printableCommands = commands.map(s =&gt; <span class="keyword">if</span> (s == <span class="literal">null</span>) <span class="string">&quot;null&quot;</span> <span class="keyword">else</span> s).toList</span><br><span class="line">    amContainer.setCommands(printableCommands.asJava)</span><br><span class="line"></span><br><span class="line">    logDebug(<span class="string">&quot;===============================================================================&quot;</span>)</span><br><span class="line">    logDebug(<span class="string">&quot;YARN AM launch context:&quot;</span>)</span><br><span class="line">    logDebug(<span class="string">s&quot;    user class: <span class="subst">$&#123;Option(args.userClass).getOrElse(&quot;N/A&quot;)&#125;</span>&quot;</span>)</span><br><span class="line">    logDebug(<span class="string">&quot;    env:&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled) &#123;</span><br><span class="line">      <span class="type">Utils</span>.redact(sparkConf, launchEnv.toSeq).foreach &#123; <span class="keyword">case</span> (k, v) =&gt;</span><br><span class="line">        logDebug(<span class="string">s&quot;        <span class="subst">$k</span> -&gt; <span class="subst">$v</span>&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    logDebug(<span class="string">&quot;    resources:&quot;</span>)</span><br><span class="line">    localResources.foreach &#123; <span class="keyword">case</span> (k, v) =&gt; logDebug(<span class="string">s&quot;        <span class="subst">$k</span> -&gt; <span class="subst">$v</span>&quot;</span>)&#125;</span><br><span class="line">    logDebug(<span class="string">&quot;    command:&quot;</span>)</span><br><span class="line">    logDebug(<span class="string">s&quot;        <span class="subst">$&#123;printableCommands.mkString(&quot; &quot;)&#125;</span>&quot;</span>)</span><br><span class="line">    logDebug(<span class="string">&quot;===============================================================================&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// send the acl settings into YARN to control who has access via YARN interfaces</span></span><br><span class="line">    <span class="keyword">val</span> securityManager = <span class="keyword">new</span> <span class="type">SecurityManager</span>(sparkConf)</span><br><span class="line">    amContainer.setApplicationACLs(</span><br><span class="line">      <span class="type">YarnSparkHadoopUtil</span>.getApplicationAclsForYarn(securityManager).asJava)</span><br><span class="line">    setupSecurityToken(amContainer)</span><br><span class="line">    amContainer</span><br></pre></td></tr></table></figure>



<p>ResourceManager接收命令，在可用的节点上启动<code>ApplicationMaster</code></p>
<p><strong>ApplicationMaster.scala</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="type">SignalUtils</span>.registerLogger(log)</span><br><span class="line">    <span class="keyword">val</span> amArgs = <span class="keyword">new</span> <span class="type">ApplicationMasterArguments</span>(args)</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line">    <span class="keyword">if</span> (amArgs.propertiesFile != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">Utils</span>.getPropertiesFromFile(amArgs.propertiesFile).foreach &#123; <span class="keyword">case</span> (k, v) =&gt;</span><br><span class="line">        sparkConf.set(k, v)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Set system properties for each config entry. This covers two use cases:</span></span><br><span class="line">    <span class="comment">// - The default configuration stored by the SparkHadoopUtil class</span></span><br><span class="line">    <span class="comment">// - The user application creating a new SparkConf in cluster mode</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Both cases create a new SparkConf object which reads these configs from system properties.</span></span><br><span class="line">    sparkConf.getAll.foreach &#123; <span class="keyword">case</span> (k, v) =&gt;</span><br><span class="line">      sys.props(k) = v</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> yarnConf = <span class="keyword">new</span> <span class="type">YarnConfiguration</span>(<span class="type">SparkHadoopUtil</span>.newConfiguration(sparkConf))</span><br><span class="line">    master = <span class="keyword">new</span> <span class="type">ApplicationMaster</span>(amArgs, sparkConf, yarnConf)  <span class="comment">// 创建ApplicationMaster</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> ugi = sparkConf.get(<span class="type">PRINCIPAL</span>) <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="comment">// We only need to log in with the keytab in cluster mode. In client mode, the driver</span></span><br><span class="line">      <span class="comment">// handles the user keytab.</span></span><br><span class="line">      <span class="keyword">case</span> <span class="type">Some</span>(principal) <span class="keyword">if</span> master.isClusterMode =&gt;</span><br><span class="line">        <span class="keyword">val</span> originalCreds = <span class="type">UserGroupInformation</span>.getCurrentUser().getCredentials()</span><br><span class="line">        <span class="type">SparkHadoopUtil</span>.get.loginUserFromKeytab(principal, sparkConf.get(<span class="type">KEYTAB</span>).orNull)</span><br><span class="line">        <span class="keyword">val</span> newUGI = <span class="type">UserGroupInformation</span>.getCurrentUser()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (master.appAttemptId == <span class="literal">null</span> || master.appAttemptId.getAttemptId &gt; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">// Re-obtain delegation tokens if this is not a first attempt, as they might be outdated</span></span><br><span class="line">          <span class="comment">// as of now. Add the fresh tokens on top of the original user&#x27;s credentials (overwrite).</span></span><br><span class="line">          <span class="comment">// Set the context class loader so that the token manager has access to jars</span></span><br><span class="line">          <span class="comment">// distributed by the user.</span></span><br><span class="line">          <span class="type">Utils</span>.withContextClassLoader(master.userClassLoader) &#123;</span><br><span class="line">            <span class="keyword">val</span> credentialManager = <span class="keyword">new</span> <span class="type">HadoopDelegationTokenManager</span>(sparkConf, yarnConf, <span class="literal">null</span>)</span><br><span class="line">            credentialManager.obtainDelegationTokens(originalCreds)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Transfer the original user&#x27;s tokens to the new user, since it may contain needed tokens</span></span><br><span class="line">        <span class="comment">// (such as those user to connect to YARN).</span></span><br><span class="line">        newUGI.addCredentials(originalCreds)</span><br><span class="line">        newUGI</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> _ =&gt;</span><br><span class="line">        <span class="type">SparkHadoopUtil</span>.get.createSparkUser()</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// master.run()  ApplicationMaster运行</span></span><br><span class="line">    ugi.doAs(<span class="keyword">new</span> <span class="type">PrivilegedExceptionAction</span>[<span class="type">Unit</span>]() &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(): <span class="type">Unit</span> = <span class="type">System</span>.exit(master.run())</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>[spark] <span class="function"><span class="keyword">def</span> <span class="title">sparkContextInitialized</span></span>(sc: <span class="type">SparkContext</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    master.sparkContextInitialized(sc)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>[spark] <span class="function"><span class="keyword">def</span> <span class="title">getAttemptId</span></span>(): <span class="type">ApplicationAttemptId</span> = &#123;</span><br><span class="line">    master.appAttemptId</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>[spark] <span class="function"><span class="keyword">def</span> <span class="title">getHistoryServerAddress</span></span>(</span><br><span class="line">      sparkConf: <span class="type">SparkConf</span>,</span><br><span class="line">      yarnConf: <span class="type">YarnConfiguration</span>,</span><br><span class="line">      appId: <span class="type">String</span>,</span><br><span class="line">      attemptId: <span class="type">String</span>): <span class="type">String</span> = &#123;</span><br><span class="line">    sparkConf.get(<span class="type">HISTORY_SERVER_ADDRESS</span>)</span><br><span class="line">      .map &#123; text =&gt; <span class="type">SparkHadoopUtil</span>.get.substituteHadoopVariables(text, yarnConf) &#125;</span><br><span class="line">      .map &#123; address =&gt; <span class="string">s&quot;<span class="subst">$&#123;address&#125;</span><span class="subst">$&#123;HistoryServer.UI_PATH_PREFIX&#125;</span>/<span class="subst">$&#123;appId&#125;</span>/<span class="subst">$&#123;attemptId&#125;</span>&quot;</span> &#125;</span><br><span class="line">      .getOrElse(<span class="string">&quot;&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>master.run()</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(): <span class="type">Int</span> = &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="keyword">val</span> attemptID = <span class="keyword">if</span> (isClusterMode) &#123;</span><br><span class="line">       <span class="comment">// Set the web ui port to be ephemeral for yarn so we don&#x27;t conflict with</span></span><br><span class="line">       <span class="comment">// other spark processes running on the same box</span></span><br><span class="line">       <span class="type">System</span>.setProperty(<span class="type">UI_PORT</span>.key, <span class="string">&quot;0&quot;</span>)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Set the master and deploy mode property to match the requested mode.</span></span><br><span class="line">       <span class="type">System</span>.setProperty(<span class="string">&quot;spark.master&quot;</span>, <span class="string">&quot;yarn&quot;</span>)</span><br><span class="line">       <span class="type">System</span>.setProperty(<span class="type">SUBMIT_DEPLOY_MODE</span>.key, <span class="string">&quot;cluster&quot;</span>)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Set this internal configuration if it is running on cluster mode, this</span></span><br><span class="line">       <span class="comment">// configuration will be checked in SparkContext to avoid misuse of yarn cluster mode.</span></span><br><span class="line">       <span class="type">System</span>.setProperty(<span class="string">&quot;spark.yarn.app.id&quot;</span>, appAttemptId.getApplicationId().toString())</span><br><span class="line"></span><br><span class="line">       <span class="type">Option</span>(appAttemptId.getAttemptId.toString)</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="type">None</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">new</span> <span class="type">CallerContext</span>(</span><br><span class="line">       <span class="string">&quot;APPMASTER&quot;</span>, sparkConf.get(<span class="type">APP_CALLER_CONTEXT</span>),</span><br><span class="line">       <span class="type">Option</span>(appAttemptId.getApplicationId.toString), attemptID).setCurrentContext()</span><br><span class="line"></span><br><span class="line">     logInfo(<span class="string">&quot;ApplicationAttemptId: &quot;</span> + appAttemptId)</span><br><span class="line"></span><br><span class="line">     <span class="comment">// This shutdown hook should run *after* the SparkContext is shut down.</span></span><br><span class="line">     <span class="keyword">val</span> priority = <span class="type">ShutdownHookManager</span>.<span class="type">SPARK_CONTEXT_SHUTDOWN_PRIORITY</span> - <span class="number">1</span></span><br><span class="line">     <span class="type">ShutdownHookManager</span>.addShutdownHook(priority) &#123; () =&gt;</span><br><span class="line">       <span class="keyword">val</span> maxAppAttempts = client.getMaxRegAttempts(sparkConf, yarnConf)</span><br><span class="line">       <span class="keyword">val</span> isLastAttempt = appAttemptId.getAttemptId() &gt;= maxAppAttempts</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!finished) &#123;</span><br><span class="line">         <span class="comment">// The default state of ApplicationMaster is failed if it is invoked by shut down hook.</span></span><br><span class="line">         <span class="comment">// This behavior is different compared to 1.x version.</span></span><br><span class="line">         <span class="comment">// If user application is exited ahead of time by calling System.exit(N), here mark</span></span><br><span class="line">         <span class="comment">// this application as failed with EXIT_EARLY. For a good shutdown, user shouldn&#x27;t call</span></span><br><span class="line">         <span class="comment">// System.exit(0) to terminate the application.</span></span><br><span class="line">         finish(finalStatus,</span><br><span class="line">           <span class="type">ApplicationMaster</span>.<span class="type">EXIT_EARLY</span>,</span><br><span class="line">           <span class="string">&quot;Shutdown hook called before final status was reported.&quot;</span>)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!unregistered) &#123;</span><br><span class="line">         <span class="comment">// we only want to unregister if we don&#x27;t want the RM to retry</span></span><br><span class="line">         <span class="keyword">if</span> (finalStatus == <span class="type">FinalApplicationStatus</span>.<span class="type">SUCCEEDED</span> || isLastAttempt) &#123;</span><br><span class="line">           unregister(finalStatus, finalMsg)</span><br><span class="line">           cleanupStagingDir(<span class="keyword">new</span> <span class="type">Path</span>(<span class="type">System</span>.getenv(<span class="string">&quot;SPARK_YARN_STAGING_DIR&quot;</span>)))</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="comment">// 集群模式下，运行runDriver()</span></span><br><span class="line">     <span class="keyword">if</span> (isClusterMode) &#123;</span><br><span class="line">       runDriver()</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 如果是Client模式运行 runExecutorLauncher()方法</span></span><br><span class="line">       runExecutorLauncher()</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">     <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt;</span><br><span class="line">       <span class="comment">// catch everything else if not specifically handled</span></span><br><span class="line">       logError(<span class="string">&quot;Uncaught exception: &quot;</span>, e)</span><br><span class="line">       finish(<span class="type">FinalApplicationStatus</span>.<span class="type">FAILED</span>,</span><br><span class="line">         <span class="type">ApplicationMaster</span>.<span class="type">EXIT_UNCAUGHT_EXCEPTION</span>,</span><br><span class="line">         <span class="string">&quot;Uncaught exception: &quot;</span> + <span class="type">StringUtils</span>.stringifyException(e))</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       metricsSystem.foreach &#123; ms =&gt;</span><br><span class="line">         ms.report()</span><br><span class="line">         ms.stop()</span><br><span class="line">       &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">       <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt;</span><br><span class="line">         logWarning(<span class="string">&quot;Exception during stopping of the metric system: &quot;</span>, e)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   exitCode</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><code>runDriver</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">runDriver</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">  addAmIpFilter(<span class="type">None</span>, <span class="type">System</span>.getenv(<span class="type">ApplicationConstants</span>.<span class="type">APPLICATION_WEB_PROXY_BASE_ENV</span>))</span><br><span class="line">  userClassThread = startUserApplication() <span class="comment">// 启动用户应用</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// This a bit hacky, but we need to wait until the spark.driver.port property has</span></span><br><span class="line">  <span class="comment">// been set by the Thread executing the user class.</span></span><br><span class="line">  logInfo(<span class="string">&quot;Waiting for spark context initialization...&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> totalWaitTime = sparkConf.get(<span class="type">AM_MAX_WAIT_TIME</span>)</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 等待上限文环境初始化成功后才可以往下运行：SparkContext</span></span><br><span class="line">    <span class="keyword">val</span> sc = <span class="type">ThreadUtils</span>.awaitResult(sparkContextPromise.future,</span><br><span class="line">      <span class="type">Duration</span>(totalWaitTime, <span class="type">TimeUnit</span>.<span class="type">MILLISECONDS</span>))</span><br><span class="line">    <span class="keyword">if</span> (sc != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">val</span> rpcEnv = sc.env.rpcEnv</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> userConf = sc.getConf</span><br><span class="line">      <span class="keyword">val</span> host = userConf.get(<span class="type">DRIVER_HOST_ADDRESS</span>)</span><br><span class="line">      <span class="keyword">val</span> port = userConf.get(<span class="type">DRIVER_PORT</span>)</span><br><span class="line">        <span class="comment">//ApplicationMaster 向ResourceManager进行注册（目的：通信，申请资源）</span></span><br><span class="line">      registerAM(host, port, userConf, sc.ui.map(_.webUrl), appAttemptId)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> driverRef = rpcEnv.setupEndpointRef(</span><br><span class="line">        <span class="type">RpcAddress</span>(host, port),</span><br><span class="line">        <span class="type">YarnSchedulerBackend</span>.<span class="type">ENDPOINT_NAME</span>)</span><br><span class="line">        <span class="comment">// ApplicationMaster向RM注册成功之后，RM会通过client给ApplicationMaster分配可用的资源</span></span><br><span class="line">      createAllocator(driverRef, userConf, rpcEnv, appAttemptId, distCacheConf)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Sanity check; should never happen in normal operation, since sc should only be null</span></span><br><span class="line">      <span class="comment">// if the user app did not create a SparkContext.</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">&quot;User did not initialize spark context!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    resumeDriver()</span><br><span class="line">    userClassThread.join()</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> e: <span class="type">SparkException</span> <span class="keyword">if</span> e.getCause().isInstanceOf[<span class="type">TimeoutException</span>] =&gt;</span><br><span class="line">      logError(</span><br><span class="line">        <span class="string">s&quot;SparkContext did not initialize after waiting for <span class="subst">$totalWaitTime</span> ms. &quot;</span> +</span><br><span class="line">         <span class="string">&quot;Please check earlier log output for errors. Failing the application.&quot;</span>)</span><br><span class="line">      finish(<span class="type">FinalApplicationStatus</span>.<span class="type">FAILED</span>,</span><br><span class="line">        <span class="type">ApplicationMaster</span>.<span class="type">EXIT_SC_NOT_INITED</span>,</span><br><span class="line">        <span class="string">&quot;Timed out waiting for SparkContext.&quot;</span>)</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    resumeDriver()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>startUserApplication</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">startUserApplication</span></span>(): <span class="type">Thread</span> = &#123;</span><br><span class="line">  logInfo(<span class="string">&quot;Starting the user application in a separate Thread&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> userArgs = args.userArgs</span><br><span class="line">  <span class="keyword">if</span> (args.primaryPyFile != <span class="literal">null</span> &amp;&amp; args.primaryPyFile.endsWith(<span class="string">&quot;.py&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// When running pyspark, the app is run using PythonRunner. The second argument is the list</span></span><br><span class="line">    <span class="comment">// of files to add to PYTHONPATH, which Client.scala already handles, so it&#x27;s empty.</span></span><br><span class="line">    userArgs = <span class="type">Seq</span>(args.primaryPyFile, <span class="string">&quot;&quot;</span>) ++ userArgs</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (args.primaryRFile != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">      (args.primaryRFile.endsWith(<span class="string">&quot;.R&quot;</span>) || args.primaryRFile.endsWith(<span class="string">&quot;.r&quot;</span>))) &#123;</span><br><span class="line">    <span class="comment">// TODO(davies): add R dependencies here</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用类加载器加载用户class，这个class就是Spark-submit时所指定的具体的class， 获取main方法</span></span><br><span class="line">  <span class="keyword">val</span> mainMethod = userClassLoader.loadClass(args.userClass)</span><br><span class="line">    .getMethod(<span class="string">&quot;main&quot;</span>, classOf[<span class="type">Array</span>[<span class="type">String</span>]])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> userThread = <span class="keyword">new</span> <span class="type">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="type">Modifier</span>.isStatic(mainMethod.getModifiers)) &#123;</span><br><span class="line">          logError(<span class="string">s&quot;Could not find static main method in object <span class="subst">$&#123;args.userClass&#125;</span>&quot;</span>)</span><br><span class="line">          finish(<span class="type">FinalApplicationStatus</span>.<span class="type">FAILED</span>, <span class="type">ApplicationMaster</span>.<span class="type">EXIT_EXCEPTION_USER_CLASS</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// invoke调用用户应用的main方法</span></span><br><span class="line">            <span class="comment">// 用户的应用程序运行时，就会初始化SparkContext</span></span><br><span class="line">          mainMethod.invoke(<span class="literal">null</span>, userArgs.toArray)</span><br><span class="line">          finish(<span class="type">FinalApplicationStatus</span>.<span class="type">SUCCEEDED</span>, <span class="type">ApplicationMaster</span>.<span class="type">EXIT_SUCCESS</span>)</span><br><span class="line">          logDebug(<span class="string">&quot;Done running user class&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> e: <span class="type">InvocationTargetException</span> =&gt;</span><br><span class="line">          e.getCause <span class="keyword">match</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> _: <span class="type">InterruptedException</span> =&gt;</span><br><span class="line">              <span class="comment">// Reporter thread can interrupt to stop user class</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">SparkUserAppException</span>(exitCode) =&gt;</span><br><span class="line">              <span class="keyword">val</span> msg = <span class="string">s&quot;User application exited with status <span class="subst">$exitCode</span>&quot;</span></span><br><span class="line">              logError(msg)</span><br><span class="line">              finish(<span class="type">FinalApplicationStatus</span>.<span class="type">FAILED</span>, exitCode, msg)</span><br><span class="line">            <span class="keyword">case</span> cause: <span class="type">Throwable</span> =&gt;</span><br><span class="line">              logError(<span class="string">&quot;User class threw exception: &quot;</span> + cause, cause)</span><br><span class="line">              finish(<span class="type">FinalApplicationStatus</span>.<span class="type">FAILED</span>,</span><br><span class="line">                <span class="type">ApplicationMaster</span>.<span class="type">EXIT_EXCEPTION_USER_CLASS</span>,</span><br><span class="line">                <span class="string">&quot;User class threw exception: &quot;</span> + <span class="type">StringUtils</span>.stringifyException(cause))</span><br><span class="line">          &#125;</span><br><span class="line">          sparkContextPromise.tryFailure(e.getCause())</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Notify the thread waiting for the SparkContext, in case the application did not</span></span><br><span class="line">        <span class="comment">// instantiate one. This will do nothing when the user code instantiates a SparkContext</span></span><br><span class="line">        <span class="comment">// (with the correct master), or when the user code throws an exception (due to the</span></span><br><span class="line">        <span class="comment">// tryFailure above).</span></span><br><span class="line">        sparkContextPromise.trySuccess(<span class="literal">null</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  userThread.setContextClassLoader(userClassLoader)</span><br><span class="line">  userThread.setName(<span class="string">&quot;Driver&quot;</span>)  <span class="comment">// 此处说明ApplicationMaster中创建了Driver子线程</span></span><br><span class="line">  userThread.start()</span><br><span class="line">  userThread</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>createAllocator</code>，RM向AM分配资源</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">createAllocator</span></span>(</span><br><span class="line">     driverRef: <span class="type">RpcEndpointRef</span>,</span><br><span class="line">     _sparkConf: <span class="type">SparkConf</span>,</span><br><span class="line">     rpcEnv: <span class="type">RpcEnv</span>,</span><br><span class="line">     appAttemptId: <span class="type">ApplicationAttemptId</span>,</span><br><span class="line">     distCacheConf: <span class="type">SparkConf</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">   <span class="comment">// In client mode, the AM may be restarting after delegation tokens have reached their TTL. So</span></span><br><span class="line">   <span class="comment">// always contact the driver to get the current set of valid tokens, so that local resources can</span></span><br><span class="line">   <span class="comment">// be initialized below.</span></span><br><span class="line">   <span class="keyword">if</span> (!isClusterMode) &#123;</span><br><span class="line">     <span class="keyword">val</span> tokens = driverRef.askSync[<span class="type">Array</span>[<span class="type">Byte</span>]](<span class="type">RetrieveDelegationTokens</span>)</span><br><span class="line">     <span class="keyword">if</span> (tokens != <span class="literal">null</span>) &#123;</span><br><span class="line">       <span class="type">SparkHadoopUtil</span>.get.addDelegationTokens(tokens, _sparkConf)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> appId = appAttemptId.getApplicationId().toString()</span><br><span class="line">   <span class="keyword">val</span> driverUrl = <span class="type">RpcEndpointAddress</span>(driverRef.address.host, driverRef.address.port,</span><br><span class="line">     <span class="type">CoarseGrainedSchedulerBackend</span>.<span class="type">ENDPOINT_NAME</span>).toString</span><br><span class="line">   <span class="keyword">val</span> localResources = prepareLocalResources(distCacheConf)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Before we initialize the allocator, let&#x27;s log the information about how executors will</span></span><br><span class="line">   <span class="comment">// be run up front, to avoid printing this out for every single executor being launched.</span></span><br><span class="line">   <span class="comment">// Use placeholders for information that changes such as executor IDs.</span></span><br><span class="line">   logInfo &#123;</span><br><span class="line">     <span class="keyword">val</span> executorMemory = _sparkConf.get(<span class="type">EXECUTOR_MEMORY</span>).toInt</span><br><span class="line">     <span class="keyword">val</span> executorCores = _sparkConf.get(<span class="type">EXECUTOR_CORES</span>)</span><br><span class="line">     <span class="keyword">val</span> dummyRunner = <span class="keyword">new</span> <span class="type">ExecutorRunnable</span>(<span class="type">None</span>, yarnConf, _sparkConf, driverUrl, <span class="string">&quot;&lt;executorId&gt;&quot;</span>,</span><br><span class="line">       <span class="string">&quot;&lt;hostname&gt;&quot;</span>, executorMemory, executorCores, appId, securityMgr, localResources,</span><br><span class="line">       <span class="type">ResourceProfile</span>.<span class="type">DEFAULT_RESOURCE_PROFILE_ID</span>)</span><br><span class="line">     dummyRunner.launchContextDebugInfo()</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//通过client，RM向ApplicationMaster分配可用的资源</span></span><br><span class="line">   allocator = client.createAllocator(</span><br><span class="line">     yarnConf,</span><br><span class="line">     _sparkConf,</span><br><span class="line">     appAttemptId,</span><br><span class="line">     driverUrl,</span><br><span class="line">     driverRef,</span><br><span class="line">     securityMgr,</span><br><span class="line">     localResources)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize the AM endpoint *after* the allocator has been initialized. This ensures</span></span><br><span class="line">   <span class="comment">// that when the driver sends an initial executor request (e.g. after an AM restart),</span></span><br><span class="line">   <span class="comment">// the allocator is ready to service requests.</span></span><br><span class="line">   rpcEnv.setupEndpoint(<span class="string">&quot;YarnAM&quot;</span>, <span class="keyword">new</span> <span class="type">AMEndpoint</span>(rpcEnv, driverRef))</span><br><span class="line"></span><br><span class="line">   allocator.allocateResources()</span><br><span class="line">   <span class="keyword">val</span> ms = <span class="type">MetricsSystem</span>.createMetricsSystem(<span class="type">MetricsSystemInstances</span>.<span class="type">APPLICATION_MASTER</span>,</span><br><span class="line">     sparkConf, securityMgr)</span><br><span class="line">   <span class="keyword">val</span> prefix = _sparkConf.get(<span class="type">YARN_METRICS_NAMESPACE</span>).getOrElse(appId)</span><br><span class="line">   ms.registerSource(<span class="keyword">new</span> <span class="type">ApplicationMasterSource</span>(prefix, allocator))</span><br><span class="line">   <span class="comment">// do not register static sources in this case as per SPARK-25277</span></span><br><span class="line">   ms.start(<span class="literal">false</span>)</span><br><span class="line">   metricsSystem = <span class="type">Some</span>(ms)</span><br><span class="line">   reporterThread = launchReporterThread()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>Container申请完成后启动相应的Container，</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Launches executors in the allocated containers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">runAllocatedContainers</span></span>(containersToUse: <span class="type">ArrayBuffer</span>[<span class="type">Container</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">for</span> (container &lt;- containersToUse) &#123;</span><br><span class="line">    executorIdCounter += <span class="number">1</span></span><br><span class="line">    <span class="keyword">val</span> executorHostname = container.getNodeId.getHost</span><br><span class="line">    <span class="keyword">val</span> containerId = container.getId</span><br><span class="line">    <span class="keyword">val</span> executorId = executorIdCounter.toString</span><br><span class="line">    assert(container.getResource.getMemory &gt;= resource.getMemory)</span><br><span class="line">    logInfo(<span class="string">s&quot;Launching container <span class="subst">$containerId</span> on host <span class="subst">$executorHostname</span> &quot;</span> +</span><br><span class="line">      <span class="string">s&quot;for executor with ID <span class="subst">$executorId</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">updateInternalState</span></span>(): <span class="type">Unit</span> = synchronized &#123;</span><br><span class="line">      runningExecutors.add(executorId)</span><br><span class="line">      numExecutorsStarting.decrementAndGet()</span><br><span class="line">      executorIdToContainer(executorId) = container</span><br><span class="line">      containerIdToExecutorId(container.getId) = executorId</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> containerSet = allocatedHostToContainersMap.getOrElseUpdate(executorHostname,</span><br><span class="line">        <span class="keyword">new</span> <span class="type">HashSet</span>[<span class="type">ContainerId</span>])</span><br><span class="line">      containerSet += containerId</span><br><span class="line">      allocatedContainerToHostMap.put(containerId, executorHostname)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (runningExecutors.size() &lt; targetNumExecutors) &#123;</span><br><span class="line">      numExecutorsStarting.incrementAndGet()</span><br><span class="line">      <span class="keyword">if</span> (launchContainers) &#123;</span><br><span class="line">          <span class="comment">// 通过线程池的方式运行Container</span></span><br><span class="line">        launcherPool.execute(() =&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// ExecutorRunnable是运行时具体要干些什么？</span></span><br><span class="line">            <span class="keyword">new</span> <span class="type">ExecutorRunnable</span>(</span><br><span class="line">              <span class="type">Some</span>(container),</span><br><span class="line">              conf,</span><br><span class="line">              sparkConf,</span><br><span class="line">              driverUrl,</span><br><span class="line">              executorId,</span><br><span class="line">              executorHostname,</span><br><span class="line">              executorMemory,</span><br><span class="line">              executorCores,</span><br><span class="line">              appAttemptId.getApplicationId.toString,</span><br><span class="line">              securityMgr,</span><br><span class="line">              localResources,</span><br><span class="line">              <span class="type">ResourceProfile</span>.<span class="type">DEFAULT_RESOURCE_PROFILE_ID</span> <span class="comment">// use until fully supported</span></span><br><span class="line">            ).run()<span class="comment">// run方法启动</span></span><br><span class="line">            updateInternalState()</span><br><span class="line">          &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> e: <span class="type">Throwable</span> =&gt;</span><br><span class="line">              numExecutorsStarting.decrementAndGet()</span><br><span class="line">              <span class="keyword">if</span> (<span class="type">NonFatal</span>(e)) &#123;</span><br><span class="line">                logError(<span class="string">s&quot;Failed to launch executor <span class="subst">$executorId</span> on container <span class="subst">$containerId</span>&quot;</span>, e)</span><br><span class="line">                <span class="comment">// Assigned container should be released immediately</span></span><br><span class="line">                <span class="comment">// to avoid unnecessary resource occupation.</span></span><br><span class="line">                amClient.releaseAssignedContainer(containerId)</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> e</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// For test only</span></span><br><span class="line">        updateInternalState()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      logInfo((<span class="string">&quot;Skip launching executorRunnable as running executors count: %d &quot;</span> +</span><br><span class="line">        <span class="string">&quot;reached target executors count: %d.&quot;</span>).format(</span><br><span class="line">        runningExecutors.size, targetNumExecutors))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>ExecutorRunnable</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">   logDebug(<span class="string">&quot;Starting Executor Container&quot;</span>)</span><br><span class="line">     <span class="comment">// 创建与NodeManager通信的Client客户端</span></span><br><span class="line">   nmClient = <span class="type">NMClient</span>.createNMClient()</span><br><span class="line">   nmClient.init(conf)</span><br><span class="line">   nmClient.start()</span><br><span class="line">     <span class="comment">//启动容器</span></span><br><span class="line">   startContainer()</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">startContainer</span></span>(): java.util.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">ByteBuffer</span>] = &#123;</span><br><span class="line">     <span class="comment">// 获取上下文环境</span></span><br><span class="line">   <span class="keyword">val</span> ctx = <span class="type">Records</span>.newRecord(classOf[<span class="type">ContainerLaunchContext</span>])</span><br><span class="line">     .asInstanceOf[<span class="type">ContainerLaunchContext</span>]</span><br><span class="line">     </span><br><span class="line">   <span class="keyword">val</span> env = prepareEnvironment().asJava</span><br><span class="line"></span><br><span class="line">   ctx.setLocalResources(localResources.asJava)</span><br><span class="line">   ctx.setEnvironment(env)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> credentials = <span class="type">UserGroupInformation</span>.getCurrentUser().getCredentials()</span><br><span class="line">   <span class="keyword">val</span> dob = <span class="keyword">new</span> <span class="type">DataOutputBuffer</span>()</span><br><span class="line">   credentials.writeTokenStorageToStream(dob)</span><br><span class="line">   ctx.setTokens(<span class="type">ByteBuffer</span>.wrap(dob.getData()))</span><br><span class="line"><span class="comment">// 准备命令</span></span><br><span class="line">   <span class="keyword">val</span> commands = prepareCommand()  <span class="comment">// 封装命令，并向相应的Container所在机器上 发送YarnCoarseGrandExecutorBackend</span></span><br><span class="line"></span><br><span class="line">   ctx.setCommands(commands.asJava)</span><br><span class="line">   ctx.setApplicationACLs(</span><br><span class="line">     <span class="type">YarnSparkHadoopUtil</span>.getApplicationAclsForYarn(securityMgr).asJava)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// If external shuffle service is enabled, register with the Yarn shuffle service already</span></span><br><span class="line">   <span class="comment">// started on the NodeManager and, if authentication is enabled, provide it with our secret</span></span><br><span class="line">   <span class="comment">// key for fetching shuffle files later</span></span><br><span class="line">   <span class="keyword">if</span> (sparkConf.get(<span class="type">SHUFFLE_SERVICE_ENABLED</span>)) &#123;</span><br><span class="line">     <span class="keyword">val</span> secretString = securityMgr.getSecretKey()</span><br><span class="line">     <span class="keyword">val</span> secretBytes =</span><br><span class="line">       <span class="keyword">if</span> (secretString != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">// This conversion must match how the YarnShuffleService decodes our secret</span></span><br><span class="line">         <span class="type">JavaUtils</span>.stringToBytes(secretString)</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// Authentication is not enabled, so just provide dummy metadata</span></span><br><span class="line">         <span class="type">ByteBuffer</span>.allocate(<span class="number">0</span>)</span><br><span class="line">       &#125;</span><br><span class="line">     ctx.setServiceData(<span class="type">Collections</span>.singletonMap(<span class="string">&quot;spark_shuffle&quot;</span>, secretBytes))</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Send the start request to the ContainerManager</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     nmClient.startContainer(container.get, ctx)</span><br><span class="line">   &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">     <span class="keyword">case</span> ex: <span class="type">Exception</span> =&gt;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(<span class="string">s&quot;Exception while starting container <span class="subst">$&#123;container.get.getId&#125;</span>&quot;</span> +</span><br><span class="line">         <span class="string">s&quot; on host <span class="subst">$hostname</span>&quot;</span>, ex)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">prepareCommand</span></span>(): <span class="type">List</span>[<span class="type">String</span>] = &#123;</span><br><span class="line">   <span class="comment">// Extra options for the JVM</span></span><br><span class="line">   <span class="keyword">val</span> javaOpts = <span class="type">ListBuffer</span>[<span class="type">String</span>]()</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Set the JVM memory</span></span><br><span class="line">   <span class="keyword">val</span> executorMemoryString = executorMemory + <span class="string">&quot;m&quot;</span></span><br><span class="line">   javaOpts += <span class="string">&quot;-Xmx&quot;</span> + executorMemoryString</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Set extra Java options for the executor, if defined</span></span><br><span class="line">   sparkConf.get(<span class="type">EXECUTOR_JAVA_OPTIONS</span>).foreach &#123; opts =&gt;</span><br><span class="line">     <span class="keyword">val</span> subsOpt = <span class="type">Utils</span>.substituteAppNExecIds(opts, appId, executorId)</span><br><span class="line">     javaOpts ++= <span class="type">Utils</span>.splitCommandString(subsOpt).map(<span class="type">YarnSparkHadoopUtil</span>.escapeForShell)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Set the library path through a command prefix to append to the existing value of the</span></span><br><span class="line">   <span class="comment">// env variable.</span></span><br><span class="line">   <span class="keyword">val</span> prefixEnv = sparkConf.get(<span class="type">EXECUTOR_LIBRARY_PATH</span>).map &#123; libPath =&gt;</span><br><span class="line">     <span class="type">Client</span>.createLibraryPathPrefix(libPath, sparkConf)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   javaOpts += <span class="string">&quot;-Djava.io.tmpdir=&quot;</span> +</span><br><span class="line">     <span class="keyword">new</span> <span class="type">Path</span>(<span class="type">Environment</span>.<span class="type">PWD</span>.$$(), <span class="type">YarnConfiguration</span>.<span class="type">DEFAULT_CONTAINER_TEMP_DIR</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Certain configs need to be passed here because they are needed before the Executor</span></span><br><span class="line">   <span class="comment">// registers with the Scheduler and transfers the spark configs. Since the Executor backend</span></span><br><span class="line">   <span class="comment">// uses RPC to connect to the scheduler, the RPC settings are needed as well as the</span></span><br><span class="line">   <span class="comment">// authentication settings.</span></span><br><span class="line">   sparkConf.getAll</span><br><span class="line">     .filter &#123; <span class="keyword">case</span> (k, v) =&gt; <span class="type">SparkConf</span>.isExecutorStartupConf(k) &#125;</span><br><span class="line">     .foreach &#123; <span class="keyword">case</span> (k, v) =&gt; javaOpts += <span class="type">YarnSparkHadoopUtil</span>.escapeForShell(<span class="string">s&quot;-D<span class="subst">$k</span>=<span class="subst">$v</span>&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Commenting it out for now - so that people can refer to the properties if required. Remove</span></span><br><span class="line">   <span class="comment">// it once cpuset version is pushed out.</span></span><br><span class="line">   <span class="comment">// The context is, default gc for server class machines end up using all cores to do gc - hence</span></span><br><span class="line">   <span class="comment">// if there are multiple containers in same node, spark gc effects all other containers</span></span><br><span class="line">   <span class="comment">// performance (which can also be other spark containers)</span></span><br><span class="line">   <span class="comment">// Instead of using this, rely on cpusets by YARN to enforce spark behaves &#x27;properly&#x27; in</span></span><br><span class="line">   <span class="comment">// multi-tenant environments. Not sure how default java gc behaves if it is limited to subset</span></span><br><span class="line">   <span class="comment">// of cores on a node.</span></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">       else &#123;</span></span><br><span class="line"><span class="comment">         // If no java_opts specified, default to using -XX:+CMSIncrementalMode</span></span><br><span class="line"><span class="comment">         // It might be possible that other modes/config is being done in</span></span><br><span class="line"><span class="comment">         // spark.executor.extraJavaOptions, so we don&#x27;t want to mess with it.</span></span><br><span class="line"><span class="comment">         // In our expts, using (default) throughput collector has severe perf ramifications in</span></span><br><span class="line"><span class="comment">         // multi-tenant machines</span></span><br><span class="line"><span class="comment">         // The options are based on</span></span><br><span class="line"><span class="comment">         // http://www.oracle.com/technetwork/java/gc-tuning-5-138395.html#0.0.0.%20When%20to%20Use</span></span><br><span class="line"><span class="comment">         // %20the%20Concurrent%20Low%20Pause%20Collector|outline</span></span><br><span class="line"><span class="comment">         javaOpts += &quot;-XX:+UseConcMarkSweepGC&quot;</span></span><br><span class="line"><span class="comment">         javaOpts += &quot;-XX:+CMSIncrementalMode&quot;</span></span><br><span class="line"><span class="comment">         javaOpts += &quot;-XX:+CMSIncrementalPacing&quot;</span></span><br><span class="line"><span class="comment">         javaOpts += &quot;-XX:CMSIncrementalDutyCycleMin=0&quot;</span></span><br><span class="line"><span class="comment">         javaOpts += &quot;-XX:CMSIncrementalDutyCycle=10&quot;</span></span><br><span class="line"><span class="comment">       &#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// For log4j configuration to reference</span></span><br><span class="line">   javaOpts += (<span class="string">&quot;-Dspark.yarn.app.container.log.dir=&quot;</span> + <span class="type">ApplicationConstants</span>.<span class="type">LOG_DIR_EXPANSION_VAR</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> userClassPath = <span class="type">Client</span>.getUserClasspath(sparkConf).flatMap &#123; uri =&gt;</span><br><span class="line">     <span class="keyword">val</span> absPath =</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">new</span> <span class="type">File</span>(uri.getPath()).isAbsolute()) &#123;</span><br><span class="line">         <span class="type">Client</span>.getClusterPath(sparkConf, uri.getPath())</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="type">Client</span>.buildPath(<span class="type">Environment</span>.<span class="type">PWD</span>.$(), uri.getPath())</span><br><span class="line">       &#125;</span><br><span class="line">     <span class="type">Seq</span>(<span class="string">&quot;--user-class-path&quot;</span>, <span class="string">&quot;file:&quot;</span> + absPath)</span><br><span class="line">   &#125;.toSeq</span><br><span class="line"></span><br><span class="line">   <span class="type">YarnSparkHadoopUtil</span>.addOutOfMemoryErrorArgument(javaOpts)</span><br><span class="line">   <span class="keyword">val</span> commands = prefixEnv ++</span><br><span class="line">     <span class="type">Seq</span>(<span class="type">Environment</span>.<span class="type">JAVA_HOME</span>.$$() + <span class="string">&quot;/bin/java&quot;</span>, <span class="string">&quot;-server&quot;</span>) ++</span><br><span class="line">     javaOpts ++</span><br><span class="line">     <span class="type">Seq</span>(<span class="string">&quot;org.apache.spark.executor.YarnCoarseGrainedExecutorBackend&quot;</span>,</span><br><span class="line">       <span class="string">&quot;--driver-url&quot;</span>, masterAddress,</span><br><span class="line">       <span class="string">&quot;--executor-id&quot;</span>, executorId,</span><br><span class="line">       <span class="string">&quot;--hostname&quot;</span>, hostname,</span><br><span class="line">       <span class="string">&quot;--cores&quot;</span>, executorCores.toString,</span><br><span class="line">       <span class="string">&quot;--app-id&quot;</span>, appId,</span><br><span class="line">       <span class="string">&quot;--resourceProfileId&quot;</span>, resourceProfileId.toString) ++</span><br><span class="line">     userClassPath ++</span><br><span class="line">     <span class="type">Seq</span>(</span><br><span class="line">       <span class="string">s&quot;1&gt;<span class="subst">$&#123;ApplicationConstants.LOG_DIR_EXPANSION_VAR&#125;</span>/stdout&quot;</span>,</span><br><span class="line">       <span class="string">s&quot;2&gt;<span class="subst">$&#123;ApplicationConstants.LOG_DIR_EXPANSION_VAR&#125;</span>/stderr&quot;</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// <span class="doctag">TODO:</span> it would be nicer to just make sure there are no null commands here</span></span><br><span class="line">   commands.map(s =&gt; <span class="keyword">if</span> (s == <span class="literal">null</span>) <span class="string">&quot;null&quot;</span> <span class="keyword">else</span> s).toList</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>AM封装指令<code>bin/java org.apache.spark.executor.YarnCoarseGrainedExecutorBackend</code>到Container所在资源中，启动YarnCoarseGrainedExecutorBackend。</p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/spark1%E6%BA%90%E7%A0%81-16328806267071.png" alt="spark1源码"></p>
<h3 id="2-组件通信"><a href="#2-组件通信" class="headerlink" title="2. 组件通信"></a>2. 组件通信</h3><blockquote>
<p><strong>BIO：阻塞式IO</strong></p>
<p><strong>NIO：非阻塞式IO</strong></p>
<p><strong>AIO：异步非阻塞式IO</strong></p>
<p>Linux对AIO支持不够好，Windows对AIO支持的好</p>
<p>Linux采用Epoll方式模仿AIO操作</p>
</blockquote>
<img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86.png" style="zoom:80%;" />



<p>Spark基于Netty新的Rpc框架，借鉴了Akka中的设计，基于Actor模型。</p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/webp-16328829051882-16328829071034.webp" alt="img"></p>
<blockquote>
<p>每个Endpoint（Client/Master/Worker）有<strong>1个InBox收件箱</strong>和<strong>N个OutBox发件箱</strong>（N&gt;=1，N取决于当前Endpoint与多少其他的endpoint进行通讯，一个与其通讯的其他Endpoint对应一个OutBox），EndPoint接收到的消息被写入InBox，发送出去的消息写入OutBox并发送其他Endpoint的InBox中</p>
</blockquote>
<p>Driver端：<code>class DriverEndpoint extends IsolatedRpcEndpoint</code></p>
<p>Executor端：<code>class CoarseGrainedExecutorBackend extends IsolatedRpcEndpoint</code></p>
<h3 id="3-应用程序的执行"><a href="#3-应用程序的执行" class="headerlink" title="3. 应用程序的执行"></a>3. 应用程序的执行</h3><p>Driver中执行用户上传的作业，其中首要的是初始化SparkContext对象。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Main entry point for Spark functionality. A SparkContext represents the connection to a Spark</span></span><br><span class="line"><span class="comment"> * cluster, and can be used to create RDDs, accumulators and broadcast variables on that cluster.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @note Only one `SparkContext` should be active per JVM. You must `stop()` the</span></span><br><span class="line"><span class="comment"> *   active `SparkContext` before creating a new one.</span></span><br><span class="line"><span class="comment"> * @param config a Spark Config object describing the application configuration. Any settings in</span></span><br><span class="line"><span class="comment"> *   this config overrides the default configs as well as system properties.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SparkContext</span>(<span class="params">config: <span class="type">SparkConf</span></span>) <span class="keyword">extends</span> <span class="title">Logging</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The call site where this SparkContext was constructed.</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> creationSite: <span class="type">CallSite</span> = <span class="type">Utils</span>.getCallSite()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!config.get(<span class="type">EXECUTOR_ALLOW_SPARK_CONTEXT</span>)) &#123;</span><br><span class="line">    <span class="comment">// In order to prevent SparkContext from being created in executors.</span></span><br><span class="line">    <span class="type">SparkContext</span>.assertOnDriver()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// In order to prevent multiple SparkContexts from being active at the same time, mark this</span></span><br><span class="line">  <span class="comment">// context as having started construction.</span></span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> this must be placed at the beginning of the SparkContext constructor.</span></span><br><span class="line">  <span class="type">SparkContext</span>.markPartiallyConstructed(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> startTime = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>[spark] <span class="keyword">val</span> stopped: <span class="type">AtomicBoolean</span> = <span class="keyword">new</span> <span class="type">AtomicBoolean</span>(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>[spark] <span class="function"><span class="keyword">def</span> <span class="title">assertNotStopped</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (stopped.get()) &#123;</span><br><span class="line">      <span class="keyword">val</span> activeContext = <span class="type">SparkContext</span>.activeContext.get()</span><br><span class="line">      <span class="keyword">val</span> activeCreationSite =</span><br><span class="line">        <span class="keyword">if</span> (activeContext == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="string">&quot;(No active SparkContext.)&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          activeContext.creationSite.longForm</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(</span><br><span class="line">        <span class="string">s&quot;&quot;</span><span class="string">&quot;Cannot call methods on a stopped SparkContext.</span></span><br><span class="line"><span class="string">           |This stopped SparkContext was created at:</span></span><br><span class="line"><span class="string">           |</span></span><br><span class="line"><span class="string">           |$&#123;creationSite.longForm&#125;</span></span><br><span class="line"><span class="string">           |</span></span><br><span class="line"><span class="string">           |The currently active SparkContext was created at:</span></span><br><span class="line"><span class="string">           |</span></span><br><span class="line"><span class="string">           |$activeCreationSite</span></span><br><span class="line"><span class="string">         &quot;</span><span class="string">&quot;&quot;</span>.stripMargin)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Create a SparkContext that loads settings from system properties (for instance, when</span></span><br><span class="line"><span class="comment">   * launching with ./bin/spark-submit).</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>() = <span class="keyword">this</span>(<span class="keyword">new</span> <span class="type">SparkConf</span>())</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Alternative constructor that allows setting common Spark properties directly</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param master Cluster URL to connect to (e.g. mesos://host:port, spark://host:port, local[4]).</span></span><br><span class="line"><span class="comment">   * @param appName A name for your application, to display on the cluster web UI</span></span><br><span class="line"><span class="comment">   * @param conf a [[org.apache.spark.SparkConf]] object specifying other Spark parameters</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(master: <span class="type">String</span>, appName: <span class="type">String</span>, conf: <span class="type">SparkConf</span>) =</span><br><span class="line">    <span class="keyword">this</span>(<span class="type">SparkContext</span>.updatedConf(conf, master, appName))</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Alternative constructor that allows setting common Spark properties directly</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param master Cluster URL to connect to (e.g. mesos://host:port, spark://host:port, local[4]).</span></span><br><span class="line"><span class="comment">   * @param appName A name for your application, to display on the cluster web UI.</span></span><br><span class="line"><span class="comment">   * @param sparkHome Location where Spark is installed on cluster nodes.</span></span><br><span class="line"><span class="comment">   * @param jars Collection of JARs to send to the cluster. These can be paths on the local file</span></span><br><span class="line"><span class="comment">   *             system or HDFS, HTTP, HTTPS, or FTP URLs.</span></span><br><span class="line"><span class="comment">   * @param environment Environment variables to set on worker nodes.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(</span><br><span class="line">      master: <span class="type">String</span>,</span><br><span class="line">      appName: <span class="type">String</span>,</span><br><span class="line">      sparkHome: <span class="type">String</span> = <span class="literal">null</span>,</span><br><span class="line">      jars: <span class="type">Seq</span>[<span class="type">String</span>] = <span class="type">Nil</span>,</span><br><span class="line">      environment: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">String</span>] = <span class="type">Map</span>()) = &#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="type">SparkContext</span>.updatedConf(<span class="keyword">new</span> <span class="type">SparkConf</span>(), master, appName, sparkHome, jars, environment))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The following constructors are required when Java code accesses SparkContext directly.</span></span><br><span class="line">  <span class="comment">// Please see SI-4278</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Alternative constructor that allows setting common Spark properties directly</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param master Cluster URL to connect to (e.g. mesos://host:port, spark://host:port, local[4]).</span></span><br><span class="line"><span class="comment">   * @param appName A name for your application, to display on the cluster web UI.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span>[spark] <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(master: <span class="type">String</span>, appName: <span class="type">String</span>) =</span><br><span class="line">    <span class="keyword">this</span>(master, appName, <span class="literal">null</span>, <span class="type">Nil</span>, <span class="type">Map</span>())</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Alternative constructor that allows setting common Spark properties directly</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param master Cluster URL to connect to (e.g. mesos://host:port, spark://host:port, local[4]).</span></span><br><span class="line"><span class="comment">   * @param appName A name for your application, to display on the cluster web UI.</span></span><br><span class="line"><span class="comment">   * @param sparkHome Location where Spark is installed on cluster nodes.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span>[spark] <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(master: <span class="type">String</span>, appName: <span class="type">String</span>, sparkHome: <span class="type">String</span>) =</span><br><span class="line">    <span class="keyword">this</span>(master, appName, sparkHome, <span class="type">Nil</span>, <span class="type">Map</span>())</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Alternative constructor that allows setting common Spark properties directly</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param master Cluster URL to connect to (e.g. mesos://host:port, spark://host:port, local[4]).</span></span><br><span class="line"><span class="comment">   * @param appName A name for your application, to display on the cluster web UI.</span></span><br><span class="line"><span class="comment">   * @param sparkHome Location where Spark is installed on cluster nodes.</span></span><br><span class="line"><span class="comment">   * @param jars Collection of JARs to send to the cluster. These can be paths on the local file</span></span><br><span class="line"><span class="comment">   *             system or HDFS, HTTP, HTTPS, or FTP URLs.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span>[spark] <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(master: <span class="type">String</span>, appName: <span class="type">String</span>, sparkHome: <span class="type">String</span>, jars: <span class="type">Seq</span>[<span class="type">String</span>]) =</span><br><span class="line">    <span class="keyword">this</span>(master, appName, sparkHome, jars, <span class="type">Map</span>())</span><br><span class="line"></span><br><span class="line">  <span class="comment">// log out Spark Version in Spark driver log</span></span><br><span class="line">  logInfo(<span class="string">s&quot;Running Spark version <span class="subst">$SPARK_VERSION</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ------------------------------------------------------------------------------------- *</span></span><br><span class="line"><span class="comment">   | Private variables. These variables keep the internal state of the context, and are    |</span></span><br><span class="line"><span class="comment">   | not accessible by the outside world. They&#x27;re mutable since we want to initialize all  |</span></span><br><span class="line"><span class="comment">   | of them to some neutral value ahead of time, so that calling &quot;stop()&quot; while the       |</span></span><br><span class="line"><span class="comment">   | constructor is still running is safe.                                                 |</span></span><br><span class="line"><span class="comment">   * ------------------------------------------------------------------------------------- */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _conf: <span class="type">SparkConf</span> = _</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _eventLogDir: <span class="type">Option</span>[<span class="type">URI</span>] = <span class="type">None</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _eventLogCodec: <span class="type">Option</span>[<span class="type">String</span>] = <span class="type">None</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _listenerBus: <span class="type">LiveListenerBus</span> = _</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _env: <span class="type">SparkEnv</span> = _</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _statusTracker: <span class="type">SparkStatusTracker</span> = _</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _progressBar: <span class="type">Option</span>[<span class="type">ConsoleProgressBar</span>] = <span class="type">None</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _ui: <span class="type">Option</span>[<span class="type">SparkUI</span>] = <span class="type">None</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _hadoopConfiguration: <span class="type">Configuration</span> = _</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _executorMemory: <span class="type">Int</span> = _</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _schedulerBackend: <span class="type">SchedulerBackend</span> = _</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _taskScheduler: <span class="type">TaskScheduler</span> = _</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _heartbeatReceiver: <span class="type">RpcEndpointRef</span> = _</span><br><span class="line">  <span class="meta">@volatile</span> <span class="keyword">private</span> <span class="keyword">var</span> _dagScheduler: <span class="type">DAGScheduler</span> = _</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _applicationId: <span class="type">String</span> = _</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _applicationAttemptId: <span class="type">Option</span>[<span class="type">String</span>] = <span class="type">None</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _eventLogger: <span class="type">Option</span>[<span class="type">EventLoggingListener</span>] = <span class="type">None</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _driverLogger: <span class="type">Option</span>[<span class="type">DriverLogger</span>] = <span class="type">None</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _executorAllocationManager: <span class="type">Option</span>[<span class="type">ExecutorAllocationManager</span>] = <span class="type">None</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _cleaner: <span class="type">Option</span>[<span class="type">ContextCleaner</span>] = <span class="type">None</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _listenerBusStarted: <span class="type">Boolean</span> = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _jars: <span class="type">Seq</span>[<span class="type">String</span>] = _</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _files: <span class="type">Seq</span>[<span class="type">String</span>] = _</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _archives: <span class="type">Seq</span>[<span class="type">String</span>] = _</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _shutdownHookRef: <span class="type">AnyRef</span> = _</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _statusStore: <span class="type">AppStatusStore</span> = _</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _heartbeater: <span class="type">Heartbeater</span> = _</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _resources: immutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">ResourceInformation</span>] = _</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _shuffleDriverComponents: <span class="type">ShuffleDriverComponents</span> = _</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _plugins: <span class="type">Option</span>[<span class="type">PluginContainer</span>] = <span class="type">None</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _resourceProfileManager: <span class="type">ResourceProfileManager</span> = _</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ------------------------------------------------------------------------------------- *</span></span><br><span class="line"><span class="comment">   | Accessors and public fields. These provide access to the internal state of the        |</span></span><br><span class="line"><span class="comment">   | context.                                                                              |</span></span><br><span class="line"><span class="comment">   * ------------------------------------------------------------------------------------- */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>[spark] <span class="function"><span class="keyword">def</span> <span class="title">conf</span></span>: <span class="type">SparkConf</span> = _conf</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Return a copy of this SparkContext&#x27;s configuration. The configuration &#x27;&#x27;cannot&#x27;&#x27; be</span></span><br><span class="line"><span class="comment">   * changed at runtime.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getConf</span></span>: <span class="type">SparkConf</span> = conf.clone()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">resources</span></span>: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">ResourceInformation</span>] = _resources</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">jars</span></span>: <span class="type">Seq</span>[<span class="type">String</span>] = _jars</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">files</span></span>: <span class="type">Seq</span>[<span class="type">String</span>] = _files</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">archives</span></span>: <span class="type">Seq</span>[<span class="type">String</span>] = _archives</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">master</span></span>: <span class="type">String</span> = _conf.get(<span class="string">&quot;spark.master&quot;</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">deployMode</span></span>: <span class="type">String</span> = _conf.get(<span class="type">SUBMIT_DEPLOY_MODE</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">appName</span></span>: <span class="type">String</span> = _conf.get(<span class="string">&quot;spark.app.name&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>[spark] <span class="function"><span class="keyword">def</span> <span class="title">isEventLogEnabled</span></span>: <span class="type">Boolean</span> = _conf.get(<span class="type">EVENT_LOG_ENABLED</span>)</span><br><span class="line">  <span class="keyword">private</span>[spark] <span class="function"><span class="keyword">def</span> <span class="title">eventLogDir</span></span>: <span class="type">Option</span>[<span class="type">URI</span>] = _eventLogDir</span><br><span class="line">  <span class="keyword">private</span>[spark] <span class="function"><span class="keyword">def</span> <span class="title">eventLogCodec</span></span>: <span class="type">Option</span>[<span class="type">String</span>] = _eventLogCodec</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isLocal</span></span>: <span class="type">Boolean</span> = <span class="type">Utils</span>.isLocalMaster(_conf)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @return true if context is stopped or in the midst of stopping.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isStopped</span></span>: <span class="type">Boolean</span> = stopped.get()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>[spark] <span class="function"><span class="keyword">def</span> <span class="title">statusStore</span></span>: <span class="type">AppStatusStore</span> = _statusStore</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An asynchronous listener bus for Spark events</span></span><br><span class="line">  <span class="keyword">private</span>[spark] <span class="function"><span class="keyword">def</span> <span class="title">listenerBus</span></span>: <span class="type">LiveListenerBus</span> = _listenerBus</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This function allows components created by SparkEnv to be mocked in unit tests:</span></span><br><span class="line">  <span class="keyword">private</span>[spark] <span class="function"><span class="keyword">def</span> <span class="title">createSparkEnv</span></span>(</span><br><span class="line">      conf: <span class="type">SparkConf</span>,</span><br><span class="line">      isLocal: <span class="type">Boolean</span>,</span><br><span class="line">      listenerBus: <span class="type">LiveListenerBus</span>): <span class="type">SparkEnv</span> = &#123;</span><br><span class="line">    <span class="type">SparkEnv</span>.createDriverEnv(conf, isLocal, listenerBus, <span class="type">SparkContext</span>.numDriverCores(master, conf))</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>SparkContext</strong>中的几个重要的字段属性<ul>
<li> <strong>SparkConf</strong>：配置对象</li>
<li>基础的环境配置</li>
<li><strong>SparkEnv</strong>：环境对象<ul>
<li>通信环境</li>
</ul>
</li>
<li><strong>SchedulerBackend</strong>：通信后台<ul>
<li>主要用于和Executor之间进行通信</li>
</ul>
</li>
<li><strong>TaskScheduler</strong>：任务调度器<ul>
<li>主要用于任务的调度</li>
</ul>
</li>
<li><strong>DAGScheduler</strong>：节点调度器<ul>
<li>主要用于阶段的划分以及任务的切分</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1-RDD依赖"><a href="#1-RDD依赖" class="headerlink" title="1. RDD依赖"></a>1. RDD依赖</h4><p>源码显示，RDD的依赖父类是<code>Dependency</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeveloperApi</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NarrowDependency</span>[<span class="type">T</span>](<span class="params">_rdd: <span class="type">RDD</span>[<span class="type">T</span>]</span>) <span class="keyword">extends</span> <span class="title">Dependency</span>[<span class="type">T</span>] </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Get the parent partitions for a child partition.</span></span><br><span class="line"><span class="comment">   * @param partitionId a partition of the child RDD</span></span><br><span class="line"><span class="comment">   * @return the partitions of the parent RDD that the child partition depends upon</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getParents</span></span>(partitionId: <span class="type">Int</span>): <span class="type">Seq</span>[<span class="type">Int</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">rdd</span></span>: <span class="type">RDD</span>[<span class="type">T</span>] = _rdd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其RDD的依赖关系可分为两种：<code>窄依赖：NarrowDependency</code>和<code>宽依赖：ShuffleDependency</code></p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211002093226904-16331383487631.png" alt="image-20211002093226904"></p>
<h5 id="窄依赖NarrowDependency"><a href="#窄依赖NarrowDependency" class="headerlink" title="窄依赖NarrowDependency"></a>窄依赖NarrowDependency</h5><blockquote>
<p>父RDD的一个或者多个分区只被子RDD的一个分区所使用，不涉及到shuffle</p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 窄依赖是一个抽象类，其具体的实现子类包括两种</span></span><br><span class="line"><span class="meta">@DeveloperApi</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NarrowDependency</span>[<span class="type">T</span>](<span class="params">_rdd: <span class="type">RDD</span>[<span class="type">T</span>]</span>) <span class="keyword">extends</span> <span class="title">Dependency</span>[<span class="type">T</span>] </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Get the parent partitions for a child partition.</span></span><br><span class="line"><span class="comment">   * @param partitionId a partition of the child RDD</span></span><br><span class="line"><span class="comment">   * @return the partitions of the parent RDD that the child partition depends upon</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getParents</span></span>(partitionId: <span class="type">Int</span>): <span class="type">Seq</span>[<span class="type">Int</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">rdd</span></span>: <span class="type">RDD</span>[<span class="type">T</span>] = _rdd</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一种是OneToOneDependency</span></span><br><span class="line"><span class="meta">@DeveloperApi</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneToOneDependency</span>[<span class="type">T</span>](<span class="params">rdd: <span class="type">RDD</span>[<span class="type">T</span>]</span>) <span class="keyword">extends</span> <span class="title">NarrowDependency</span>[<span class="type">T</span>](<span class="params">rdd</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getParents</span></span>(partitionId: <span class="type">Int</span>): <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(partitionId)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@DeveloperApi</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RangeDependency</span>[<span class="type">T</span>](<span class="params">rdd: <span class="type">RDD</span>[<span class="type">T</span>], inStart: <span class="type">Int</span>, outStart: <span class="type">Int</span>, length: <span class="type">Int</span></span>)</span></span><br><span class="line">  <span class="keyword">extends</span> <span class="type">NarrowDependency</span>[<span class="type">T</span>](rdd) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getParents</span></span>(partitionId: <span class="type">Int</span>): <span class="type">List</span>[<span class="type">Int</span>] = &#123;</span><br><span class="line">    <span class="keyword">if</span> (partitionId &gt;= outStart &amp;&amp; partitionId &lt; outStart + length) &#123;</span><br><span class="line">      <span class="type">List</span>(partitionId - outStart + inStart)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">Nil</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对应于两种窄依赖，如下图所示：<strong>OneToOneDependency</strong></p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AA%84%E4%BE%9D%E8%B5%961.png" alt="窄依赖"></p>
<p><strong>RangeDependency</strong></p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AA%84%E4%BE%9D%E8%B5%962.png" alt="窄依赖2"></p>
<h5 id="宽依赖ShuffleDependency"><a href="#宽依赖ShuffleDependency" class="headerlink" title="宽依赖ShuffleDependency"></a>宽依赖ShuffleDependency</h5><blockquote>
<p>父RDD的一个分区被子RDD的多个分区使用，涉及到shuffle</p>
</blockquote>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/834652-20170505114231242-1674540562.png" alt="img"></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * :: DeveloperApi ::</span></span><br><span class="line"><span class="comment"> * Represents a dependency on the output of a shuffle stage. Note that in the case of shuffle,</span></span><br><span class="line"><span class="comment"> * the RDD is transient since we don&#x27;t need it on the executor side.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param _rdd the parent RDD</span></span><br><span class="line"><span class="comment"> * @param partitioner partitioner used to partition the shuffle output</span></span><br><span class="line"><span class="comment"> * @param serializer [[org.apache.spark.serializer.Serializer Serializer]] to use. If not set</span></span><br><span class="line"><span class="comment"> *                   explicitly then the default serializer, as specified by `spark.serializer`</span></span><br><span class="line"><span class="comment"> *                   config option, will be used.</span></span><br><span class="line"><span class="comment"> * @param keyOrdering key ordering for RDD&#x27;s shuffles</span></span><br><span class="line"><span class="comment"> * @param aggregator map/reduce-side aggregator for RDD&#x27;s shuffle</span></span><br><span class="line"><span class="comment"> * @param mapSideCombine whether to perform partial aggregation (also known as map-side combine)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@DeveloperApi</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShuffleDependency</span>[<span class="type">K</span>: <span class="type">ClassTag</span>, <span class="type">V</span>: <span class="type">ClassTag</span>, <span class="type">C</span>: <span class="type">ClassTag</span>](<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">    @transient private val _rdd: <span class="type">RDD</span>[_ &lt;: <span class="type">Product2</span>[<span class="type">K</span>, <span class="type">V</span>]],</span></span></span><br><span class="line"><span class="params"><span class="class">    val partitioner: <span class="type">Partitioner</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    val serializer: <span class="type">Serializer</span> = <span class="type">SparkEnv</span>.get.serializer,</span></span></span><br><span class="line"><span class="params"><span class="class">    val keyOrdering: <span class="type">Option</span>[<span class="type">Ordering</span>[<span class="type">K</span>]] = <span class="type">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    val aggregator: <span class="type">Option</span>[<span class="type">Aggregator</span>[<span class="type">K</span>, <span class="type">V</span>, <span class="type">C</span>]] = <span class="type">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    val mapSideCombine: <span class="type">Boolean</span> = false</span>)</span></span><br><span class="line">  <span class="keyword">extends</span> <span class="type">Dependency</span>[<span class="type">Product2</span>[<span class="type">K</span>, <span class="type">V</span>]] &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">rdd</span></span>: <span class="type">RDD</span>[<span class="type">Product2</span>[<span class="type">K</span>, <span class="type">V</span>]] = _rdd.asInstanceOf[<span class="type">RDD</span>[<span class="type">Product2</span>[<span class="type">K</span>, <span class="type">V</span>]]]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>[spark] <span class="keyword">val</span> keyClassName: <span class="type">String</span> = reflect.classTag[<span class="type">K</span>].runtimeClass.getName</span><br><span class="line">  <span class="keyword">private</span>[spark] <span class="keyword">val</span> valueClassName: <span class="type">String</span> = reflect.classTag[<span class="type">V</span>].runtimeClass.getName</span><br><span class="line">  <span class="comment">// Note: It&#x27;s possible that the combiner class tag is null, if the combineByKey</span></span><br><span class="line">  <span class="comment">// methods in PairRDDFunctions are used instead of combineByKeyWithClassTag.</span></span><br><span class="line">  <span class="keyword">private</span>[spark] <span class="keyword">val</span> combinerClassName: <span class="type">Option</span>[<span class="type">String</span>] =</span><br><span class="line">    <span class="type">Option</span>(reflect.classTag[<span class="type">C</span>]).map(_.runtimeClass.getName)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> shuffleId: <span class="type">Int</span> = _rdd.context.newShuffleId()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> shuffleHandle: <span class="type">ShuffleHandle</span> = _rdd.context.env.shuffleManager.registerShuffle(</span><br><span class="line">    shuffleId, _rdd.partitions.length, <span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">  _rdd.sparkContext.cleaner.foreach(_.registerShuffleForCleanup(<span class="keyword">this</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h5><p>在Spark中，使用<strong>转换算子</strong>对RDD进行操作时，会形成RDD的血缘依赖关系；这个依赖关系即为<code>Dependency</code>，分为<code>NarrowDependency</code>和<code>ShuffleDependency</code>两种。这个阶段并不会触发算子的实际执行。RDD中的阶段即根据RDD的血缘关系依赖类型（<code>ShuflleDependency</code>）进行Stage的划分的。</p>
<h4 id="2-阶段的划分"><a href="#2-阶段的划分" class="headerlink" title="2. 阶段的划分"></a>2. 阶段的划分</h4><p>入口是编写的Spark任务中的行动算子，此处是<code>collect()</code>算子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> transformation.singleValue</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">mapRDD</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">		<span class="keyword">val</span> conf: <span class="type">SparkConf</span> = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;mapRDD&quot;</span>)</span><br><span class="line">		<span class="keyword">val</span> sc: <span class="type">SparkContext</span> = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line">		<span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(<span class="string">&quot;0&quot;</span>)</span><br><span class="line">		<span class="keyword">val</span> rdd1: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), <span class="number">4</span>)</span><br><span class="line">		<span class="comment">//TODO map</span></span><br><span class="line">		println(<span class="string">&quot;=====map算子======&quot;</span>)</span><br><span class="line">		rdd1.map(&#123;</span><br><span class="line">			<span class="keyword">case</span> i: <span class="type">Int</span> =&gt;</span><br><span class="line">				println(<span class="string">&quot;执行一次map操作&quot;</span>)</span><br><span class="line">				i -&gt; <span class="number">1</span></span><br><span class="line">		&#125;).collect()</span><br><span class="line">		<span class="comment">//TODO mapPartitions</span></span><br><span class="line">		println(<span class="string">&quot;=====mapPartitions算子======&quot;</span>)</span><br><span class="line">		rdd1.mapPartitions(x =&gt; &#123;</span><br><span class="line">			println(<span class="string">&quot;执行一次map操作&quot;</span>)</span><br><span class="line">			x.map(_ -&gt; <span class="number">1</span>)</span><br><span class="line">		&#125;).collect()</span><br><span class="line"></span><br><span class="line">		<span class="comment">//TODO</span></span><br><span class="line">		rdd1.mapPartitionsWithIndex((index, data) =&gt; &#123;</span><br><span class="line">			data.map((index, _))</span><br><span class="line">		&#125;).collect().foreach(print)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>collect()</code>算子会触发任务的执行</p>
<p><strong>RDD.scala</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//========================= RDD.scala ===============================</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Return an array that contains all of the elements in this RDD.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @note This method should only be used if the resulting array is expected to be small, as</span></span><br><span class="line"><span class="comment">   * all the data is loaded into the driver&#x27;s memory.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">collect</span></span>(): <span class="type">Array</span>[<span class="type">T</span>] = withScope &#123;</span><br><span class="line">    <span class="keyword">val</span> results = sc.runJob(<span class="keyword">this</span>, (iter: <span class="type">Iterator</span>[<span class="type">T</span>]) =&gt; iter.toArray)<span class="comment">// runJob执行作业</span></span><br><span class="line">    <span class="type">Array</span>.concat(results: _*)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//========================= SparkContext.scala ===============================</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Run a job on all partitions in an RDD and return the results in an array.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">runJob</span></span>[<span class="type">T</span>, <span class="type">U</span>: <span class="type">ClassTag</span>](rdd: <span class="type">RDD</span>[<span class="type">T</span>], func: <span class="type">Iterator</span>[<span class="type">T</span>] =&gt; <span class="type">U</span>): <span class="type">Array</span>[<span class="type">U</span>] = &#123;</span><br><span class="line">    runJob(rdd, func, <span class="number">0</span> until rdd.partitions.length)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Run a job on a given set of partitions of an RDD, but take a function of type</span></span><br><span class="line"><span class="comment">   * `Iterator[T] =&gt; U` instead of `(TaskContext, Iterator[T]) =&gt; U`.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">runJob</span></span>[<span class="type">T</span>, <span class="type">U</span>: <span class="type">ClassTag</span>](</span><br><span class="line">      rdd: <span class="type">RDD</span>[<span class="type">T</span>],</span><br><span class="line">      func: <span class="type">Iterator</span>[<span class="type">T</span>] =&gt; <span class="type">U</span>,</span><br><span class="line">      partitions: <span class="type">Seq</span>[<span class="type">Int</span>]): <span class="type">Array</span>[<span class="type">U</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> cleanedFunc = clean(func)</span><br><span class="line">    runJob(rdd, (ctx: <span class="type">TaskContext</span>, it: <span class="type">Iterator</span>[<span class="type">T</span>]) =&gt; cleanedFunc(it), partitions)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Run a function on a given set of partitions in an RDD and return the results as an array.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">runJob</span></span>[<span class="type">T</span>, <span class="type">U</span>: <span class="type">ClassTag</span>](</span><br><span class="line">      rdd: <span class="type">RDD</span>[<span class="type">T</span>],</span><br><span class="line">      func: (<span class="type">TaskContext</span>, <span class="type">Iterator</span>[<span class="type">T</span>]) =&gt; <span class="type">U</span>,</span><br><span class="line">      partitions: <span class="type">Seq</span>[<span class="type">Int</span>]): <span class="type">Array</span>[<span class="type">U</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> results = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">U</span>](partitions.size)</span><br><span class="line">    runJob[<span class="type">T</span>, <span class="type">U</span>](rdd, func, partitions, (index, res) =&gt; results(index) = res)</span><br><span class="line">    results</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Run a function on a given set of partitions in an RDD and pass the results to the given</span></span><br><span class="line"><span class="comment">   * handler function. This is the main entry point for all actions in Spark.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">runJob</span></span>[<span class="type">T</span>, <span class="type">U</span>: <span class="type">ClassTag</span>](</span><br><span class="line">      rdd: <span class="type">RDD</span>[<span class="type">T</span>],</span><br><span class="line">      func: (<span class="type">TaskContext</span>, <span class="type">Iterator</span>[<span class="type">T</span>]) =&gt; <span class="type">U</span>,</span><br><span class="line">      partitions: <span class="type">Seq</span>[<span class="type">Int</span>],</span><br><span class="line">      resultHandler: (<span class="type">Int</span>, <span class="type">U</span>) =&gt; <span class="type">Unit</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (stopped.get()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">&quot;SparkContext has been shutdown&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> callSite = getCallSite</span><br><span class="line">    <span class="keyword">val</span> cleanedFunc = clean(func)</span><br><span class="line">    logInfo(<span class="string">&quot;Starting job: &quot;</span> + callSite.shortForm)</span><br><span class="line">    <span class="keyword">if</span> (conf.getBoolean(<span class="string">&quot;spark.logLineage&quot;</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">      logInfo(<span class="string">&quot;RDD&#x27;s recursive dependencies:\n&quot;</span> + rdd.toDebugString)</span><br><span class="line">    &#125;</span><br><span class="line">    dagScheduler.runJob(rdd, cleanedFunc, partitions, callSite, resultHandler, localProperties.get) <span class="comment">// 最终通过DagScheduler执行Job</span></span><br><span class="line">    progressBar.foreach(_.finishAll())</span><br><span class="line">    rdd.doCheckpoint()</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//========================= DAGScheduler.scala ===============================</span></span><br><span class="line"><span class="keyword">private</span>[scheduler] <span class="class"><span class="keyword">class</span> <span class="title">DAGSchedulerEventProcessLoop</span>(<span class="params">dagScheduler: <span class="type">DAGScheduler</span></span>)</span></span><br><span class="line">  <span class="keyword">extends</span> <span class="type">EventLoop</span>[<span class="type">DAGSchedulerEvent</span>](<span class="string">&quot;dag-scheduler-event-loop&quot;</span>) <span class="keyword">with</span> <span class="type">Logging</span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>[scheduler] <span class="keyword">val</span> eventProcessLoop = <span class="keyword">new</span> <span class="type">DAGSchedulerEventProcessLoop</span>(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Run an action job on the given RDD and pass all the results to the resultHandler function as</span></span><br><span class="line"><span class="comment">   * they arrive.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param rdd target RDD to run tasks on</span></span><br><span class="line"><span class="comment">   * @param func a function to run on each partition of the RDD</span></span><br><span class="line"><span class="comment">   * @param partitions set of partitions to run on; some jobs may not want to compute on all</span></span><br><span class="line"><span class="comment">   *   partitions of the target RDD, e.g. for operations like first()</span></span><br><span class="line"><span class="comment">   * @param callSite where in the user program this job was called</span></span><br><span class="line"><span class="comment">   * @param resultHandler callback to pass each result to</span></span><br><span class="line"><span class="comment">   * @param properties scheduler properties to attach to this job, e.g. fair scheduler pool name</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @throws Exception when the job fails</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">runJob</span></span>[<span class="type">T</span>, <span class="type">U</span>](</span><br><span class="line">      rdd: <span class="type">RDD</span>[<span class="type">T</span>],</span><br><span class="line">      func: (<span class="type">TaskContext</span>, <span class="type">Iterator</span>[<span class="type">T</span>]) =&gt; <span class="type">U</span>,</span><br><span class="line">      partitions: <span class="type">Seq</span>[<span class="type">Int</span>],</span><br><span class="line">      callSite: <span class="type">CallSite</span>,</span><br><span class="line">      resultHandler: (<span class="type">Int</span>, <span class="type">U</span>) =&gt; <span class="type">Unit</span>,</span><br><span class="line">      properties: <span class="type">Properties</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> start = <span class="type">System</span>.nanoTime</span><br><span class="line">    <span class="keyword">val</span> waiter = submitJob(rdd, func, partitions, callSite, resultHandler, properties)  <span class="comment">// 提交任务</span></span><br><span class="line">    <span class="comment">// Note: Do not call Await.ready(future) because that calls `scala.concurrent.blocking`,</span></span><br><span class="line">    <span class="comment">// which causes concurrent SQL executions to fail if a fork-join pool is used. Note that</span></span><br><span class="line">    <span class="comment">// due to idiosyncrasies in Scala, `awaitPermission` is not actually used anywhere so it&#x27;s</span></span><br><span class="line">    <span class="comment">// safe to pass in null here. For more detail, see SPARK-13747.</span></span><br><span class="line">    <span class="keyword">val</span> awaitPermission = <span class="literal">null</span>.asInstanceOf[scala.concurrent.<span class="type">CanAwait</span>]</span><br><span class="line">    waiter.completionFuture.ready(<span class="type">Duration</span>.<span class="type">Inf</span>)(awaitPermission)</span><br><span class="line">    waiter.completionFuture.value.get <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> scala.util.<span class="type">Success</span>(_) =&gt;</span><br><span class="line">        logInfo(<span class="string">&quot;Job %d finished: %s, took %f s&quot;</span>.format</span><br><span class="line">          (waiter.jobId, callSite.shortForm, (<span class="type">System</span>.nanoTime - start) / <span class="number">1e9</span>))</span><br><span class="line">      <span class="keyword">case</span> scala.util.<span class="type">Failure</span>(exception) =&gt;</span><br><span class="line">        logInfo(<span class="string">&quot;Job %d failed: %s, took %f s&quot;</span>.format</span><br><span class="line">          (waiter.jobId, callSite.shortForm, (<span class="type">System</span>.nanoTime - start) / <span class="number">1e9</span>))</span><br><span class="line">        <span class="comment">// SPARK-8644: Include user stack trace in exceptions coming from DAGScheduler.</span></span><br><span class="line">        <span class="keyword">val</span> callerStackTrace = <span class="type">Thread</span>.currentThread().getStackTrace.tail</span><br><span class="line">        exception.setStackTrace(exception.getStackTrace ++ callerStackTrace)</span><br><span class="line">        <span class="keyword">throw</span> exception</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Submit an action job to the scheduler.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param rdd target RDD to run tasks on</span></span><br><span class="line"><span class="comment">   * @param func a function to run on each partition of the RDD</span></span><br><span class="line"><span class="comment">   * @param partitions set of partitions to run on; some jobs may not want to compute on all</span></span><br><span class="line"><span class="comment">   *   partitions of the target RDD, e.g. for operations like first()</span></span><br><span class="line"><span class="comment">   * @param callSite where in the user program this job was called</span></span><br><span class="line"><span class="comment">   * @param resultHandler callback to pass each result to</span></span><br><span class="line"><span class="comment">   * @param properties scheduler properties to attach to this job, e.g. fair scheduler pool name</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @return a JobWaiter object that can be used to block until the job finishes executing</span></span><br><span class="line"><span class="comment">   *         or can be used to cancel the job.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @throws IllegalArgumentException when partitions ids are illegal</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">submitJob</span></span>[<span class="type">T</span>, <span class="type">U</span>](</span><br><span class="line">      rdd: <span class="type">RDD</span>[<span class="type">T</span>],</span><br><span class="line">      func: (<span class="type">TaskContext</span>, <span class="type">Iterator</span>[<span class="type">T</span>]) =&gt; <span class="type">U</span>,</span><br><span class="line">      partitions: <span class="type">Seq</span>[<span class="type">Int</span>],</span><br><span class="line">      callSite: <span class="type">CallSite</span>,</span><br><span class="line">      resultHandler: (<span class="type">Int</span>, <span class="type">U</span>) =&gt; <span class="type">Unit</span>,</span><br><span class="line">      properties: <span class="type">Properties</span>): <span class="type">JobWaiter</span>[<span class="type">U</span>] = &#123;</span><br><span class="line">    <span class="comment">// Check to make sure we are not launching a task on a partition that does not exist.</span></span><br><span class="line">    <span class="keyword">val</span> maxPartitions = rdd.partitions.length</span><br><span class="line">    partitions.find(p =&gt; p &gt;= maxPartitions || p &lt; <span class="number">0</span>).foreach &#123; p =&gt;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(</span><br><span class="line">        <span class="string">&quot;Attempting to access a non-existent partition: &quot;</span> + p + <span class="string">&quot;. &quot;</span> +</span><br><span class="line">          <span class="string">&quot;Total number of partitions: &quot;</span> + maxPartitions)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> jobId = nextJobId.getAndIncrement()</span><br><span class="line">    <span class="keyword">if</span> (partitions.size == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Return immediately if the job is running 0 tasks</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">JobWaiter</span>[<span class="type">U</span>](<span class="keyword">this</span>, jobId, <span class="number">0</span>, resultHandler)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(partitions.size &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">val</span> func2 = func.asInstanceOf[(<span class="type">TaskContext</span>, <span class="type">Iterator</span>[_]) =&gt; _]</span><br><span class="line">    <span class="keyword">val</span> waiter = <span class="keyword">new</span> <span class="type">JobWaiter</span>(<span class="keyword">this</span>, jobId, partitions.size, resultHandler)</span><br><span class="line">      <span class="comment">// 核心代码，JobSubmitted会创建一个DAGSchedulerEvent事件，</span></span><br><span class="line">      <span class="comment">// DAGSchedulerEventProcessLoop会通过post方法将上述创建的DAGSchedulerEvent添加到EventQueue事件队列中，等待后续事件的执行</span></span><br><span class="line">    eventProcessLoop.post(<span class="type">JobSubmitted</span>(</span><br><span class="line">      jobId, rdd, func2, partitions.toArray, callSite, waiter,</span><br><span class="line">      <span class="type">SerializationUtils</span>.clone(properties)))</span><br><span class="line">    waiter</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>DAGSchedulerEvent.scala</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** A result-yielding job was submitted on a target RDD */</span></span><br><span class="line"><span class="keyword">private</span>[scheduler] <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">JobSubmitted</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">    jobId: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    finalRDD: <span class="type">RDD</span>[_],</span></span></span><br><span class="line"><span class="params"><span class="class">    func: (<span class="type">TaskContext</span>, <span class="type">Iterator</span>[_]</span>) <span class="title">=&gt;</span> <span class="title">_</span>,</span></span><br><span class="line">    partitions: <span class="type">Array</span>[<span class="type">Int</span>],</span><br><span class="line">    callSite: <span class="type">CallSite</span>,</span><br><span class="line">    listener: <span class="type">JobListener</span>,</span><br><span class="line">    properties: <span class="type">Properties</span> = <span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">extends</span> <span class="type">DAGSchedulerEvent</span></span><br></pre></td></tr></table></figure>

<p><strong>EventLoop.scala</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 事件队列器其实就是一个由链表结构组成的双向阻塞队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> eventQueue: <span class="type">BlockingQueue</span>[<span class="type">E</span>] = <span class="keyword">new</span> <span class="type">LinkedBlockingDeque</span>[<span class="type">E</span>]()</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一个事件循环，用于从调用者接收事件并处理事件线程中的所有事件。 它将启动一个独占事件线程来处理所有事件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Put the event into the event queue. The event thread will process it later.</span></span><br><span class="line"><span class="comment">   将事件添加到事件队列中，event线程会之后处理它</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post</span></span>(event: <span class="type">E</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    eventQueue.put(event)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如何取事件？通过一个子线程eventThread</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> stopped = <span class="keyword">new</span> <span class="type">AtomicBoolean</span>(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> eventThread = <span class="keyword">new</span> <span class="type">Thread</span>(name) &#123;</span><br><span class="line">    setDaemon(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stopped.get) &#123;</span><br><span class="line">          <span class="keyword">val</span> event = eventQueue.take() <span class="comment">// 通过take方法取出事件</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            onReceive(event) <span class="comment">// 核心代码</span></span><br><span class="line">          &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="type">NonFatal</span>(e) =&gt;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                onError(e)</span><br><span class="line">              &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="type">NonFatal</span>(e) =&gt; logError(<span class="string">&quot;Unexpected error in &quot;</span> + name, e)</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> ie: <span class="type">InterruptedException</span> =&gt; <span class="comment">// exit even if eventQueue is not empty</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">NonFatal</span>(e) =&gt; logError(<span class="string">&quot;Unexpected error in &quot;</span> + name, e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>DAGScheduler.scala</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onReceive</span></span>(event: <span class="type">DAGSchedulerEvent</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> timerContext = timer.time()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      doOnReceive(event)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      timerContext.stop()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">doOnReceive</span></span>(event: <span class="type">DAGSchedulerEvent</span>): <span class="type">Unit</span> = event <span class="keyword">match</span> &#123; <span class="comment">// 模式匹配，匹配出相应类型的Event</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">JobSubmitted</span>(jobId, rdd, func, partitions, callSite, listener, properties) =&gt;</span><br><span class="line">      dagScheduler.handleJobSubmitted(jobId, rdd, func, partitions, callSite, listener, properties) <span class="comment">// 通过dagScheduler.handleJobSubmitted方法处理提交的事件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="type">MapStageSubmitted</span>(jobId, dependency, callSite, listener, properties) =&gt;</span><br><span class="line">      dagScheduler.handleMapStageSubmitted(jobId, dependency, callSite, listener, properties)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="type">StageCancelled</span>(stageId) =&gt;</span><br><span class="line">      dagScheduler.handleStageCancellation(stageId)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="type">JobCancelled</span>(jobId) =&gt;</span><br><span class="line">      dagScheduler.handleJobCancellation(jobId)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="type">JobGroupCancelled</span>(groupId) =&gt;</span><br><span class="line">      dagScheduler.handleJobGroupCancelled(groupId)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="type">AllJobsCancelled</span> =&gt;</span><br><span class="line">      dagScheduler.doCancelAllJobs()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="type">ExecutorAdded</span>(execId, host) =&gt;</span><br><span class="line">      dagScheduler.handleExecutorAdded(execId, host)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="type">ExecutorLost</span>(execId, reason) =&gt;</span><br><span class="line">      <span class="keyword">val</span> filesLost = reason <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">SlaveLost</span>(_, <span class="literal">true</span>) =&gt; <span class="literal">true</span></span><br><span class="line">        <span class="keyword">case</span> _ =&gt; <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      dagScheduler.handleExecutorLost(execId, filesLost)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="type">BeginEvent</span>(task, taskInfo) =&gt;</span><br><span class="line">      dagScheduler.handleBeginEvent(task, taskInfo)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="type">GettingResultEvent</span>(taskInfo) =&gt;</span><br><span class="line">      dagScheduler.handleGetTaskResult(taskInfo)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> completion: <span class="type">CompletionEvent</span> =&gt;</span><br><span class="line">      dagScheduler.handleTaskCompletion(completion)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="type">TaskSetFailed</span>(taskSet, reason, exception) =&gt;</span><br><span class="line">      dagScheduler.handleTaskSetFailed(taskSet, reason, exception)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="type">ResubmitFailedStages</span> =&gt;</span><br><span class="line">      dagScheduler.resubmitFailedStages()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*================================== Stage的划分 =================================== */</span></span><br><span class="line"> <span class="comment">// 此方法会涉及到阶段Stage的划分</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>[scheduler] <span class="function"><span class="keyword">def</span> <span class="title">handleJobSubmitted</span></span>(jobId: <span class="type">Int</span>,</span><br><span class="line">      finalRDD: <span class="type">RDD</span>[_],</span><br><span class="line">      func: (<span class="type">TaskContext</span>, <span class="type">Iterator</span>[_]) =&gt; _,</span><br><span class="line">      partitions: <span class="type">Array</span>[<span class="type">Int</span>],</span><br><span class="line">      callSite: <span class="type">CallSite</span>,</span><br><span class="line">      listener: <span class="type">JobListener</span>,</span><br><span class="line">      properties: <span class="type">Properties</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> finalStage: <span class="type">ResultStage</span> = <span class="literal">null</span>  <span class="comment">// FinalStage，也叫做ResultStage</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// New stage creation may throw an exception if, for example, jobs are run on a</span></span><br><span class="line">      <span class="comment">// HadoopRDD whose underlying HDFS files have been deleted.</span></span><br><span class="line">      finalStage = createResultStage(finalRDD, func, partitions, jobId, callSite) <span class="comment">// 创建ResultStage</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt;</span><br><span class="line">        logWarning(<span class="string">&quot;Creating new stage failed due to exception - job: &quot;</span> + jobId, e)</span><br><span class="line">        listener.jobFailed(e)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> job = <span class="keyword">new</span> <span class="type">ActiveJob</span>(jobId, finalStage, callSite, listener, properties)</span><br><span class="line">    clearCacheLocs()</span><br><span class="line">    logInfo(<span class="string">&quot;Got job %s (%s) with %d output partitions&quot;</span>.format(</span><br><span class="line">      job.jobId, callSite.shortForm, partitions.length))</span><br><span class="line">    logInfo(<span class="string">&quot;Final stage: &quot;</span> + finalStage + <span class="string">&quot; (&quot;</span> + finalStage.name + <span class="string">&quot;)&quot;</span>)</span><br><span class="line">    logInfo(<span class="string">&quot;Parents of final stage: &quot;</span> + finalStage.parents)</span><br><span class="line">    logInfo(<span class="string">&quot;Missing parents: &quot;</span> + getMissingParentStages(finalStage))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> jobSubmissionTime = clock.getTimeMillis()</span><br><span class="line">    jobIdToActiveJob(jobId) = job</span><br><span class="line">    activeJobs += job</span><br><span class="line">    finalStage.setActiveJob(job)</span><br><span class="line">    <span class="keyword">val</span> stageIds = jobIdToStageIds(jobId).toArray</span><br><span class="line">    <span class="keyword">val</span> stageInfos = stageIds.flatMap(id =&gt; stageIdToStage.get(id).map(_.latestInfo))</span><br><span class="line">    listenerBus.post(</span><br><span class="line">      <span class="type">SparkListenerJobStart</span>(job.jobId, jobSubmissionTime, stageInfos, properties))</span><br><span class="line">    submitStage(finalStage)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Create a ResultStage associated with the provided jobId.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">createResultStage</span></span>(</span><br><span class="line">      rdd: <span class="type">RDD</span>[_],</span><br><span class="line">      func: (<span class="type">TaskContext</span>, <span class="type">Iterator</span>[_]) =&gt; _,</span><br><span class="line">      partitions: <span class="type">Array</span>[<span class="type">Int</span>],</span><br><span class="line">      jobId: <span class="type">Int</span>,</span><br><span class="line">      callSite: <span class="type">CallSite</span>): <span class="type">ResultStage</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> parents = getOrCreateParentStages(rdd, jobId) <span class="comment">// 获取或创建上一阶段，说白了就是父阶段，在此阶段创建完成之后要保证父阶段处理完成</span></span><br><span class="line">    <span class="keyword">val</span> id = nextStageId.getAndIncrement()</span><br><span class="line">    <span class="keyword">val</span> stage = <span class="keyword">new</span> <span class="type">ResultStage</span>(id, rdd, func, partitions, parents, jobId, callSite)  <span class="comment">// 真正创建ResultStage的位置</span></span><br><span class="line">    stageIdToStage(id) = stage</span><br><span class="line">    updateJobIdStageIdMaps(jobId, stage)</span><br><span class="line">    stage</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Get or create the list of parent stages for a given RDD.  The new Stages will be created with</span></span><br><span class="line"><span class="comment">   * the provided firstJobId.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">getOrCreateParentStages</span></span>(rdd: <span class="type">RDD</span>[_], firstJobId: <span class="type">Int</span>): <span class="type">List</span>[<span class="type">Stage</span>] = &#123;</span><br><span class="line">    getShuffleDependencies(rdd).map &#123; shuffleDep =&gt;</span><br><span class="line">      getOrCreateShuffleMapStage(shuffleDep, firstJobId)</span><br><span class="line">    &#125;.toList</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns shuffle dependencies that are immediate parents of the given RDD.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * This function will not return more distant ancestors.  For example, if C has a shuffle</span></span><br><span class="line"><span class="comment">   * dependency on B which has a shuffle dependency on A:</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * A &lt;-- B &lt;-- C</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * calling this function with rdd C will only return the B &lt;-- C dependency.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * This function is scheduler-visible for the purpose of unit testing.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span>[scheduler] <span class="function"><span class="keyword">def</span> <span class="title">getShuffleDependencies</span></span>(</span><br><span class="line">      rdd: <span class="type">RDD</span>[_]): <span class="type">HashSet</span>[<span class="type">ShuffleDependency</span>[_, _, _]] = &#123;</span><br><span class="line">    <span class="keyword">val</span> parents = <span class="keyword">new</span> <span class="type">HashSet</span>[<span class="type">ShuffleDependency</span>[_, _, _]]</span><br><span class="line">    <span class="keyword">val</span> visited = <span class="keyword">new</span> <span class="type">HashSet</span>[<span class="type">RDD</span>[_]]</span><br><span class="line">    <span class="keyword">val</span> waitingForVisit = <span class="keyword">new</span> <span class="type">Stack</span>[<span class="type">RDD</span>[_]]</span><br><span class="line">    waitingForVisit.push(rdd)</span><br><span class="line">    <span class="keyword">while</span> (waitingForVisit.nonEmpty) &#123;</span><br><span class="line">      <span class="keyword">val</span> toVisit = waitingForVisit.pop()</span><br><span class="line">      <span class="keyword">if</span> (!visited(toVisit)) &#123;</span><br><span class="line">        visited += toVisit</span><br><span class="line">        toVisit.dependencies.foreach &#123;</span><br><span class="line">          <span class="keyword">case</span> shuffleDep: <span class="type">ShuffleDependency</span>[_, _, _] =&gt;</span><br><span class="line">            parents += shuffleDep</span><br><span class="line">          <span class="keyword">case</span> dependency =&gt;</span><br><span class="line">            waitingForVisit.push(dependency.rdd)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    parents</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Gets a shuffle map stage if one exists in shuffleIdToMapStage. Otherwise, if the</span></span><br><span class="line"><span class="comment">   * shuffle map stage doesn&#x27;t already exist, this method will create the shuffle map stage in</span></span><br><span class="line"><span class="comment">   * addition to any missing ancestor shuffle map stages.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">getOrCreateShuffleMapStage</span></span>(</span><br><span class="line">      shuffleDep: <span class="type">ShuffleDependency</span>[_, _, _],</span><br><span class="line">      firstJobId: <span class="type">Int</span>): <span class="type">ShuffleMapStage</span> = &#123;</span><br><span class="line">    shuffleIdToMapStage.get(shuffleDep.shuffleId) <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Some</span>(stage) =&gt;</span><br><span class="line">        stage</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">        <span class="comment">// Create stages for all missing ancestor shuffle dependencies.</span></span><br><span class="line">        getMissingAncestorShuffleDependencies(shuffleDep.rdd).foreach &#123; dep =&gt;</span><br><span class="line">          <span class="comment">// Even though getMissingAncestorShuffleDependencies only returns shuffle dependencies</span></span><br><span class="line">          <span class="comment">// that were not already in shuffleIdToMapStage, it&#x27;s possible that by the time we</span></span><br><span class="line">          <span class="comment">// get to a particular dependency in the foreach loop, it&#x27;s been added to</span></span><br><span class="line">          <span class="comment">// shuffleIdToMapStage by the stage creation process for an earlier dependency. See</span></span><br><span class="line">          <span class="comment">// SPARK-13902 for more information.</span></span><br><span class="line">          <span class="keyword">if</span> (!shuffleIdToMapStage.contains(dep.shuffleId)) &#123;</span><br><span class="line">            createShuffleMapStage(dep, firstJobId)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Finally, create a stage for the given shuffle dependency.</span></span><br><span class="line">        createShuffleMapStage(shuffleDep, firstJobId)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates a ShuffleMapStage that generates the given shuffle dependency&#x27;s partitions. If a</span></span><br><span class="line"><span class="comment">   * previously run stage generated the same shuffle data, this function will copy the output</span></span><br><span class="line"><span class="comment">   * locations that are still available from the previous shuffle to avoid unnecessarily</span></span><br><span class="line"><span class="comment">   * regenerating data.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">createShuffleMapStage</span></span>(shuffleDep: <span class="type">ShuffleDependency</span>[_, _, _], jobId: <span class="type">Int</span>): <span class="type">ShuffleMapStage</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> rdd = shuffleDep.rdd</span><br><span class="line">    <span class="keyword">val</span> numTasks = rdd.partitions.length</span><br><span class="line">    <span class="keyword">val</span> parents = getOrCreateParentStages(rdd, jobId) <span class="comment">// 判断此依赖的RDD是否也存在父阶段，如果有就创建ShuffleMapStage</span></span><br><span class="line">    <span class="keyword">val</span> id = nextStageId.getAndIncrement()</span><br><span class="line">    <span class="keyword">val</span> stage = <span class="keyword">new</span> <span class="type">ShuffleMapStage</span>(id, rdd, numTasks, parents, jobId, rdd.creationSite, shuffleDep)</span><br><span class="line"></span><br><span class="line">    stageIdToStage(id) = stage</span><br><span class="line">    shuffleIdToMapStage(shuffleDep.shuffleId) = stage</span><br><span class="line">    updateJobIdStageIdMaps(jobId, stage)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mapOutputTracker.containsShuffle(shuffleDep.shuffleId)) &#123;</span><br><span class="line">      <span class="comment">// A previously run stage generated partitions for this shuffle, so for each output</span></span><br><span class="line">      <span class="comment">// that&#x27;s still available, copy information about that output location to the new stage</span></span><br><span class="line">      <span class="comment">// (so we don&#x27;t unnecessarily re-compute that data).</span></span><br><span class="line">      <span class="keyword">val</span> serLocs = mapOutputTracker.getSerializedMapOutputStatuses(shuffleDep.shuffleId)</span><br><span class="line">      <span class="keyword">val</span> locs = <span class="type">MapOutputTracker</span>.deserializeMapStatuses(serLocs)</span><br><span class="line">      (<span class="number">0</span> until locs.length).foreach &#123; i =&gt;</span><br><span class="line">        <span class="keyword">if</span> (locs(i) ne <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// locs(i) will be null if missing</span></span><br><span class="line">          stage.addOutputLoc(i, locs(i))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Kind of ugly: need to register RDDs with the cache and map output tracker here</span></span><br><span class="line">      <span class="comment">// since we can&#x27;t do it in the RDD constructor because # of partitions is unknown</span></span><br><span class="line">      logInfo(<span class="string">&quot;Registering RDD &quot;</span> + rdd.id + <span class="string">&quot; (&quot;</span> + rdd.getCreationSite + <span class="string">&quot;)&quot;</span>)</span><br><span class="line">      mapOutputTracker.registerShuffle(shuffleDep.shuffleId, rdd.partitions.length)</span><br><span class="line">    &#125;</span><br><span class="line">    stage</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong><font color=red>Spark中阶段的划分数（Stage数量）== ShuffleDependency（Shuffle依赖）的数量+1</font></strong></p>
<h5 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h5><ol>
<li><strong>DAGScheduler</strong>会将接收到的<strong>Job</strong>封装成<strong>JobSubmitted</strong>事件（实际是DAGSchedulerEvent），加入到eventQueue（事件阻塞队列中）</li>
<li>eventThread事件线程的<code>run()</code>方法会从阻塞队列中取出相应的event事件</li>
<li>事件取出之后，会经过<font color=green>handleJobSubmitted()</font>方法进行<strong>阶段的划分</strong>，阶段可分为两种类型：<ul>
<li><strong>ResultStage（也叫做FinalStage）</strong></li>
<li><strong>ShuffleMapStage</strong></li>
</ul>
</li>
<li>在每一个<strong>Stage创建之前</strong>，会通过<code>getOrCreateParentStages</code>方法获取或创建该阶段的<strong>父阶段</strong></li>
<li>**getOrCreateParentStages()**方法会根据传入的RDD的依赖类型是否是<code>ShuffleDependency</code>进行阶段的划分</li>
<li>阶段的划分是从后向前进行划分的，真正的Job执行，是从前往后进行执行的</li>
<li><strong>Spark的Job中的Stage阶段数=ShuffleDependency的数量+1</strong></li>
</ol>
<h4 id="3-任务的切分"><a href="#3-任务的切分" class="headerlink" title="3. 任务的切分"></a>3. 任务的切分</h4><p><strong>DAGScheduler.scala</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="keyword">private</span>[scheduler] <span class="function"><span class="keyword">def</span> <span class="title">handleJobSubmitted</span></span>(jobId: <span class="type">Int</span>,</span><br><span class="line">     finalRDD: <span class="type">RDD</span>[_],</span><br><span class="line">     func: (<span class="type">TaskContext</span>, <span class="type">Iterator</span>[_]) =&gt; _,</span><br><span class="line">     partitions: <span class="type">Array</span>[<span class="type">Int</span>],</span><br><span class="line">     callSite: <span class="type">CallSite</span>,</span><br><span class="line">     listener: <span class="type">JobListener</span>,</span><br><span class="line">     properties: <span class="type">Properties</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> finalStage: <span class="type">ResultStage</span> = <span class="literal">null</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// New stage creation may throw an exception if, for example, jobs are run on a</span></span><br><span class="line">     <span class="comment">// HadoopRDD whose underlying HDFS files have been deleted.</span></span><br><span class="line">     finalStage = createResultStage(finalRDD, func, partitions, jobId, callSite)  <span class="comment">// 此处会划分阶段Stage</span></span><br><span class="line">   &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">     <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt;</span><br><span class="line">       logWarning(<span class="string">&quot;Creating new stage failed due to exception - job: &quot;</span> + jobId, e)</span><br><span class="line">       listener.jobFailed(e)</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 阶段划分完成之后，会创建一个活跃的Job作业。</span></span><br><span class="line">   <span class="keyword">val</span> job = <span class="keyword">new</span> <span class="type">ActiveJob</span>(jobId, finalStage, callSite, listener, properties)</span><br><span class="line">   clearCacheLocs()</span><br><span class="line">   logInfo(<span class="string">&quot;Got job %s (%s) with %d output partitions&quot;</span>.format(</span><br><span class="line">     job.jobId, callSite.shortForm, partitions.length))</span><br><span class="line">   logInfo(<span class="string">&quot;Final stage: &quot;</span> + finalStage + <span class="string">&quot; (&quot;</span> + finalStage.name + <span class="string">&quot;)&quot;</span>)</span><br><span class="line">   logInfo(<span class="string">&quot;Parents of final stage: &quot;</span> + finalStage.parents)</span><br><span class="line">   logInfo(<span class="string">&quot;Missing parents: &quot;</span> + getMissingParentStages(finalStage))</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> jobSubmissionTime = clock.getTimeMillis()</span><br><span class="line">   jobIdToActiveJob(jobId) = job</span><br><span class="line">   activeJobs += job</span><br><span class="line">   finalStage.setActiveJob(job)</span><br><span class="line">   <span class="keyword">val</span> stageIds = jobIdToStageIds(jobId).toArray</span><br><span class="line">   <span class="keyword">val</span> stageInfos = stageIds.flatMap(id =&gt; stageIdToStage.get(id).map(_.latestInfo))</span><br><span class="line">   listenerBus.post(</span><br><span class="line">     <span class="type">SparkListenerJobStart</span>(job.jobId, jobSubmissionTime, stageInfos, properties))</span><br><span class="line">     <span class="comment">// 提交阶段</span></span><br><span class="line">   submitStage(finalStage)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*======================  提交阶段   ======================*/</span></span><br><span class="line"> <span class="comment">/** Submits stage, but first recursively submits any missing parents. */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">submitStage</span></span>(stage: <span class="type">Stage</span>) &#123;</span><br><span class="line">   <span class="keyword">val</span> jobId = activeJobForStage(stage)</span><br><span class="line">   <span class="keyword">if</span> (jobId.isDefined) &#123;</span><br><span class="line">     logDebug(<span class="string">&quot;submitStage(&quot;</span> + stage + <span class="string">&quot;)&quot;</span>)</span><br><span class="line">       <span class="comment">// 传过来的是ResultStage</span></span><br><span class="line">     <span class="keyword">if</span> (!waitingStages(stage) &amp;&amp; !runningStages(stage) &amp;&amp; !failedStages(stage)) &#123;</span><br><span class="line">         <span class="comment">// getMissingParentStages：获取丢失的父阶段，或者是未提交的阶段</span></span><br><span class="line">       <span class="keyword">val</span> missing = getMissingParentStages(stage).sortBy(_.id)</span><br><span class="line">       logDebug(<span class="string">&quot;missing: &quot;</span> + missing)</span><br><span class="line">         <span class="comment">// 如果missing为空，就代表次阶段没有父阶段了</span></span><br><span class="line">       <span class="keyword">if</span> (missing.isEmpty) &#123;</span><br><span class="line">         logInfo(<span class="string">&quot;Submitting &quot;</span> + stage + <span class="string">&quot; (&quot;</span> + stage.rdd + <span class="string">&quot;), which has no missing parents&quot;</span>)</span><br><span class="line">           <span class="comment">// 提交任务  submitMissingTasks</span></span><br><span class="line">         submitMissingTasks(stage, jobId.get)  <span class="comment">// 提交任务的核心方法</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 如果有未提交，或者父阶段，就递归的提交父阶段</span></span><br><span class="line">         <span class="keyword">for</span> (parent &lt;- missing) &#123;</span><br><span class="line">           submitStage(parent)  <span class="comment">// 此处会有一个递归</span></span><br><span class="line">         &#125;</span><br><span class="line">         waitingStages += stage</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     abortStage(stage, <span class="string">&quot;No active job for stage &quot;</span> + stage.id, <span class="type">None</span>)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>小总结</strong></p>
<p>上述源码可以看出，阶段划分完成之后，会通过<strong>submitStage()<strong>方法提交最后一个</strong>ResultStage</strong>阶段。</p>
<p>在<strong>submitStage()<strong>方法内部首先会通过</strong>getMissingParentStages</strong>方法找到传过来的Stage是否存在Parent<strong>父阶段</strong>；</p>
<ul>
<li><p>如果不存在父阶段，就通过<strong>submitMissingTask</strong>方法提交本阶段的任务；</p>
</li>
<li><p>如果存在父阶段，就递归的提交父阶段；</p>
</li>
</ul>
<p><strong>submitMissingTasks()</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/** Called when stage&#x27;s parents are available and we can now do its task. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">submitMissingTasks</span></span>(stage: <span class="type">Stage</span>, jobId: <span class="type">Int</span>) &#123;</span><br><span class="line">    logDebug(<span class="string">&quot;submitMissingTasks(&quot;</span> + stage + <span class="string">&quot;)&quot;</span>)</span><br><span class="line">    <span class="comment">// Get our pending tasks and remember them in our pendingTasks entry</span></span><br><span class="line">    stage.pendingPartitions.clear()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First figure out the indexes of partition ids to compute.</span></span><br><span class="line">    <span class="keyword">val</span> partitionsToCompute: <span class="type">Seq</span>[<span class="type">Int</span>] = stage.findMissingPartitions()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the scheduling pool, job group, description, etc. from an ActiveJob associated</span></span><br><span class="line">    <span class="comment">// with this Stage</span></span><br><span class="line">    <span class="keyword">val</span> properties = jobIdToActiveJob(jobId).properties</span><br><span class="line"></span><br><span class="line">    runningStages += stage</span><br><span class="line">    <span class="comment">// SparkListenerStageSubmitted should be posted before testing whether tasks are</span></span><br><span class="line">    <span class="comment">// serializable. If tasks are not serializable, a SparkListenerStageCompleted event</span></span><br><span class="line">    <span class="comment">// will be posted, which should always come after a corresponding SparkListenerStageSubmitted</span></span><br><span class="line">    <span class="comment">// event.</span></span><br><span class="line">    stage <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> s: <span class="type">ShuffleMapStage</span> =&gt;</span><br><span class="line">        outputCommitCoordinator.stageStart(stage = s.id, maxPartitionId = s.numPartitions - <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">case</span> s: <span class="type">ResultStage</span> =&gt;</span><br><span class="line">        outputCommitCoordinator.stageStart(</span><br><span class="line">          stage = s.id, maxPartitionId = s.rdd.partitions.length - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> taskIdToLocations: <span class="type">Map</span>[<span class="type">Int</span>, <span class="type">Seq</span>[<span class="type">TaskLocation</span>]] = <span class="keyword">try</span> &#123;</span><br><span class="line">      stage <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> s: <span class="type">ShuffleMapStage</span> =&gt;</span><br><span class="line">          partitionsToCompute.map &#123; id =&gt; (id, getPreferredLocs(stage.rdd, id))&#125;.toMap</span><br><span class="line">        <span class="keyword">case</span> s: <span class="type">ResultStage</span> =&gt;</span><br><span class="line">          partitionsToCompute.map &#123; id =&gt;</span><br><span class="line">            <span class="keyword">val</span> p = s.partitions(id)</span><br><span class="line">            (id, getPreferredLocs(stage.rdd, p))</span><br><span class="line">          &#125;.toMap</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">NonFatal</span>(e) =&gt;</span><br><span class="line">        stage.makeNewStageAttempt(partitionsToCompute.size)</span><br><span class="line">        listenerBus.post(<span class="type">SparkListenerStageSubmitted</span>(stage.latestInfo, properties))</span><br><span class="line">        abortStage(stage, <span class="string">s&quot;Task creation failed: <span class="subst">$e</span>\n<span class="subst">$&#123;Utils.exceptionString(e)&#125;</span>&quot;</span>, <span class="type">Some</span>(e))</span><br><span class="line">        runningStages -= stage</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stage.makeNewStageAttempt(partitionsToCompute.size, taskIdToLocations.values.toSeq)</span><br><span class="line">    listenerBus.post(<span class="type">SparkListenerStageSubmitted</span>(stage.latestInfo, properties))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Maybe we can keep the taskBinary in Stage to avoid serializing it multiple times.</span></span><br><span class="line">    <span class="comment">// Broadcasted binary for the task, used to dispatch tasks to executors. Note that we broadcast</span></span><br><span class="line">    <span class="comment">// the serialized copy of the RDD and for each task we will deserialize it, which means each</span></span><br><span class="line">    <span class="comment">// task gets a different copy of the RDD. This provides stronger isolation between tasks that</span></span><br><span class="line">    <span class="comment">// might modify state of objects referenced in their closures. This is necessary in Hadoop</span></span><br><span class="line">    <span class="comment">// where the JobConf/Configuration object is not thread-safe.</span></span><br><span class="line">    <span class="keyword">var</span> taskBinary: <span class="type">Broadcast</span>[<span class="type">Array</span>[<span class="type">Byte</span>]] = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// For ShuffleMapTask, serialize and broadcast (rdd, shuffleDep).</span></span><br><span class="line">      <span class="comment">// For ResultTask, serialize and broadcast (rdd, func).</span></span><br><span class="line">      <span class="keyword">val</span> taskBinaryBytes: <span class="type">Array</span>[<span class="type">Byte</span>] = stage <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> stage: <span class="type">ShuffleMapStage</span> =&gt;</span><br><span class="line">          <span class="type">JavaUtils</span>.bufferToArray(</span><br><span class="line">            closureSerializer.serialize((stage.rdd, stage.shuffleDep): <span class="type">AnyRef</span>))</span><br><span class="line">        <span class="keyword">case</span> stage: <span class="type">ResultStage</span> =&gt;</span><br><span class="line">          <span class="type">JavaUtils</span>.bufferToArray(closureSerializer.serialize((stage.rdd, stage.func): <span class="type">AnyRef</span>))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      taskBinary = sc.broadcast(taskBinaryBytes)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="comment">// In the case of a failure during serialization, abort the stage.</span></span><br><span class="line">      <span class="keyword">case</span> e: <span class="type">NotSerializableException</span> =&gt;</span><br><span class="line">        abortStage(stage, <span class="string">&quot;Task not serializable: &quot;</span> + e.toString, <span class="type">Some</span>(e))</span><br><span class="line">        runningStages -= stage</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Abort execution</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">case</span> <span class="type">NonFatal</span>(e) =&gt;</span><br><span class="line">        abortStage(stage, <span class="string">s&quot;Task serialization failed: <span class="subst">$e</span>\n<span class="subst">$&#123;Utils.exceptionString(e)&#125;</span>&quot;</span>, <span class="type">Some</span>(e))</span><br><span class="line">        runningStages -= stage</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/*================== 创建任务Task  ==================*/</span></span><br><span class="line">    <span class="keyword">val</span> tasks: <span class="type">Seq</span>[<span class="type">Task</span>[_]] = <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 根据Stage的类型：ShuffleMapStage类型；还是ResultStage类型创建不同类型的任务Task</span></span><br><span class="line">      stage <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> stage: <span class="type">ShuffleMapStage</span> =&gt;</span><br><span class="line">          <span class="comment">// 分区计算，返回相应的分区id，默认是0 until partitions</span></span><br><span class="line">          partitionsToCompute.map &#123; id =&gt;</span><br><span class="line">            <span class="keyword">val</span> locs = taskIdToLocations(id)</span><br><span class="line">            <span class="keyword">val</span> part = stage.rdd.partitions(id)</span><br><span class="line">              <span class="comment">// 创建ShuffleMapTask类型的Task</span></span><br><span class="line">            <span class="keyword">new</span> <span class="type">ShuffleMapTask</span>(stage.id, stage.latestInfo.attemptId,</span><br><span class="line">              taskBinary, part, locs, stage.latestInfo.taskMetrics, properties, <span class="type">Option</span>(jobId),</span><br><span class="line">              <span class="type">Option</span>(sc.applicationId), sc.applicationAttemptId)</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> stage: <span class="type">ResultStage</span> =&gt;</span><br><span class="line">          partitionsToCompute.map &#123; id =&gt;</span><br><span class="line">            <span class="keyword">val</span> p: <span class="type">Int</span> = stage.partitions(id)</span><br><span class="line">            <span class="keyword">val</span> part = stage.rdd.partitions(p)</span><br><span class="line">            <span class="keyword">val</span> locs = taskIdToLocations(id)</span><br><span class="line">              <span class="comment">// 创建ResultTask类型的Task</span></span><br><span class="line">            <span class="keyword">new</span> <span class="type">ResultTask</span>(stage.id, stage.latestInfo.attemptId,</span><br><span class="line">              taskBinary, part, locs, id, properties, stage.latestInfo.taskMetrics,</span><br><span class="line">              <span class="type">Option</span>(jobId), <span class="type">Option</span>(sc.applicationId), sc.applicationAttemptId)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">NonFatal</span>(e) =&gt;</span><br><span class="line">        abortStage(stage, <span class="string">s&quot;Task creation failed: <span class="subst">$e</span>\n<span class="subst">$&#123;Utils.exceptionString(e)&#125;</span>&quot;</span>, <span class="type">Some</span>(e))</span><br><span class="line">        runningStages -= stage</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 每个Stage中对应的任务Task创建好之后，会发送给TaskScheduler进行Task任务的调度</span></span><br><span class="line">    <span class="keyword">if</span> (tasks.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      logInfo(<span class="string">&quot;Submitting &quot;</span> + tasks.size + <span class="string">&quot; missing tasks from &quot;</span> + stage + <span class="string">&quot; (&quot;</span> + stage.rdd + <span class="string">&quot;)&quot;</span>)</span><br><span class="line">      stage.pendingPartitions ++= tasks.map(_.partitionId)</span><br><span class="line">      logDebug(<span class="string">&quot;New pending partitions: &quot;</span> + stage.pendingPartitions)</span><br><span class="line">        <span class="comment">// 每一个阶段创建好的任务Task会被封装成TaskSet对象，通过TaskScheduler.submitTasks将Stage中的任务Tasks传递给TaskScheduler进行任务的调度</span></span><br><span class="line">      taskScheduler.submitTasks(<span class="keyword">new</span> <span class="type">TaskSet</span>(</span><br><span class="line">        tasks.toArray, stage.id, stage.latestInfo.attemptId, jobId, properties))</span><br><span class="line">      stage.latestInfo.submissionTime = <span class="type">Some</span>(clock.getTimeMillis())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Because we posted SparkListenerStageSubmitted earlier, we should mark</span></span><br><span class="line">      <span class="comment">// the stage as completed here in case there are no tasks to run</span></span><br><span class="line">      markStageAsFinished(stage, <span class="type">None</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> debugString = stage <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> stage: <span class="type">ShuffleMapStage</span> =&gt;</span><br><span class="line">          <span class="string">s&quot;Stage <span class="subst">$&#123;stage&#125;</span> is actually done; &quot;</span> +</span><br><span class="line">            <span class="string">s&quot;(available: <span class="subst">$&#123;stage.isAvailable&#125;</span>,&quot;</span> +</span><br><span class="line">            <span class="string">s&quot;available outputs: <span class="subst">$&#123;stage.numAvailableOutputs&#125;</span>,&quot;</span> +</span><br><span class="line">            <span class="string">s&quot;partitions: <span class="subst">$&#123;stage.numPartitions&#125;</span>)&quot;</span></span><br><span class="line">        <span class="keyword">case</span> stage : <span class="type">ResultStage</span> =&gt;</span><br><span class="line">          <span class="string">s&quot;Stage <span class="subst">$&#123;stage&#125;</span> is actually done; (partitions: <span class="subst">$&#123;stage.numPartitions&#125;</span>)&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">      logDebug(debugString)</span><br><span class="line"></span><br><span class="line">      submitWaitingChildStages(stage)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h5 id="小总结-2"><a href="#小总结-2" class="headerlink" title="小总结"></a>小总结</h5><ol>
<li><p>阶段划分完成之后，<strong>ResultStage</strong>类型的<strong>finalStage</strong>即可创建完成，之后通过**submitStage()**方法进行阶段的提交</p>
</li>
<li><p><strong>submitStage()<strong>接收到</strong>ResultStage</strong>后，首先会尝试获取传入阶段Stage的父阶段：<strong>getMissingParentStages()</strong></p>
</li>
<li><p>如果parent阶段为空，即传入的阶段<strong>没有父阶段</strong>，就通过**submitMissingTask()**方法来提交Stage中的任务</p>
</li>
<li><p>如果parent阶段不为空，即传入的阶段<strong>还有父阶段没有提交</strong>，就递归的调用**submitStage()**进行父阶段的提交</p>
</li>
<li><p>**submitMissingTask()**接收到传入的Stage，会根据传入的Stage的类型创建相应类型的Task</p>
<ul>
<li><table>
<thead>
<tr>
<th align="center">Stage类型</th>
<th align="center">Task类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>ShuffleMapStage</strong></td>
<td align="center"><strong>ShuffleMapTask</strong></td>
</tr>
<tr>
<td align="center"><strong>ResultStage</strong></td>
<td align="center"><strong>ResultTask</strong></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>任务<strong>Task</strong>创建好之后，会被封装成<strong>TaskSet</strong>对象，通过<strong>TaskScheduler</strong>的<strong>submitTasks()<strong>方法传递给</strong>TaskScheduler</strong>进行任务的调度</p>
</li>
</ol>
<h4 id="4-任务的调度"><a href="#4-任务的调度" class="headerlink" title="4. 任务的调度"></a>4. 任务的调度</h4><p><strong>TaskScheduler</strong>是一个Trait特质，其子类<strong>TaskSchedulerImpl</strong>是具体的实现类</p>
<p><strong>TaskSchedulerImpl.scala</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*================================     TaskSchedulerImpl     ================================*/</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">submitTasks</span></span>(taskSet: <span class="type">TaskSet</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> tasks = taskSet.tasks</span><br><span class="line">    logInfo(<span class="string">&quot;Adding task set &quot;</span> + taskSet.id + <span class="string">&quot; with &quot;</span> + tasks.length + <span class="string">&quot; tasks&quot;</span>)</span><br><span class="line">    <span class="keyword">this</span>.synchronized &#123;</span><br><span class="line">        <span class="comment">// 将接收到的TaskSet进一步封装成TaskSetManager对象</span></span><br><span class="line">      <span class="keyword">val</span> manager = createTaskSetManager(taskSet, maxTaskFailures)</span><br><span class="line">      <span class="keyword">val</span> stage = taskSet.stageId</span><br><span class="line">      <span class="keyword">val</span> stageTaskSets =</span><br><span class="line">        taskSetsByStageIdAndAttempt.getOrElseUpdate(stage, <span class="keyword">new</span> <span class="type">HashMap</span>[<span class="type">Int</span>, <span class="type">TaskSetManager</span>])</span><br><span class="line">      stageTaskSets(taskSet.stageAttemptId) = manager</span><br><span class="line">      <span class="keyword">val</span> conflictingTaskSet = stageTaskSets.exists &#123; <span class="keyword">case</span> (_, ts) =&gt;</span><br><span class="line">        ts.taskSet != taskSet &amp;&amp; !ts.isZombie</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (conflictingTaskSet) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">s&quot;more than one active taskSet for stage <span class="subst">$stage</span>:&quot;</span> +</span><br><span class="line">          <span class="string">s&quot; <span class="subst">$&#123;stageTaskSets.toSeq.map&#123;_._2.taskSet.id&#125;</span>.mkString(&quot;</span>,<span class="string">&quot;)&#125;&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="comment">// 将上述构建好的TaskSetManager对象添加到资源调度池中rootPool中（有放就有取，是在backend.reviveOffers()）</span></span><br><span class="line">        <span class="comment">// schedulableBuilder调度构建器，涉及到两种：FIFO和Fair，调度模式默认为FIFO</span></span><br><span class="line">      schedulableBuilder.addTaskSetManager(manager, manager.taskSet.properties)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!isLocal &amp;&amp; !hasReceivedTask) &#123;</span><br><span class="line">        starvationTimer.scheduleAtFixedRate(<span class="keyword">new</span> <span class="type">TimerTask</span>() &#123;</span><br><span class="line">          <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasLaunchedTask) &#123;</span><br><span class="line">              logWarning(<span class="string">&quot;Initial job has not accepted any resources; &quot;</span> +</span><br><span class="line">                <span class="string">&quot;check your cluster UI to ensure that workers are registered &quot;</span> +</span><br><span class="line">                <span class="string">&quot;and have sufficient resources&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">this</span>.cancel()</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="type">STARVATION_TIMEOUT_MS</span>, <span class="type">STARVATION_TIMEOUT_MS</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      hasReceivedTask = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处的调用从资源调度池中取相应的任务（SchedulerBackend 复活，唤醒 Offers）</span></span><br><span class="line">    backend.reviveOffers()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>SchedulerBackend.scala</strong>是一个特质，其子类实现分为集群模式：<strong>CoarseGrainedSchedulerBackend</strong>和本地模式：<strong>LocalSchedulerBackend</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*特质*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A backend interface for scheduling systems that allows plugging in different ones under</span></span><br><span class="line"><span class="comment"> * TaskSchedulerImpl. We assume a Mesos-like model where the application gets resource offers as</span></span><br><span class="line"><span class="comment"> * machines become available and can launch tasks on them.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span>[spark] <span class="class"><span class="keyword">trait</span> <span class="title">SchedulerBackend</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> appId = <span class="string">&quot;spark-application-&quot;</span> + <span class="type">System</span>.currentTimeMillis</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">start</span></span>(): <span class="type">Unit</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">stop</span></span>(): <span class="type">Unit</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">reviveOffers</span></span>(): <span class="type">Unit</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">defaultParallelism</span></span>(): <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">killTask</span></span>(taskId: <span class="type">Long</span>, executorId: <span class="type">String</span>, interruptThread: <span class="type">Boolean</span>): <span class="type">Unit</span> =</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UnsupportedOperationException</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isReady</span></span>(): <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Get an application ID associated with the job.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @return An application ID</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">applicationId</span></span>(): <span class="type">String</span> = appId</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Get the attempt ID for this run, if the cluster manager supports multiple</span></span><br><span class="line"><span class="comment">   * attempts. Applications run in client mode will not have attempt IDs.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @return The application attempt id, if available.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">applicationAttemptId</span></span>(): <span class="type">Option</span>[<span class="type">String</span>] = <span class="type">None</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Get the URLs for the driver logs. These URLs are used to display the links in the UI</span></span><br><span class="line"><span class="comment">   * Executors tab for the driver.</span></span><br><span class="line"><span class="comment">   * @return Map containing the log names and their respective URLs</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getDriverLogUrls</span></span>: <span class="type">Option</span>[<span class="type">Map</span>[<span class="type">String</span>, <span class="type">String</span>]] = <span class="type">None</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CoarseGrainedSchedulerBackend.scala</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">reviveOffers</span></span>() &#123;</span><br><span class="line">    <span class="comment">// SchedulerBackend给自己发送消息，SchedulerBackend在receive方法中接收到消息</span></span><br><span class="line">   driverEndpoint.send(<span class="type">ReviveOffers</span>)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收消息</span></span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">PartialFunction</span>[<span class="type">Any</span>, <span class="type">Unit</span>] = &#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="type">StatusUpdate</span>(executorId, taskId, state, data) =&gt;</span><br><span class="line">       scheduler.statusUpdate(taskId, state, data.value)</span><br><span class="line">       <span class="keyword">if</span> (<span class="type">TaskState</span>.isFinished(state)) &#123;</span><br><span class="line">         executorDataMap.get(executorId) <span class="keyword">match</span> &#123;</span><br><span class="line">           <span class="keyword">case</span> <span class="type">Some</span>(executorInfo) =&gt;</span><br><span class="line">             executorInfo.freeCores += scheduler.<span class="type">CPUS_PER_TASK</span></span><br><span class="line">             makeOffers(executorId)</span><br><span class="line">           <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">             <span class="comment">// Ignoring the update since we don&#x27;t know about the executor.</span></span><br><span class="line">             logWarning(<span class="string">s&quot;Ignored task status update (<span class="subst">$taskId</span> state <span class="subst">$state</span>) &quot;</span> +</span><br><span class="line">               <span class="string">s&quot;from unknown executor with ID <span class="subst">$executorId</span>&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">// 模式匹配，匹配到ReviveOffers类型，最终调用makeOffers方法</span></span><br><span class="line">     <span class="keyword">case</span> <span class="type">ReviveOffers</span> =&gt;</span><br><span class="line">       makeOffers()</span><br><span class="line"></span><br><span class="line">     <span class="keyword">case</span> <span class="type">KillTask</span>(taskId, executorId, interruptThread) =&gt;</span><br><span class="line">       executorDataMap.get(executorId) <span class="keyword">match</span> &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="type">Some</span>(executorInfo) =&gt;</span><br><span class="line">           executorInfo.executorEndpoint.send(<span class="type">KillTask</span>(taskId, executorId, interruptThread))</span><br><span class="line">         <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">           <span class="comment">// Ignoring the task kill since the executor is not registered.</span></span><br><span class="line">           logWarning(<span class="string">s&quot;Attempted to kill task <span class="subst">$taskId</span> for unknown executor <span class="subst">$executorId</span>.&quot;</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Make fake resource offers on all executors：翻译：在所有的Executor上创建假的resource offers</span></span><br><span class="line">   <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">makeOffers</span></span>() &#123;</span><br><span class="line">     <span class="comment">// Filter out executors under killing</span></span><br><span class="line">     <span class="keyword">val</span> activeExecutors = executorDataMap.filterKeys(executorIsAlive)   <span class="comment">// 过滤出目前还存活的Executors</span></span><br><span class="line">       <span class="comment">// 会把存活的Executor封装成workOffers样例类对象，其中包括：Executor的id，Executor的远程Host地址，和Executor的空闲核心数</span></span><br><span class="line">     <span class="keyword">val</span> workOffers = activeExecutors.map &#123; <span class="keyword">case</span> (id, executorData) =&gt;</span><br><span class="line">       <span class="keyword">new</span> <span class="type">WorkerOffer</span>(id, executorData.executorHost, executorData.freeCores)</span><br><span class="line">     &#125;.toIndexedSeq</span><br><span class="line">       <span class="comment">// 最终通过launchTasks方法启动具体的任务</span></span><br><span class="line">     launchTasks(scheduler.resourceOffers(workOffers))</span><br><span class="line">       </span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       	具体从调度池中取任务：scheduler.resourceOffers(workOffers)</span></span><br><span class="line"><span class="comment">       	这里的scheduler就是TaskScheduler任务调度器</span></span><br><span class="line"><span class="comment">       	任务取回之后，会伴随着LaunchTasks消息发送给相应的Executor</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Launch tasks returned by a set of resource offers</span></span><br><span class="line">   <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">launchTasks</span></span>(tasks: <span class="type">Seq</span>[<span class="type">Seq</span>[<span class="type">TaskDescription</span>]]) &#123;</span><br><span class="line">     <span class="keyword">for</span> (task &lt;- tasks.flatten) &#123;</span><br><span class="line">         <span class="comment">// ，每一个task会先序列化</span></span><br><span class="line">       <span class="keyword">val</span> serializedTask = ser.serialize(task)</span><br><span class="line">       <span class="keyword">if</span> (serializedTask.limit &gt;= maxRpcMessageSize) &#123;</span><br><span class="line">         scheduler.taskIdToTaskSetManager.get(task.taskId).foreach &#123; taskSetMgr =&gt;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">var</span> msg = <span class="string">&quot;Serialized task %s:%d was %d bytes, which exceeds max allowed: &quot;</span> +</span><br><span class="line">               <span class="string">&quot;spark.rpc.message.maxSize (%d bytes). Consider increasing &quot;</span> +</span><br><span class="line">               <span class="string">&quot;spark.rpc.message.maxSize or using broadcast variables for large values.&quot;</span></span><br><span class="line">             msg = msg.format(task.taskId, task.index, serializedTask.limit, maxRpcMessageSize)</span><br><span class="line">             taskSetMgr.abort(msg)</span><br><span class="line">           &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">             <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt; logError(<span class="string">&quot;Exception in error callback&quot;</span>, e)</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">val</span> executorData = executorDataMap(task.executorId)</span><br><span class="line">         executorData.freeCores -= scheduler.<span class="type">CPUS_PER_TASK</span></span><br><span class="line"></span><br><span class="line">         logDebug(<span class="string">s&quot;Launching task <span class="subst">$&#123;task.taskId&#125;</span> on executor id: <span class="subst">$&#123;task.executorId&#125;</span> hostname: &quot;</span> +</span><br><span class="line">           <span class="string">s&quot;<span class="subst">$&#123;executorData.executorHost&#125;</span>.&quot;</span>)</span><br><span class="line">		<span class="comment">// 向ExecutorEndPoint发送相应的LaunchTask消息（序列化后的task会被封装成LaunchTask消息）</span></span><br><span class="line">         executorData.executorEndpoint.send(<span class="type">LaunchTask</span>(<span class="keyword">new</span> <span class="type">SerializableBuffer</span>(serializedTask)))</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>TaskSchedulerImpl.scala</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从资源调度池中取出相应的任务Tasks </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Called by cluster manager to offer resources on slaves. We respond by asking our active task</span></span><br><span class="line"><span class="comment">   * sets for tasks in order of priority. We fill each node with tasks in a round-robin manner so</span></span><br><span class="line"><span class="comment">   * that tasks are balanced across the cluster.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">resourceOffers</span></span>(offers: <span class="type">IndexedSeq</span>[<span class="type">WorkerOffer</span>]): <span class="type">Seq</span>[<span class="type">Seq</span>[<span class="type">TaskDescription</span>]] = synchronized &#123;</span><br><span class="line">    <span class="comment">// Mark each slave as alive and remember its hostname</span></span><br><span class="line">    <span class="comment">// Also track if new executor is added</span></span><br><span class="line">    <span class="keyword">var</span> newExecAvail = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> (o &lt;- offers) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hostToExecutors.contains(o.host)) &#123;</span><br><span class="line">        hostToExecutors(o.host) = <span class="keyword">new</span> <span class="type">HashSet</span>[<span class="type">String</span>]()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!executorIdToRunningTaskIds.contains(o.executorId)) &#123;</span><br><span class="line">        hostToExecutors(o.host) += o.executorId</span><br><span class="line">        executorAdded(o.executorId, o.host)</span><br><span class="line">        executorIdToHost(o.executorId) = o.host</span><br><span class="line">        executorIdToRunningTaskIds(o.executorId) = <span class="type">HashSet</span>[<span class="type">Long</span>]()</span><br><span class="line">        newExecAvail = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (rack &lt;- getRackForHost(o.host)) &#123;</span><br><span class="line">        hostsByRack.getOrElseUpdate(rack, <span class="keyword">new</span> <span class="type">HashSet</span>[<span class="type">String</span>]()) += o.host</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Randomly shuffle offers to avoid always placing tasks on the same set of workers.</span></span><br><span class="line">    <span class="keyword">val</span> shuffledOffers = <span class="type">Random</span>.shuffle(offers)</span><br><span class="line">    <span class="comment">// Build a list of tasks to assign to each worker.</span></span><br><span class="line">      <span class="comment">// 每个Task和相应的workOffer会被分装成TaskDescription对象，这些TaskDescription对象就是最终要返回的Tasks</span></span><br><span class="line">    <span class="keyword">val</span> tasks = shuffledOffers.map(o =&gt; <span class="keyword">new</span> <span class="type">ArrayBuffer</span>[<span class="type">TaskDescription</span>](o.cores))</span><br><span class="line">    <span class="keyword">val</span> availableCpus = shuffledOffers.map(o =&gt; o.cores).toArray</span><br><span class="line">      <span class="comment">// 调度池中的任务会根据调度算法进行任务的优先级排序，得到排序好的任务集</span></span><br><span class="line">    <span class="keyword">val</span> sortedTaskSets = rootPool.getSortedTaskSetQueue</span><br><span class="line">    <span class="keyword">for</span> (taskSet &lt;- sortedTaskSets) &#123;</span><br><span class="line">      logDebug(<span class="string">&quot;parentName: %s, name: %s, runningTasks: %s&quot;</span>.format(</span><br><span class="line">        taskSet.parent.name, taskSet.name, taskSet.runningTasks))</span><br><span class="line">      <span class="keyword">if</span> (newExecAvail) &#123;</span><br><span class="line">        taskSet.executorAdded()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Take each TaskSet in our scheduling order, and then offer it each node in increasing order</span></span><br><span class="line">    <span class="comment">// of locality levels so that it gets a chance to launch local tasks on all of them.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> the preferredLocality order: PROCESS_LOCAL, NODE_LOCAL, NO_PREF, RACK_LOCAL, ANY</span></span><br><span class="line">      <span class="comment">// 任务的本地化调度级别：进程本地化，节点本地化，机架本地化，任意，无偏向</span></span><br><span class="line">    <span class="keyword">for</span> (taskSet &lt;- sortedTaskSets) &#123;</span><br><span class="line">      <span class="keyword">var</span> launchedAnyTask = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">var</span> launchedTaskAtCurrentMaxLocality = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// 任务的本地化级别调度，移动数据不如移动计算</span></span><br><span class="line">      <span class="keyword">for</span> (currentMaxLocality &lt;- taskSet.myLocalityLevels) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">          launchedTaskAtCurrentMaxLocality = resourceOfferSingleTaskSet(</span><br><span class="line">            taskSet, currentMaxLocality, shuffledOffers, availableCpus, tasks)</span><br><span class="line">          launchedAnyTask |= launchedTaskAtCurrentMaxLocality</span><br><span class="line">        &#125; <span class="keyword">while</span> (launchedTaskAtCurrentMaxLocality)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!launchedAnyTask) &#123;</span><br><span class="line">        taskSet.abortIfCompletelyBlacklisted(hostToExecutors)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tasks.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      hasLaunchedTask = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 返回任务</span></span><br><span class="line">    <span class="keyword">return</span> tasks</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h5 id="小总结-3"><a href="#小总结-3" class="headerlink" title="小总结"></a>小总结</h5><ol>
<li><strong>TaskScheduler</strong>的<strong>submitTask()<strong>方法接收到</strong>DAGScheduler</strong>传递过来的<strong>TaskSet</strong>，将<strong>TaskSet</strong>进一步封装成<strong>TaskSetManager</strong>，来监控或者失败重试相应的<strong>Task</strong></li>
<li><strong>TaskSetManager</strong>构建好之后，<strong>TaskScheduler</strong>会将<strong>TaskSetManager</strong>加入到资源调度池<strong>rootPool</strong>中</li>
<li>资源调度池中有放就有取</li>
<li>实际触发取出资源调度池中的任务的方式是<strong>backend.reviveOffers()</strong></li>
<li><strong>SchedulerBackend</strong>(调度后端)的<strong>reviveOffers()<strong>方法会通过</strong>DriverEndPoint.send(ReviveOffers)<strong>给自己发送消息；</strong>CoarseGrainedSchedulerBackend</strong>接收到消息后根据消息的类型匹配到<strong>ReviveOffer</strong>类型，然后执行<strong>makeOffers()<strong>方法创建</strong>WorkOffer</strong></li>
<li><strong>makeOffers()<strong>方法中，首先会过滤出目前存活的</strong>Executor</strong>，然后将<strong>Executor</strong>封装成<strong>WorkOffer</strong>对象<strong>workOffers</strong></li>
<li><strong>workOffers</strong>创建完成后，<strong>TaskScheduler</strong>会按照<strong>FIFO</strong>（默认）或者<strong>Fair</strong>调度算法从资源调度池中取出相应的<strong>TaskSetManager</strong>，进一步取出<strong>TaskSet</strong>中<strong>Task</strong>，结合<strong>workOffers</strong>，按照任务的本地化调度级别，将<strong>Task</strong>和相应的<strong>workOffer</strong>封装成<strong>TaskDescription</strong>对象</li>
<li>接下来通过<strong>launchTask()<strong>方法将</strong>TaskDescription</strong>任务信息发送给远程的<strong>Executor</strong>机器上</li>
<li>在<strong>launchTask()<strong>方法内部，首先会对</strong>TaskDescription</strong>进行序列化，序列化完成后，会将序列化后的数据封装成<strong>LaunchTask</strong>对象消息</li>
<li>最终<strong>LaunchTask</strong>消息会被发送到远程的<strong>ExecutorEndPoint</strong>上，进行任务的执行</li>
</ol>
<h4 id="5-任务的执行"><a href="#5-任务的执行" class="headerlink" title="5. 任务的执行"></a>5. 任务的执行</h4><p><strong>CoarseGrainedExecutorBackend</strong>接收到<strong>CoarseGrainedSchedulerBackend</strong>发送来的<strong>LaunchTask</strong>消息。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*======================================  CoarseGrainedExecutorBackend.scala  =======================================*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">PartialFunction</span>[<span class="type">Any</span>, <span class="type">Unit</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">RegisteredExecutor</span> =&gt;</span><br><span class="line">      logInfo(<span class="string">&quot;Successfully registered with driver&quot;</span>)</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> <span class="type">Executor</span>(executorId, hostname, env, userClassPath, isLocal = <span class="literal">false</span>)</span><br><span class="line">      &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">NonFatal</span>(e) =&gt;</span><br><span class="line">          exitExecutor(<span class="number">1</span>, <span class="string">&quot;Unable to create executor due to &quot;</span> + e.getMessage, e)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="type">RegisterExecutorFailed</span>(message) =&gt;</span><br><span class="line">      exitExecutor(<span class="number">1</span>, <span class="string">&quot;Slave registration failed: &quot;</span> + message)</span><br><span class="line">	<span class="comment">// 接收到消息，并匹配到LaunchTask类型的消息</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">LaunchTask</span>(data) =&gt;</span><br><span class="line">      <span class="keyword">if</span> (executor == <span class="literal">null</span>) &#123;</span><br><span class="line">        exitExecutor(<span class="number">1</span>, <span class="string">&quot;Received LaunchTask command but executor was null&quot;</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 将LaunchTask中的消息进行反序列化，得到相应的TaskDescription</span></span><br><span class="line">        <span class="keyword">val</span> taskDesc = ser.deserialize[<span class="type">TaskDescription</span>](data.value)</span><br><span class="line">        logInfo(<span class="string">&quot;Got assigned task &quot;</span> + taskDesc.taskId)</span><br><span class="line">          <span class="comment">// executor通过launchTask()方法在Executor上发布相应的Task</span></span><br><span class="line">        executor.launchTask(<span class="keyword">this</span>, taskId = taskDesc.taskId, attemptNumber = taskDesc.attemptNumber,</span><br><span class="line">          taskDesc.name, taskDesc.serializedTask)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="type">KillTask</span>(taskId, _, interruptThread) =&gt;</span><br><span class="line">      <span class="keyword">if</span> (executor == <span class="literal">null</span>) &#123;</span><br><span class="line">        exitExecutor(<span class="number">1</span>, <span class="string">&quot;Received KillTask command but executor was null&quot;</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executor.killTask(taskId, interruptThread)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="type">StopExecutor</span> =&gt;</span><br><span class="line">      stopping.set(<span class="literal">true</span>)</span><br><span class="line">      logInfo(<span class="string">&quot;Driver commanded a shutdown&quot;</span>)</span><br><span class="line">      <span class="comment">// Cannot shutdown here because an ack may need to be sent back to the caller. So send</span></span><br><span class="line">      <span class="comment">// a message to self to actually do the shutdown.</span></span><br><span class="line">      self.send(<span class="type">Shutdown</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Shutdown</span> =&gt;</span><br><span class="line">      stopping.set(<span class="literal">true</span>)</span><br><span class="line">      <span class="keyword">new</span> <span class="type">Thread</span>(<span class="string">&quot;CoarseGrainedExecutorBackend-stop-executor&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">          <span class="comment">// executor.stop() will call `SparkEnv.stop()` which waits until RpcEnv stops totally.</span></span><br><span class="line">          <span class="comment">// However, if `executor.stop()` runs in some thread of RpcEnv, RpcEnv won&#x27;t be able to</span></span><br><span class="line">          <span class="comment">// stop until `executor.stop()` returns, which becomes a dead-lock (See SPARK-14180).</span></span><br><span class="line">          <span class="comment">// Therefore, we put this line in a new thread.</span></span><br><span class="line">          executor.stop()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;.start()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Executor.scala</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Maintains the list of running tasks.</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> runningTasks = <span class="keyword">new</span> <span class="type">ConcurrentHashMap</span>[<span class="type">Long</span>, <span class="type">TaskRunner</span>]  <span class="comment">// 维护正在运行的task列表</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">launchTask</span></span>(</span><br><span class="line">      context: <span class="type">ExecutorBackend</span>,</span><br><span class="line">      taskId: <span class="type">Long</span>,</span><br><span class="line">      attemptNumber: <span class="type">Int</span>,</span><br><span class="line">      taskName: <span class="type">String</span>,</span><br><span class="line">      serializedTask: <span class="type">ByteBuffer</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="comment">// 此处的tr实际上是创建一个实现了Runnable接口的线程对象TaskRunner</span></span><br><span class="line">    <span class="keyword">val</span> tr = <span class="keyword">new</span> <span class="type">TaskRunner</span>(context, taskId = taskId, attemptNumber = attemptNumber, taskName,</span><br><span class="line">      serializedTask)</span><br><span class="line">      <span class="comment">// 记录正在运行的Task</span></span><br><span class="line">    runningTasks.put(taskId, tr)</span><br><span class="line">      <span class="comment">// 通过线程池来最终执行相应的的Task任务</span></span><br><span class="line">    threadPool.execute(tr)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*================================   TaskRunner类继承了Runnable接口    ================================*/</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">TaskRunner</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">      execBackend: <span class="type">ExecutorBackend</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">      val taskId: <span class="type">Long</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">      val attemptNumber: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">      taskName: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">      serializedTask: <span class="type">ByteBuffer</span></span>)</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="type">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> threadName = <span class="string">s&quot;Executor task launch worker for task <span class="subst">$taskId</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Whether this task has been killed. */</span></span><br><span class="line">    <span class="meta">@volatile</span> <span class="keyword">private</span> <span class="keyword">var</span> killed = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@volatile</span> <span class="keyword">private</span> <span class="keyword">var</span> threadId: <span class="type">Long</span> = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getThreadId</span></span>: <span class="type">Long</span> = threadId</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Whether this task has been finished. */</span></span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">&quot;TaskRunner.this&quot;</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> finished = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isFinished</span></span>: <span class="type">Boolean</span> = synchronized &#123; finished &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** How much the JVM process has spent in GC when the task starts to run. */</span></span><br><span class="line">    <span class="meta">@volatile</span> <span class="keyword">var</span> startGCTime: <span class="type">Long</span> = _</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The task to run. This will be set in run() by deserializing the task binary coming</span></span><br><span class="line"><span class="comment">     * from the driver. Once it is set, it will never be changed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@volatile</span> <span class="keyword">var</span> task: <span class="type">Task</span>[<span class="type">Any</span>] = _</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kill</span></span>(interruptThread: <span class="type">Boolean</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">      logInfo(<span class="string">s&quot;Executor is trying to kill <span class="subst">$taskName</span> (TID <span class="subst">$taskId</span>)&quot;</span>)</span><br><span class="line">      killed = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">if</span> (task != <span class="literal">null</span>) &#123;</span><br><span class="line">        synchronized &#123;</span><br><span class="line">          <span class="keyword">if</span> (!finished) &#123;</span><br><span class="line">            task.kill(interruptThread)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the finished flag to true and clear the current thread&#x27;s interrupt status</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">setTaskFinishedAndClearInterruptStatus</span></span>(): <span class="type">Unit</span> = synchronized &#123;</span><br><span class="line">      <span class="keyword">this</span>.finished = <span class="literal">true</span></span><br><span class="line">      <span class="comment">// SPARK-14234 - Reset the interrupted status of the thread to avoid the</span></span><br><span class="line">      <span class="comment">// ClosedByInterruptException during execBackend.statusUpdate which causes</span></span><br><span class="line">      <span class="comment">// Executor to crash</span></span><br><span class="line">      <span class="type">Thread</span>.interrupted()</span><br><span class="line">      <span class="comment">// Notify any waiting TaskReapers. Generally there will only be one reaper per task but there</span></span><br><span class="line">      <span class="comment">// is a rare corner-case where one task can have two reapers in case cancel(interrupt=False)</span></span><br><span class="line">      <span class="comment">// is followed by cancel(interrupt=True). Thus we use notifyAll() to avoid a lost wakeup:</span></span><br><span class="line">      notifyAll()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">      threadId = <span class="type">Thread</span>.currentThread.getId</span><br><span class="line">      <span class="type">Thread</span>.currentThread.setName(threadName)</span><br><span class="line">      <span class="keyword">val</span> threadMXBean = <span class="type">ManagementFactory</span>.getThreadMXBean</span><br><span class="line">      <span class="keyword">val</span> taskMemoryManager = <span class="keyword">new</span> <span class="type">TaskMemoryManager</span>(env.memoryManager, taskId)</span><br><span class="line">      <span class="keyword">val</span> deserializeStartTime = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line">      <span class="keyword">val</span> deserializeStartCpuTime = <span class="keyword">if</span> (threadMXBean.isCurrentThreadCpuTimeSupported) &#123;</span><br><span class="line">        threadMXBean.getCurrentThreadCpuTime</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="number">0</span>L</span><br><span class="line">      <span class="type">Thread</span>.currentThread.setContextClassLoader(replClassLoader)</span><br><span class="line">      <span class="keyword">val</span> ser = env.closureSerializer.newInstance()</span><br><span class="line">      logInfo(<span class="string">s&quot;Running <span class="subst">$taskName</span> (TID <span class="subst">$taskId</span>)&quot;</span>)</span><br><span class="line">      execBackend.statusUpdate(taskId, <span class="type">TaskState</span>.<span class="type">RUNNING</span>, <span class="type">EMPTY_BYTE_BUFFER</span>)</span><br><span class="line">      <span class="keyword">var</span> taskStart: <span class="type">Long</span> = <span class="number">0</span></span><br><span class="line">      <span class="keyword">var</span> taskStartCpu: <span class="type">Long</span> = <span class="number">0</span></span><br><span class="line">      startGCTime = computeTotalGcTime()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> (taskFiles, taskJars, taskProps, taskBytes) =</span><br><span class="line">          <span class="type">Task</span>.deserializeWithDependencies(serializedTask)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Must be set before updateDependencies() is called, in case fetching dependencies</span></span><br><span class="line">        <span class="comment">// requires access to properties contained within (e.g. for access control).</span></span><br><span class="line">        <span class="type">Executor</span>.taskDeserializationProps.set(taskProps)</span><br><span class="line"></span><br><span class="line">        updateDependencies(taskFiles, taskJars)</span><br><span class="line">        task = ser.deserialize[<span class="type">Task</span>[<span class="type">Any</span>]](taskBytes, <span class="type">Thread</span>.currentThread.getContextClassLoader)</span><br><span class="line">        task.localProperties = taskProps</span><br><span class="line">        task.setTaskMemoryManager(taskMemoryManager)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If this task has been killed before we deserialized it, let&#x27;s quit now. Otherwise,</span></span><br><span class="line">        <span class="comment">// continue executing the task.</span></span><br><span class="line">        <span class="keyword">if</span> (killed) &#123;</span><br><span class="line">          <span class="comment">// Throw an exception rather than returning, because returning within a try&#123;&#125; block</span></span><br><span class="line">          <span class="comment">// causes a NonLocalReturnControl exception to be thrown. The NonLocalReturnControl</span></span><br><span class="line">          <span class="comment">// exception will be caught by the catch block, leading to an incorrect ExceptionFailure</span></span><br><span class="line">          <span class="comment">// for the task.</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">TaskKilledException</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logDebug(<span class="string">&quot;Task &quot;</span> + taskId + <span class="string">&quot;&#x27;s epoch is &quot;</span> + task.epoch)</span><br><span class="line">        env.mapOutputTracker.updateEpoch(task.epoch)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the actual task and measure its runtime.</span></span><br><span class="line">        taskStart = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line">        taskStartCpu = <span class="keyword">if</span> (threadMXBean.isCurrentThreadCpuTimeSupported) &#123;</span><br><span class="line">          threadMXBean.getCurrentThreadCpuTime</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="number">0</span>L</span><br><span class="line">        <span class="keyword">var</span> threwException = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">val</span> value = <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 任务真正的运行</span></span><br><span class="line">          <span class="keyword">val</span> res = task.run(</span><br><span class="line">            taskAttemptId = taskId,</span><br><span class="line">            attemptNumber = attemptNumber,</span><br><span class="line">            metricsSystem = env.metricsSystem)</span><br><span class="line">          threwException = <span class="literal">false</span></span><br><span class="line">          res</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">val</span> releasedLocks = env.blockManager.releaseAllLocksForTask(taskId)</span><br><span class="line">          <span class="keyword">val</span> freedMemory = taskMemoryManager.cleanUpAllAllocatedMemory()</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (freedMemory &gt; <span class="number">0</span> &amp;&amp; !threwException) &#123;</span><br><span class="line">            <span class="keyword">val</span> errMsg = <span class="string">s&quot;Managed memory leak detected; size = <span class="subst">$freedMemory</span> bytes, TID = <span class="subst">$taskId</span>&quot;</span></span><br><span class="line">            <span class="keyword">if</span> (conf.getBoolean(<span class="string">&quot;spark.unsafe.exceptionOnMemoryLeak&quot;</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(errMsg)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              logWarning(errMsg)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (releasedLocks.nonEmpty &amp;&amp; !threwException) &#123;</span><br><span class="line">            <span class="keyword">val</span> errMsg =</span><br><span class="line">              <span class="string">s&quot;<span class="subst">$&#123;releasedLocks.size&#125;</span> block locks were not released by TID = <span class="subst">$taskId</span>:\n&quot;</span> +</span><br><span class="line">                releasedLocks.mkString(<span class="string">&quot;[&quot;</span>, <span class="string">&quot;, &quot;</span>, <span class="string">&quot;]&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> (conf.getBoolean(<span class="string">&quot;spark.storage.exceptionOnPinLeak&quot;</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(errMsg)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              logWarning(errMsg)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> taskFinish = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line">        <span class="keyword">val</span> taskFinishCpu = <span class="keyword">if</span> (threadMXBean.isCurrentThreadCpuTimeSupported) &#123;</span><br><span class="line">          threadMXBean.getCurrentThreadCpuTime</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="number">0</span>L</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the task has been killed, let&#x27;s fail it.</span></span><br><span class="line">        <span class="keyword">if</span> (task.killed) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">TaskKilledException</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> resultSer = env.serializer.newInstance()</span><br><span class="line">        <span class="keyword">val</span> beforeSerialization = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line">        <span class="keyword">val</span> valueBytes = resultSer.serialize(value)</span><br><span class="line">        <span class="keyword">val</span> afterSerialization = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Deserialization happens in two parts: first, we deserialize a Task object, which</span></span><br><span class="line">        <span class="comment">// includes the Partition. Second, Task.run() deserializes the RDD and function to be run.</span></span><br><span class="line">        task.metrics.setExecutorDeserializeTime(</span><br><span class="line">          (taskStart - deserializeStartTime) + task.executorDeserializeTime)</span><br><span class="line">        task.metrics.setExecutorDeserializeCpuTime(</span><br><span class="line">          (taskStartCpu - deserializeStartCpuTime) + task.executorDeserializeCpuTime)</span><br><span class="line">        <span class="comment">// We need to subtract Task.run()&#x27;s deserialization time to avoid double-counting</span></span><br><span class="line">        task.metrics.setExecutorRunTime((taskFinish - taskStart) - task.executorDeserializeTime)</span><br><span class="line">        task.metrics.setExecutorCpuTime(</span><br><span class="line">          (taskFinishCpu - taskStartCpu) - task.executorDeserializeCpuTime)</span><br><span class="line">        task.metrics.setJvmGCTime(computeTotalGcTime() - startGCTime)</span><br><span class="line">        task.metrics.setResultSerializationTime(afterSerialization - beforeSerialization)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Note: accumulator updates must be collected after TaskMetrics is updated</span></span><br><span class="line">        <span class="keyword">val</span> accumUpdates = task.collectAccumulatorUpdates()</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> do not serialize value twice</span></span><br><span class="line">        <span class="keyword">val</span> directResult = <span class="keyword">new</span> <span class="type">DirectTaskResult</span>(valueBytes, accumUpdates)</span><br><span class="line">        <span class="keyword">val</span> serializedDirectResult = ser.serialize(directResult)</span><br><span class="line">        <span class="keyword">val</span> resultSize = serializedDirectResult.limit</span><br><span class="line"></span><br><span class="line">        <span class="comment">// directSend = sending directly back to the driver</span></span><br><span class="line">        <span class="keyword">val</span> serializedResult: <span class="type">ByteBuffer</span> = &#123;</span><br><span class="line">          <span class="keyword">if</span> (maxResultSize &gt; <span class="number">0</span> &amp;&amp; resultSize &gt; maxResultSize) &#123;</span><br><span class="line">            logWarning(<span class="string">s&quot;Finished <span class="subst">$taskName</span> (TID <span class="subst">$taskId</span>). Result is larger than maxResultSize &quot;</span> +</span><br><span class="line">              <span class="string">s&quot;(<span class="subst">$&#123;Utils.bytesToString(resultSize)&#125;</span> &gt; <span class="subst">$&#123;Utils.bytesToString(maxResultSize)&#125;</span>), &quot;</span> +</span><br><span class="line">              <span class="string">s&quot;dropping it.&quot;</span>)</span><br><span class="line">            ser.serialize(<span class="keyword">new</span> <span class="type">IndirectTaskResult</span>[<span class="type">Any</span>](<span class="type">TaskResultBlockId</span>(taskId), resultSize))</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resultSize &gt; maxDirectResultSize) &#123;</span><br><span class="line">            <span class="keyword">val</span> blockId = <span class="type">TaskResultBlockId</span>(taskId)</span><br><span class="line">            env.blockManager.putBytes(</span><br><span class="line">              blockId,</span><br><span class="line">              <span class="keyword">new</span> <span class="type">ChunkedByteBuffer</span>(serializedDirectResult.duplicate()),</span><br><span class="line">              <span class="type">StorageLevel</span>.<span class="type">MEMORY_AND_DISK_SER</span>)</span><br><span class="line">            logInfo(</span><br><span class="line">              <span class="string">s&quot;Finished <span class="subst">$taskName</span> (TID <span class="subst">$taskId</span>). <span class="subst">$resultSize</span> bytes result sent via BlockManager)&quot;</span>)</span><br><span class="line">            ser.serialize(<span class="keyword">new</span> <span class="type">IndirectTaskResult</span>[<span class="type">Any</span>](blockId, resultSize))</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logInfo(<span class="string">s&quot;Finished <span class="subst">$taskName</span> (TID <span class="subst">$taskId</span>). <span class="subst">$resultSize</span> bytes result sent to driver&quot;</span>)</span><br><span class="line">            serializedDirectResult</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        execBackend.statusUpdate(taskId, <span class="type">TaskState</span>.<span class="type">FINISHED</span>, serializedResult)</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> ffe: <span class="type">FetchFailedException</span> =&gt;</span><br><span class="line">          <span class="keyword">val</span> reason = ffe.toTaskFailedReason</span><br><span class="line">          setTaskFinishedAndClearInterruptStatus()</span><br><span class="line">          execBackend.statusUpdate(taskId, <span class="type">TaskState</span>.<span class="type">FAILED</span>, ser.serialize(reason))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> _: <span class="type">TaskKilledException</span> =&gt;</span><br><span class="line">          logInfo(<span class="string">s&quot;Executor killed <span class="subst">$taskName</span> (TID <span class="subst">$taskId</span>)&quot;</span>)</span><br><span class="line">          setTaskFinishedAndClearInterruptStatus()</span><br><span class="line">          execBackend.statusUpdate(taskId, <span class="type">TaskState</span>.<span class="type">KILLED</span>, ser.serialize(<span class="type">TaskKilled</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> _: <span class="type">InterruptedException</span> <span class="keyword">if</span> task.killed =&gt;</span><br><span class="line">          logInfo(<span class="string">s&quot;Executor interrupted and killed <span class="subst">$taskName</span> (TID <span class="subst">$taskId</span>)&quot;</span>)</span><br><span class="line">          setTaskFinishedAndClearInterruptStatus()</span><br><span class="line">          execBackend.statusUpdate(taskId, <span class="type">TaskState</span>.<span class="type">KILLED</span>, ser.serialize(<span class="type">TaskKilled</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="type">CausedBy</span>(cDE: <span class="type">CommitDeniedException</span>) =&gt;</span><br><span class="line">          <span class="keyword">val</span> reason = cDE.toTaskFailedReason</span><br><span class="line">          setTaskFinishedAndClearInterruptStatus()</span><br><span class="line">          execBackend.statusUpdate(taskId, <span class="type">TaskState</span>.<span class="type">FAILED</span>, ser.serialize(reason))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> t: <span class="type">Throwable</span> =&gt;</span><br><span class="line">          <span class="comment">// Attempt to exit cleanly by informing the driver of our failure.</span></span><br><span class="line">          <span class="comment">// If anything goes wrong (or this was a fatal exception), we will delegate to</span></span><br><span class="line">          <span class="comment">// the default uncaught exception handler, which will terminate the Executor.</span></span><br><span class="line">          logError(<span class="string">s&quot;Exception in <span class="subst">$taskName</span> (TID <span class="subst">$taskId</span>)&quot;</span>, t)</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Collect latest accumulator values to report back to the driver</span></span><br><span class="line">          <span class="keyword">val</span> accums: <span class="type">Seq</span>[<span class="type">AccumulatorV2</span>[_, _]] =</span><br><span class="line">            <span class="keyword">if</span> (task != <span class="literal">null</span>) &#123;</span><br><span class="line">              task.metrics.setExecutorRunTime(<span class="type">System</span>.currentTimeMillis() - taskStart)</span><br><span class="line">              task.metrics.setJvmGCTime(computeTotalGcTime() - startGCTime)</span><br><span class="line">              task.collectAccumulatorUpdates(taskFailed = <span class="literal">true</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="type">Seq</span>.empty</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">val</span> accUpdates = accums.map(acc =&gt; acc.toInfo(<span class="type">Some</span>(acc.value), <span class="type">None</span>))</span><br><span class="line"></span><br><span class="line">          <span class="keyword">val</span> serializedTaskEndReason = &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              ser.serialize(<span class="keyword">new</span> <span class="type">ExceptionFailure</span>(t, accUpdates).withAccums(accums))</span><br><span class="line">            &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">              <span class="keyword">case</span> _: <span class="type">NotSerializableException</span> =&gt;</span><br><span class="line">                <span class="comment">// t is not serializable so just send the stacktrace</span></span><br><span class="line">                ser.serialize(<span class="keyword">new</span> <span class="type">ExceptionFailure</span>(t, accUpdates, <span class="literal">false</span>).withAccums(accums))</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          setTaskFinishedAndClearInterruptStatus()</span><br><span class="line">          execBackend.statusUpdate(taskId, <span class="type">TaskState</span>.<span class="type">FAILED</span>, serializedTaskEndReason)</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Don&#x27;t forcibly exit unless the exception was inherently fatal, to avoid</span></span><br><span class="line">          <span class="comment">// stopping other tasks unnecessarily.</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="type">Utils</span>.isFatalError(t)) &#123;</span><br><span class="line">            <span class="type">SparkUncaughtExceptionHandler</span>.uncaughtException(t)</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        runningTasks.remove(taskId)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h5 id="小总结-4"><a href="#小总结-4" class="headerlink" title="小总结"></a>小总结</h5><ol>
<li><strong>CoarseGrainedExecutorBackend</strong>接收到<strong>CoarseGrainedSchedulerBackend</strong>发送过来的<strong>LaunchTask</strong>消息</li>
<li>在<strong>CoarseGrainedExecutorBackend</strong>内部，首先会对<strong>LaunchTask</strong>消息进行反序列化，重新得到序列化之前的<strong>TaskDescription</strong>对象</li>
<li>反序列化出来的<strong>TaskDescription</strong>会被<strong>Executor</strong>通过**launchTask()**方法发布任务Task</li>
<li>在<strong>Executor</strong>的<strong>launchTask</strong>方法内部，首先会根据<strong>TaskDescription</strong>创建一个实现了<strong>Runnable</strong>接口的线程<strong>TaskRuner</strong>对象<strong>tr</strong></li>
<li>然后记录正在运行的任务</li>
<li>最终通过线程池<strong>threadPool</strong>来执行<strong>TaskRunner</strong>对象<strong>tr</strong></li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="source/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6-16334225169802.svg" alt="未命名文件"></p>
<ol>
<li>编写的<strong>Spark</strong>程序，每遇到一个<strong>Action</strong>算子就会启动一个<strong>Job</strong></li>
<li>首先会进入<strong>DAGScheduler</strong>的<strong>runJob</strong>方法中，进一步触发<strong>DAGScheduler</strong>中的**submitJob()**方法</li>
<li><strong>submitJob()<strong>方法内部会将</strong>rdd</strong>封装成实现了<strong>DAGSchedulerEvent</strong>类的<strong>JobSubmitted</strong>事件，添加到<strong>DAGSchedulerEventProcessLoop</strong>中的<strong>eventQueue</strong>中</li>
<li><strong>DAGSchedulerEventProcessLoop</strong>中会有一个事件线程<strong>EventThread</strong>，<strong>run</strong>方法就会从阻塞队列<code>EventQueue</code>中取出相应的事件进行运行。</li>
<li>取出来的事件会通过<strong>handleJobSubmitted()<strong>方法进行</strong>阶段的划分</strong>和<strong>阶段的提交</strong>处理</li>
<li>在<strong>handleJobSubmitted</strong>方法内部，首先会定义一个<strong>ResultStage</strong>类型的变量<strong>finalStage</strong>，在真正赋值之前会先创建其父阶段（如果父阶段存在），每个<strong>stage</strong>对象都会记录其<strong>父阶段</strong>的信息<strong>Parent</strong></li>
<li><strong>finalStage</strong>创建完成之后，通过<strong>submitStage()<strong>方法提交</strong>ResultStage</strong>阶段</li>
<li>submitStage()方法内部，首先会通过<strong>getMissingParentStages()<strong>方法获取传递过来的阶段的父阶段，如果父阶段存在，则递归的提交父阶段</strong>submitStage(parentStage)</strong>,如果不存在父阶段，就通过<strong>submitMissingTasks(…)<strong>进行</strong>阶段中任务的切分与提交</strong></li>
<li>在<strong>submitMissingTask()<strong>方法中，会根据传递过来的</strong>stage</strong>的类型创建相应类型的<strong>Task</strong><ul>
<li>如果<strong>Stage</strong>的类型是<strong>ShuffleMapStage</strong>，就创建<strong>ShuffleMapTask</strong>类型的<strong>Task</strong></li>
<li>如果<strong>Stage</strong>的类型是<strong>ResultStage</strong>，就创建<strong>ResultTask</strong>类型的<strong>Task</strong></li>
</ul>
</li>
<li>一个阶段中的<strong>Tasks</strong>创建完成后，会被封装成<strong>TaskSet</strong>对象</li>
<li>通过<strong>taskScheduler.submitTask()<strong>方法传递给</strong>TaskScheduler</strong>进行任务级别的调度</li>
<li><strong>TaskScheduler</strong>的<strong>submitTask()<strong>方法接收到</strong>TaskSet</strong>后，会把<strong>TaskSet</strong>进一步封装成<strong>TaskSetManager</strong>对象（负责监控任务的执行状态，失败重试等），然后根据<strong>FIFO（默认）</strong>或者<strong>Fair策略</strong>加入到资源调度池<strong>rooPool</strong>中</li>
<li>每调用一次<strong>submitTask</strong>方法，就会相应的执行一次**backend.reviveOffers()**方法</li>
<li>集群下对应的<strong>SchedulerBackend</strong>为<strong>CoarseGrainedSchedulerBackend</strong>，其中<strong>reviveOffers()<strong>方法内部会通过</strong>driverEndPoint.send(ReviveOffers)<strong>给自己发送</strong>ReviveOffers</strong>消息</li>
<li><strong>CoarseGrainedSchedulerBackend</strong>收到传来的<strong>ReviveOffers</strong>类型的消息后，触发**makeOffers()**方法</li>
<li><strong>makeOffers()<strong>方法首先会过滤出目前还存活的</strong>Executor</strong>，并将存活的<strong>Executor</strong>封装成<strong>WorkOffers</strong>对象<strong>workOffers</strong>，之后调用<code>taskScheduler.resourceOffers(workOffers)</code></li>
<li>随后会通过<strong>TaskScheduler</strong>中的<strong>resourceOffers(workOffers)<strong>，将资源调度池rootPool中的TaskSetManager按照特定的</strong>调度算法FIFO(默认)或者Fair</strong>取出，将其中的<strong>Task</strong>和<strong>WorkOffers</strong>对象结合任务的<strong>本地化调度级别</strong>，封装成<strong>TaskDescription</strong>对象，并将其<strong>TaskDescription</strong>进行返回到上述<strong>SchedulerBackend</strong>的**makeOffers()**中，继续向下执行</li>
<li>接下来会调用<strong>launchTask()<strong>方法进行</strong>Task的发布</strong></li>
<li>在<strong>launchTask()<strong>方法内部会将相应的</strong>TaskDescription</strong>进行<strong>序列化</strong>，然后将<strong>序列化后的TaskDescription封装成LaunchTask</strong>消息</li>
<li>封装好的<strong>LaunchTask消息</strong>会通过<strong>executorEndPoint.send()方法</strong>发送给远程机器相应的<strong>Executor</strong>上</li>
<li><strong>CoarseGrainedExecutorBackend</strong>中的<strong>receive()<strong>方法负责接收远程的调度后端</strong>CoarseGrainedSchedulerBackend</strong>发送来的消息，其中首先会创建Executor对象，用于执行相应的任务</li>
<li><strong>CoarseGrainedExecutorBackend</strong>接收到<strong>CoarseGrainedSchedulerBackend</strong>发送过来的<strong>LaunchTask消息</strong>，会对该消息进行<strong>反序列化</strong>，得到相应的<strong>TaskDescription</strong></li>
<li>然后通过<strong>executor.launchTask(…)<strong>方法发布相应序列化后的任务</strong>TaskDescription</strong>到对应的<strong>Executor对象</strong>中</li>
<li>在具体的<strong>Executor对象</strong>中，会根据<strong>launchTask()<strong>方法接收到的</strong>Task</strong>创建一个实现了<strong>Runnable接口</strong>的<strong>TaskRunner</strong>对象<strong>rn</strong>，并将该运行中的任务记录到runningTasks中做记录</li>
<li>最终通过<strong>线程池threadPool</strong>的方式，运行上述<strong>rn</strong>对象，其具体的实现细节定义在了<strong>rn</strong>的**run()**方法中</li>
</ol>
<h3 id="4-Shuffle"><a href="#4-Shuffle" class="headerlink" title="4. Shuffle"></a>4. Shuffle</h3><h4 id="1-Shuffle的原理和执行过程"><a href="#1-Shuffle的原理和执行过程" class="headerlink" title="1. Shuffle的原理和执行过程"></a>1. Shuffle的原理和执行过程</h4><h4 id="2-Shuffle写磁盘"><a href="#2-Shuffle写磁盘" class="headerlink" title="2. Shuffle写磁盘"></a>2. Shuffle写磁盘</h4><h4 id="3-Shuffle读取磁盘"><a href="#3-Shuffle读取磁盘" class="headerlink" title="3. Shuffle读取磁盘"></a>3. Shuffle读取磁盘</h4><h3 id="5-内存的管理"><a href="#5-内存的管理" class="headerlink" title="5. 内存的管理"></a>5. 内存的管理</h3><h4 id="1-内存的分类"><a href="#1-内存的分类" class="headerlink" title="1. 内存的分类"></a>1. 内存的分类</h4><h4 id="2-内存的配置"><a href="#2-内存的配置" class="headerlink" title="2. 内存的配置"></a>2. 内存的配置</h4><h2 id="11-面试中遇到的问题"><a href="#11-面试中遇到的问题" class="headerlink" title="11. 面试中遇到的问题"></a>11. 面试中遇到的问题</h2><h3 id="1-如何减少任务的网络IO"><a href="#1-如何减少任务的网络IO" class="headerlink" title="1. 如何减少任务的网络IO"></a>1. 如何减少任务的网络IO</h3><p>当数据量比较大的时候，如何减少数据网络传输的网络IO？</p>
<blockquote>
<p>使用轻量级序列化</p>
<p>采用压缩</p>
</blockquote>
<h1 id="Hive-复习"><a href="#Hive-复习" class="headerlink" title="Hive 复习"></a>Hive 复习</h1><h3 id="1-外部表与内部表"><a href="#1-外部表与内部表" class="headerlink" title="1. 外部表与内部表"></a>1. 外部表与内部表</h3><p>内部表又叫做管理表，创建表时不做任何指定，默认创建的就是内部表。想要创建外部表，则需要使用External进行修饰。</p>
<table>
<thead>
<tr>
<th></th>
<th>内部表</th>
<th>外部表</th>
</tr>
</thead>
<tbody><tr>
<td>数据存储位置</td>
<td>内部表数据存储的位置由<code>hive.metastore.warehouse.dir</code>参数指定，默认情况下表的数据存储在HDFS的<code>/user/hive/warehouse/数据库名.db/表名/</code>目录下</td>
<td>外部表数据的存储位置创建表时由<code>Location</code>参数指定；</td>
</tr>
<tr>
<td>导入数据</td>
<td>在导入数据到内部表，内部表将数据移动到自己的数据仓库目录下，数据的声明周期有Hive来进行管理</td>
<td>外部表不会将数据移动到自己的数据仓库目录下，只是在元数据中存储了数据的位置。</td>
</tr>
<tr>
<td>删除表</td>
<td>删除元数据（metadata）和文件</td>
<td>只删除元数据（metadata）</td>
</tr>
</tbody></table>
<h3 id="2-分区与分桶"><a href="#2-分区与分桶" class="headerlink" title="2. 分区与分桶"></a>2. 分区与分桶</h3><ul>
<li><p>分区是将数据按照目录进行划分，将Hive的表的数据进行划分，可以在查询的时候只查询一部分的数据，从而避免全量查询。</p>
</li>
<li><p>分桶是在分区的基础上更细粒度的将数据进行划分。</p>
<p>将整个数据内容按照某列取hash值，对桶的个数取模的方式决定该条记录存放在哪个桶中；具有相同hash值的数据进入到同一个桶，形成同一个文件</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.enforce.bucketing<span class="operator">=</span><span class="literal">true</span>;</span><br><span class="line"><span class="keyword">set</span> mapreduce.job.reduces<span class="operator">=</span><span class="number">4</span>; # 分成<span class="number">4</span>个桶</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user_buckets(id <span class="type">int</span>, name string)</span><br><span class="line">clustered <span class="keyword">by</span>(id) <span class="keyword">into</span> <span class="number">4</span> buckets</span><br><span class="line"><span class="type">row</span> format delimited fields terminated <span class="keyword">by</span> <span class="string">&#x27;\t&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-Hive-抽样"><a href="#3-Hive-抽样" class="headerlink" title="3. Hive 抽样"></a>3. Hive 抽样</h3><ol>
<li><p>数据块抽样</p>
<ol>
<li><p>tablesample(n percent)</p>
<blockquote>
<p>根据hive表数据的大小按比例抽取数据，并保存到新的hive表中。</p>
</blockquote>
</li>
<li><p>tablesample(n M)</p>
<blockquote>
<p>指定抽样数据的大小，单位为M</p>
</blockquote>
</li>
<li><p>tablesample(n rows)</p>
<blockquote>
<p>指定抽样数据的行数，其中n代表每个map任务均取n行数据，map数量可通过hive表的简单查询语句确定</p>
</blockquote>
</li>
</ol>
</li>
<li><p>分桶抽样</p>
<p>hive中分桶其实就是根据某一个字段Hash取模，放入指定数据的桶中，比如将表table_1按照ID分成100个桶，其算法是hash(id) % 100，这样，hash(id) % 100 = 0的数据被放到第一个桶中，hash(id) % 100 = 1的记录被放到第二个桶中。创建分桶表的关键语句为：CLUSTER BY语句。</p>
<blockquote>
<p>分桶抽样语法：</p>
<p><code>tablesample(bucket x out of y [on colname])</code></p>
<p>其中x是要抽样的桶编号，编号从1开始，colname表示抽样的列，y表示桶的数量。</p>
<p>例如：将表随机分成10组，抽取其中的第一个桶的数据</p>
<p><code>select * from table1 tablesample(bucket 1 out of 10 on rand())</code></p>
<p>y必须是table总bucket数的倍数或者因子。hive根据y的大小，决定抽样的比例。例如，table总共分了4份，当y=2时，抽取(4/2=)2个bucket的数据，当y=8时，抽取(4/8=)1/2个bucket的数据。</p>
<p>x表示从哪个bucket开始抽取，如果需要取多个分区，以后的分区号为当前分区号加上y。例如，table总bucket数为4，tablesample(bucket 1 out of 2)，表示总共抽取（4/2=）2个bucket的数据，抽取第1(x)个和第3(x+y)个bucket的数据。</p>
<p>注意：x的值必须小于等于y的值，否则</p>
<p>FAILED: SemanticException [Error 10061]: Numerator should not be bigger than denominator in sample clause for table stu_buck</p>
</blockquote>
</li>
<li><p>随机抽样</p>
<ol>
<li><p>使用<code>rand()函数</code>进行随机抽样，limit关键字限制抽样返回的数据，其中rand函数前的distribute 和sort 关键字可以保证数据在mapper和reducer阶段是随机分布的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_n <span class="keyword">where</span> col<span class="operator">=</span>xxx distribute <span class="keyword">by</span> rand() sort <span class="keyword">by</span> rand() limit num;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 还可以使用order by</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_n <span class="keyword">where</span> col<span class="operator">=</span>xxx <span class="keyword">order</span> <span class="keyword">by</span> rand() limit num;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="4-order-by-、-distribute-by-、sort-by-和-cluster-by-四个by的区别"><a href="#4-order-by-、-distribute-by-、sort-by-和-cluster-by-四个by的区别" class="headerlink" title="4. order by 、 distribute by 、sort by 和 cluster by 四个by的区别"></a>4. order by 、 distribute by 、sort by 和 cluster by 四个by的区别</h3><h4 id="1-order-by"><a href="#1-order-by" class="headerlink" title="1. order by"></a>1. order by</h4><p>全局排序，只有一个reduce；</p>
<p>缺点：当数据量非常大的时候，耗时太长，效率低下，适用于数据量较小的场景。</p>
<p>有点：数据全局排序</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> sal <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>

<p>当使用order by 时，默认只走一个reduce，和设置多少个reduce个数无关。</p>
<h4 id="2-sort-by"><a href="#2-sort-by" class="headerlink" title="2. sort by"></a>2. sort by</h4><p>对每一reduce内部的数据进行排序，全局结果集来说不是排序的，即只能保证每一个reduce输出的文件中的数据是按照规定的字段进行排序的；适用于数据量较大，但对排序要求不严格的场合，可以大幅度提升执行效率。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> mapreduce.job.reduces<span class="operator">=</span><span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp sort <span class="keyword">by</span> deptno <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>

<p>需要预先设置reduce个数，结果各个reduce文件内部有序，全局无序</p>
<h4 id="3-distribute-by"><a href="#3-distribute-by" class="headerlink" title="3. distribute by"></a>3. distribute by</h4><p>控制特定的key到指定的reducer，方便后续的聚集操作。类似于MR中partiton，一般会结合sort by使用；这边需要设置reduces的数量为分区的数量，否则不会启动相应的reducer去进行任务的执行，这最终会导致不能完全分区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set mapreduce.job.reduces=<span class="number">3</span>;</span><br><span class="line">select * from emp distribute by deptno sort by empno desc;</span><br></pre></td></tr></table></figure>

<p>distribute by的分区规则是根据分区字段的hash码与reduce的个数进行取模后，余数相同的分到一个分区。</p>
<p>hive要求distribute by语句要写在sort by语句之前。</p>
<h4 id="4-Cluster-By"><a href="#4-Cluster-By" class="headerlink" title="4. Cluster By"></a>4. Cluster By</h4><p>当distribute by和sort by字段相同时，可以使用cluster by方式。</p>
<p>cluster by除了具有distribute by的功能外还兼具sort by的功能。但是排序只能是升序排序，不能指定排序规则为ASC或者DESC。<br>1）以下两种写法等价</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp cluster <span class="keyword">by</span> deptno;</span><br><span class="line">hive (<span class="keyword">default</span>)<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp distribute <span class="keyword">by</span> deptno sort <span class="keyword">by</span> deptno;</span><br></pre></td></tr></table></figure>

<h3 id="5-函数"><a href="#5-函数" class="headerlink" title="5. 函数"></a>5. 函数</h3><h4 id="5-1-系统内置函数"><a href="#5-1-系统内置函数" class="headerlink" title="5.1 系统内置函数"></a>5.1 系统内置函数</h4><ol>
<li><p><strong>nvl</strong>：NVL：给值为 NULL 的数据赋值，它的格式是 NVL( value，default_value)。它的功能是如 果 value 为 NULL，则 NVL 函数返回 default_value 的值，否则返回 value 的值，如果两个参数 都为 NULL  ，则返回 NULL。</p>
</li>
<li><p>```sql<br>case     when 条件 then</p>
<pre><code>    when 条件    then
    else    
</code></pre>
<p>end    as 字段名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. ```sql</span><br><span class="line">   concat_ws(&#x27;分隔符&#x27;,字符串1，字符串2,或者 collect_set())</span><br></pre></td></tr></table></figure></li>
<li><p><strong>炸裂函数</strong>：explode</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">		id</span><br><span class="line">		,catagory</span><br><span class="line"><span class="keyword">from</span> 	<span class="keyword">table</span></span><br><span class="line"><span class="keyword">where</span>	...</span><br><span class="line"><span class="keyword">and</span>		...</span><br><span class="line"><span class="keyword">lateral</span> <span class="keyword">view</span></span><br><span class="line">		explode(集合) temp_view <span class="keyword">as</span> catagory</span><br><span class="line">;</span><br></pre></td></tr></table></figure></li>
<li><p>split()</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">split(category,<span class="string">&#x27;,&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="5-2-窗口函数over"><a href="#5-2-窗口函数over" class="headerlink" title="5.2 窗口函数over()"></a>5.2 窗口函数over()</h4><h5 id="LAG-col-n-default-val"><a href="#LAG-col-n-default-val" class="headerlink" title="LAG(col, n, default_val)"></a>LAG(col, n, default_val)</h5><p>当前行的前第n行数据</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询顾客上次购买时间</span></span><br><span class="line">spark.sql(</span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    |select</span></span><br><span class="line"><span class="string">    | name, orderdate, cost,</span></span><br><span class="line"><span class="string">    | lag(orderdate, 1, &#x27;1997-03-15&#x27;) over(partition by name order by orderdate)</span></span><br><span class="line"><span class="string">    |from business</span></span><br><span class="line"><span class="string">    |&quot;&quot;&quot;</span>.stripMargin</span><br><span class="line">).show(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">+----+----------+----+----------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">|name|orderdate |cost|lag(orderdate, <span class="number">1</span>, <span class="number">1997</span><span class="number">-03</span><span class="number">-15</span>) <span class="type">OVER</span> (<span class="type">PARTITION</span> <span class="type">BY</span> name <span class="type">ORDER</span> <span class="type">BY</span> orderdate <span class="type">ASC</span> <span class="type">NULLS</span> <span class="type">FIRST</span> <span class="type">ROWS</span> <span class="type">BETWEEN</span> <span class="number">1</span> <span class="type">PRECEDING</span> <span class="type">AND</span> <span class="number">1</span> <span class="type">PRECEDING</span>)|</span><br><span class="line">+----+----------+----+----------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">|mart|<span class="number">2017</span><span class="number">-04</span><span class="number">-08</span>|<span class="number">62</span>  |<span class="number">1997</span><span class="number">-03</span><span class="number">-15</span>                                                                                                                        |</span><br><span class="line">|mart|<span class="number">2017</span><span class="number">-04</span><span class="number">-09</span>|<span class="number">68</span>  |<span class="number">2017</span><span class="number">-04</span><span class="number">-08</span>                                                                                                                        |</span><br><span class="line">|mart|<span class="number">2017</span><span class="number">-04</span><span class="number">-11</span>|<span class="number">75</span>  |<span class="number">2017</span><span class="number">-04</span><span class="number">-09</span>                                                                                                                        |</span><br><span class="line">|mart|<span class="number">2017</span><span class="number">-04</span><span class="number">-13</span>|<span class="number">94</span>  |<span class="number">2017</span><span class="number">-04</span><span class="number">-11</span>                                                                                                                        |</span><br><span class="line">|jack|<span class="number">2017</span><span class="number">-01</span><span class="number">-01</span>|<span class="number">10</span>  |<span class="number">1997</span><span class="number">-03</span><span class="number">-15</span>                                                                                                                        |</span><br><span class="line">|jack|<span class="number">2017</span><span class="number">-01</span><span class="number">-05</span>|<span class="number">46</span>  |<span class="number">2017</span><span class="number">-01</span><span class="number">-01</span>                                                                                                                        |</span><br><span class="line">|jack|<span class="number">2017</span><span class="number">-01</span><span class="number">-08</span>|<span class="number">55</span>  |<span class="number">2017</span><span class="number">-01</span><span class="number">-05</span>                                                                                                                        |</span><br><span class="line">|jack|<span class="number">2017</span><span class="number">-02</span><span class="number">-03</span>|<span class="number">23</span>  |<span class="number">2017</span><span class="number">-01</span><span class="number">-08</span>                                                                                                                        |</span><br><span class="line">|jack|<span class="number">2017</span><span class="number">-04</span><span class="number">-06</span>|<span class="number">42</span>  |<span class="number">2017</span><span class="number">-02</span><span class="number">-03</span>                                                                                                                        |</span><br><span class="line">|tony|<span class="number">2017</span><span class="number">-01</span><span class="number">-02</span>|<span class="number">15</span>  |<span class="number">1997</span><span class="number">-03</span><span class="number">-15</span>                                                                                                                        |</span><br><span class="line">|tony|<span class="number">2017</span><span class="number">-01</span><span class="number">-04</span>|<span class="number">29</span>  |<span class="number">2017</span><span class="number">-01</span><span class="number">-02</span>                                                                                                                        |</span><br><span class="line">|tony|<span class="number">2017</span><span class="number">-01</span><span class="number">-07</span>|<span class="number">50</span>  |<span class="number">2017</span><span class="number">-01</span><span class="number">-04</span>                                                                                                                        |</span><br><span class="line">|neil|<span class="number">2017</span><span class="number">-05</span><span class="number">-10</span>|<span class="number">12</span>  |<span class="number">1997</span><span class="number">-03</span><span class="number">-15</span>                                                                                                                        |</span><br><span class="line">|neil|<span class="number">2017</span><span class="number">-06</span><span class="number">-12</span>|<span class="number">80</span>  |<span class="number">2017</span><span class="number">-05</span><span class="number">-10</span>                                                                                                                        |</span><br><span class="line">+----+----------+----+----------------------------------------------------------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>

<h5 id="LEAD-col-n-default-val"><a href="#LEAD-col-n-default-val" class="headerlink" title="LEAD(col, n, default_val)"></a>LEAD(col, n, default_val)</h5><p>当前行的后第n行数据</p>
<h5 id="ntile-n"><a href="#ntile-n" class="headerlink" title="ntile(n)"></a>ntile(n)</h5><p>把有序窗口的行分发到指定数据的组中，各个组有编号，编号从 1 开始，对 于每一行，NTILE 返回此行所属的组的编号。</p>
<p>可用于返回前%多少的数据，例如分5组，取前20%，那么取组号为1的即可。</p>
<h5 id="rank排名函数"><a href="#rank排名函数" class="headerlink" title="rank排名函数"></a>rank排名函数</h5><p>三种常用的排名函数</p>
<ol>
<li>rank()<ul>
<li>排序相同时会重复，总数不会变</li>
<li>例如：1,2,2,4</li>
</ul>
</li>
<li>row_number()<ul>
<li>根据顺序计算</li>
<li>例如：1,2,3,4</li>
</ul>
</li>
<li>dense_rank()<ul>
<li>排序相同时会重复，总数会减少</li>
<li>例如：1,2,2,3</li>
</ul>
</li>
</ol>
<h3 id="6-Hive调优"><a href="#6-Hive调优" class="headerlink" title="6. Hive调优"></a>6. Hive调优</h3><h4 id="6-1-开启map端预聚合"><a href="#6-1-开启map端预聚合" class="headerlink" title="6.1 开启map端预聚合"></a>6.1 开启map端预聚合</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 是否在map端及你行聚合，默认为True</span></span><br><span class="line"><span class="keyword">set</span> hive.map.aggr<span class="operator">=</span><span class="literal">true</span>;</span><br><span class="line"><span class="comment">-- 在Map端进行预聚合操作的条目数</span></span><br><span class="line"><span class="keyword">set</span> hive.groupby.mapaggr.checkinterval <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line"><span class="comment">-- 有数据倾斜时进行负载均衡（默认为false）</span></span><br><span class="line"><span class="keyword">set</span> hive.groupby.skewindata <span class="operator">=</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>默认情况下，使用<strong>group by</strong>，Map阶段同一key的数据会分发给一个reduce，当一个key数据过大时，就会产生数据倾斜。</p>
<p>这是可以开启map端预聚合，可以在map端先做一部分的聚合，这样就在一定程度上可以较少进入同一个reducer中的数据了。</p>
<h4 id="6-2-count（distinct-）-优化"><a href="#6-2-count（distinct-）-优化" class="headerlink" title="6.2 count（distinct ） 优化"></a>6.2 count（distinct ） 优化</h4><p>由于<code>count(distinct)</code>操作需要用一个reduce task来完成，这一个reduce需要处理的数据量太大，就会导致整个Job很难完成。</p>
<p>一般<code>count distinct</code>可使用<code>先group by， 再count</code>的方式替换。</p>
<p>因为<code>group by</code>可以通过增加reduces的数量，加快执行速度</p>
<p><code>set mapreduce.job.reduces=5;</code></p>
<h4 id="6-3-避免笛卡尔积"><a href="#6-3-避免笛卡尔积" class="headerlink" title="6.3 避免笛卡尔积"></a>6.3 避免笛卡尔积</h4><h4 id="6-4-行列过滤"><a href="#6-4-行列过滤" class="headerlink" title="6.4 行列过滤"></a>6.4 行列过滤</h4><p>在进行<code>join</code>的时候, 尽量先使用<code>where</code>条件过滤掉一些不合符业务场景的数据，从而减少join前后的两张表的数据量。</p>
<p>如果，先join后过滤，那么就会先全表关联，之后再过滤</p>
<p>查询列的时候，避免使用*;（实际的SQL规范中，也是禁止使用**）</p>
<h4 id="6-5-合理设置map和reduce的数量"><a href="#6-5-合理设置map和reduce的数量" class="headerlink" title="6.5 合理设置map和reduce的数量"></a>6.5 合理设置map和reduce的数量</h4><ol>
<li>通常情况下，作业会通过input的目录产生一个或者多个map任务，主要决定因素取决于input的文件总个数，input的文件大小，集群设置的文件块大小。（切片数）</li>
<li>是不是map数越多越好呢？<ul>
<li>答案hi否定</li>
<li>如果一个任务有很多小文件（远远小于块大小 128m），则每个小文件也会被当做一个块，用一个 map 任务来完成，而一个 map 任务启动和初始化的时间远远大 于逻辑处理的时间，就会造成很大的资源浪费。而且，同时可执行的 map 数是受限的。</li>
</ul>
</li>
<li>是不是保证每个 map 处理接近 128m 的文件块，就高枕无忧了？<ul>
<li>答案也是不一定。比如有一个 127m 的文件，正常会用一个 map 去完成，但这个文件只 有一个或者两个小字段，却有几千万的记录，如果 map 处理的逻辑比较复杂，用一个 map 任务去做，肯定也比较耗时。</li>
</ul>
</li>
</ol>
<h5 id="复杂文件增加map数"><a href="#复杂文件增加map数" class="headerlink" title="复杂文件增加map数"></a>复杂文件增加map数</h5><p>当input的文件都很大，任务逻辑复杂，map执行非常慢的时候，可以考虑增加map数，来使得每个map处理的数据量减少，从而提高任务的执行效率。</p>
<h5 id="小文件行合并"><a href="#小文件行合并" class="headerlink" title="小文件行合并"></a>小文件行合并</h5><p>在map执行前，对于小文件进行合并，减少不必要的map数（比如一个文件只有一条数据，但是不合并的情况就会启动一个map来处理这个一条数据，但是map</p>
<p>的启动和加载时间远远大于处理时间，反而耗时）</p>
<h4 id="6-6-并行执行"><a href="#6-6-并行执行" class="headerlink" title="6.6 并行执行"></a>6.6 并行执行</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.exec.parallel<span class="operator">=</span><span class="literal">true</span>; <span class="comment">-- 打开任务并行执行</span></span><br><span class="line"><span class="keyword">set</span> hive.exec.parallel.thread.number<span class="operator">=</span><span class="number">16</span>; <span class="comment">-- 同一个SQL允许最大并行度，默认为8</span></span><br></pre></td></tr></table></figure>



<h3 id="7-Hive源码学习"><a href="#7-Hive源码学习" class="headerlink" title="7. Hive源码学习"></a>7. Hive源码学习</h3><img src="source/2021年8月份秋招复习笔记/src=http%3A%2F%2Fwww.pianshen.com%2Fimages%2F312%2F2c1818a3d8f7bee6d472827c0fc3c908.JPEG&refer=http%3A%2F%2Fwww.pianshen.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg" alt="img" style="zoom:50%;" />



<p><strong>SQL Parser 解析器</strong></p>
<p>将sql字符串转换成抽象语法树AST，这一步一般都用第三方工具库完成，比如antlr；对AST进行语法分析，比如表是否存在，字段是否存在，sql语义是否有误。</p>
<p><strong>Physical Plan 编译器</strong></p>
<p>将AST编译生成逻辑执行计划。</p>
<p><strong>Query Optimizer 优化器</strong></p>
<p>对逻辑执行计划进行优化</p>
<p><strong>Execution 执行器</strong></p>
<p>把逻辑执行计划转换成可以运行的物理执行计划。对于Hive来说，就是MR、Spark。</p>
<h4 id="7-1-HOL转换成MR任务流程说明"><a href="#7-1-HOL转换成MR任务流程说明" class="headerlink" title="7.1 HOL转换成MR任务流程说明"></a>7.1 HOL转换成MR任务流程说明</h4><ol>
<li>进入程序，利用<code>Antlr</code>框架定义的HQL语法规则，对HQL完成<code>词法分析</code>、<code>语法分析</code>，将HQL转换成抽象语法树：<code>AST</code></li>
<li>遍历AST，抽象出查询的基本组成单元<code>QueryBlock(查询快)</code>，可以理解为最小的查询执行单元</li>
<li>遍历<code>QueryBlock</code>,将其转换为<code>OperatorTree</code>（操作树，也就是逻辑执行计划），可以理解为不可拆分的一个逻辑执行单元</li>
<li>利用逻辑优化器对<code>OperatorTree（操作树）</code>进行逻辑优化。例如合并不必要的<code>ReduceSinkOperator</code>，减少Shuffle数据量；</li>
<li>遍历<code>OperatorTree</code>，转换成TaskTree。也就是翻译成MR任务的流程，将逻辑执行计划转换为物理执行计划。</li>
<li>使用物理优化器对TaskTree进行物理优化；</li>
<li>生成最终的执行计划，提交任务到Hadoop集群运行。</li>
</ol>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210814152542812-16289259443932.png" alt="image-20210814152542812"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">runInternal</span><span class="params">(String command, <span class="type">boolean</span> alreadyCompiled)</span></span><br><span class="line"><span class="keyword">throws</span> CommandProcessorResponse &#123;</span><br><span class="line"> errorMessage = <span class="literal">null</span>;</span><br><span class="line"> SQLState = <span class="literal">null</span>;</span><br><span class="line"> downstreamError = <span class="literal">null</span>;</span><br><span class="line"> LockedDriverState.setLockedDriverState(lDrvState);</span><br><span class="line"> lDrvState.stateLock.lock();</span><br><span class="line"></span><br><span class="line"> ... ...</span><br><span class="line"> <span class="type">PerfLogger</span> <span class="variable">perfLogger</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> <span class="keyword">if</span> (!alreadyCompiled) &#123;</span><br><span class="line"> <span class="comment">// compile internal will automatically reset the perf logger</span></span><br><span class="line"> <span class="comment">//1.编译 HQL 语句</span></span><br><span class="line"> compileInternal(command, <span class="literal">true</span>);   <span class="comment">// 这个方法里面会包含 解析器，编译器和优化器这个三个组件</span></span><br><span class="line"> <span class="comment">// then we continue to use this perf logger</span></span><br><span class="line"> perfLogger = SessionState.getPerfLogger();</span><br><span class="line"> &#125;</span><br><span class="line"> ... ...</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="comment">//2.执行</span></span><br><span class="line"> execute();		<span class="comment">// 这里会涉及到执行器</span></span><br><span class="line"> &#125; <span class="keyword">catch</span> (CommandProcessorResponse cpr) &#123;</span><br><span class="line"> rollback(cpr);</span><br><span class="line"> <span class="keyword">throw</span> cpr;</span><br><span class="line"> &#125;</span><br><span class="line"> isFinishedWithError = <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ASTNode</span> <span class="variable">tree</span> <span class="operator">=</span> ParseUtils.parse(command, ctx); <span class="comment">// 解析器解析HQL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在ParseUtils.parse() 方法中</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">1. 首先会对sql进行词法分析，得到词法单元token</span></span><br><span class="line"><span class="comment">2. 对token进行语法分析，最终将解析结果赋值给r</span></span><br><span class="line"><span class="comment">3. 通过r.getTree(); 方法获取最终的抽象语法树AST</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">sem.analyze(tree,ctx); <span class="comment">// 编译器与优化器</span></span><br><span class="line"><span class="comment">// Hive中的优化器（逻辑优化器）都好多好多种，其基本的抽象类为Transform类，其子类实现了各种的优化策略：例如（MapJoinProcessor策略，group Optimizer；分区过滤优化：PartitionConditionRemover；SimplePredicatePushDown）、</span></span><br><span class="line"><span class="comment">// 物理优化器提供的三种：Tez，MR，Spark </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font color=red>小总结：</font></p>
<ol>
<li><strong>CliDriver处理传过来的SQL，按照<code>;</code>进行HQL语句的切分，每个HQL单独进行处理</strong></li>
<li><strong>将<code>HQL</code>传递给Hive的<code>Driver组件</code></strong></li>
<li><strong>在Hive的<code>Driver</code>内部：</strong><ol>
<li><strong>解析器将<code>HQL</code>解析成抽象语法树<code>AST(具体使用的是</code>ParseUtils.parse()`方法)</strong><ul>
<li><strong>先对HQL进行词法分析，生成<font color=green>词法单元:Token</font></strong></li>
<li><strong>然后对词法单元Token进行语法分析，生成抽象语法树ASt</strong></li>
<li><strong>这个过程使用的是第三方框架<code>Antlr</code></strong></li>
</ul>
</li>
<li><strong>编译器将AST进行编译，抽象出<code>QueryBlock</code>查询子块，进一步编译成<code>OperatorTree操作树</code>逻辑执行计划</strong></li>
<li><strong>逻辑优化器对<code>OperatorTree</code>进行逻辑优化（具体的逻辑优化器抽象类为<code>Transform</code>类）,编译器将优化后的逻辑执行计划转换成<code>TaskTree物理执行计划</code></strong></li>
<li><strong>物理优化器将<code>TaskTree进行物理优化</code>（物理优化器共有三种 ：<code>TezOptimizer</code>,<code>MapReduceOptimizer</code>,<code>SparkOptimizer</code>）</strong><ul>
<li><strong>其中MR的物理优化器在执行物理优化器方法之前就已经进行了相应的优化。</strong></li>
</ul>
</li>
<li><strong><code>execut()方法</code>,将物理执行计划转化成MR任务，封装成<code>Job</code>,提交至集群运行任务。</strong></li>
</ol>
</li>
</ol>
<h3 id="8-HQL练习"><a href="#8-HQL练习" class="headerlink" title="8. HQL练习"></a>8. HQL练习</h3><p>作者：Pure201911132215663<br>链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/737802?source_id=discuss_experience_nctrack&amp;channel=-1">https://www.nowcoder.com/discuss/737802?source_id=discuss_experience_nctrack&amp;channel=-1</a><br>来源：牛客网</p>
<p>表sal_sum，每次统计前三个月的<a href="">销售</a>额<br> month    sal<br> 1       5<br> 2       3<br> 3       5<br> 4       7    </p>
<p>​     …….<br>​    </p>
<p> 12      6    </p>
<p> 1+2+3，2+3+4，3+4+5 。。。    </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">		<span class="keyword">month</span></span><br><span class="line">		<span class="built_in">sum</span>(sal) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">month</span> <span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">2</span> preceding <span class="keyword">and</span> <span class="keyword">current</span> <span class="type">row</span>)	<span class="keyword">as</span> sal_3_sum</span><br><span class="line"><span class="keyword">from</span>	sal_sum</span><br></pre></td></tr></table></figure>











<h1 id="Zookeeper复习"><a href="#Zookeeper复习" class="headerlink" title="Zookeeper复习"></a>Zookeeper复习</h1><h2 id="1-Zookeeper内部原理"><a href="#1-Zookeeper内部原理" class="headerlink" title="1. Zookeeper内部原理"></a>1. Zookeeper内部原理</h2><h3 id="1-1-选举机制"><a href="#1-1-选举机制" class="headerlink" title="1.1 选举机制"></a>1.1 选举机制</h3><ol>
<li><font color=red>半数机制：集群中半数以上机器存活，集群可用。所以Zookeeper适合安装奇数台服务器。</font></li>
<li>Zookeeper虽然在配置文件中并没有指定<strong>Master</strong>和<strong>Slave</strong>。但是，Zookeeper工作时，是有一个节点为Leader，其他则为Follower，Leader是通过内部的选举机制临时产生的。</li>
</ol>
<p><strong>三个核心的选举原则</strong></p>
<ol>
<li>Zookeeper集群中只有超过半数以上的服务器启动，集群才能正常工作；</li>
<li>在集群正常工作之前，<code>myid</code>小的服务器给<code>myid</code>大的服务器投票，知道集群正常工作，选出<code>leader</code>；</li>
<li>选出<code>Leader</code>之后，之前的服务器状态由<code>Looking</code>改变为<code>Following</code>，以后的服务器都是<code>Follower</code>。</li>
</ol>
<p>以一个简单的例子来说明整个选举的过程：</p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/webp-20210810162423999" alt="img"></p>
<p>假设有五台服务器组成的Zookeeper集群，他们的id从1~5，同时他们都是最新启动的，也就是没有历史数据，在存放数据量这一点上，都是一样的。假设这些服务器依序启动。</p>
<ol>
<li><p>服务器1启动，发起一次选举</p>
<blockquote>
<p>服务器1投自己一票，此时集群不够半数以上（3票），选举无法完成；</p>
<p>服务器1状态保持为<code>LOOKING</code></p>
</blockquote>
</li>
<li><p>服务器2启动，再发起一次选举</p>
<blockquote>
<p>服务器2投自己一票，然后服务器1与服务器2交换投票信息，此时服务器1发现服务器2的id比自己的大，更改选票投给服务器2.</p>
<p>此时服务器1票数0票，服务器2票数2票，不够半数以上（3票），选举无法完成；（服务器1的票数在投票结束后，清零）</p>
<p>服务器1，2保持<code>LOOKING</code></p>
</blockquote>
</li>
<li><p>服务器3启动，发起一次选举</p>
<blockquote>
<p>与上面过程一样，服务器1和服务器2先投自己一票，服务器3也投自己一票。</p>
<p>在交换投票信息的时候，发现此时还是LOOKING状态（还没有选取出leader），且服务器3的id最大，那么服务器3就会得到3票，此时服务器3的票数已经超过半数了（3票）</p>
<p>服务器1，2更新状态为FOLLOWING，服务器3更改状态为LEADING；</p>
</blockquote>
</li>
<li><p>服务器4启动，发起一次选举</p>
<blockquote>
<p>此时服务器1，2，3已经不是<code>LOOKING</code>状态，不会改变选票信息。交换选票信息结果：服务器3为3票，服务器4为1票。</p>
<p>此时服务器4服从多数，更改选票信息为服务器3；服务器3此时有4票</p>
<p>服务器4并更改状态为<code>FOLLOWING</code>;</p>
</blockquote>
</li>
<li><p>服务器5启动，同4一样投票给3，此时服务器3一共5票，服务器5为0票；</p>
<blockquote>
<p>服务器5更改状态为<code>FOLLOWING</code></p>
</blockquote>
</li>
</ol>
<h3 id="2-节点类型"><a href="#2-节点类型" class="headerlink" title="2. 节点类型"></a>2. 节点类型</h3><ul>
<li>持久（Persistent）：客户端和服务器端断开连接后，创建的节点不删除</li>
<li>短暂（Ephemeral）：客户端与服务器端断开连接后，创建的节点自己会自动删除</li>
</ul>
<p>说明：创建znode时，设置顺序标识，znode名称后会附加一个值，顺序号是一个单调递增的计数器，由父节点维护。</p>
<p><font color=red>注意：分布式系统中，顺序号可以被用于为所有的事件进行全局排序，这样客户端可以通过顺序号推断事件的顺序。</font></p>
<h3 id="3-Stat结构体"><a href="#3-Stat结构体" class="headerlink" title="3. Stat结构体"></a>3. Stat结构体</h3><h3 id="4-监听器原理"><a href="#4-监听器原理" class="headerlink" title="4. 监听器原理"></a>4. 监听器原理</h3><p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/src=http%253A%252F%252Fimage.bubuko.com%252Finfo%252F202002%252F20200209175734687167.png&refer=http%253A%252F%252Fimage.bubuko.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg" alt="img"></p>
<ol>
<li>首先要有一个main()线程</li>
<li>在main线程中创建Zookeeper客户端，这时就会创建两个线程：一个负责网络连接通信（connect），一个负责监听（Listener）。</li>
<li>通过connect线程，将注册的监听事件发送给Zookeeper。</li>
<li>在Zookeeper的注册监听器列表中将注册的监听事件添加到列表中</li>
<li>Zookeeper监听到数据或路径变化，就会将这个消息发送给listener线程</li>
<li>listener线程内部调用了process()方法。</li>
</ol>
<p>常见的监听：</p>
<ol>
<li><p>监听节点数据的变化</p>
<p><code>get path[watch]</code></p>
</li>
<li><p>监听子节点增减的变化</p>
<p><code>ls path[watch]</code></p>
</li>
</ol>
<h3 id="5-Zookeeper写数据流程"><a href="#5-Zookeeper写数据流程" class="headerlink" title="5. Zookeeper写数据流程"></a>5. Zookeeper写数据流程</h3><p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/src=http%253A%252F%252Fimg2018.cnblogs.com%252Fi-beta%252F1201165%252F202002%252F1201165-20200226224404735-1637370414.png&refer=http%253A%252F%252Fimg2018.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg" alt="img"></p>
<ol>
<li>client向zookeeper的Server1上写数据，发送一个写请求。</li>
<li>如果server1不是leader，那么server1会把接收到的请求进一步转发给Leader，因为每个Zookeeper的Server里面有一个Leader。这个Leader会将写请求广播给各个Server，比如Server1，Server2，Server4，Server5；各个Server写成功后就会通知Leader。</li>
<li>当Leader收到<strong>大多数Server数据写成功了</strong>（内部协议：<strong>ZAB</strong>），那么就说明数据写成功了。写成功之后，Leader会告诉Server1数据写成功了。</li>
<li>Server1会进一步通知Client数据写成功了，这时救人位整个操作成功了。</li>
</ol>
<h3 id="6-Zookeeper的常用命令"><a href="#6-Zookeeper的常用命令" class="headerlink" title="6. Zookeeper的常用命令"></a>6. Zookeeper的常用命令</h3><table>
<thead>
<tr>
<th>命令基本语法</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>ls path[watch]</td>
<td>使用ls命令来查看当前znode中所包含的内容</td>
</tr>
<tr>
<td>ls2 path[watch]</td>
<td>查看当前节点数据并能看到更新次数等数据</td>
</tr>
<tr>
<td>create</td>
<td>普通创建<br />-s含有序列<br />-e 临时（重启或超时消失）</td>
</tr>
<tr>
<td>get path[watch]</td>
<td>获得节点的值</td>
</tr>
<tr>
<td>set</td>
<td>设置节点的具体值</td>
</tr>
<tr>
<td>stat</td>
<td>查看节点状态</td>
</tr>
<tr>
<td>delete</td>
<td>删除节点</td>
</tr>
<tr>
<td>rmr</td>
<td>递归删除节点</td>
</tr>
</tbody></table>
<h1 id="Kafka复习"><a href="#Kafka复习" class="headerlink" title="Kafka复习"></a>Kafka复习</h1><p>kafka是一个分布式的，基于消息订阅-发布模式的消息队列。Kafka对消息保存时根据Topic进行归类。每个消费者组可以订阅不同的Topic；且同一个消费者组的一个消费者只能消费一个分区中的数据。</p>
<p>无论是Kafka集群，还是consumer都依赖于<strong>zookeeper</strong>集群保存一些meta信息，来保证系统可用性。</p>
<p><strong>点对点模式（一对一，消费者主动拉取数据，消息收到后消息清除）</strong></p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Mjc2ODM1,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<p>消息生产者生产消息发送到Queue，然后消息消费者从Queue中取到并且消费消息。消息被消费后，queue中不再有存储，所以消息消费者不可能消费已经被消费的消息。Queue支持存在多个消费者，但是对一个消费者而言，只会有一个消费者可以消费。</p>
<p><strong>发布/订阅模式（一对多，消费者消费数据之后不会清除消息）</strong></p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Mjc2ODM1,size_16,color_FFFFFF,t_70-20210811102106660.png" alt="在这里插入图片描述"></p>
<p>消息生产者（发布）将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到topic的消息会被所有订阅者消费。</p>
<p>而发布/订阅模式的消息队列还可以分为两种：</p>
<ol>
<li>队列推送消息给消费者</li>
<li>消费者主动拉取消息</li>
</ol>
<p>如果采用第一种 队列推送消息给消费者，但是每个消费者的消费速度是不一定一致的，因此会发生消息的浪费情况。</p>
<p>在Kafka中则采用的第二种：消费者主动拉取消息。</p>
<h2 id="1-消息队列的作用（为什么使用消息队列？）"><a href="#1-消息队列的作用（为什么使用消息队列？）" class="headerlink" title="1. 消息队列的作用（为什么使用消息队列？）"></a>1. 消息队列的作用（为什么使用消息队列？）</h2><h3 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h3><p>举个例子：双十一用户，假设在某一时间段内用户的下单请求峰值达到了一亿多，如果不使用消息队列，服务器端就要同时处理这一亿多的请求，如果服务器性能不够，就会崩掉！<br>如果使用了消息队列，就可以实现削峰的作用，限制同时访问服务器的请求数量，从而降低服务器端的负担。</p>
<h3 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h3><p>通常生产者和消费者的业务逻辑是不同的，当消费者的消费业务逻辑发生变化时，如果不使用消息队列，就需要把整个生产-消费的逻辑改变。<br>如果使用了消息队列，生产者和消费者就实现了解耦，当需求发生变化时，只需要更改需要更改的一方，而不是修改整个 生产-消费的过程。</p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户<br>把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要<br>的时候再去处理它们。</p>
<h2 id="2-Kafka的特点"><a href="#2-Kafka的特点" class="headerlink" title="2. Kafka的特点"></a>2. Kafka的特点</h2><ul>
<li>类似于消息队列和商业的消息系统，kafka提供对流式数据的发布和订阅</li>
<li>kafka提供一种持久的容错的方式存储流式数据</li>
<li>kafka拥有良好的性能，可以及时地处理流式数据</li>
</ul>
<h2 id="3-Kafka基础架构"><a href="#3-Kafka基础架构" class="headerlink" title="3. Kafka基础架构"></a>3. Kafka基础架构</h2><p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Mjc2ODM1,size_16,color_FFFFFF,t_70-20210811102926988.png" alt="在这里插入图片描述"></p>
<ol>
<li><p><strong>producer</strong>：消息生产者，就是向Kafka broker发消息的客户端；</p>
</li>
<li><p><strong>consumer</strong>：消息消费者，想kafka broker拉取消息的客户端；</p>
</li>
<li><p><strong>Topic</strong>：可以理解为一个队列；</p>
</li>
<li><p><strong>consumer group（CG）</strong>：这是Kafka用来实现一个topic消息的广播（发送给所有的Consumer）和单播（发给任意一个consumer）的手段</p>
<p>一个topic可以有多个CG。topic的消息复制（不是真正的复制，是逻辑上的复制）到所有的CG，<strong>但每个partition只会把消息发给CG中的一个consumer</strong></p>
<p>如果需要实现广播，那么只需将每个consumer单独设置一个CG就可以了</p>
<p>如果需要实现单播（一个消费者一个分区），只需将所有的consumer设置在同一个CG中即可。</p>
<p>用CG还可以将consumer进行自由的分组而不需要多次发送消息到不同的topic中；</p>
</li>
<li><p><strong>Broker</strong>：一台kafka服务器就是一个broker。一个集群由多个broker组成。一个broker可以容纳多个topic；</p>
</li>
<li><p><strong>partition</strong>：为了实现扩展性，一个非常大的topic可以分布到多个broker（即服务器上）上。一个topic可以分为多个partition，每个partition是一个有序的队列。partition中的每条消息都会分配一个有序的id（offset）。kafka只保证按一个partition中的顺序将消息发给consumer，不保证一个topic的整体（多个partition间）的顺序。</p>
</li>
<li><p><strong>Offset</strong>：kafka的存储文件都是按照offset.kafka来命名，用offset做名字的好处是方便查找。例如想找位于2049的位置，只要找到2048.kafka的文件即可。淡然the first offset就是<code>00000000000.kafka</code>。</p>
</li>
<li><p><strong>Replication</strong>:副本，为了保证集群中的某个节点发生故障的时候，该节点上的partition数据不会丢失，且kafka仍然能够继续工作，kafka提供了副本机制，一个topic的每个分区都有若干个副本，一个<code>leader</code>和若干个<code>follower</code></p>
</li>
<li><p><strong>leader</strong>: 每个分区多个副本的“主”，生产者发送数据的对象，以及消费者消费数据的对象都是leader</p>
</li>
<li><p><strong>follower</strong>：每个分区多个副本中的“从“，实时从leader中同步数据，保持和leader数据的同步。leader发生故障时，某个follower会成为新的leader。</p>
</li>
</ol>
<h2 id="4-Kafka部署注意事项"><a href="#4-Kafka部署注意事项" class="headerlink" title="4. Kafka部署注意事项"></a>4. Kafka部署注意事项</h2><p>在配置Kafka上的server.properties时，要注意，每台broker的broker.id是需要设置不同的数字.<font  color=red>broker.id不能重复</font></p>
<p>Kafka运行需要依赖于zookeeper，需要在配置文件中配置zookeeper集群的地址。</p>
<p>在启动kafka集群之前要确保zookeeper集群已经成功启动了。kafka集群停止的时候，要先停kafka，后停zookeeper，要不然kafka会关不掉的。</p>
<h2 id="5-Kafka架构深入"><a href="#5-Kafka架构深入" class="headerlink" title="5. Kafka架构深入"></a>5. Kafka架构深入</h2><h3 id="5-1-Kafka工作流程以及文件存储机制"><a href="#5-1-Kafka工作流程以及文件存储机制" class="headerlink" title="5.1 Kafka工作流程以及文件存储机制"></a>5.1 Kafka工作流程以及文件存储机制</h3><p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Mjc2ODM1,size_16,color_FFFFFF,t_70#pic_center-16286927154611" alt="在这里插入图片描述"></p>
<p>Kafka中消息是以topic进行分类的，生产者生产消息，消费者消费消息，都是面向topic的。<br>topic是逻辑上的概念，而partition是物理上的概念，每个partition对应一个log文件，该log文件中存储的就是producer生产的数据。Producer生产的数据会被不断追加到该log文件末端，且每条数据都有自己的offset。消费者组中的每个消费者，都会实时记录自己消费到了那个offset，以便出错恢复时，从上次的位置继续消费。</p>
<h4 id="文件存储机制"><a href="#文件存储机制" class="headerlink" title="文件存储机制"></a>文件存储机制</h4><img src="source/2021年8月份秋招复习笔记/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Mjc2ODM1,size_16,color_FFFFFF,t_70#pic_center-16286931799323" alt="在这里插入图片描述" style="zoom:50%;" />

<p>由于生产者生产的消息会不断追加到log文件末尾，为防止log文件过大导致数据定位效率低下，kafka采取了<strong>切片</strong>和<strong>索引</strong>机制，将每个partition分为多个<strong>segment</strong>。每个segment对应两个文件：<code>.index</code>和<code>.log</code>。这些文件位于一个文件夹下，该文件命名规则为：<code>topic名称+分区序号</code>。</p>
<p>例如，first 这个 topic 有三个分区，则其对应的文件夹为：first0,first-1,first-2。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00000000000000000000.index</span><br><span class="line">00000000000000000000.log</span><br><span class="line">00000000000000170410.index</span><br><span class="line">00000000000000170410.log</span><br><span class="line">00000000000000239430.index</span><br><span class="line">00000000000000239430.log</span><br></pre></td></tr></table></figure>

<p>index 和 log 文件以当前 segment 的第一条消息的 offset 命名。</p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Mjc2ODM1,size_16,color_FFFFFF,t_70#pic_center-16286934145025" alt="**在这里插入图片描述**"></p>
<p>“index”文件存储着大量的索引信息，“log”文件存储大量的数据，索引文件中的元数据指向对应数据文件中message的物理偏移地址。</p>
<h3 id="5-2-生产者"><a href="#5-2-生产者" class="headerlink" title="5.2 生产者"></a>5.2 生产者</h3><p><strong>分区的原因：</strong></p>
<ol>
<li>在集群中扩展，每个partition可以通过调整以适应它所在的机器，而一个topic又可以有多个patirion，因此整个集群就可以使用任意大小的数据了。</li>
<li>可以提高并发，因为可以以partition为单位读写了。</li>
</ol>
<p><strong>分区原则</strong></p>
<p>生产者producer发送数据的时候，需要将数据封装成一个<code>ProducerRecord</code>对象。生产者发送<code>ProducerRecord</code>对象的时候，可以指定分区号;</p>
<ol>
<li>指定partition的情况下，直接将指定的值作为partition值</li>
<li>没有指定partition的值但是有key的情况下，将key的hash值与topic的partitions数进行取余得到partition值；</li>
<li>既没有partition值又没有key值的情况下，第一次调用时随机生成一个证书（后面每次调用的时候，在这个整数上自增），将这个值与topic可用的partition总数取余得到partition值，这就是常说的<code>round-robin</code>轮询算法。</li>
</ol>
<h4 id="数据可靠性"><a href="#数据可靠性" class="headerlink" title="数据可靠性"></a>数据可靠性</h4><p><strong>为保证producer发送的数据，能可靠的发送到指定的topic，topic的每个partition收到producer发送的数据后，都需要向producer发送<code>ack</code>（acknowledge确认收到），如果producer收到ack，就会进行下一轮的发送，否则重新发送数据（一定时间内没有接收到ack的时候）。</strong></p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Mjc2ODM1,size_16,color_FFFFFF,t_70#pic_center-16286953647487" alt="在这里插入图片描述"></p>
<p><strong>何时发送ack？</strong></p>
<p>确保有follower与leader同步完成，leader再发送ack，这样才能保证leader挂掉之后，能在follower中选举出新的leader。</p>
<p><strong>多少个follower同步完成之后发送ack？</strong></p>
<p>现有方案：</p>
<ul>
<li>半数以上的follower同步完成，即可发送ack</li>
<li>全部的follower同步完成，才可以发送ack</li>
</ul>
<table>
<thead>
<tr>
<th>方案</th>
<th>延迟</th>
<th>副本数量</th>
</tr>
</thead>
<tbody><tr>
<td>半数以上完成同步，就发送ack</td>
<td>低延迟</td>
<td>选举新的leader时，容忍n台节点的故障，需要2n+1个副本</td>
</tr>
<tr>
<td>全部完成同步，才发送ack</td>
<td>延迟高</td>
<td>选举新的leader时，容忍n台节点的故障，需要n+1个副本</td>
</tr>
</tbody></table>
<p>Kafka选择了第二种方案，原因如下：</p>
<ol>
<li>同样为了容忍n台节点的故障，第一种方案需要2n+1个副本，而第二种方案只需要n+1个副本，而Kafka的每个分区都有大量的数据，第一种方案会造成大量数据的冗余。</li>
<li>虽然第二种方案的网络延迟会比较高，但网络延迟对Kafka的影响较小。</li>
</ol>
<h5 id="ISR同步副本机制"><a href="#ISR同步副本机制" class="headerlink" title="ISR同步副本机制"></a>ISR同步副本机制</h5><p>采用第二种方案之后，设想以下场景：leader收到数据，所有的follower都开始同步数据，但有一个follower，因为某种故障，迟迟不能与leader进行同步，那么leader就要一直等下去，直到它完成同步，才能发送ack，这个问题怎么解决呢？</p>
<p><font color=green>在kafka中，每个分区的Leader维护一个动态<code>in-sync-replica set</code>(ISR),意为和leader保持同步的follower的集合。当ISR中的follower完成数据的同步之后，leader就会给follower发送ack。如果follower长时间未向leader同步数据，则该follower将被踢出ISR，该时间阈值由<code>replica.lag.time.max.ms</code>参数设定。Leader发生故障之后，就会从ISR中选举新的Leader。</font></p>
<h5 id="ack应答机制"><a href="#ack应答机制" class="headerlink" title="ack应答机制"></a>ack应答机制</h5><p>对于某些不太重要的数据，对数据的可靠性要求不是很高，能够容忍数据的少量丢失，所以没有必要等ISR中的follower全部接收成功。所以Kafka为用户提供了三种可靠性级别，用户根据可靠性和延迟的要求进行权衡，选择配置。</p>
<p><strong>ACK参数：</strong></p>
<blockquote>
<p>0：producer不等待broker的ack，这一操作提供了一个最低的延迟，broker一接收到还没有写入磁盘就已经返回，当broker故障的时候有可能<strong>丢数据</strong>。</p>
<p>1：producer等待broker的ack，partition的leader落盘成功后返回ack，如果在follower同步成功之前leader故障，那么将会<strong>丢数据</strong>；</p>
<p>-1（all）：producer等待broker的ack，partition的leader和follower全部落盘成功后才返回ack。但是如果在follower同步完成之后，broker发送ack之前，leader发生故障，那么会造成<strong>数据重复</strong>。</p>
</blockquote>
<h5 id="故障处理细节"><a href="#故障处理细节" class="headerlink" title="故障处理细节"></a>故障处理细节</h5><p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Mjc2ODM1,size_16,color_FFFFFF,t_70-20210812102618331.png" alt="在这里插入图片描述"></p>
<p>接下来介绍一下Kafka中一个topic的一个分区的broker挂掉之后，是如恢复的。</p>
<p><font color=green>两个重要的核心概念：</font></p>
<ul>
<li>LEO(Log End Offset)：日志末偏移量<ul>
<li>指的是每个副本最大的offset</li>
</ul>
</li>
<li>HW(Hign WaterMark)：高水位<ul>
<li>指的是消费者能够见到的最大的offset，ISR队列中最小的LEO（高水位）</li>
</ul>
</li>
</ul>
<h6 id="1-follower故障"><a href="#1-follower故障" class="headerlink" title="1. follower故障"></a>1. follower故障</h6><p>follower发生故障之后，会被临时踢出ISR，待该follower恢复后，follower会读取本地磁盘记录的上次的HW，并将log文件高于HW的部分截取掉，从HW开始向leader进行同步。<strong>等待follower的LEO大于等于此时的该分区Partition的HW</strong>，即follower追上leader之后，就可以重新加入ISR了。</p>
<h6 id="2-leader故障"><a href="#2-leader故障" class="headerlink" title="2. leader故障"></a>2. leader故障</h6><p>leader发生故障之后，会从ISR中选取一个新的Leader，之后，为了保证多个副本之间的数据一致性，其余的follower会先将各自的log文件中<font color=red>高于HW的部分截取掉</font>，然后从新的leader同步数据。（新官上任三把火，其他人都要按照我的规矩办事，废除上任的制度）</p>
<p><font color=red>注意：这只能保证副本之间的数据一致性，并不能保证数据不丢失或者不重复。</font></p>
<h5 id="Exactly-Once语义"><a href="#Exactly-Once语义" class="headerlink" title="Exactly Once语义"></a>Exactly Once语义</h5><p>将服务器的ack级别设置为-1，可以保证Producer到Server之间不会丢失数据，即 <strong>At Least Once语义（至少一次）</strong>。相对的，将服务器ack级别设置为0，可以保证生产者每条消息只会被发送一次，即<strong>At Most Once语义（至多一次）。</strong></p>
<p>AtLeaseOnce可以保证数据不丢失，但是不能保证数据不重复；相对的，AtMostOnce可以保证数据不重复，但是不能保证数据不丢失。但是对于一些非常重要的信息，比如说交易数据，下游数据消费者要求数据即不能重复也不能丢失，即Exactly Once语义。在 0.11 版本以前的 Kafka，对此是无能为力的，只能保证数据不丢失，再在下游消费者对数据做全局去重。对于多个下游应用的情况，每个都需要单独做全局去重，这就对性能造成了很大影响。<br>0.11 版本的 Kafka，引入了一项重大特性：幂等性。所谓的幂等性就是指 Producer 不论向 Server 发送多少次重复数据，Server 端都只会持久化一条。幂等性结合 At Least Once 语义，就构成了 Kafka 的 Exactly Once 语义。即：<br><strong>AtLeaseOnce + <em>幂等性</em> = Exactly Once</strong></p>
<p>要启动幂等性，只需将Producer的参数中<code>enable.idompotence</code>设置为<code>true</code>即可。</p>
<h3 id="5-3-分区分配策略"><a href="#5-3-分区分配策略" class="headerlink" title="5.3 分区分配策略"></a>5.3 分区分配策略</h3><h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Mjc2ODM1,size_16,color_FFFFFF,t_70-20210812104838555.png" alt="在这里插入图片描述"></p>
<p>Range策略针对的是主题。</p>
<p>由于消费者1，2同时订阅了主题1，而消费者1，2属于同一消费者组。</p>
<p>range策略：主题中的消息数/消费者组中的消费者数   ——  3/2 = 1…..1.那么化为范围的时候，就有一个消费者中要消费2条消息（因为没有整除）</p>
<h4 id="RoundRobin"><a href="#RoundRobin" class="headerlink" title="RoundRobin"></a>RoundRobin</h4><p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Mjc2ODM1,size_16,color_FFFFFF,t_70-20210812105106318.png" alt="在这里插入图片描述"></p>
<p>RoundRobin策略针对的是消费者组，组内不同消费者订阅的不同主题topic，消费者组内的所有消费者都可以消费这些主题中的消息，消费方式采用轮询。<br><strong>这里需要注意：</strong></p>
<blockquote>
<p>如果采用了这种分区分配策略，就会导致没有订阅topic的消费者也消费到了消息，这样就有可能造成信息分配错了。所以默认是Range策略。同时在生产环境中，同一个消费者组内的消费者订阅的主题是要保持一致的。</p>
</blockquote>
<h3 id="5-4-kafka-消息发送流程"><a href="#5-4-kafka-消息发送流程" class="headerlink" title="5.4 kafka 消息发送流程"></a>5.4 kafka 消息发送流程</h3><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210812145139764-8751101.png" alt="image-20210812145139764" style="zoom:50%;" />



<p>Kafka的Producer发送消息采用的是异步发送的方式。在消息发送的过程中，涉及到了两个线程：**<code>main线程 和 Sender线程</code><strong>，以及一个线程共享变量</strong><code>RecordAccumulator</code>.**</p>
<p>main线程将消息发送给RecordAccumulator，Sender线程不断从RecordAccumulator中拉取消息发送到kafka broker上。</p>
<h3 id="5-5-Kafka中的选举机制"><a href="#5-5-Kafka中的选举机制" class="headerlink" title="5.5 Kafka中的选举机制"></a>5.5 Kafka中的选举机制</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/357042753">参考文章</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_27143551/article/details/103033641?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">Kafka| 你一定不能错过的Kafka控制器</a></p>
<h4 id="1-Kafka的控制器Controller是如何被选举出来的？"><a href="#1-Kafka的控制器Controller是如何被选举出来的？" class="headerlink" title="1. Kafka的控制器Controller是如何被选举出来的？"></a>1. Kafka的控制器Controller是如何被选举出来的？</h4><p>每台Broker都能充当控制器，那么，当集群启动后，Kafka怎么确认控制器位于哪台Broker呢？</p>
<p><font color=red>实际上，Broker在启动时，会尝试去Zookeeper中创建 <code>/controller节点</code>。Kafka当前选举控制器的规则是：第一个成功创建<code>/controller节点</code>的Broker会被指定为控制器。</font></p>
<h5 id="控制器的作用"><a href="#控制器的作用" class="headerlink" title="控制器的作用"></a>控制器的作用</h5><ol>
<li><p><strong>主题管理（创建、删除、增加分区）</strong></p>
<ul>
<li>控制器帮助我们完成对Kafka主题的创建、删除、以及分区增加的操作。换句话说，当我们执行 <em><strong>*kafka-topics*</strong></em> 脚本时，大部分的后台工作都是控制器来完成的。</li>
</ul>
</li>
<li><p><strong>分区重分配</strong></p>
<ul>
<li>分区重分配主要是指：<code>kafka-reassign-partition脚本</code>，提供的对已有主题分区进行细粒度的分配功能。这部分功能也是控制器实现的。</li>
</ul>
</li>
<li><p><strong>Preferred领导者选举</strong></p>
</li>
<li><p><strong>集群成员管理（新增Broker， Broker主动关闭、Broker宕机）</strong></p>
<ul>
<li><p>这是控制器提供的第 4 类功能，包括自动检测新增 Broker、Broker 主动关闭及被动宕机。这种自动检测是依赖于前面提到的 Watch 功能和 ZooKeeper 临时节点组合实现的。</p>
<p>比如，控制器组件会利用 ****Watch 机制****检查 ZooKeeper 的 /brokers/ids 节点下的子节点数量变更。目前，当有新 Broker 启动后，它会在 /brokers 下创建专属的 znode 节点。一旦创建完毕，ZooKeeper 会通过 Watch 机制将消息通知推送给控制器，这样，控制器就能自动地感知到这个变化，进而开启后续的新增 Broker 作业。</p>
<p>侦测 Broker 存活性则是依赖于刚刚提到的另一个机制：****临时节点****。每个 Broker 启动后，会在 /brokers/ids 下创建一个临时 znode。当 Broker 宕机或主动关闭后，该 Broker 与 ZooKeeper 的会话结束，这个 znode 会被自动删除。同理，ZooKeeper 的 Watch 机制将这一变更推送给控制器，这样控制器就能知道有 Broker 关闭或宕机了，从而进行“善后”。</p>
</li>
</ul>
</li>
<li><p><strong>数据服务</strong></p>
<ul>
<li>控制器的最后一大类工作，就是向其他Broker提供数据服务。控制器上保存了最全的集群元数据信息，其他所有Broker会定期接收控制器发来的元数据更新请求，从而更新其内存中的缓存数据。</li>
</ul>
</li>
</ol>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/640.jpeg" alt="640?wx_fmt=jpeg"></p>
<h5 id="控制器故障转移"><a href="#控制器故障转移" class="headerlink" title="控制器故障转移"></a>控制器故障转移</h5><p>在 Kafka 集群运行过程中，只能有一台 Broker 充当控制器的角色，那么这就存在****单点失效****（Single Point of Failure）的风险，Kafka 是如何应对单点失效的呢？答案就是，为控制器提供故障转移功能，也就是说所谓的 Failover。</p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/640-20210812152030393.jpeg" alt="640?wx_fmt=jpeg"></p>
<p>最开始时，Broker0是控制器，当Broker0宕机后，Zookeeper通过Watch机制感知到并删除了<code>/controller临时节点</code>。之后，所有存活的Broker开始竞选新的控制器身份。Broker3最后抢占成功，成功在Zookeeper上创建了<code>controller节点</code>。之后，Broker3会从Zookeeper中读取集群元数据信息，并初始化到自己的缓存中。</p>
<h4 id="分区Leader的选取"><a href="#分区Leader的选取" class="headerlink" title="分区Leader的选取"></a>分区Leader的选取</h4><p><strong>分区leader副本的选举</strong>由<strong>控制器</strong>负责具实施。当创建分区、分区上线这些时候，都需要执行leader的选举动作。</p>
<p><strong>基本策略</strong></p>
<p>按照<strong>AR</strong>（Kafka topic中一个分区的所有副本）集合中副本的顺序查找第一个存活的副本，并且这个副本在ISR集合中。一个分区的AR集合在分配的时候就被指定，并且只要不发生重分配的情况，集合内部副本的顺序是保持不变的，而分区的ISR集合中副本的顺序可能会改变。</p>
<h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><ol>
<li>Kafka中的ISR，OSR，AR分别代表什么？<ul>
<li>ISR：与leader 保持同步的follower</li>
<li>OSR：与leader副本同步滞后过多的follower集合</li>
<li>AR：分区的所有副本</li>
</ul>
</li>
<li>Kafka中的HW、LEO等分别代表什么？<ul>
<li>LEO：是log文件末尾的偏移量</li>
<li>HW：一个分区中所有副本最小的offset</li>
</ul>
</li>
<li>Kafka中是怎么体现消息顺序性的。<ul>
<li>生产消息时，每次生产的数据都会追加到log文件的末尾</li>
<li>消费时，消费者会维护一个offset偏移量，根据偏移量就可以保证消息的顺序性</li>
</ul>
</li>
<li>Kafka中的分区器、序列化器、拦截器是否了解？他们之间的处理顺序是什么？<ul>
<li><strong>拦截器</strong></li>
<li><strong>序列化器</strong></li>
<li><strong>分区器</strong></li>
</ul>
</li>
<li>Kafka生产者客户端的整体结构是什么样子的？使用了几个线程来处理？分别是什么？<ul>
<li>包括两个线程：main线程和sender线程</li>
<li>组件包括：Procuder、拦截器。序列化器、分区器、共享变量RecordAccumulator和sender线程</li>
<li><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210812153815055-8753896.png" alt="image-20210812153815055" style="zoom:50%;" /></li>
</ul>
</li>
<li>Kafka哪些情形会造成重复消费？<ul>
<li>先消费信息，然后提交offset（如果当信息消费成功之后，offset提交之前，consumer宕机了）</li>
<li>在consumer恢复的时候，还是会从之前的那个偏移量读取数据，这时就会造成重复消费。</li>
</ul>
</li>
<li>kafka哪些情景会造成消息泄漏消费？<ul>
<li>先提交offset，后消费数据</li>
<li>在offset提交offset完成后，消费数据前，consumer宕机了，就有可能造成消息漏消费</li>
</ul>
</li>
</ol>
<h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><h3 id="如何提高生产者的吞吐量？"><a href="#如何提高生产者的吞吐量？" class="headerlink" title="如何提高生产者的吞吐量？"></a>如何提高生产者的吞吐量？</h3><ul>
<li>ack设置为0，不等待broker是否落盘成功，生产者继续发送数据。</li>
<li>生产者端配置<code>batch.size</code>参数，一次按照batch发送，默认16KB</li>
<li><code>linger.ms</code>,这个参数控制：当消息不够一个批次的时候，最长等待时间，如果超过这个时间就算每个达到<code>batch.size</code>,也会发送数据到<code>broker </code></li>
</ul>
<p><strong>待补充</strong></p>
<h1 id="Flink复习"><a href="#Flink复习" class="headerlink" title="Flink复习"></a>Flink复习</h1><h2 id="1-WaterMark"><a href="#1-WaterMark" class="headerlink" title="1. WaterMark"></a>1. WaterMark</h2><p>WaterMark主要是缓解数据乱序所带来的的影响。</p>
<h2 id="2-CheckPoint（一致性检查点）"><a href="#2-CheckPoint（一致性检查点）" class="headerlink" title="2. CheckPoint（一致性检查点）"></a>2. CheckPoint（一致性检查点）</h2><ul>
<li>flink故障恢复机制的核心</li>
<li>有状态流应用的一致性检查点，其实就是所有任务的<strong>状态</strong>，在某个时间点的一份快照，这个时间点，应该是所有任务都恰好处理完一个相同的输入数据的时候。</li>
</ul>
<h4 id="检查点保存（Checkpoint）"><a href="#检查点保存（Checkpoint）" class="headerlink" title="检查点保存（Checkpoint）"></a>检查点保存（Checkpoint）</h4><p>做checkpoint的时候，状态后端是按照一组一组进行保存的，当所有的任务都恰好处理完一个相同的输入数据的时候，就将所有任务的<font color=green>当前状态进行保存</font>（<strong>而不是保存正在处理的数据</strong>）。</p>
<p> <img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/src=http://oscimg.oschina.net/oscnet/c15e5cf0-5f5a-48ac-ba14-b3d370a196cb.png&refer=http://oscimg.oschina.net&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg" alt="img"></p>
<p>如上图：状态的保存时机是source，sum_even和sum_odd这三个任务都处理完5这个数据的时间点，将这些任务的状态进行保存。</p>
<p>如果不能保证所有任务都处理完相同的输入，可能会出现以下情况：</p>
<p>source处理完5，但是由于网络原因，4,3都在堵塞中，导致sum_event和sum_odd还没有处理出完3,4,5这三个数据。如果此时发生故障，在进行故障恢复的时候，就会丢失数据。</p>
<h4 id="从检查点恢复状态"><a href="#从检查点恢复状态" class="headerlink" title="从检查点恢复状态"></a>从检查点恢复状态</h4><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2020.cnblogs.com%2Fblog%2F1824311%2F202009%2F1824311-20200908213604870-202910531.png&refer=http%3A%2F%2Fimg2020.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1630159603&t=9156f9309a498e83d6fe0a15fa6dc8e9" alt="img"></p>
<p>如上述图：当处理到7这个数据的时候，sum_odd任务所负责的分区挂了，此时就需要做检查点恢复。</p>
<ul>
<li>在执行流应用程序期间，Flink会定期保存状态的一致检查点。</li>
<li>如果发生故障，Flink将会使用最近的检查点来一致恢复应用程序的状态，并重新启动处理流程。</li>
</ul>
<p>这就需要数据源能够有<font color=red>数据重放的功能</font></p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/url=http://dingyue.ws.126.net/2021/0727/1e1f12b7j00qwwn0g002ac000hs00umg.jpg&thumbnail=650x2147483647&quality=80&type=jpg" alt="img"></p>
<ol>
<li>遇到故障之后，第一步就是重启应用</li>
<li>第二步是从checkpoint中读取状态，将状态重置</li>
<li>从检查点重启应用程序后，其内部状态与检查点完成时的状态完全相同。</li>
<li>第三步：开始消费并处理检查点到发生故障之间的所有数据</li>
<li>这种检查点的保存和恢复机制可以为应用程序状态提供（Exactly-one）的一致性，因为所有算子都会保存检查点并恢复其所有状态，这样一来所有的输入流都会被重置到检查点完成时的位置。</li>
</ol>
<p>关于Flink实现Exactly-Once的几点要求：</p>
<ul>
<li>source端支持数据重放的功能，当发生故障的时候，source可以进行故障之前的数据重放</li>
<li>Flink内部通过CheckPoint保证发生故障时，状态的重置。</li>
<li>sink端需要有<strong>幂等性</strong>或者<strong>事务性</strong>（日志预写和两阶段提交2PC）的支持。</li>
</ul>
<h4 id="CheckPoint算法"><a href="#CheckPoint算法" class="headerlink" title="CheckPoint算法"></a>CheckPoint算法</h4><p>其核心就是<font color=red>barrier对齐</font></p>
<p>其本质是基于Chandy-Lamport算法的分布式快照算法的改进。</p>
<p>将检查点的保存和数据处理分开，不暂停整个应用</p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/i=20210111152147546.png" alt="在这里插入图片描述"></p>
<ul>
<li>现在是一个两个输入流的应用程序，用并行的两个source任务来读取</li>
</ul>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/i=2021011115251435.png" alt="在这里插入图片描述"></p>
<ul>
<li>JobManager会向每个Source任务发送一条带有检查点ID的消息，通过这种方法来启动检查点</li>
<li>这个消息会传递给下游所有任务</li>
</ul>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/i=20210111153027619.png" alt="在这里插入图片描述"></p>
<ul>
<li>数据源将它们的状态写入检查点，并发出一个检查点barrier，广播发到下游任务。状态后端在状态存入检查点之后，会返回通知给source任务，source任务就会向jobmanager确定检查点完成。</li>
</ul>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/i=20210111153426447.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>分界线对齐（barrier对齐）：barrier向下游传递，sum任务会等待所有输入分区的barrier到达。</p>
</li>
<li><p>对于barrier已经到达的分区，继续接收到的数据会被缓存起来；而barrier尚未到达的分区，数据会被正常处理。</p>
</li>
</ul>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/i=20210111153926877.png" alt="在这里插入图片描述"></p>
<ul>
<li>当接收到所有分区的barrier时，任务就将其状态保存到状态后端的检查点中，然后barrier继续向下游转发。</li>
</ul>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/i=2021011115420988-16300710261841.png" alt="在这里插入图片描述"></p>
<ul>
<li>向下游转发barrier后，任务继续正常的进行数据处理</li>
</ul>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/i=20210111154304922.png" alt="在这里插入图片描述"></p>
<ul>
<li>sink任务想JobManager确认状态保存到checkpoint完毕</li>
<li>当所有任务都确认已经成功将状态保存到检查点时，检查点就真正完成了。</li>
</ul>
<p>每个任务都有相应的状态的检查点，所有任务的状态checkpoint被状态后端state backend保存，当出现故障的时候哦，从此checkpoint就可以恢复任务。</p>
<h4 id="状态后端"><a href="#状态后端" class="headerlink" title="状态后端"></a>状态后端</h4><ul>
<li><p><strong>MemoryStateBackend</strong></p>
<p>内存级的状态后端，会将<strong>键控状态</strong>作为内存中的对象进行管理，将它们存储在TaskManager的JVM堆上 ；而将Checkpoint存储在JobManager的内存中。</p>
</li>
<li><p><strong>FsStateBackend</strong></p>
<p>将checkpoint存到远程的持久化文件系统（FileSystem）上。而对于本地状态，跟MemoryStateBackend一样，也会存在TaskManager的JVM堆上。</p>
</li>
<li><p><strong>RocksDBStateBackend</strong></p>
<p>将所有状态序列化后，存入本地的RocksDB中存储。</p>
</li>
</ul>
<h2 id="3-Flink中的状态一致性"><a href="#3-Flink中的状态一致性" class="headerlink" title="3.Flink中的状态一致性"></a>3.Flink中的状态一致性</h2><h3 id="一致性级别"><a href="#一致性级别" class="headerlink" title="一致性级别"></a>一致性级别</h3><p>在流处理中，一致性可以分为3个级别：</p>
<ul>
<li><strong>at-most-once</strong>: 这其实是没有正确性保证的委婉说法——故障发生之后，计数结果可能丢失，同样的还有UDP。（至多一次）</li>
<li><strong>at-least-once</strong>：这表示计数结果可能大于正确值，但绝不会小于正确值。也就是说，计数程序在发生故障后可能多算，但是绝不会少算。（至少一次）</li>
<li><strong>exactly-once</strong>：这指的是系统保证在发生故障后得到的计数结果与正确值一致。（精确一致）</li>
</ul>
<p>Flink的一个重大价值在于：<strong>它既保证了exactly-once，也具有低延迟和高吞吐的处理能力。</strong></p>
<h4 id="端到端（end-to-end）状态一致性"><a href="#端到端（end-to-end）状态一致性" class="headerlink" title="端到端（end to end）状态一致性"></a>端到端（end to end）状态一致性</h4><ul>
<li>flink内部保证——依赖checkpoint</li>
<li>source端——需要外部数据源可重放数据（可重置数据的读取位置）</li>
<li>sink端——需要保证从故障恢复时，数据不会重复写入外部系统。<ul>
<li>对于sink端，又有两种具体的实现方式：<strong>幂等性写入</strong>和<strong>事务性写入</strong></li>
<li><strong>幂等性写入</strong>：就是说一个操作，可以重复执行很多次，但只导致一次结果更改，也就是说，后面再重复执行就不起作用了。</li>
<li><strong>事务写入</strong>：需要构建事务来写入外部系统，构建的事务对应着checkpoint，等到checkpoint真正完成的时候，才把所有对应的结果写入sink系统中。<ul>
<li>对于事务写入，具体又有两种实现方式：预写日志（WAL）和两阶段提交（2PC）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-分布式事务"><a href="#4-分布式事务" class="headerlink" title="4.分布式事务"></a>4.分布式事务</h2><h3 id="1-本地事务"><a href="#1-本地事务" class="headerlink" title="1. 本地事务"></a>1. 本地事务</h3><p>在计算机系统中，更多的是通过关系型数据库来控制事务，这是利用数据库本身的事务特性来实现的，因此叫数据库事务。由于应用主要靠关系数据库来控制事务，而数据库通常和应用在同一个服务器，所以<strong>基于关系型数据库的事务又称为本地事务</strong></p>
<p><u>数据库事务在实现时会将一次事务设计的所有操作全部纳入到一个不可分割的执行单元，执行单元中的所有操作要么成功，要么都失败，只要其中任一操作执行失败，都将导致整个事务的回滚</u></p>
<h3 id="2-分布式事务"><a href="#2-分布式事务" class="headerlink" title="2.分布式事务"></a>2.分布式事务</h3><p>分布式系统会把一个应用系统拆分为可独立部署的多个服务，因此需要服务与服务之间远程协作才能完成事务操作，这种分布式系统环境下由不同的服务之间通过网络远程协作完成事务称之为<strong>分布式事务</strong>，例如用户注册送积分事务，创建订单减少库存事务，银行转账事务等都是分布式事务。</p>
<blockquote>
<p>举个例子</p>
<p>创建订单在一台服务器上；</p>
<p>减少库存在另一台服务器上；</p>
<p>两个服务要通过分布式事务来保证 <strong>一致性</strong></p>
</blockquote>
<ul>
<li>跨数据库示例，也需要分布式事务。</li>
<li>多服务访问同一个数据库实例<ul>
<li>跨JVM进程，也需要分布式事务</li>
</ul>
</li>
</ul>
<h3 id="3-CAP-理论"><a href="#3-CAP-理论" class="headerlink" title="3. CAP 理论"></a>3. CAP 理论</h3><ul>
<li>C一致性</li>
<li>A可用性</li>
<li>分区容错性</li>
</ul>
<h4 id="一致性C"><a href="#一致性C" class="headerlink" title="一致性C"></a>一致性C</h4><p>一致性是指写操作后的读操作可以读取到最新的数据状态，当数据分布在多个节点上，从任意节点读取到的数据都是最新的状态。</p>
<p><font color=green>说白了就是主从之间的数据一致性</font></p>
<p><strong>如何实现一致性？</strong></p>
<ul>
<li>写入主数据库后要将数据同步到从数据库</li>
<li>写入主数据库后，再向从数据库同步期间要将从数据库锁定，待同步完成后再释放锁，以免在新数据写入成功后，向从数据库查询到旧的数据。</li>
</ul>
<p><strong>分布式系统一致性的特点：</strong></p>
<ul>
<li>由于存在数据同步的过程，写操作的相应会有一定的延迟</li>
<li>为了保证数据一致性会对资源暂时锁定，待数据同步完成释放锁定资源</li>
<li>如果请求数据同步失败的节点则会返回错误信息，一定不会返回旧数据。</li>
</ul>
<h4 id="可用性A"><a href="#可用性A" class="headerlink" title="可用性A"></a>可用性A</h4><p>可用性是指任何事物操作都可以得到相应结果，且不会出现响应超时或响应错误。</p>
<p><strong>如何实现可用性？</strong></p>
<ol>
<li>写入主数据库后要将数据同步到从数据库</li>
<li>由于要保证从数据库的可用性，不可将从数据库中的资源进行锁定</li>
<li>即使数据还没有同步过来，从数据库也要返回要查询到的数据，哪怕是旧数据，如果旧数据也没有则可以按照约定返回一个默认信息，但不能返回错误或响应超时。</li>
</ol>
<h4 id="分期容忍性"><a href="#分期容忍性" class="headerlink" title="分期容忍性"></a>分期容忍性</h4><p>通常分布式系统的各个节点部署在不同的子网，这就是网络分区，不可避免的会出现由于网络问题而导致节点之间通信失败，此时仍可对外提供服务，这叫分区容忍性。</p>
<p><strong>如何实现分区容忍性？</strong></p>
<ol>
<li>尽量使用异步代取同步操作，例如使用异步方式将数据从主数据库同步到从数据库，这样节点之间能有效的实现松耦合。</li>
<li>添加从数据库节点，其中一个节点挂了其他从节点提供服务</li>
</ol>
<p><font color=red>分区容忍性是分布式系统的基本能力</font></p>
<h4 id="CAP-组合方式"><a href="#CAP-组合方式" class="headerlink" title="CAP 组合方式"></a>CAP 组合方式</h4><p><strong>在所有分布式事务场景中不会同时具备CAP三个特性，因为在具备P的前提下C和A是不能共存的</strong></p>
<h4 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h4><ol>
<li>强一致性和最终一致性</li>
</ol>
<ul>
<li><p>CP</p>
</li>
<li><p>AP</p>
</li>
</ul>
<p>BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的缩写。BASE理论是对CAP中AP的一个扩展，通过牺牲强一致性来获得可用性，当出现故障允许部分不可用但要保证核心功能可用，允许数据在一段时间内是不一致的，但最终达到一致状态。满足BASE理论的事务，称之为<strong>柔性事务</strong></p>
<h3 id="4-分布式事务解决方案☞2PC（两阶段提交）"><a href="#4-分布式事务解决方案☞2PC（两阶段提交）" class="headerlink" title="4. 分布式事务解决方案☞2PC（两阶段提交）"></a>4. 分布式事务解决方案☞2PC（两阶段提交）</h3><p>针对不同的分布式场景，业界常见的解决方案有2PC，TCC可靠消息最终一致性、最大努力通知这几种</p>
<h4 id="1-什么是2PC"><a href="#1-什么是2PC" class="headerlink" title="1. 什么是2PC"></a>1. 什么是2PC</h4><p>2PC即两阶段提交协议，是将整个事务流程分为两个阶段，<strong>准备阶段（Prepare phase）</strong>、<strong>提交阶段（commit phase）</strong>，2是指两个阶段，P是指准备阶段；C是指提交阶段。</p>
<blockquote>
<p>举例</p>
<p>张三和李四好久不见，老友约起聚餐，饭店老板要求先买单，才能出票。这时张三和李四分别抱怨近况不如意，囊中羞涩，都不愿意请客，这时只能AA。只有张三和李四都付款老板才能出票安排就餐。但由于张三和李四都是铁公鸡，形成了尴尬的一幕：</p>
<ul>
<li>准备阶段：老板要求张三付款，张三付款；老板要求李四付款，李四付款。</li>
<li>提交阶段：老板出票，两人纷纷落座就餐。</li>
</ul>
<p>例子中形成了一个事务，若张三和李四其中一人拒绝付款，或钱不够，店老板都不会给出票，并且会把已收款退回。</p>
</blockquote>
<p>整个事务过程由<font color=red>事务管理器</font>和<font color=red>参与者</font>组成</p>
<p>店老板就是事务管理器；张三和李四就是参与者；事务管理器负责决策整个分布式事务的提交和回滚，事务参与者负责自己本地事务的提交和回滚。</p>
<p>在计算机部分关系数据库如MySql支持两阶段提交协议：</p>
<ol>
<li><p>准备阶段：事务管理器给每个参与者发送Prepare消息，每个数据库参与者在本地执行事务，并写本地的Undo/Redo日志，此时事务没有提交</p>
<p>(Undo日志是记录修改前的数据，用于数据库的回滚；Redo日志是记录修改后的数据，用于提交事务后写入数据文件）</p>
</li>
<li><p>提交阶段：如果<strong>事务管理器</strong>收到了<strong>参与者的执行失败或者超时消息时</strong>，直接给每个参与者发送回滚（Rollback）消息；否则，发送提交（Commit）消息；参与者根据事务管理器的指令执行提交或者回滚操作，并释放事务处理过程中使用的锁资源。<font color=red>注意：必须在最后阶段释放锁资源。</font></p>
</li>
</ol>
<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fattach.dataguru.cn%2Fattachments%2Fforum%2F201509%2F20%2F084322huqeon7nkwtakmwq.png&refer=http%3A%2F%2Fattach.dataguru.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1633742797&t=84d69a96c3939ab09772d54e6a7613b6" alt="img"></p>
<p>如果任何一方参与者的本地事务执行失败了，那么事务管理器就会给其他参与者发送<strong>Rollback</strong>指令，是其他参与者进行<strong>回滚</strong>。</p>
<h4 id="2-解决方案XA"><a href="#2-解决方案XA" class="headerlink" title="2. 解决方案XA"></a>2. 解决方案XA</h4><p><strong>DTP模型定义角色</strong></p>
<ul>
<li>AP：应用程序，可以理解为使用DTP分布式事务的程序</li>
<li>RM：资源管理器，可以理解为事务的参与者</li>
<li>TM：事务管理器，负责协调和管理事务，事务管理器控制着全局事务，管理事务生命周期，并协调各个RM。<strong>全局事务</strong>是指分布式处理环境中，需要操作多个数据库共同完成一个工作，这个工作即是一个全局事务。</li>
<li>DTP模型定义TM和RM之间通讯的接口规范叫<strong>XA</strong>，简单理解为数据库提供的2PC接口协议，<strong>基于数据库的XA协议来实现2PC又称为XA方案。</strong></li>
</ul>
<ol>
<li>在<strong>准备阶段</strong>RM执行实际的业务操作，但不提交事务，资源锁定；</li>
<li>在<strong>提交阶段</strong>TM会接受RM在准备阶段的执行回复，只要有任一个RM执行失败，TM会通知所有RM执行回滚操作，否则，TM将会通知所有RM提交该事务。提交阶段结束资源锁释放。</li>
</ol>
<p><strong>XA方案的问题：</strong></p>
<ul>
<li>需要本地数据库支持XA协议</li>
<li>资源所需要等到两个阶段结束才释放，性能较差。</li>
</ul>
<h4 id="3-解决方案Seata方案"><a href="#3-解决方案Seata方案" class="headerlink" title="3.解决方案Seata方案"></a>3.解决方案Seata方案</h4><p>Seata是阿里中间件团队发起的开源项目Fescar，后更名为Seata，他是一个开源的分布式事务框架。</p>
<p>传统的2PC的问题在Seata中得到了解决，它通过对本地关系数据库的分支事务的协调来驱动完成全局事务，是工作在应用层的中间件。主要优点是性能较好，且不长时间占用连接资源，它以高效并且对业务0侵入的方式解决微服务场景下面临的分布式事务问题，他目前提供AT模式（即2PC）及TCC模式的分布式事务解决方案。</p>
<p><strong>Seata的设计思想如下：</strong></p>
<p>Seata的设计目标是其一是对业务无侵入，因此从业务侵入的2PC方案着手，在传统2PC的基础上演进，并讲解2PC方案面临的问题。</p>
<p>Seata把一个分布式事务理解成一个包含了若干<strong>分支事务</strong>的<strong>全局事务</strong>。全局事务的职责是协调其下管辖的分支事务达成一致，要么一起成功提交，要么一起失败回滚。此外，通常分支事务本身就是一个关系数据库的本地事务，下图全局事务与分支事务的关系图：</p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210909102257596-16311541787475.png" alt="image-20210909102257596"></p>
<p>与传统2PC的模型类似，Seata定义了3个组件来协议分布式事务的处理过程</p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210909102436921.png" alt="image-20210909102436921"></p>
<ul>
<li>Transaction Coordinate（TC）：<strong>事务协调器</strong>，它是独立的中间件，需要独立部署运行，它维护全局事务的运行状态，接收TM指令发起全局事务的提交与回滚，负责与RM通信协调各个分支事务的提交或回滚。</li>
<li>Transaction Manager（TM）：<strong>事务管理器</strong>，TM需要嵌入应用程序中工作，它负责开启一个全局事务，并最终向<strong>TC</strong>发起<strong>全局提交或全局回滚的指令</strong>。</li>
<li>Resource Manager（RM）：<strong>控制分支事务</strong>，负责分支注册、状态汇报，并且接收事务协调器TC的指令，驱动分支（本地）事务的提交和回滚。</li>
</ul>
<p>Seata方案的每个本地或者分支事务在执行完毕之后就执行提交操作，回滚的时候，删除数据的方式进行回滚。</p>
<p><strong>Seata实现2PC与传统的2PC的差别</strong></p>
<p>架构层次方面，传统2PC方案的RM实际上是在数据库层，RM本质上就是数据库自身，通过XA协议实现，而Seata的RM是以jar包的形式作为中间件层部署在应用程序这一侧的。</p>
<p>而两阶段提交方面，传统2PC无论第二阶段的决议是commit还是rollback，事务性资源的锁都要保持到Phase2完成才释放。而Seata的做法是在Phase1就将本地事务提交，这样就可省去Phase2持锁的时间，整体提高效率。</p>
<h1 id="数仓复习"><a href="#数仓复习" class="headerlink" title="数仓复习"></a>数仓复习</h1><h2 id="数仓理论"><a href="#数仓理论" class="headerlink" title="数仓理论"></a>数仓理论</h2><h3 id="待补充。。。"><a href="#待补充。。。" class="headerlink" title="待补充。。。"></a>待补充。。。</h3><h3 id="路径分析-与-桑基图"><a href="#路径分析-与-桑基图" class="headerlink" title="路径分析  与  桑基图"></a>路径分析  与  桑基图</h3><blockquote>
<p>路径分析:</p>
<p>​    是指用户在APP中或者网站中的<strong>访问路径</strong>。为了衡量网站<strong>优化的效果</strong>或者<strong>营销推广的效果</strong>，以及了解<strong>用户行为偏好</strong>，时常要对访问路径进行分析。</p>
</blockquote>
<blockquote>
<p>桑基图：</p>
<p>​    是用于描述一组值到另一组值的流向的图表。比如下图的人口流动情况</p>
<img src="source/大数据学习之路/v2-5d7aee3655ceb6be8625ddb58e1724bd_r.jpg" alt="img" style="zoom:100%;" />

<p>边的左侧节点表示起始点：<strong>Source</strong></p>
<p>边的右侧节点表示终止点：<strong>Target</strong></p>
<p>桑基图需要提供每种页面，节点的跳转次数。每个流向或者跳转由 source 与 target 表示。</p>
<ul>
<li>source：跳转起始页面（<strong>不允许为空</strong>）</li>
<li>target：跳转终到页面（<strong>可为空</strong>）</li>
</ul>
<p>❌<strong>桑基图所展示的流程中不允许存在环</strong></p>
</blockquote>
<p>😨<strong>source不允许为空的解决方案</strong></p>
<p>通常情况下我们以直观简单的思想去定义 source和target的时候，可能会存在source为null的业务场景，例如下述sql，将last_page_id作为source就存在null的情况：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">	session_id</span><br><span class="line">    ,last_page_id 	source</span><br><span class="line">    ,page_id 		target</span><br><span class="line"><span class="keyword">from</span> dwd_page_log</span><br><span class="line"><span class="keyword">where</span> dt<span class="operator">=</span><span class="string">&#x27;2020-06-14&#x27;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>source</th>
<th>target</th>
</tr>
</thead>
<tbody><tr>
<td><font color=red>null</font></td>
<td>home</td>
</tr>
<tr>
<td>home</td>
<td>search</td>
</tr>
<tr>
<td>search</td>
<td>good_list</td>
</tr>
<tr>
<td>good_list</td>
<td>good_detail</td>
</tr>
<tr>
<td>good_detail</td>
<td>login</td>
</tr>
<tr>
<td>login</td>
<td>good_detail</td>
</tr>
<tr>
<td>good_detail</td>
<td>cart</td>
</tr>
<tr>
<td>cart</td>
<td>trade</td>
</tr>
<tr>
<td>trade</td>
<td>payment</td>
</tr>
</tbody></table>
<p>这种情况我们可以转变思路，可以将 <strong>page_id作为 source</strong>， <strong>当前行的下一行的page_id作为target</strong>，这样就避免了source为null的情况了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">	session_id</span><br><span class="line">	,page_id														source</span><br><span class="line">	,<span class="built_in">lead</span>(page,<span class="number">1</span>,<span class="keyword">null</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> session_id <span class="keyword">order</span> <span class="keyword">by</span> ts) 	target</span><br><span class="line"><span class="keyword">from</span> dwd_page_log</span><br><span class="line"><span class="keyword">where</span> dt<span class="operator">=</span><span class="string">&#x27;2020-06-14&#x27;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>source</th>
<th>target</th>
</tr>
</thead>
<tbody><tr>
<td>home</td>
<td>search</td>
</tr>
<tr>
<td>search</td>
<td>good_list</td>
</tr>
<tr>
<td>good_list</td>
<td>good_detail</td>
</tr>
<tr>
<td>good_detail</td>
<td>login</td>
</tr>
<tr>
<td>login</td>
<td>good_detail</td>
</tr>
<tr>
<td>good_detail</td>
<td>cart</td>
</tr>
<tr>
<td>cart</td>
<td>trade</td>
</tr>
<tr>
<td>trade</td>
<td>payment</td>
</tr>
<tr>
<td>payment</td>
<td><font color=red>null</font></td>
</tr>
</tbody></table>
<p>虽然解决了source不为null的问题，但是观察上述数据，<code>good_detail -&gt; login, login -&gt; good_detail</code> 存在环，此时可以为每次跳转增加跳转序号，根据跳转序号为每个页面增加页面序号。</p>
<p>预期结果：</p>
<table>
<thead>
<tr>
<th>source</th>
<th>target</th>
<th>step</th>
</tr>
</thead>
<tbody><tr>
<td>home1️⃣</td>
<td>search2️⃣</td>
<td>1</td>
</tr>
<tr>
<td>search2️⃣</td>
<td>good_list3️⃣</td>
<td>2</td>
</tr>
<tr>
<td>good_list3️⃣</td>
<td>good_detail4️⃣</td>
<td>3</td>
</tr>
<tr>
<td>good_detail4️⃣</td>
<td>login5️⃣</td>
<td>4</td>
</tr>
<tr>
<td>login5️⃣</td>
<td>good_detail6️⃣</td>
<td>5</td>
</tr>
<tr>
<td>good_detail6️⃣</td>
<td>cart7️⃣</td>
<td>6</td>
</tr>
<tr>
<td>cart7️⃣</td>
<td>trade8️⃣</td>
<td>7</td>
</tr>
<tr>
<td>trade8️⃣</td>
<td>payment9️⃣</td>
<td>8</td>
</tr>
<tr>
<td>payment9️⃣</td>
<td><font color=red>null</font></td>
<td>9</td>
</tr>
<tr>
<td>home1️⃣</td>
<td>mine2️⃣</td>
<td>1</td>
</tr>
<tr>
<td>mine2️⃣</td>
<td>orders_unpaid3️⃣</td>
<td>2</td>
</tr>
<tr>
<td>orders_unpaid3️⃣</td>
<td>good_detail4️⃣</td>
<td>3</td>
</tr>
<tr>
<td>good_detail4️⃣</td>
<td>good_spec5️⃣</td>
<td>4</td>
</tr>
<tr>
<td>good_spec5️⃣</td>
<td>comment6️⃣</td>
<td>5</td>
</tr>
<tr>
<td>comment6️⃣</td>
<td>trade7️⃣</td>
<td>6</td>
</tr>
<tr>
<td>trade7️⃣</td>
<td>payment8️⃣</td>
<td>7</td>
</tr>
<tr>
<td>payment8️⃣</td>
<td><font color=red>null</font></td>
<td>8</td>
</tr>
</tbody></table>
<p>这样 环<code>good_detail -&gt; login, login -&gt; good_detail</code> 就变成了<code>good_detail4 -&gt; login5, login5 -&gt; good_detail6</code>, 环就不复存在啦！😊</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 解决环的问题</span></span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">        concat(source,<span class="string">&#x27;：&#x27;</span>,step) 	source <span class="comment">-- 其实页面添加id</span></span><br><span class="line">        ,concat(target,<span class="string">&#x27;：&#x27;</span>,step<span class="operator">+</span><span class="number">1</span>) 	target <span class="comment">-- 终止页面添加id</span></span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">    (</span><br><span class="line">        <span class="comment">-- 当前查询可将每个会话的跳转明细查询出来，包括页面的跳转次序</span></span><br><span class="line">        <span class="keyword">select</span></span><br><span class="line">            session_id</span><br><span class="line">            ,page_id source</span><br><span class="line">            ,<span class="built_in">lead</span>(page_id,<span class="number">1</span>,<span class="keyword">null</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> session_id <span class="keyword">order</span> <span class="keyword">by</span> ts) target  <span class="comment">-- 当前行的下一行page_id 作为target，没有下一行默认值为null</span></span><br><span class="line">            ,<span class="built_in">row_number</span>() <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> session_id <span class="keyword">order</span> <span class="keyword">by</span> ts) step <span class="comment">-- 每次会话的跳转序号</span></span><br><span class="line">        <span class="keyword">from</span></span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">select</span></span><br><span class="line">                last_page_id</span><br><span class="line">                ,page_id</span><br><span class="line">                ,concat(mid_id,<span class="string">&#x27;-&#x27;</span>,<span class="built_in">last_value</span>(if(last_page_id <span class="keyword">is</span> <span class="keyword">null</span>,ts,<span class="keyword">null</span>),<span class="literal">true</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> mid_id <span class="keyword">order</span> <span class="keyword">by</span> ts)) session_id</span><br><span class="line">                ,ts</span><br><span class="line">            <span class="keyword">from</span> dwd_page_log</span><br><span class="line">            <span class="keyword">where</span> dt<span class="operator">=</span><span class="string">&#x27;2020-06-14&#x27;</span></span><br><span class="line">        ) t1</span><br><span class="line">    ) t2</span><br></pre></td></tr></table></figure>







<h2 id="开发小技巧"><a href="#开发小技巧" class="headerlink" title="开发小技巧"></a>开发小技巧</h2><h3 id="区分-维度-与-指标"><a href="#区分-维度-与-指标" class="headerlink" title="区分 维度 与 指标"></a>区分 维度 与 指标</h3><p>在进行指标的开发时，总会涉及到很多个维度字段，在开发时，首先就要区分这些<strong>维度字段</strong> 与 <strong>指标字段</strong>，然后先不考虑维度问题<code>换句话说就是：所有维度的汇总值</code>，<font color=red>先把所有维度的总汇总指标值计算出来之后，再通过group by 维度字段 来进行维度的细分！</font>，这样做会比直接考虑维度要简单的多。</p>
<blockquote>
<p>举个例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> ads_visit_stats;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> ads_visit_stats (</span><br><span class="line">  `dt` STRING COMMENT <span class="string">&#x27;统计日期&#x27;</span>,</span><br><span class="line">  `is_new` STRING COMMENT <span class="string">&#x27;新老标识,1:新,0:老&#x27;</span>,</span><br><span class="line">  `recent_days` <span class="type">BIGINT</span> COMMENT <span class="string">&#x27;最近天数,1:最近1天,7:最近7天,30:最近30天&#x27;</span>,</span><br><span class="line">  `channel` STRING COMMENT <span class="string">&#x27;渠道&#x27;</span>,</span><br><span class="line">  `uv_count` <span class="type">BIGINT</span> COMMENT <span class="string">&#x27;日活(访问人数)&#x27;</span>,</span><br><span class="line">  `duration_sec` <span class="type">BIGINT</span> COMMENT <span class="string">&#x27;页面停留总时长&#x27;</span>,</span><br><span class="line">  `avg_duration_sec` <span class="type">BIGINT</span> COMMENT <span class="string">&#x27;一次会话，页面停留平均时长,单位为描述&#x27;</span>,</span><br><span class="line">  `page_count` <span class="type">BIGINT</span> COMMENT <span class="string">&#x27;页面总浏览数&#x27;</span>,</span><br><span class="line">  `avg_page_count` <span class="type">BIGINT</span> COMMENT <span class="string">&#x27;一次会话，页面平均浏览数&#x27;</span>,</span><br><span class="line">  `sv_count` <span class="type">BIGINT</span> COMMENT <span class="string">&#x27;会话次数&#x27;</span>,</span><br><span class="line">  `bounce_count` <span class="type">BIGINT</span> COMMENT <span class="string">&#x27;跳出数&#x27;</span>,</span><br><span class="line">  `bounce_rate` <span class="type">DECIMAL</span>(<span class="number">16</span>,<span class="number">2</span>) COMMENT <span class="string">&#x27;跳出率&#x27;</span></span><br><span class="line">) COMMENT <span class="string">&#x27;访客统计&#x27;</span></span><br><span class="line"><span class="type">ROW</span> FORMAT DELIMITED FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\t&#x27;</span></span><br><span class="line">LOCATION <span class="string">&#x27;/warehouse/gmall/ads/ads_visit_stats/&#x27;</span>;</span><br></pre></td></tr></table></figure>


</blockquote>
<p>区分上述表中的维度与指标</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>dt</th>
<th>统计时间</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>is_new</td>
<td>新老标识</td>
</tr>
<tr>
<td></td>
<td>recent_days</td>
<td>最近天数</td>
</tr>
<tr>
<td></td>
<td>channel</td>
<td>渠道</td>
</tr>
<tr>
<td><strong>指标</strong></td>
<td>uv_count</td>
<td>日活</td>
</tr>
<tr>
<td></td>
<td>duration_sec</td>
<td>页面停留时长（所有会话）</td>
</tr>
<tr>
<td></td>
<td>avg_duration_sec</td>
<td>一次会话，页面停留平均时长</td>
</tr>
<tr>
<td></td>
<td>page_count</td>
<td>页面总浏览数（所有会话）</td>
</tr>
<tr>
<td></td>
<td>avg_page_count</td>
<td>一次会话，页面平均浏览数</td>
</tr>
<tr>
<td></td>
<td>sv_count</td>
<td>会话次数</td>
</tr>
<tr>
<td></td>
<td>bounce_count</td>
<td>跳出数：一次会话中只浏览一个页面</td>
</tr>
<tr>
<td></td>
<td>bounce_rate</td>
<td>跳出数/会话次数</td>
</tr>
</tbody></table>
<ol>
<li>先不考虑维度，计算出总的会话指标值（最近一天的数据）</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    <span class="built_in">count</span>(<span class="keyword">distinct</span> mid_id) uv_count</span><br><span class="line">    ,<span class="built_in">sum</span>(duration)<span class="operator">/</span><span class="number">1000</span> duration_sec</span><br><span class="line">    ,<span class="built_in">avg</span>(duration)<span class="operator">/</span><span class="number">1000</span> avg_duration_sec</span><br><span class="line">    ,<span class="built_in">sum</span>(page_count) page_count</span><br><span class="line">    ,<span class="built_in">avg</span>(page_count) avg_page_count</span><br><span class="line">    ,<span class="built_in">count</span>(<span class="keyword">distinct</span> session_id) sv_count</span><br><span class="line">    ,<span class="built_in">sum</span>(if(page_count<span class="operator">=</span><span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>)) bounce_count</span><br><span class="line">    ,<span class="built_in">sum</span>(if(page_count<span class="operator">=</span><span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> session_id) bounce_rate</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">        session_id <span class="comment">-- 每次会话</span></span><br><span class="line">        ,mid_id</span><br><span class="line">        ,<span class="built_in">count</span>(page_id) page_count</span><br><span class="line">        ,<span class="built_in">sum</span>(during_time)<span class="operator">/</span><span class="number">1000</span> duration</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">select</span> mid_id       <span class="comment">-- 设备id</span></span><br><span class="line">             , last_page_id <span class="comment">-- 上一页id</span></span><br><span class="line">             , page_id      <span class="comment">-- 本页id</span></span><br><span class="line">             , during_time  <span class="comment">-- 本页面停留时间</span></span><br><span class="line">             , ts           <span class="comment">-- 跳入当前页面的时间</span></span><br><span class="line">            , concat(mid_id,<span class="string">&#x27;-&#x27;</span>,<span class="built_in">last_value</span>(session_start_point,<span class="literal">true</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> mid_id <span class="keyword">order</span> <span class="keyword">by</span> ts)) session_id</span><br><span class="line">        <span class="keyword">from</span></span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">select</span> mid_id       <span class="comment">-- 设备id</span></span><br><span class="line">                 , last_page_id <span class="comment">-- 上一页id</span></span><br><span class="line">                 , page_id      <span class="comment">-- 本页id</span></span><br><span class="line">                 , during_time  <span class="comment">-- 本页面停留时间</span></span><br><span class="line">                 , ts           <span class="comment">-- 跳入当前页面的时间</span></span><br><span class="line">                ,if(last_page_id <span class="keyword">is</span> <span class="keyword">null</span>, ts, <span class="keyword">null</span>) session_start_point</span><br><span class="line">            <span class="keyword">from</span> dwd_page_log</span><br><span class="line">            <span class="keyword">where</span> dt <span class="operator">=</span> <span class="string">&#x27;2020-06-14&#x27;</span></span><br><span class="line">        ) t1</span><br><span class="line">    ) t2</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> session_id,mid_id</span><br><span class="line">) t3</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>添加维度</p>
<ol>
<li><p>添加渠道维度</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    channel</span><br><span class="line">    ,<span class="built_in">count</span>(<span class="keyword">distinct</span> mid_id) uv_count</span><br><span class="line">    ,<span class="built_in">sum</span>(duration)<span class="operator">/</span><span class="number">1000</span> duration_sec</span><br><span class="line">    ,<span class="built_in">avg</span>(duration)<span class="operator">/</span><span class="number">1000</span> avg_duration_sec</span><br><span class="line">    ,<span class="built_in">sum</span>(page_count) page_count</span><br><span class="line">    ,<span class="built_in">avg</span>(page_count) avg_page_count</span><br><span class="line">    ,<span class="built_in">count</span>(<span class="keyword">distinct</span> session_id) sv_count</span><br><span class="line">    ,<span class="built_in">sum</span>(if(page_count<span class="operator">=</span><span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>)) bounce_count</span><br><span class="line">    ,<span class="built_in">sum</span>(if(page_count<span class="operator">=</span><span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> session_id) bounce_rate</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">        session_id <span class="comment">-- 每次会话</span></span><br><span class="line">         ,channel</span><br><span class="line">        ,mid_id</span><br><span class="line">        ,<span class="built_in">count</span>(page_id) page_count</span><br><span class="line">        ,<span class="built_in">sum</span>(during_time)<span class="operator">/</span><span class="number">1000</span> duration</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">select</span> mid_id       <span class="comment">-- 设备id</span></span><br><span class="line">             , last_page_id <span class="comment">-- 上一页id</span></span><br><span class="line">             , page_id      <span class="comment">-- 本页id</span></span><br><span class="line">             , during_time  <span class="comment">-- 本页面停留时间</span></span><br><span class="line">             , ts           <span class="comment">-- 跳入当前页面的时间</span></span><br><span class="line">             ,channel</span><br><span class="line">            , concat(mid_id,<span class="string">&#x27;-&#x27;</span>,<span class="built_in">last_value</span>(session_start_point,<span class="literal">true</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> mid_id <span class="keyword">order</span> <span class="keyword">by</span> ts)) session_id</span><br><span class="line">        <span class="keyword">from</span></span><br><span class="line">        (</span><br><span class="line">            <span class="keyword">select</span> mid_id       <span class="comment">-- 设备id</span></span><br><span class="line">                 , last_page_id <span class="comment">-- 上一页id</span></span><br><span class="line">                 , page_id      <span class="comment">-- 本页id</span></span><br><span class="line">                 , during_time  <span class="comment">-- 本页面停留时间</span></span><br><span class="line">                 , ts           <span class="comment">-- 跳入当前页面的时间</span></span><br><span class="line">                 , channel      <span class="comment">-- 渠道</span></span><br><span class="line">                ,if(last_page_id <span class="keyword">is</span> <span class="keyword">null</span>, ts, <span class="keyword">null</span>) session_start_point</span><br><span class="line">            <span class="keyword">from</span> dwd_page_log</span><br><span class="line">            <span class="keyword">where</span> dt <span class="operator">=</span> <span class="string">&#x27;2020-06-14&#x27;</span></span><br><span class="line">        ) t1</span><br><span class="line">    ) t2</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> session_id,mid_id,channel</span><br><span class="line">) t3</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> channel</span><br></pre></td></tr></table></figure></li>
<li><p>以此类推，添加其他维度字段，实现，将总的数据进行维度的划分。</p>
</li>
</ol>
</li>
</ol>
<h3 id="同时求-近1天，近7天，-近30天的指标值（通过一个字段的不同取值来区分）"><a href="#同时求-近1天，近7天，-近30天的指标值（通过一个字段的不同取值来区分）" class="headerlink" title="同时求 近1天，近7天， 近30天的指标值（通过一个字段的不同取值来区分）"></a>同时求 近1天，近7天， 近30天的指标值（通过一个字段的不同取值来区分）</h3><p>当我们在一张表中同时求近1天，近7天和近30天的指标累积值时，一般有两种思路：</p>
<ol>
<li><p>先按近1天的逻辑进行分区过滤，计算指标值，然后将相同的逻辑拷贝出3份，每份按照相应的分区进行过滤，包括近1天的分区，近7天的分区，近30天的分组，然后将这三部分的数据最终进行<code>union all</code>操作，即可完成。</p>
<blockquote>
<p>这种方式虽然比较直接，但是同样的逻辑需要复制出3份，当修改逻辑代码时，需要同时修改3份代码，容易出错。而且代码不简洁！</p>
</blockquote>
</li>
<li><p>可以通过UDTF函数（一近多出）的方式将基础表中的数据进行扩容，分别生成近1天，近7天和近30天的这3类数据，然后通过对不同类别的数据分别进行统计，完成指标值的计算。</p>
<blockquote>
<p>![未命名文件 (1)](source/大数据学习之路/未命名文件 (1).png)</p>
</blockquote>
</li>
</ol>
<p>样例代码：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    TODO 会话的划分</span></span><br><span class="line"><span class="comment">            每个mid_id 的上一页page_id为null的时候就是每次会话的开始</span></span><br><span class="line"><span class="comment">            会话划分，新增一个字段，表示会话的id ： mid_id  +  会话开始时间</span></span><br><span class="line"><span class="comment">        over() 中 存在order by， 则窗口中的数据行数是  上边界 到 当前行。</span></span><br><span class="line"><span class="comment">        last_value() 接收两个参数：一个是要选择的字段， 另一个参数是一个bool类型的，false：表示不跳过null， true表示跳过空值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;2020-06-14&#x27;</span>                                               dt               <span class="comment">-- 统计日期</span></span><br><span class="line">     , is_new                                                                      <span class="comment">-- 新老标识</span></span><br><span class="line">     , recent_days                                                                 <span class="comment">-- 最近天数</span></span><br><span class="line">     , channel                                                                     <span class="comment">-- 渠道</span></span><br><span class="line">     , <span class="built_in">count</span>(<span class="keyword">distinct</span> mid_id)                                     uv_count         <span class="comment">-- 日活</span></span><br><span class="line">     , <span class="built_in">sum</span>(duration) <span class="operator">/</span> <span class="number">1000</span>                                       duration_sec     <span class="comment">-- 页面停留总时长</span></span><br><span class="line">     , <span class="built_in">avg</span>(duration) <span class="operator">/</span> <span class="number">1000</span>                                       avg_duration_sec <span class="comment">-- 一次会话 页面停留平均时长</span></span><br><span class="line">     , <span class="built_in">sum</span>(page_count)                                            page_count       <span class="comment">-- 页面浏览总数</span></span><br><span class="line">     , <span class="built_in">avg</span>(page_count)                                            avg_page_count   <span class="comment">-- 每次会话，平均页面浏览数</span></span><br><span class="line">     , <span class="built_in">count</span>(<span class="keyword">distinct</span> session_id)                                 sv_count         <span class="comment">-- 会话次数</span></span><br><span class="line">     , <span class="built_in">sum</span>(if(page_count <span class="operator">=</span> <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>))                              bounce_count     <span class="comment">-- 跳出数</span></span><br><span class="line">     , <span class="built_in">sum</span>(if(page_count <span class="operator">=</span> <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> session_id) bounce_rate      <span class="comment">-- 跳出率</span></span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">         <span class="keyword">select</span> session_id <span class="comment">-- 每次会话</span></span><br><span class="line">              , channel</span><br><span class="line">              , recent_days</span><br><span class="line">              , is_new</span><br><span class="line">              , mid_id</span><br><span class="line">              , <span class="built_in">count</span>(page_id)          page_count</span><br><span class="line">              , <span class="built_in">sum</span>(during_time) <span class="operator">/</span> <span class="number">1000</span> duration</span><br><span class="line">         <span class="keyword">from</span> (</span><br><span class="line">                  <span class="keyword">select</span> t1.mid_id    <span class="comment">-- 设备id</span></span><br><span class="line">                       , last_page_id <span class="comment">-- 上一页id</span></span><br><span class="line">                       , page_id      <span class="comment">-- 本页id</span></span><br><span class="line">                       , during_time  <span class="comment">-- 本页面停留时间</span></span><br><span class="line">                       , ts           <span class="comment">-- 跳入当前页面的时间</span></span><br><span class="line">                       , channel</span><br><span class="line">                       , recent_days</span><br><span class="line">                       , if(t0.visit_date_first <span class="operator">&gt;=</span> date_add(<span class="string">&#x27;2020-06-14&#x27;</span>, <span class="operator">-</span>recent_days <span class="operator">+</span> <span class="number">1</span>), <span class="number">1</span>, <span class="number">0</span>)                   is_new</span><br><span class="line">                       , concat(t1.mid_id, <span class="string">&#x27;-&#x27;</span>, <span class="built_in">last_value</span>(session_start_point, <span class="literal">true</span>)</span><br><span class="line">                                                           <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> t1.recent_days,t1.mid_id <span class="keyword">order</span> <span class="keyword">by</span> ts)) session_id</span><br><span class="line">                  <span class="keyword">from</span> (</span><br><span class="line">                           <span class="keyword">select</span> mid_id       <span class="comment">-- 设备id</span></span><br><span class="line">                                , last_page_id <span class="comment">-- 上一页id</span></span><br><span class="line">                                , page_id      <span class="comment">-- 本页id</span></span><br><span class="line">                                , during_time  <span class="comment">-- 本页面停留时间</span></span><br><span class="line">                                , ts           <span class="comment">-- 跳入当前页面的时间</span></span><br><span class="line">                                , channel      <span class="comment">-- 渠道</span></span><br><span class="line">                                , recent_days  <span class="comment">-- 最近天数</span></span><br><span class="line">                                , if(last_page_id <span class="keyword">is</span> <span class="keyword">null</span>, ts, <span class="keyword">null</span>) session_start_point</span><br><span class="line">                           <span class="keyword">from</span> dwd_page_log</span><br><span class="line">                                    <span class="keyword">lateral</span> <span class="keyword">view</span> explode(<span class="keyword">array</span>(<span class="number">1</span>, <span class="number">7</span>, <span class="number">30</span>)) tmp <span class="keyword">as</span> recent_days  <span class="comment">-- 此处 通过UDTF函数将原始数据 扩容为原来的3倍</span></span><br><span class="line">                           <span class="keyword">where</span> dt <span class="operator">&gt;=</span> date_add(<span class="string">&#x27;2020-06-14&#x27;</span>, <span class="operator">-</span>recent_days <span class="operator">+</span> <span class="number">1</span>)</span><br><span class="line">                       ) t1</span><br><span class="line">                           <span class="keyword">left</span> <span class="keyword">join</span></span><br><span class="line">                       (</span><br><span class="line">                           <span class="keyword">select</span> mid_id</span><br><span class="line">                                , visit_date_first</span><br><span class="line">                           <span class="keyword">from</span> dwt_visitor_topic</span><br><span class="line">                           <span class="keyword">where</span> dt <span class="operator">=</span> <span class="string">&#x27;2020-06-14&#x27;</span></span><br><span class="line">                       ) t0</span><br><span class="line">                       <span class="keyword">on</span> t1.mid_id <span class="operator">=</span> t0.mid_id</span><br><span class="line">              ) t2</span><br><span class="line">         <span class="keyword">group</span> <span class="keyword">by</span> session_id, mid_id, channel, is_new, recent_days</span><br><span class="line">     ) t3</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> channel, is_new, recent_days</span><br></pre></td></tr></table></figure>













<h1 id="网络复习"><a href="#网络复习" class="headerlink" title="网络复习"></a>网络复习</h1><h2 id="1-OSI的七层参考模型"><a href="#1-OSI的七层参考模型" class="headerlink" title="1. OSI的七层参考模型"></a>1. OSI的七层参考模型</h2><p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/1439096-20201115232936579-1750711590.png" alt="img"></p>
<table>
<thead>
<tr>
<th>应用层</th>
<th>访问网络服务的接口（DNS）</th>
<th>单位</th>
</tr>
</thead>
<tbody><tr>
<td>表示层</td>
<td>提供数据格式转换服务</td>
<td></td>
</tr>
<tr>
<td>会话层</td>
<td>建立端连接并提供访问验证和会话管理</td>
<td></td>
</tr>
<tr>
<td>传输层</td>
<td>提供应用进程之间的逻辑通信<br />常见：TCP、UDP、进程、端口（socket）</td>
<td>数据段（segment）</td>
</tr>
<tr>
<td>网络层</td>
<td>为数据在节点之间传输创建逻辑链路，并分组转发数据<br />例如：对子网间的数据包进行路由选择<br />常见：路由器、多层交换机、防火墙</td>
<td>分组（数据包）（packet）</td>
</tr>
<tr>
<td>数据链路层</td>
<td>在通信的实体间建立数据链路连接<br />例如：将数据分帧，并处理流控制、物理地址寻址、重发等<br />常见：网卡，网桥，二层交换机等。</td>
<td>帧（frame）</td>
</tr>
<tr>
<td>物理层</td>
<td>为数据端设备提供原始比特流（01）的传输大的通路<br />网络通信的传输介质，由电缆与设备共同构成<br />常见：中继器，集线器，网线等</td>
<td>比特（bit）</td>
</tr>
</tbody></table>
<p>7层参考模型是一个标准，而非实现。</p>
<p><strong>五层参考模型</strong></p>
<p>物理层，数据链路层，网络层，传输层，应用层</p>
<h2 id="2-一次完整的Http请求过程"><a href="#2-一次完整的Http请求过程" class="headerlink" title="2. 一次完整的Http请求过程"></a>2. 一次完整的Http请求过程</h2><p>第一种回答：</p>
<ol>
<li>建立客户机与服务器连接</li>
<li>建立连接后，客户机发送一个请求给服务器</li>
<li>服务器收到请求给予相应信息</li>
<li>客户端浏览器将返回的内容解析并呈现，断开连接。</li>
</ol>
<p>第二种回答：</p>
<ol>
<li>DNS域名解析</li>
<li>发起TCP的3次握手</li>
<li>建立TCP连接后发起http请求</li>
<li>服务器响应http请求，浏览器得到html代码</li>
<li>浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）</li>
<li>浏览器对页面进行渲染呈现给用户</li>
</ol>
<h2 id="3-DNS"><a href="#3-DNS" class="headerlink" title="3. DNS"></a>3. DNS</h2><p>DNS：域名系统，因特网上作为<code>域名</code>和<code>IP地址</code>相互映射的一个分布式数据库,能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p>
<p>通过主机名，最终得到该主机名对应的ip地址的过程叫做域名解析（或主机名解析）</p>
<h3 id="3-1-DNS的工作原理"><a href="#3-1-DNS的工作原理" class="headerlink" title="3.1 DNS的工作原理"></a>3.1 DNS的工作原理</h3><p>将主机域名转换为ip地址，属于应用层协议，使用UDP传输。</p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/70.jpeg" alt="这里写图片描述"></p>
<p>域名到IP地址的解析过程的要点如下：</p>
<ol>
<li>当某一个应用需要把主机名解析为IP地址时，该应用进程就调用解析程序，并称为DNS的一个客户，把待解析的域名放在DNS请求报文中，以<strong>UDP</strong>用户数据报方式发给本地域名服务器。</li>
<li>本地域名服务器在查找域名后，把对应的IP地址放在回答报文中返回。应用程序获得目的主机的IP地址后即可进行通信。</li>
<li>若本地域名服务器不能回答该请求，则此域名服务器就暂时称为DNS的另一个客户，并向其他域名服务器发出查询请求。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/mocas_wang/article/details/109167660">参考文献</a></p>
<ul>
<li>请求一旦发起，若是chrome浏览器，现在浏览器找之前看看有<strong>没有缓存过的域名对应的ip地址</strong>，有的话，直接跳过DNS解析，若是没有，就会找<strong>硬盘的hosts文件</strong>，有的话，直接找到hosts文件里面的ip</li>
<li>如果本地的hosts文件没有得到对应的ip地址，浏览器会发出一个<code>dns请求到本地DNS服务器,本地dns服务器一般都是你的网络接入服务器商提供</code>，比如中国移动、中国电信等。</li>
<li>查询你输入的网址的DNS请求到本地DNS服务器之后，<strong>本地DNS服务器会首先查询它的缓存记录</strong>，如果缓存中由此条记录，就可以直接返回结果，此过程是<strong>递归的方式进行查询</strong>。如果没有，<strong>本地DNS服务器还要向DNS根服务器</strong>进行查询。</li>
<li>本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。</li>
<li>最后，本地DNS服务器向<strong>域名的解析服务器</strong>发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</li>
</ul>
<h2 id="4-Http长连接与短连接"><a href="#4-Http长连接与短连接" class="headerlink" title="4. Http长连接与短连接"></a>4. Http长连接与短连接</h2><ul>
<li>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作（实际上就是TCP），就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</li>
<li>使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这条已经建立的连接。<code>Keep-Alive</code>不会永久保持连接，它有一个保持时间，可以在不同的服务器软件中设置这个时间。实现长连接需要客户端和服务端都支持长连接。</li>
</ul>
<p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p>
<h2 id="5-HTTP请求方法"><a href="#5-HTTP请求方法" class="headerlink" title="5. HTTP请求方法"></a>5. HTTP请求方法</h2><table>
<thead>
<tr>
<th>序 号</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>GET</td>
<td>请求指定的页面信息，并返回实体主体。</td>
</tr>
<tr>
<td>2</td>
<td>HEAD</td>
<td>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td>
</tr>
<tr>
<td>3</td>
<td>POST</td>
<td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。</td>
</tr>
<tr>
<td>4</td>
<td>PUT</td>
<td>从客户端向服务器传送的数据取代指定的文档的内容。</td>
</tr>
<tr>
<td>5</td>
<td>DELETE</td>
<td>请求服务器删除指定的页面。</td>
</tr>
<tr>
<td>6</td>
<td>CONNECT</td>
<td>HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td>
</tr>
<tr>
<td>7</td>
<td>OPTIONS</td>
<td>允许客户端查看服务器的性能。</td>
</tr>
<tr>
<td>8</td>
<td>TRACE</td>
<td>回显服务器收到的请求，主要用于测试或诊断。</td>
</tr>
<tr>
<td>9</td>
<td>PATCH</td>
<td>是对 PUT 方法的补充，用来对已知资源进行局部更新 。</td>
</tr>
</tbody></table>
<h3 id="GET-与-POST的区别？"><a href="#GET-与-POST的区别？" class="headerlink" title="GET 与 POST的区别？"></a>GET 与 POST的区别？</h3><ol>
<li>get把请求的数据放在url上，参数之间以&amp;相连，所以get不太安全；post把数据放在HTTP的包体内（request body）</li>
<li>get提交数据最大是2k（限制实际上取决于浏览器），post理论上没有限制。</li>
<li>GET请求会被浏览器主动缓存，而POST不会，除非手动设置。</li>
</ol>
<h2 id="6-HTTPS和HTTP的区别"><a href="#6-HTTPS和HTTP的区别" class="headerlink" title="6. HTTPS和HTTP的区别"></a>6. HTTPS和HTTP的区别</h2><ol>
<li>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</li>
<li>https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。</li>
<li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443</li>
</ol>
<h2 id="7-什么是RARP？工作原理"><a href="#7-什么是RARP？工作原理" class="headerlink" title="7. 什么是RARP？工作原理"></a>7. 什么是RARP？工作原理</h2><p>概括：反向地址转换协议，网络层协议，<code>RARP</code>与<code>ARP</code>工作方式相反。RARP使只知道自己硬件地址的主机能够知道IP的地址。RARP发出要反向解释的物理地址并希望返回其IP地址，应答包括能够提供所需信息的RARP服务器发出的IP地址。</p>
<p><strong>原理</strong></p>
<ol>
<li>往上上的每台设备都会有一个独一无二的硬件地址，通常是由设备厂商分配的MAC地址。主机从网卡上读取MAC地址，然后在网络上发送一个<code>RARP</code>请求的广播数据包,请求RARP服务器回复该主机的IP地址</li>
<li>RARP服务器收到RARP请求数据包，为其分配IP地址，并将RARP回应发送给主机</li>
<li>PC1收到RARP回应后，就使用得到的IP地址进行通讯。</li>
</ol>
<h2 id="8-什么是ARP？"><a href="#8-什么是ARP？" class="headerlink" title="8. 什么是ARP？"></a>8. 什么是ARP？</h2><p><code>ARP</code>地址解析协议，其基本功能为透过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。它是IPV4中网络层必不可少的协议，不过在IPV6中已不再适用，并被邻居发现协议（NDP）所替代。</p>
<p><strong>工作流程</strong></p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/70.png" alt="这里写图片描述"></p>
<p>假设主机A和B在同一个网段，主机A要向主机B发送信息，具体的地址解析过程如下：<br>(1)  主机A首先查看自己的ARP表，确定其中是否包含有主机B对应的ARP表项。如果找到了对应的MAC地址，则主机A直接利用ARP表中的MAC地址，对IP数据包进行帧封装，并将数据包发送给主机B。</p>
<p>(2) 如果主机A在ARP表中找不到对应的MAC地址，则将缓存该数据报文，然后以广播方式发送一个ARP请求报文。ARP请求报文中的发送端IP地址和发送端MAC地址为主机A的IP地址和MAC地址，目标IP地址和目标MAC地址为主机B的IP地址和全0的MAC地址。由于ARP请求报文以广播方式发送，该网段上的所有主机都可以接收到该请求，但只有被请求的主机（即主机B）会对该请求进行处理。</p>
<p>(3) 主机B比较自己的IP地址和ARP请求报文中的目标IP地址，当两者相同时进行如下处理：将ARP请求报文中的发送端（即主机A）的IP地址和MAC地址存入自己的ARP表中。之后以单播方式发送ARP响应报文给主机A，其中包含了自己的MAC地址。</p>
<p>(4) 主机A收到ARP响应报文后，将主机B的MAC地址加入到自己的ARP表中以用于后续报文的转发，同时将IP数据包进行封装后发送出去。</p>
<h2 id="9-TCP-头部信息"><a href="#9-TCP-头部信息" class="headerlink" title="9. TCP 头部信息"></a>9. TCP 头部信息</h2><p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/20160406120904661.png" alt="这里写图片描述"></p>
<ul>
<li><p><strong>序号</strong>（32bit）：传输方向上字节流的字节编号。初始时序号会被设置一个随机的初始值（ISN），之后每次发送数据时，<code>序号值=ISN+数据在整个字节流中的偏移</code>。</p>
<p>假设A-&gt;B且ISN=1024，第一段数据512字节已经到B，则第二段数据发送时序号为1024+512.用于解决网络包乱序问题。</p>
</li>
<li><p><strong>确认号</strong>（32bit）：接收方对发送方TCP报文段的响应，其值是收到的序号值+1.（ack）</p>
</li>
<li><p><strong>首部长</strong>（4bit）：标识首部有多少个4字节*首部长，最大为15，即60字节。</p>
</li>
<li><p><strong>标志位</strong>（6bit）：</p>
<ul>
<li>URG：标志紧急指针是否有效</li>
<li><strong>ACK</strong>：标志确认号是否有效（确认报文段）。用于解决丢包问题。</li>
<li>PSH：提示接收端立即从缓冲读走数据。</li>
<li>RST：表示要求对方重新建立连接（复位报文段）。</li>
<li><strong>SYN</strong>：表示请求建立一个连接（连接报文段）。</li>
<li><strong>FIN</strong>：表示关闭连接（断开报文段）。</li>
</ul>
</li>
<li><p><strong>窗口</strong>（16bit）：接收窗口。用于告知对方（发送方）本方的缓冲还能接收多少字节数据。用于解决流控。</p>
</li>
<li><p><strong>检验和</strong>（16bit）：接收端用CRC检验整个报文段有无损失。</p>
</li>
</ul>
<p><strong>常见TCP的连接状态有哪些？</strong></p>
<ul>
<li><strong>CLOSED</strong>：初始状态</li>
<li><strong>LISTEN</strong>：服务器处于监听状态。</li>
<li><strong>SYN_SEND</strong>：客户端socket执行connect连接，发送SYN包，进入此状态。</li>
<li><strong>SYN_RECV</strong>：服务端收到SYN包并发送服务端SYN包，进入此状态。</li>
<li><strong>ESTABLISH</strong>：表示连接建立。客户端发送了最后一个ACK包后进入此状态，服务端接收到ACK包后进入此状态。</li>
<li><strong>FIN_WAIT_1</strong>：终止连接的一方（通常是客户机），发送了FIN报文后进入此状态，等待对方FIN。</li>
<li><strong>CLOSE_WAIT</strong>：（假设服务器）接收到客户机FIN包之后等待关闭的阶段。在接收到对方的FIN包之后，自然是需要立即回复ACK包的，表示已经知道断开请求。但是本方是否立即断开连接（发送FIN包）取决于是否还有数据需要发送给客户端，若有，则在发送FIN包之前均为此状态。</li>
<li><strong>FIN_WAIT_2</strong>：此时是半连接状态，即有一方要求关闭连接，等待另一方关闭。客户端接收到服务器的ACK包，但并没有立即接收到服务端的FIN包，进入FIN_WAIT_2状态。</li>
<li><strong>LAST_ACK</strong>：服务端发动最后的FIN包，等待最后的客户端ACK响应，进入此状态。</li>
<li><strong>TIME_WAIT</strong>：客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态。</li>
</ul>
<h2 id="10-TCP-三次握手🤝与四次挥手👋🏻"><a href="#10-TCP-三次握手🤝与四次挥手👋🏻" class="headerlink" title="10. TCP 三次握手🤝与四次挥手👋🏻"></a>10. TCP 三次握手🤝与四次挥手👋🏻</h2><p><strong>三次握手</strong></p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png"></p>
<h2 id="课程沉淀"><a href="#课程沉淀" class="headerlink" title="课程沉淀"></a>课程沉淀</h2><h3 id="1-物理层"><a href="#1-物理层" class="headerlink" title="1. 物理层"></a>1. 物理层</h3><p><strong>物理层的作用：</strong></p>
<ul>
<li>连接不同的物理设备</li>
<li>传输比特流（<strong>比特</strong>是物理层的基本单位）</li>
</ul>
<p><strong>信道</strong></p>
<ul>
<li>单工信道：单向发送</li>
<li>半双工信道：同一时间只能单向发送</li>
<li>全双工信道：同一时间可以双向发送</li>
</ul>
<p><strong>分用-复用技术：</strong></p>
<ul>
<li>频分复用</li>
<li>时分复用</li>
<li>波分复用</li>
<li>码分复用</li>
</ul>
<h3 id="2-数据链路层"><a href="#2-数据链路层" class="headerlink" title="2. 数据链路层"></a>2. 数据链路层</h3><ul>
<li><p>封装成帧</p>
</li>
<li><p>帧：是数据链路层数据的基本单位</p>
</li>
<li><p>透明传输</p>
<ul>
<li>“透明“</li>
<li>控制字符在帧数据中，但是要当做不存在的去处理</li>
<li><code>SOH  --&gt;  EOT --&gt; EOT</code> 通过转义字符转换帧头、帧尾</li>
</ul>
</li>
<li><p>差错监测</p>
<ul>
<li>物理层只管传输比特流，无法控制是否出错</li>
<li>数据链路层负责起”差错监测“的工作</li>
<li><strong>奇偶校验码</strong><ul>
<li>如果出错位置为偶数，那么就无法判断是否出错</li>
</ul>
</li>
<li><strong>CRC</strong><ul>
<li>一种根据传输或保存的数据而<strong>产生固定位数校验码</strong>的方法</li>
<li><strong>检测</strong>数据传输或者保存后可能出现的错误</li>
<li>生成的数字计算出来并且附加到<strong>数据后面</strong></li>
</ul>
</li>
</ul>
<p><strong>CRC计算</strong></p>
</li>
</ul>
<img src="source/2021年8月份秋招复习笔记/image-20210826145958572-16299612004811-16299612155912.png" alt="image-20210826145958572" style="zoom:50%;" />

<p>最高阶是几，就在后面填几个0；</p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210826150352497-16299614343404.png" alt="image-20210826150352497"></p>
<p>模2运算后的余数，添加到原始串的末尾</p>
<p>发送端会计算出上述的位串，发送给接收端，接收端也会做模2运算，来对比最终得到的余数是否为0，来判断信息在传输过程中，是否出错了。</p>
<p><strong>CRC的错误检测能力与位串的阶数r有关</strong></p>
<p>数据链路层只进行数据的检测，不进行纠正。</p>
<img src="source/2021年8月份秋招复习笔记/image-20210826150649365-16299616136935.png" alt="image-20210826150649365" style="zoom:50%;" />

<h3 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3. 网络层"></a>3. 网络层</h3><table>
<thead>
<tr>
<th>应用层</th>
<th>为计算机用户提供接口和服务</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>表示层</td>
<td>数据处理（编码解码、加密解密）</td>
<td></td>
</tr>
<tr>
<td>会话层</td>
<td>管理（建立、维护、重连）通信会话</td>
<td></td>
</tr>
<tr>
<td>传输层</td>
<td>管理端到端的通信连接</td>
<td></td>
</tr>
<tr>
<td>网络层</td>
<td>数据路由（决定数据在网络的路径）</td>
<td></td>
</tr>
<tr>
<td>数据链路层</td>
<td>管理相邻节点之间的数据通信</td>
<td></td>
</tr>
<tr>
<td>物理层</td>
<td>数据通信的光电物理特性</td>
<td></td>
</tr>
</tbody></table>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210826152556164-16299627579376.png" alt="image-20210826152556164"></p>
<h4 id="IP协议详解"><a href="#IP协议详解" class="headerlink" title="IP协议详解"></a>IP协议详解</h4><ul>
<li>Ip协议使得复杂的实际网络变为一个虚拟互连的网络</li>
<li>IP协议使得网络层可以屏蔽底层细节而专注网络层的数据转发</li>
<li><font color=red>IP协议解决了在虚拟网络中数据报传输路径的问题</font></li>
</ul>
<p><strong>IP协议：</strong></p>
<ul>
<li>IP地址长度为32位，常分成4个8位</li>
<li>IP地址常使用点分十进制来表示（0<del>255. 0</del>255. 0<del>255. 0</del>255）</li>
</ul>
<table>
<thead>
<tr>
<th>协议名</th>
<th>字段值</th>
</tr>
</thead>
<tbody><tr>
<td>ICMP</td>
<td>1</td>
</tr>
<tr>
<td>IGMP</td>
<td>2</td>
</tr>
<tr>
<td>IP</td>
<td>4</td>
</tr>
<tr>
<td>TCP</td>
<td>6</td>
</tr>
<tr>
<td>UDP</td>
<td>17</td>
</tr>
<tr>
<td>OSPF</td>
<td>89</td>
</tr>
</tbody></table>
<h4 id="IP协议的转发流程"><a href="#IP协议的转发流程" class="headerlink" title="IP协议的转发流程"></a>IP协议的转发流程</h4><ul>
<li><strong>逐跳</strong>（hop-by-hop）</li>
</ul>
<h5 id="1-路由表简介"><a href="#1-路由表简介" class="headerlink" title="1. 路由表简介"></a>1. 路由表简介</h5><p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210830141834926-16303043159223.png" alt="image-20210830141834926"></p>
<ul>
<li>A通过网卡发出数据帧</li>
<li>数据帧到达路由器，路由器取出前6字节</li>
<li>路由器匹配MAC地址表，找到对应的网络接口</li>
<li>路由器往该网络接口发送数据帧</li>
</ul>
<table>
<thead>
<tr>
<th>目的IP地址</th>
<th>下一跳IP地址</th>
</tr>
</thead>
<tbody><tr>
<td>IP1</td>
<td>IP4</td>
</tr>
<tr>
<td>IP2</td>
<td>IP5</td>
</tr>
<tr>
<td>。。。</td>
<td>。。。</td>
</tr>
</tbody></table>
<h5 id="2-IP协议的转发流程"><a href="#2-IP协议的转发流程" class="headerlink" title="2.IP协议的转发流程"></a>2.IP协议的转发流程</h5><p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210830141932789.png" alt="image-20210830141932789"></p>
<p>​    网络层：</p>
<ul>
<li>A发出目的地为C的IP数据报，<font color=red>查询路由表发现下一跳为E</font></li>
<li>A将数据报发送给E</li>
<li><font color=red>E查询路由表发现下一步跳为F</font>，将数据报发送给F</li>
<li><font color=red>F查询路由表发现目的地C直接连接</font>，将数据报发送给C</li>
</ul>
<p>数据链路层：</p>
<ul>
<li>A发出目的地为C的IP数据报，查询路由表发现下一跳为E</li>
<li>A将IP数据报交给数据链路层，并告知目的MAC地址是E</li>
<li>数据链路层填充源MAC地址和目的MAC地址E</li>
<li>数据链路层通过物理层将数据发送给E</li>
</ul>
<ul>
<li>E的数据链路层接收到数据帧，<font color=red>把帧数据交给网络层</font></li>
<li>E<font color=red>查询路由表，发现下一跳为F</font></li>
<li>E<font color=red>把数据报交给数据链路层，并告知目的MAC地址为F</font></li>
<li>E的数据链路层<font color=red>封装数据帧并发送</font></li>
</ul>
<ul>
<li>F的数据链路层接收到数据帧，把<font color=red>帧数据交给网络层</font></li>
<li>F<font color=red>查询路由表，发现下一跳为C</font></li>
<li>F<font color=red>把数据报交给数据链路层</font>，<font color=red>并告知目的MAC地址为C</font></li>
<li>F的数据链路层<font color=red>封装数据帧并发送</font></li>
</ul>
<p>整个过程中：</p>
<ol>
<li>数据帧每一跳的MAC地址都在变化</li>
<li>IP数据报每一跳的IP地址始终不变</li>
</ol>
<h4 id="ARP协议和RARP协议"><a href="#ARP协议和RARP协议" class="headerlink" title="ARP协议和RARP协议"></a>ARP协议和RARP协议</h4><h5 id="ARP地址解析协议"><a href="#ARP地址解析协议" class="headerlink" title="ARP地址解析协议"></a>ARP地址解析协议</h5><p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210830143707374-16303054283854.png" alt="image-20210830143707374"></p>
<p><strong>ARP缓存表</strong></p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210830143741682-16303054635275.png" alt="image-20210830143741682"></p>
<ul>
<li>ARP缓存表是ARP协议和RARP协议运行的关键</li>
<li>ARP缓存表缓存了IP地址到硬件地址之间的映射关系</li>
<li>ARP缓存表中的记录并不是永久有效的，有一定的期限</li>
</ul>
<img src="source/2021年8月份秋招复习笔记/image-20210830144740667.png" alt="image-20210830144740667" style="zoom:80%;" />



<p>当ARP缓存表中<font color=green>没有对应的IP地址与MAC地址的映射</font>的时候</p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210830144246148.png" alt="image-20210830144246148"></p>
<ul>
<li>E检查MAC地址表，发现没有C的信息</li>
<li>E将广播A的数据包到除A以外的端口</li>
<li>E将收到来自B、C的回应，并将地址记录</li>
</ul>
<h5 id="RARP逆地址解析协议"><a href="#RARP逆地址解析协议" class="headerlink" title="RARP逆地址解析协议"></a>RARP逆地址解析协议</h5><p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210830145003625.png" alt="image-20210830145003625"></p>
<p>将MAC地址转换成IP地址的协议</p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210830141932789.png" alt="image-20210830141932789"></p>
<ul>
<li>A发出目的地为C的IP数据报，<font color=red>查询路由表发现下一跳为E</font></li>
<li>A将IP数据报<font color=red>交给数据链路层(查询ARP缓存表，得到目的MAC地址)，并告知目的MAC地址是E</font></li>
<li>数据链路层<font color=red>填充源MAC地址</font>A和<font color=red>目的MAC地址E</font></li>
<li>数据链路层通过物理层将数据发送给E</li>
</ul>
<ul>
<li>E的数据链路层接收到数据帧，<font color=red>把帧数据交给网络层</font></li>
<li>E<font color=red>查询路由表(RARP 根据MAC地址，查询出IP地址)，发现下一跳为F</font></li>
<li>E<font color=red>把数据报交给数据链路层，并告知目的MAC地址为F</font></li>
<li>E的数据链路层<font color=red>封装数据帧并发送</font></li>
</ul>
<h4 id="IP地址的子网划分"><a href="#IP地址的子网划分" class="headerlink" title="IP地址的子网划分"></a>IP地址的子网划分</h4><h5 id="1-分类的IP地址"><a href="#1-分类的IP地址" class="headerlink" title="1. 分类的IP地址"></a>1. 分类的IP地址</h5><p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210830150452674.png" alt="image-20210830150452674"></p>
<p>IP地址可分为两个部分：<strong>网络号</strong>、<strong>主机号</strong></p>
<p>根据网络与主机号所占位数的不同，可以将IP地址分成：A类地址、B类地址、C类地址三种</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>A类地址</td>
<td>网络号：8位；主机号：24位；首位为0</td>
</tr>
<tr>
<td>B类地址</td>
<td>网络号：16位；主机号：16位；首位为10</td>
</tr>
<tr>
<td>C类地址</td>
<td>网络号：24位；主机号：8位；首位为110</td>
</tr>
</tbody></table>
<img src="source/2021年8月份秋招复习笔记/image-20210830150719139.png" alt="image-20210830150719139" style="zoom:80%;" />



<table>
<thead>
<tr>
<th></th>
<th>最小网络号</th>
<th>最大网络号</th>
<th>子网数</th>
<th>最小主机号</th>
<th>最大主机号</th>
<th>主机数量</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>0<br />(0000 0000)</td>
<td>127<br />(0111 1111)</td>
<td>2^7</td>
<td>0.0.0</td>
<td>255.255.255</td>
<td>2^24</td>
</tr>
<tr>
<td>B</td>
<td>128.0<br />(1000 0000.|<br />0000 0000)</td>
<td>191.255<br />(1011 1111.<br />1111 1111)</td>
<td>2^14</td>
<td>0.0<br /></td>
<td>255.255</td>
<td>2^16</td>
</tr>
<tr>
<td>C</td>
<td>192.0.0<br />(1100 0000.<br />0000 0000<br />)</td>
<td>223.255.255</td>
<td>2^21</td>
<td>0</td>
<td>255</td>
<td>2^8</td>
</tr>
</tbody></table>
<h6 id="特殊的主机号"><a href="#特殊的主机号" class="headerlink" title="特殊的主机号"></a>特殊的主机号</h6><ul>
<li>主机号全0表示当前网络段，不可分配为特定主机</li>
<li>主机号为全1表示<strong>广播地址</strong>，向当前网络段所有主机发送消息</li>
</ul>
<blockquote>
<p>举个例子：</p>
<p>1.2.3.4：A类地址</p>
<p>1.0.0.0：网络段</p>
<p>1.255.255.255：广播地址</p>
</blockquote>
<p>特殊地址不能被分配给主机的。</p>
<h6 id="特殊的网络号"><a href="#特殊的网络号" class="headerlink" title="特殊的网络号"></a>特殊的网络号</h6><ul>
<li><p>A类地址<font color=red>网络段全0（0000 0000） 表示特殊网络</font></p>
</li>
<li><p>A类地址<font color=red>网络段后7位全1（0111 1111:127）表示回环地址</font></p>
</li>
<li><p>B类地址<font color=red>网络段（1000 0000.0000 0000：:128.0）是不可使用的</font></p>
</li>
<li><p>C类地址<font color=red>网络段（192.0.0）</font>是不可使用的</p>
</li>
</ul>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210830153927092.png" alt="image-20210830153927092"></p>
<p>如何判断一个IP地址是哪一类的IP地址呢？</p>
<blockquote>
<p>将网络号的前8位取出来，转化成二进制，通过判断前3个二进制位，来判断</p>
<p>0：A类</p>
<p>10：B类</p>
<p>110：C类</p>
</blockquote>
<h5 id="2-划分子网"><a href="#2-划分子网" class="headerlink" title="2. 划分子网"></a>2. 划分子网</h5><h5 id="3-无分类编址CIDR"><a href="#3-无分类编址CIDR" class="headerlink" title="3. 无分类编址CIDR"></a>3. 无分类编址CIDR</h5><h1 id="操作系统复习"><a href="#操作系统复习" class="headerlink" title="操作系统复习"></a>操作系统复习</h1><h1 id="Redis复习"><a href="#Redis复习" class="headerlink" title="Redis复习"></a>Redis复习</h1><h2 id="1-常用数据类型"><a href="#1-常用数据类型" class="headerlink" title="1.  常用数据类型"></a>1.  常用数据类型</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set key value</span><br><span class="line">get key</span><br><span class="line"></span><br><span class="line">setnx key  value  # 当key不存在的时候，才创建此key的数据</span><br></pre></td></tr></table></figure>

<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lpush：相当于从左侧压栈，rpush相当于从右侧压栈</span><br><span class="line">lrange：相当于从左侧开始读元素。没有rrange</span><br><span class="line"></span><br><span class="line">lpop：从list左侧移除第一个元素；rpop从右侧移除第一个元素</span><br><span class="line"></span><br><span class="line">lindex list 1：获取list从左侧开始的索引为1的值</span><br><span class="line"></span><br><span class="line">llen list：获取list长度</span><br><span class="line">lrem list count（1,2，3.） value：从list移除指定的值，如果有重复数据，可以指定移除的个数 。精确匹配</span><br></pre></td></tr></table></figure>



<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sadd myset &quot;hello&quot;</span><br><span class="line">smembers myset</span><br><span class="line">sismember myset &quot;hashdf&quot;</span><br><span class="line">srem myset &quot;hello&quot; # 移除集合中指定的元素</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hset myhash name ha # 创建hash myhash 并指定field： name    value：ha</span><br><span class="line">hget myhash name</span><br></pre></td></tr></table></figure>

<h3 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h3><p>有序集合</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd salary 2500 xiaohong 5000 zhangsan 500 xiaozhang # 有序集合添加元素，需要指定每个元素的权重</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE salary 0 -1 withscores # 查看元素，可以指定查询结果是否带权重</span><br></pre></td></tr></table></figure>

<h3 id="BitMap位图"><a href="#BitMap位图" class="headerlink" title="BitMap位图"></a>BitMap位图</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">使用bitmap来记录 周一至周日的打卡</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">周一：1 周二：0 周三：0 周四：1…………</span></span><br><span class="line">127.0.0.1:6379&gt; setbit sign 0 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 1 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 2 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 3 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 4 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 5 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 6 0</span><br><span class="line">(integer) 0</span><br><span class="line">====================</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 3 # 查看周四是否打卡</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash"><span class="comment">####################</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">统计 打卡的天数</span></span><br><span class="line">127.0.0.1:6379&gt; bitcount sign 0 6 #统计周一至周日的打开天数</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>



<h2 id="2-Redis持久化"><a href="#2-Redis持久化" class="headerlink" title="2. Redis持久化"></a>2. Redis持久化</h2><p>Redis是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以Redis提供了持久化功能！</p>
<h3 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h3><p>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时将快照文件直接读到内存里。</p>
<p>Redis会单独创建（<code>fork</code>）一个进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模的数据恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加高效。<code>RDB的缺点是最后一次持久化后的数据可能会丢失</code>。<strong>RDB保存的文件是<code>dump.rdb</code></strong></p>
<p><strong>优点：</strong></p>
<ol>
<li>适合大规模的数据恢复</li>
<li>对数据的完整性和一致性要求不高</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>在一定时间间隔做一次备份，所以如果redis意外宕机的话，就会丢失最后一次快照的所有修改</li>
<li>fork的时候，内存中的数据被克隆了一份，大致2倍的内存膨胀。</li>
</ol>
<p><strong>RDB持久化触发规则</strong></p>
<ol>
<li>一分钟内改了1万次</li>
<li>5分钟内改了10次</li>
<li>15分钟内改了1次</li>
</ol>
<h3 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h3><p>AOF是以日志的形式来记录每个写操作，将redis执行过的所有写指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写执行从前到后执行一遍，以完成数据的恢复工作。</p>
<p>AOF保存的是<code>appendonly.aof</code></p>
<p><strong>注意：</strong></p>
<p><code>appendonly.aof</code>与<code>dump.rdb</code>两者是可以共存的，但是，当redis启动的时候，会先加载aof文件恢复数据。</p>
<p><strong>Appendfsync：数据同步策略</strong></p>
<ol>
<li>Always：同步持久化 每次发生数据变更会被立即记录到磁盘， 这种同步方式性能较差但数据完整性比较好</li>
<li>Everysec： 出厂默认推荐， 异步操作，每秒记录 如果一秒内宕机，有数据丢失</li>
<li>No：不进行数据同步</li>
</ol>
<p><strong>AOF优势</strong></p>
<ul>
<li>每修改同步：appendfsync always 同步持久化，每次发生数据变更会被立即记录到磁盘，性能较差但是数据完整性比较高</li>
<li>每秒同步： appendfsync everysec 异步操作，每秒记录 ，如果一秒内宕机，有数据丢失</li>
<li>不同步：appendfsync no 从不同步</li>
</ul>
<p><strong>劣势</strong></p>
<ul>
<li>对于相同数据集的数据而言，aof文件要远大于rdb文件，恢复速度慢于rdb</li>
<li>AOF运行效率要慢于rdb，每秒同步策略效率较好，不同步效率和rdb相同</li>
</ul>
<h2 id="3-哨兵Sentine模式（反客为主的自动版）"><a href="#3-哨兵Sentine模式（反客为主的自动版）" class="headerlink" title="3. 哨兵Sentine模式（反客为主的自动版）"></a>3. 哨兵Sentine模式（反客为主的自动版）</h2><p>主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费时费力，还会造成一段时间内服务不可用。Redis2.8开始正式提供了 <strong>Sentinel</strong>（哨兵）架构来解决这个问题</p>
<p>哨兵模式下，能后后台监视主机是否宕机故障，如果故障了根据投票数自动将从库切换成主库。</p>
<p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，他会独立的运行。<strong>其原理是：哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</strong></p>
<img src="source/2021年8月份秋招复习笔记/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Mjc2ODM1,size_16,color_FFFFFF,t_70#pic_center-16289931893091" alt="在这里插入图片描述" style="zoom:50%;" />

<p><strong>哨兵的两个作用</strong></p>
<ul>
<li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器</li>
<li>当哨兵检测到master宕机，会自动将slave切换到master，然后通过<strong>发布订阅模式</strong>通知其他的从服务器，修改配置文件，让他们切换主机</li>
</ul>
<p>然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</p>
<img src="source/2021年8月份秋招复习笔记/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Mjc2ODM1,size_16,color_FFFFFF,t_70#pic_center-16289933054913" alt="在这里插入图片描述" style="zoom:50%;" />



<h2 id="4-Redis-中-Key的过期淘汰机制"><a href="#4-Redis-中-Key的过期淘汰机制" class="headerlink" title="4. Redis 中 Key的过期淘汰机制"></a>4. Redis 中 Key的过期淘汰机制</h2><h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h3><p>Redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除</p>
<p>为什么是随机而不是检查所有key？因为如果你设置的key成千上万，没100ms豆浆所有存在的key检查一遍，会给cpu带来较大的压力。</p>
<h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><p>定期删除由于是随机抽取可能会导致很多过期key到了过期时间并没有被删除。</p>
<p>所以用户在从缓存获取数据的时候，redis会检查这个key是否过期了，如果过期就删除这个key，这时候就会将过期key从缓存中清除</p>
<h2 id="5-内存淘汰机制"><a href="#5-内存淘汰机制" class="headerlink" title="5. 内存淘汰机制"></a>5. 内存淘汰机制</h2><p>如果仅仅使用**<code>定期删除+惰性删除</code>**机制还是会留下一个严重的隐患：如果定期删除保留下了很多已经过期的key，而且用户长时间都没有使用过这些过期key，就会导致过期的key无法被<code>惰性删除</code>，从而导致过期的key一直堆积在内存中，最终造成Redis内存块被消耗殆尽。</p>
<p>Redis的<strong>内存淘汰机制</strong>应运而生</p>
<h3 id="8种内存淘汰机制"><a href="#8种内存淘汰机制" class="headerlink" title="8种内存淘汰机制"></a>8种内存淘汰机制</h3><ol>
<li><code>noeviction</code><ul>
<li>不驱逐任何key</li>
</ul>
</li>
<li><code>allkeys-lru</code><ul>
<li>对所有key使用LRU算法进行删除（<strong>默认</strong>）</li>
</ul>
</li>
<li><code>volatile-lru</code><ul>
<li>对所有设置了过期时间的key使用lru算法进行删除</li>
</ul>
</li>
<li><code>allkeys-random</code><ul>
<li>对所有key随机删除</li>
</ul>
</li>
<li><code>volatile-random</code><ul>
<li>对所有设置了过期时间的key随机删除</li>
</ul>
</li>
<li><code>volatile-ttl</code><ul>
<li>删除马上要过期的key</li>
</ul>
</li>
<li><code>allkeys-lfu</code><ul>
<li>对所有key使用LFU算法进行删除</li>
</ul>
</li>
<li><code>volatile-lfu</code><ul>
<li>对所有设置了过期时间的key使用LFU算法进行删除</li>
</ul>
</li>
</ol>
<h1 id="Git复习"><a href="#Git复习" class="headerlink" title="Git复习"></a>Git复习</h1><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h1 id="Docker复习"><a href="#Docker复习" class="headerlink" title="Docker复习"></a>Docker复习</h1><h1 id="经典算法复习"><a href="#经典算法复习" class="headerlink" title="经典算法复习"></a>经典算法复习</h1><h2 id="1-经典排序及部分优化"><a href="#1-经典排序及部分优化" class="headerlink" title="1. 经典排序及部分优化"></a>1. 经典排序及部分优化</h2><h3 id="1-Bubble-Sort"><a href="#1-Bubble-Sort" class="headerlink" title="1. Bubble Sort"></a>1. Bubble Sort</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] bubbleSort(<span class="type">int</span>[] array)&#123;</span><br><span class="line">	<span class="keyword">if</span>(array.length == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> array;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;array.length-<span class="number">1</span>;i++)&#123;		<span class="comment">//比较a.length-1轮即可，比较一轮找到一个</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;array.length-<span class="number">1</span>-i;j++)&#123;		<span class="comment">//无序区间[0,a.length-1-i)</span></span><br><span class="line">			<span class="keyword">if</span>(array[j+<span class="number">1</span>]&lt;array[j])&#123;</span><br><span class="line">				<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[j+<span class="number">1</span>];</span><br><span class="line">				array[j+<span class="number">1</span>] = array[j];</span><br><span class="line">				array[j] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优化</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 冒泡排序</span></span><br><span class="line"><span class="comment">   *  优化点： 如果一趟排序中没有任何一对元素交换位置，那么整个序列已经是有序的，就不需要再进行排序了</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] array)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array == <span class="literal">null</span> || array.length==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> flag;</span><br><span class="line">    <span class="type">int</span> <span class="variable">changeIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lastChangeIndex</span> <span class="operator">=</span> array.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;array.length;i++)&#123;</span><br><span class="line">      flag = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;lastChangeIndex-<span class="number">1</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[j]&gt;array[j+<span class="number">1</span>])&#123;</span><br><span class="line">          flag = <span class="literal">false</span>;  <span class="comment">// 优化点：如果当前排序趟中并没有两个元素的交换，那么说明整个序列已经有序了，无需再进行比较了</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[j+<span class="number">1</span>];</span><br><span class="line">          array[j+<span class="number">1</span>] =  array[j];</span><br><span class="line">          array[j] = temp;</span><br><span class="line">          changeIndex = j; <span class="comment">// 记录每次交换的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      lastChangeIndex = changeIndex; <span class="comment">// 记录最后一次交换的位置</span></span><br><span class="line">      <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//        break;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h3 id="2-Selection-Sort"><a href="#2-Selection-Sort" class="headerlink" title="2. Selection Sort"></a>2. Selection Sort</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>优化</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同时确定 最大值和最小值这两个位置上的数</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="3-Insertion-Sort"><a href="#3-Insertion-Sort" class="headerlink" title="3. Insertion Sort"></a>3. Insertion Sort</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基础版</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">  <span class="type">int</span> current;</span><br><span class="line">  <span class="type">int</span> preIndex;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">    current = nums[i+<span class="number">1</span>];</span><br><span class="line">    preIndex=i;</span><br><span class="line">    <span class="keyword">while</span> (preIndex&gt;=<span class="number">0</span>&amp;&amp;current&lt;nums[preIndex])&#123;</span><br><span class="line">      <span class="comment">//TODO 一次向前插入比较，如果当前元素小于前面的元素，那么就将前面的元素移动到后边</span></span><br><span class="line">      nums[preIndex+<span class="number">1</span>] = nums[preIndex];</span><br><span class="line">      preIndex--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO 最后一次将当前插入元素赋值到最终的位置</span></span><br><span class="line">    nums[preIndex+<span class="number">1</span>]=current;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>优化</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 优化版: 折半插入排序</span></span><br><span class="line"><span class="comment">  *  当代插入元素往前插入的时候，没有必要一个一个进行比较，可以通过折半查找（二分查找）的方式进行定位</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort2</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">  <span class="type">int</span> current;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> i-<span class="number">1</span>;</span><br><span class="line">    current = nums[i];</span><br><span class="line">    <span class="comment">// TODO 折半查找寻找待插入的最终位置</span></span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> low + (high-low)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span>(nums[mid]&gt;current)&#123;</span><br><span class="line">        high = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        low = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO 将hight前面的数据往后移动一位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i-<span class="number">1</span>;j&gt;high;j--)&#123;</span><br><span class="line">      nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[high+<span class="number">1</span>] = current; <span class="comment">//TODO 最终将待插入元素插入到指定位置</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-Quick-Sort"><a href="#4-Quick-Sort" class="headerlink" title="4. Quick Sort"></a>4. Quick Sort</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        sort(nums, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (low &gt; high) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> low;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> high;</span><br><span class="line">        <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> nums[left];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">//TODO 先从后往前找比基准小的数</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] &gt;= base) &#123; <span class="comment">// 等于的时候也需要考虑</span></span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[left] = nums[right]; <span class="comment">// 移动到前半部分</span></span><br><span class="line">            <span class="comment">//TODO 在从前往后找比基准大的数</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] &lt;= base) &#123; <span class="comment">// 等于的时候也需要考虑</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[right] = nums[left]; <span class="comment">// 移动到后半部分</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            nums[left] = base; <span class="comment">// 当 left==right 时，将基准填写到此处</span></span><br><span class="line">            sort(nums, low, left - <span class="number">1</span>);    <span class="comment">// 继续排序前半部分</span></span><br><span class="line">            sort(nums, left + <span class="number">1</span>, high);   <span class="comment">//  继续排序后半部分</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        sort(array);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : array) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-HeapSort"><a href="#5-HeapSort" class="headerlink" title="5. HeapSort"></a>5. HeapSort</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大顶堆类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Heap</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Heap</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        array = arr;</span><br><span class="line">        size = arr.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildHeap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="built_in">this</span>.size / <span class="number">2</span> - <span class="number">1</span>;  <span class="comment">// 最后一个非叶子节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">            adjHeap(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">adjHeap</span><span class="params">(<span class="type">int</span> rootIndex)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftIndex</span> <span class="operator">=</span> <span class="number">2</span> * rootIndex + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightIndex</span> <span class="operator">=</span> <span class="number">2</span> * rootIndex + <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> rootIndex;</span><br><span class="line">        <span class="comment">//TODO 找出 根元素，左子树元素， 右子树元素三者的最大的值的那个索引</span></span><br><span class="line">        <span class="keyword">if</span> (leftIndex &lt; <span class="built_in">this</span>.size &amp;&amp; array[leftIndex] &gt; array[maxIndex]) &#123;</span><br><span class="line">            maxIndex = leftIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightIndex &lt; <span class="built_in">this</span>.size &amp;&amp; array[rightIndex] &gt; array[maxIndex]) &#123;</span><br><span class="line">            maxIndex = rightIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxIndex != rootIndex) &#123;</span><br><span class="line">            <span class="comment">//交换两个节点的值</span></span><br><span class="line">            swap(maxIndex, rootIndex);</span><br><span class="line">            <span class="comment">//TODO 继续调整交换完数据的子树</span></span><br><span class="line">            adjHeap(maxIndex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 先构建堆</span></span><br><span class="line">            buildHeap();</span><br><span class="line">            <span class="comment">// 交换堆顶元素</span></span><br><span class="line">            swap(<span class="number">0</span>, size-<span class="number">1</span>);</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">Heap</span> <span class="variable">heap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Heap</span>(nums);</span><br><span class="line">        heap.sort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : array) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6. 归并排序"></a>6. 归并排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[array.length];</span><br><span class="line">        mergeSort(array, <span class="number">0</span>, array.length - <span class="number">1</span>, temp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : array) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归并排序主要有两个重要的步骤：分+合</span></span><br><span class="line"><span class="comment">     * 分：即将数组分为一块块更小的数组，直至之后一个元素</span></span><br><span class="line"><span class="comment">     * 合：进行将两个小分区的数据进行合并排序</span></span><br><span class="line"><span class="comment">     * 整个过程中，将排序的数据存放到一个临时数组中temp。</span></span><br><span class="line"><span class="comment">     * 最终将temp数组中的数据赋值到原始数组中。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="comment">// 当left小于right的时候，进行分+合</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 分</span></span><br><span class="line">            <span class="comment">// 分左</span></span><br><span class="line">            mergeSort(array, left, mid, temp);</span><br><span class="line">            <span class="comment">// 分右</span></span><br><span class="line">            mergeSort(array, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">            <span class="comment">// 合</span></span><br><span class="line">            merge(array, left, mid, right, temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 判断条件：左侧索引不要超过mid；右侧索引不要超过右边界</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 将数据顺序的传入到temp数组中</span></span><br><span class="line">            <span class="keyword">if</span> (array[i] &lt;= array[j]) &#123;</span><br><span class="line">                temp[t] = array[i];</span><br><span class="line">                t += <span class="number">1</span>;</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[t] = array[j];</span><br><span class="line">                t += <span class="number">1</span>;</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上述循环执行完成后，有可能会存在一个区间中的数据还有剩余数据</span></span><br><span class="line">        <span class="comment">// 处理区间剩余元素（因为会存在一个区间还有剩余数据）</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            temp[t] = array[i];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">            temp[t] = array[j];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            j += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上述循环处理完成后，temp数组中的数据即为合并完之后的有序的数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftTemp</span> <span class="operator">=</span> left;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* 限定当前区间的右边界 */</span></span><br><span class="line">        <span class="keyword">while</span> (leftTemp &lt;= right) &#123;</span><br><span class="line">            array[leftTemp++] = temp[t++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-ShellSort"><a href="#7-ShellSort" class="headerlink" title="7. ShellSort"></a>7. ShellSort</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">//TODO gap 递减</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> gap=size/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap /= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//TODO 根据gap确定每组中的后边的元素，然后根据此元素-gap，就可以得到前面的数</span></span><br><span class="line">            <span class="comment">//TODO i:代表即将插入的元素角标，作为每一组比较数据的最后一个元素角标</span></span><br><span class="line">            <span class="comment">//TODO j:代表与i同一组的数组元素角标</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=gap;i&lt;size;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=i; j-gap&gt;=<span class="number">0</span>&amp;&amp;nums[j-gap]&gt;nums[j]; j -= gap)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[j];</span><br><span class="line">                    nums[j] = nums[j-gap];</span><br><span class="line">                    nums[j-gap] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="2-分布式算法"><a href="#2-分布式算法" class="headerlink" title="2. 分布式算法"></a>2. 分布式算法</h2><h3 id="1-分布式id生成算法（雪花算法）"><a href="#1-分布式id生成算法（雪花算法）" class="headerlink" title="1. 分布式id生成算法（雪花算法）"></a>1. 分布式id生成算法（雪花算法）</h3><h4 id="SnowFlake"><a href="#SnowFlake" class="headerlink" title="SnowFlake"></a><strong>SnowFlake</strong></h4><p>其核心思想就是：使用一个64bit的long型的数字作为全局唯一id。这个ID引入了时间戳，基本上保持自增的。</p>
<p><strong>64bit各段所代表的意义</strong></p>
<ol>
<li>第一部分： <strong>1bit</strong><ul>
<li>高位第一位通常为符号位，而生成的ID一般都是正整数的，所以第一位保持为0</li>
</ul>
</li>
<li>第二部分：<strong>41bit</strong><ul>
<li>41bit表示时间戳，单位是毫秒</li>
<li>换算成年就是表示69年的时间</li>
</ul>
</li>
<li>第三部分：<strong>10bit</strong><ul>
<li>5bit：表示机房id</li>
<li>5bit：表示机器id</li>
</ul>
</li>
<li>第四部分：<strong>12bit</strong><ul>
<li>12bit表示序号，也就是某个机房某台机器上在这一毫秒内同时生成的id序号，0000-0000-0000</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdWorker</span> &#123;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//因为二进制里第一个 bit 为如果是 1，那么都是负数，但是我们生成的 id 都是正数，所以第一个 bit 统一都是 0。</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">//机器ID  2进制5位  32位减掉1位 31个</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">long</span> workerId;</span><br><span class="line">	<span class="comment">//机房ID 2进制5位  32位减掉1位 31个</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">long</span> datacenterId;</span><br><span class="line">	<span class="comment">//代表一毫秒内生成的多个id的最新序号  12位 4096 -1 = 4095 个</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">long</span> sequence;</span><br><span class="line">	<span class="comment">//设置一个时间初始值    2^41 - 1   差不多可以用69年</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">long</span> <span class="variable">twepoch</span> <span class="operator">=</span> <span class="number">1585644268888L</span>;</span><br><span class="line">	<span class="comment">//5位的机器id</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">long</span> <span class="variable">workerIdBits</span> <span class="operator">=</span> <span class="number">5L</span>;</span><br><span class="line">	<span class="comment">//5位的机房id</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">long</span> <span class="variable">datacenterIdBits</span> <span class="operator">=</span> <span class="number">5L</span>;</span><br><span class="line">	<span class="comment">//每毫秒内产生的id数 2 的 12次方</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">long</span> <span class="variable">sequenceBits</span> <span class="operator">=</span> <span class="number">12L</span>;</span><br><span class="line">	<span class="comment">// 这个是二进制运算，就是5 bit最多只能有31个数字，也就是说机器id最多只能是32以内</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">long</span> <span class="variable">maxWorkerId</span> <span class="operator">=</span> -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br><span class="line">	<span class="comment">// 这个是一个意思，就是5 bit最多只能有31个数字，机房id最多只能是32以内</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">long</span> <span class="variable">maxDatacenterId</span> <span class="operator">=</span> -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; datacenterIdBits);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">private</span> <span class="type">long</span> <span class="variable">workerIdShift</span> <span class="operator">=</span> sequenceBits; <span class="comment">//12</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">long</span> <span class="variable">datacenterIdShift</span> <span class="operator">=</span> sequenceBits + workerIdBits; <span class="comment">// 12+5=17</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">long</span> <span class="variable">timestampLeftShift</span> <span class="operator">=</span> sequenceBits + workerIdBits + datacenterIdBits; <span class="comment">// 12 + 5 + 5 = 22</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">long</span> <span class="variable">sequenceMask</span> <span class="operator">=</span> -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; sequenceBits);</span><br><span class="line">	<span class="comment">//记录产生时间毫秒数，判断是否是同1毫秒</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">long</span> <span class="variable">lastTimestamp</span> <span class="operator">=</span> -<span class="number">1L</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getWorkerId</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> workerId;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getDatacenterId</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> datacenterId;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTimestamp</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> workerId	机器id</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> datacenterId	数据中心id（机房id）</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> sequence		序列号</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">IdWorker</span><span class="params">(<span class="type">long</span> workerId, <span class="type">long</span> datacenterId, <span class="type">long</span> sequence)</span> &#123;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">// 检查机房id和机器id是否超过31 不能小于0</span></span><br><span class="line">		<span class="keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">					String.format(<span class="string">&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;</span>,maxWorkerId));</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line"> </span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">					String.format(<span class="string">&quot;datacenter Id can&#x27;t be greater than %d or less than 0&quot;</span>,maxDatacenterId));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">this</span>.workerId = workerId;</span><br><span class="line">		<span class="built_in">this</span>.datacenterId = datacenterId;</span><br><span class="line">		<span class="built_in">this</span>.sequence = sequence;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//TODO 这个是核心方法，通过调用nextId()方法，让当前这台机器上的snowflake算法程序生成一个全局唯一的id</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// 这儿就是获取当前时间戳，单位是毫秒</span></span><br><span class="line">		<span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> timeGen();</span><br><span class="line">		<span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line"> </span><br><span class="line">			System.err.printf(</span><br><span class="line">					<span class="string">&quot;clock is moving backwards. Rejecting requests until %d.&quot;</span>, lastTimestamp);</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">					String.format(<span class="string">&quot;Clock moved backwards. Refusing to generate id for %d milliseconds&quot;</span>,</span><br><span class="line">							lastTimestamp - timestamp));</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">// 下面是说假设在同一个毫秒内，又发送了一个请求生成一个id</span></span><br><span class="line">		<span class="comment">// 这个时候就得把seqence序号给递增1，最多就是4096</span></span><br><span class="line">		<span class="keyword">if</span> (lastTimestamp == timestamp) &#123;</span><br><span class="line"> </span><br><span class="line">			<span class="comment">// 这个意思是说一个毫秒内最多只能有4096个数字，无论你传递多少进来，</span></span><br><span class="line">			<span class="comment">//这个位运算保证始终就是在4096这个范围内，避免你自己传递个sequence超过了4096这个范围</span></span><br><span class="line">			sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</span><br><span class="line">			<span class="comment">//当某一毫秒的时间，产生的id数 超过4095，系统会进入等待，直到下一毫秒，系统继续产生ID</span></span><br><span class="line">			<span class="keyword">if</span> (sequence == <span class="number">0</span>) &#123;</span><br><span class="line">				timestamp = tilNextMillis(lastTimestamp);</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 每个时间戳内，序列号都从0开始</span></span><br><span class="line">			sequence = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 这儿记录一下最近一次生成id的时间戳，单位是毫秒</span></span><br><span class="line">		lastTimestamp = timestamp;</span><br><span class="line">		<span class="comment">// 这儿就是最核心的二进制位运算操作，生成一个64bit的id</span></span><br><span class="line">		<span class="comment">// 先将当前时间戳左移，放到41 bit那儿；将机房id左移放到5 bit那儿；将机器id左移放到5 bit那儿；将序号放最后12 bit</span></span><br><span class="line">		<span class="comment">// 最后拼接起来成一个64 bit的二进制数字，转换成10进制就是个long型</span></span><br><span class="line">		<span class="keyword">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) |</span><br><span class="line">				(datacenterId &lt;&lt; datacenterIdShift) |</span><br><span class="line">				(workerId &lt;&lt; workerIdShift) | sequence;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 当某一毫秒的时间，产生的id数 超过4095，系统会进入等待，直到下一毫秒，系统继续产生ID</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> lastTimestamp</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">long</span> <span class="title function_">tilNextMillis</span><span class="params">(<span class="type">long</span> lastTimestamp)</span> &#123;</span><br><span class="line"> </span><br><span class="line">		<span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> timeGen();</span><br><span class="line"> 		<span class="comment">//TODO 知道当前时间戳大于上一次时间戳的时候，退出循环</span></span><br><span class="line">		<span class="keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;</span><br><span class="line">			timestamp = timeGen();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> timestamp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取当前时间戳</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">long</span> <span class="title function_">timeGen</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *  main 测试类</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		System.out.println(<span class="number">1</span>&amp;<span class="number">4596</span>);</span><br><span class="line">		System.out.println(<span class="number">2</span>&amp;<span class="number">4596</span>);</span><br><span class="line">		System.out.println(<span class="number">6</span>&amp;<span class="number">4596</span>);</span><br><span class="line">		System.out.println(<span class="number">6</span>&amp;<span class="number">4596</span>);</span><br><span class="line">		System.out.println(<span class="number">6</span>&amp;<span class="number">4596</span>);</span><br><span class="line">		System.out.println(<span class="number">6</span>&amp;<span class="number">4596</span>);</span><br><span class="line"><span class="comment">//		IdWorker worker = new IdWorker(1,1,1);</span></span><br><span class="line"><span class="comment">//		for (int i = 0; i &lt; 22; i++) &#123;</span></span><br><span class="line"><span class="comment">//			System.out.println(worker.nextId());</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h3 id="2-Flink中的检查点一致性算法"><a href="#2-Flink中的检查点一致性算法" class="headerlink" title="2. Flink中的检查点一致性算法"></a>2. Flink中的检查点一致性算法</h3><p><strong>关键：</strong>检查点<code>barrier</code>对齐，上游所有分区的<code>barrier</code>都被处理完之后，才做<code>checkpoint</code>，保证barrier之前的数据都处理完。</p>
<p>其中有的分区的数据处理的快，barrier处理完成后，还会继续处理接收到数据，这些数据可以被<code>缓存</code>起来，等待所有的barrier对齐之后，把当前的状态保存到<code>状态后端</code>,然后继续下下游传递。</p>
<h3 id="3-分布式一致性算法"><a href="#3-分布式一致性算法" class="headerlink" title="3. 分布式一致性算法"></a>3. 分布式一致性算法</h3><h4 id="CAP理论的定义"><a href="#CAP理论的定义" class="headerlink" title="CAP理论的定义"></a>CAP理论的定义</h4><p>CAP指的是：<strong>Consistency一致性；Availability可用性；Partition tolerance分区容错性</strong>（分区容错性要保证）</p>
<p>CAP理论中，CP与AP二选一</p>
<p>强调的客户端发出请求之后，服务端先去保证一致性还是先返回</p>
<p>Redis是AP架构：客户端发出请求之后，服务端不侧重一致性，而是先返回相应信息</p>
<p>Zookeeper是CP架构：即客户端发出请求之后，服务端需要先保证一致性，（其他节点需要同步，保持一致）才响应客户端；（内部使用的paxos算法，多数派只要同步了，就返回响应）</p>
<p><strong>分布式环境一定要保证一致性</strong></p>
<p>分布式一致性问题解决的一般方案：<font color=red>state machine replication（状态机复制）</font></p>
<p>通俗的说，每个操作都是一条日志其他节点同步到这些日志执行来实现集群一致性的。</p>
<p><strong>弱一致性模型</strong>（其他节点不立即同步后才响应，但是最终会保证一致性的）</p>
<pre><code>- **DNS**
- GOSSIP
</code></pre>
<p><strong>强一致性模型</strong>（先保证其他节点同步）</p>
<ul>
<li><strong>Paxos</strong>（多数派）</li>
<li><strong>Raft（multi paxos）</strong></li>
<li><strong>ZAB（multi paxos）</strong></li>
<li>同步（只要有一个节点没有同步成功，整个集群就会不可用）</li>
</ul>
<img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210817101206793-9166328.png" alt="image-20210817101206793" style="zoom:50%;" />





<h4 id="决策模型"><a href="#决策模型" class="headerlink" title="决策模型"></a>决策模型</h4><p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210817101527618-9166529.png" alt="image-20210817101527618"></p>
<p><strong>Client</strong>：系统外部角色，请求发起者。像民众。</p>
<p><strong>Proposer</strong>：提议一个值，用于投票表决。向议员，替民众提出议案</p>
<p>**Acceptor(Voter)**：对每个提议的值进行投票，并存储接收的值</p>
<p><strong>Learner：</strong>被告知投票的结果，接收达成共识的值，存储保存，不参与投票的过程。像记录员。（做备份）</p>
<h4 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h4><h5 id="Basic-Paxos基本流程"><a href="#Basic-Paxos基本流程" class="headerlink" title="Basic Paxos基本流程"></a>Basic Paxos基本流程</h5><p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210817102317518-9167001.png" alt="image-20210817102317518"></p>
<p><strong>tips：</strong></p>
<ol>
<li>每个提案都会有一个<strong>唯一的id</strong>，而且是<strong>全局自增</strong>的。<ul>
<li>全局自增的目的是保证日志数据的有序性</li>
<li>例如：当前提案id为5，如果来了一个4号的提案，就会认为这个提案是过时的，不会再处理</li>
</ul>
</li>
<li>二阶段提交</li>
</ol>
<p><strong>角色介绍</strong></p>
<p>一阶段：</p>
<ol>
<li><font color=red>Phase 1a：Prepare</font><ul>
<li>proposer提出一个提案，编号为N，此N大于这个proposer之前提出的提案编号。请求Accpetor的quorum（最大的允许数量）接受。</li>
</ul>
</li>
<li><font color=red>Phase 1b：Promise</font><ul>
<li>如果N大于此acceptor之前接收的任何提案编号则接收，否则拒绝</li>
</ul>
</li>
</ol>
<p>二阶段：</p>
<ol start="3">
<li><font color=red>Phase 2a：Accept</font><ul>
<li>如果达到了多数派（多数派都接收到了这个大于之前提案的请求，响应给proposer）,proposer会发出accept请求，此请求包含提案编号<strong>N</strong>，以及<strong>提案内容</strong>。</li>
</ul>
</li>
<li><font color=red>Phase 2b：Accepted</font><ul>
<li>如果此acceptor在此期间没有收到任何编号大于N的提案，则接收此提案的内容，否则忽略。</li>
</ul>
</li>
</ol>
<p><strong>Basic Paxos部分节点失败，但达到quoroms</strong></p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210817155911310-9187152.png" alt="image-20210817155911310"></p>
<p>只要promise过半即可</p>
<p><strong>Basic Paxos Proposer失败</strong></p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210817160123682-9187286.png" alt="image-20210817160123682"></p>
<p>Proposer故障，Proposer可以配置HA，然后客户端需要提出一个新的提案，然后内容是上一次提案的内容，但是提案的ID需要自增。</p>
<p><strong>Basic Paxos<font color=red>活锁问题</font></strong></p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210817160516330-9187518.png" alt="image-20210817160516330"></p>
<p>1号提案提出后，很短的时间内，2号提案又提出，这样会导致先发出的1号的提案不会被Promise</p>
<p>然后1号提案不甘心，有重新提交了一次，此次提案id为3，但是2号提案的id只小于3，2号提案就会被拒绝。</p>
<p>解决活锁的方式：随机增加超时时间，就是一次提案失败之后，可以稍稍等待一段时候之后再去提交。</p>
<p><strong>Basic Paxos模型其他问题</strong>：一次提案，多次RPC请求。</p>
<h5 id="Multi-Paxos"><a href="#Multi-Paxos" class="headerlink" title="Multi Paxos"></a>Multi Paxos</h5><p><code>Multi Paxos</code>是在多个<code>Accpetor</code>中选举出来一个<code>主节点</code>，然后所有的提案都会先经过这个<code>主 Accpetor</code>进行处理后，同步给其他<code>Accpetor</code>。</p>
<p><img src="source/2021%E5%B9%B48%E6%9C%88%E4%BB%BD%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210817162816837-9188898.png" alt="image-20210817162816837"></p>
<h5 id="强一致性算法–Raft"><a href="#强一致性算法–Raft" class="headerlink" title="强一致性算法–Raft"></a>强一致性算法–Raft</h5><p><strong>三个子问题</strong></p>
<ol>
<li><strong>Leader Election</strong>（领导者选举）</li>
<li><strong>Log replication</strong>（日志复制）</li>
<li><strong>Safety</strong>（安全、恢复）</li>
</ol>
<p><strong>重新定义角色（状态）</strong></p>
<ol>
<li><p><strong>Leader</strong>（领导者）</p>
</li>
<li><p><strong>Follower</strong>（跟随者）</p>
</li>
<li><p><strong>Candidate</strong>（参选者）</p>
</li>
</ol>
<p><strong>Raft算法流程动画演示：</strong><a target="_blank" rel="noopener" href="https://raft.github.io/">https://raft.github.io/</a></p>
<p><a target="_blank" rel="noopener" href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></p>
<p>流程说明前提：每个节点都会有一个<font color=green>election timeout</font>,如果时间倒计时达到了这个时间，该节点就会变为Condidate。处于<code>Condidate</code>状态（角色）的节点会给自己投一票，然后给其他节点发送消息，询问是否投自己一票；</p>
<p>如果其他节点收到上述消息，那么<font color=green>election timeout</font>倒计时就会重置，然后会应答给<code>Candidate</code>节点，当<code>Candidate</code>节点收到半数以上的应答就会转换为<code>Leader</code>状态，并向其它节点发送<code>心跳信息</code>，其他节点也要返回应答信息，其他节点只要收到信息就会重置<font color=green>election timeout</font>倒计时。</p>
<p>如果有Leader挂了，那么就重新进行选举。</p>
<p>具体步骤入校</p>
<ol>
<li><p>刚开始的时候，所有节点均处于<code>Follower</code>状态。每个节点都会有一个<code>timeout</code>超时时间，处于<code>Follower</code>状态的节点一旦节点倒计时超过timeout的时候，就会变为Condidate状态，然后向其他节点发送信息，竞选<code>Leader</code>，只要收到过半的应答信息，此节点就会晋胜为<code>Leader</code>。随后<code>Leader</code>节点会不断的向集群中的其他<code>Follower</code>节点发送心跳信息。集群中的每个节点只要收到消息，其本身的超时倒计时都会重置。</p>
</li>
<li><p>当集群中的节点<code>Leader</code>宕机（挂了），那么其他<code>Follower</code>就收不到心跳信息了，所以会重新选取Leader，过程跟第一步是一样的。</p>
<ul>
<li>如果原始<code>Leader</code>恢复之后，就会变成<code>Follower</code>，然后与此时的Follower同步数据，（历史数据也会同步过来）。</li>
</ul>
</li>
<li><p>集群中的请求都是通过<code>Leader</code>来进行处理的。</p>
<ul>
<li>比如客户端想<code>Leader</code>发送一的请求，请求写一条数据，然后<code>Leader</code>会便随着心跳信息转发这个写请求到集群中的其他节点，此时<code>Leader</code>的数据还没有写入到log中，等待集群中其他节点的回应。如果回应数达到了<strong>半数以上</strong>，那么此时<code>Leader</code>才会commit，真正的将数据写入到log中。此时其他的节点还没有同步到Log中。</li>
<li>伴随着下一次的心跳信息的接收，其他节点才会同步数据到log上。</li>
</ul>
</li>
<li><p>Raft会出现脑裂问题：</p>
<ul>
<li><p>当此时的<code>Leader</code>以大部分节点之间的通信被阻断后，其它大部分节点接收不到了<code>Leader</code>的心跳信息，他们之间就会重新进行<code>Leader</code>的竞选，竞选成功后就会出现<code>两个Leader</code>的情况（脑裂问题）</p>
</li>
<li><p><strong>脑裂的解决方案</strong></p>
<ul>
<li><p><font color=red>引入一个新的概念：region leader。region leader是一个逻辑上的概念，任意时刻对于某一个region来说，一定只拥有一个region leader，每个region leader在任期期间之内尝试每隔t时间间隔，在raft group内部更新一下region leader的lease。所有的读写请求都必须通过region leader完成</font></p>
</li>
<li><p>但是指的注意的是，region leader和raft leader可能不是一个节点，当region leader和raft leader不重合的时候，region leader会将请求转发给当前的raft leader，当网络出现分区时，会出现以下情况：</p>
<ol>
<li><strong>region leader落在多数派，老raft leader在多数派这边</strong><ul>
<li>对于第一种情况，<code>region leader</code>的lease不会过期，因为<code>region leader</code>的心跳仍然能更新到多数派的节点上，老的<code>raft leader</code>任然能同步到大多数节点上，少数派这边也不会选举出新的<code>Leader</code>，这种情况下不会出现stale read</li>
</ul>
</li>
<li><strong>region leader落在多数派，老raft leader在少数派这边</strong><ul>
<li>第二种情况，他的<code>raft leader</code>被分到了少数派，多数派这边选举出新的<code>raft leader</code>，如果此时的<code>region leader</code>在多数派。</li>
</ul>
</li>
<li><strong>region leader落在少数派，老raft leader在多数派这边</strong><ul>
<li>第三种情况，<code>region leader</code>落在了少数派这边，老<code>raft leader</code>在多数派这边，这种情况下客户端请求到<code>region leader</code>，它发现无法联系到<code>leader</code>，（因为在少数派这边没有办法选举出新的leader），请求会失败，直到本次<code>region leader</code>的lease过期，同时新的<code>region leader</code>会在多数派那边产生（因为新的region leader 需要尝试走一遍raft流程）。因为老的<code>region leader</code>没办法写入成功，所以也不会出现stale read。但是付出的代价是在<code>region leader lease</code>期间的系统可用性</li>
</ul>
</li>
<li><strong>region leader落在多数派，老raft leader在少数派这边</strong><ul>
<li>第四种情况与第三种情况类似，多数派那边会产生一个新的<code>raft leader</code>和<code>region leader</code></li>
</ul>
</li>
</ol>
<p>总体来说，这种方法牺牲了一定的可用性（在脑裂时部分客户端的可用性）换取了一致性的保证。</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="强一致性算法-ZAB"><a href="#强一致性算法-ZAB" class="headerlink" title="强一致性算法-ZAB"></a>强一致性算法-ZAB</h5><p>原理与Raft基本上相同。</p>
<p>在一些名词叫法上有些区别：如ZAB将某个leader的周期称为<code>epoch</code>，而raft则称之为<code>term</code>。</p>
<p>实现上也有些许不同：如raft的心跳方向是有leader值follower。而ZAB则是相反的。</p>
<p><strong>状态机复制的共识算法</strong></p>
<h1 id="面试中遇到的问题"><a href="#面试中遇到的问题" class="headerlink" title="面试中遇到的问题"></a>面试中遇到的问题</h1><h2 id="1-自己的亮点"><a href="#1-自己的亮点" class="headerlink" title="1. 自己的亮点"></a>1. 自己的亮点</h2><ol>
<li>自主学习能力强，有记笔记，写文档，CSDN博客，刷题的习惯。对于刷题这方面，维护了一个github库。</li>
<li>会不定时的进行阶段性的总结，每做过的一个小任务，做完之后都会复盘，找到其中遇到的问题，下次再遇到如何避免。</li>
<li>对于需求的开发，每次自己都会尝试给自己定一个排期，比如一个需求技术文档产出需要多长时间，任务开发需要多长时间、数据测试上线需要多长时间、看板配置需要多长时间。。。等等。</li>
<li>沟通上，乐于交流，沟通，对于下派不懂的任务我会首先自己去思考怎么去做，会，然后把疑问汇总起来，请教身边的哥哥姐姐。</li>
</ol>
<h2 id="2-面试谈薪资技巧"><a href="#2-面试谈薪资技巧" class="headerlink" title="2. 面试谈薪资技巧"></a>2. 面试谈薪资技巧</h2><h3 id="1-面试官问你的期望薪资要求（期望薪资是多少？）"><a href="#1-面试官问你的期望薪资要求（期望薪资是多少？）" class="headerlink" title="1. 面试官问你的期望薪资要求（期望薪资是多少？）"></a>1. 面试官问你的期望薪资要求（期望薪资是多少？）</h3><p>不要直接报出你的期望薪资，不要直接就报出具体的薪资，把问题抛回去：<strong>咱们公司对我这个岗位的薪资预算大概是多少？</strong></p>
<h3 id="2-我觉得你要的薪酬有点高？？？"><a href="#2-我觉得你要的薪酬有点高？？？" class="headerlink" title="2. 我觉得你要的薪酬有点高？？？"></a>2. 我觉得你要的薪酬有点高？？？</h3><p>这是明显的打压式问题。</p>
<p><font color=red>就今年的行情啊，各家公司都在控制相应岗位的成本，但是我对我自己的能力和贡献值还是有信心的</font></p>
<ol>
<li>一来，我有我所应聘的这个岗位的实习经历，从需求对接，技术评审到任务开发，数据测试，上线，看板配置，以及需求二次迭代，我自己都独自的完成过。</li>
<li>二来，我对Spark SQL任务的有实际的调优经验，而且是独自完成，动手能力我还是很有自信的。</li>
<li>三来，我平常学习工作会有<strong>记笔记</strong>和<strong>复盘</strong>的习惯，github上自己维护了一个<strong>blog</strong>，会定期的去把阶段性的学习成果push到上面，定期总结，回顾，还有重构（不同时期对待一个问题的看法会有所改变）。</li>
<li>最后一点就是沟通方面，不管是与产品进行沟通，还是与身边的哥哥姐姐这些大佬进行沟通，毫无压力。而且酒量也不错，社交这方面也是强项。</li>
</ol>
<h3 id="3-如果HR没有和你谈薪资"><a href="#3-如果HR没有和你谈薪资" class="headerlink" title="3. 如果HR没有和你谈薪资"></a>3. 如果HR没有和你谈薪资</h3><p>不要直接问你能给我多少钱，可以换个方法问：</p>
<p><strong>咱们这公司的薪资结构和绩效是怎么样的？</strong></p>
<h2 id="2-针对于实习项目，业务上缺乏自己独立的思考"><a href="#2-针对于实习项目，业务上缺乏自己独立的思考" class="headerlink" title="2. 针对于实习项目，业务上缺乏自己独立的思考"></a>2. 针对于实习项目，业务上缺乏自己独立的思考</h2><h3 id="2-1-可视化全平台产品运营数据分析"><a href="#2-1-可视化全平台产品运营数据分析" class="headerlink" title="2.1 可视化全平台产品运营数据分析"></a>2.1 可视化全平台产品运营数据分析</h3><p>需求背景：统计各方向运营数据报表的访问信息，看清报表的实际使用情况。</p>
<h4 id="一期需求"><a href="#一期需求" class="headerlink" title="一期需求"></a>一期需求</h4><p>一期需求只做数易可视化平台，乘客方向的运营报表统计。</p>
<p>在这个阶段，我自己有过独自思考的两个点：</p>
<ol>
<li><p><strong>一个是对于可视化平台这块的，在日后的需求迭代中，有没有可能会扩展到其他平台？</strong></p>
<ul>
<li>针对于第一点，我这里独自做了一个集齐某滴内部所有可视化平台的流量数据的统一性建设，将埋点数据进行抽取，隔离出一张可视化全平台的报表流量DWD数据明细层。</li>
<li>每类报表为其分配了特定的id进行区分，report_type</li>
</ul>
</li>
<li><p><strong>第二点是有没有可能会扩展到除了乘客方向的其他业务方向？</strong></p>
<ul>
<li><p>这里需要说明 一点，每个平台配置好的报表会统一的配置到一个叫做某花筒的门户下，但是这个门户下没有相应报表的维度信息</p>
</li>
<li><p>其他方向包括</p>
<blockquote>
<p>某司机；某特惠月；某网开台，某MP，某UT，某拼车，某安全，某决策，某乘客等9个方向</p>
</blockquote>
</li>
<li><p><strong>短期方案</strong>，是每个业务方向的报表维度信息会汇总到2个产品姐姐那边，然后最后会统一的按照我的dim层设计的字段，统一维护到线上的一个文档中，然后每天以全量的方式导入至dim维度层。</p>
</li>
<li><p><strong>长期方案</strong>，产品方与某花筒平台的后台负责方进行报表维度数据的落表，这样就不需要我们手动来维护整个报表</p>
</li>
</ul>
</li>
</ol>
<h4 id="二期需求"><a href="#二期需求" class="headerlink" title="二期需求"></a>二期需求</h4><p>从数易的可视化平台扩展到某易、某表王、某制化这3个可视化平台，业务方向从1个乘客方向，慢慢扩展到了：某司机；某特惠月；某网开台，某MP，某UT，某拼车，某安全，某决策，某乘客等9个业务方向。</p>
<h3 id="2-2-全生态数据增长建设"><a href="#2-2-全生态数据增长建设" class="headerlink" title="2.2 全生态数据增长建设"></a>2.2 全生态数据增长建设</h3><p>需求：<strong>某网约车在微信，支付宝，QQ等生态下均有相应的业务</strong></p>
<p>我主要做的工作是：<strong>对于冒泡，订单的场景归因的建设</strong></p>
<h4 id="一期需求-1"><a href="#一期需求-1" class="headerlink" title="一期需求"></a>一期需求</h4><p>只做<strong>微信</strong>这一个生态的。</p>
<p>场景归因采用<strong>末次归因</strong>的方法：</p>
<ul>
<li>冒泡前的最近一次的场景入口曝光</li>
<li>呼单前的最近一次的场景入口曝光</li>
</ul>
<p>自我思考：</p>
<ul>
<li><strong>日后可不可能会扩展到其他生态</strong>？</li>
<li><strong>采用末次归因，跨天的如何解决</strong>？</li>
</ul>
<p>对于可不可能扩展到其他生态这个问题，我独自设计了一个包括全生态下的小程序的流量数据明细层，然后通过分区字段进行区分。DWD明细层；会给表的说明信息打上生态的标签。</p>
<p>不管是哪个生态的场景归因，都依赖于这个统一的DWD层</p>
<h4 id="二期需求-1"><a href="#二期需求-1" class="headerlink" title="二期需求"></a>二期需求</h4><p>生态从微信，扩展到 支付宝，QQ、银行等生态</p>
<h2 id="3-回答问题逻辑绕，啰嗦"><a href="#3-回答问题逻辑绕，啰嗦" class="headerlink" title="3. 回答问题逻辑绕，啰嗦"></a>3. 回答问题逻辑绕，啰嗦</h2><p>简明扼要的进行回答，总结性的回答。</p>
<h2 id="4-大数据组件了解少"><a href="#4-大数据组件了解少" class="headerlink" title="4. 大数据组件了解少"></a>4. 大数据组件了解少</h2><h2 id="5-为什么要分层"><a href="#5-为什么要分层" class="headerlink" title="5. 为什么要分层"></a>5. 为什么要分层</h2><p>分层的好处</p>
<ol>
<li>隔离原始数据，原始数据中可能会包含大量的敏感数据，类似于：身份证号，手机号，经纬度，</li>
<li>减少重复开发，开发人员也会减少很多不必要的工作量</li>
<li>在一定程度上也会解耦</li>
<li>把复杂问题简单化</li>
</ol>
<h2 id="6-要展现自己的亮点，保持主动性"><a href="#6-要展现自己的亮点，保持主动性" class="headerlink" title="6. 要展现自己的亮点，保持主动性"></a>6. 要展现自己的亮点，保持主动性</h2><ol>
<li>善于沟通</li>
<li>阶段性总结复盘</li>
<li>养成了书写文档的习惯</li>
<li>定期复盘</li>
</ol>
<h2 id="7-自身存在的缺点"><a href="#7-自身存在的缺点" class="headerlink" title="7. 自身存在的缺点"></a>7. 自身存在的缺点</h2><ol>
<li>有时候会比较粗心<ul>
<li>随意会在学习和工作中我会提前列好 to-do list ，以免遗漏任务</li>
<li>会定期进行阶段性的总结和复盘，某个任务中遇到了哪些问题，如何解决的，下次如何避免</li>
</ul>
</li>
<li>记忆力不是很强，东西一学多了，之前的东西就会忘记<ul>
<li>自己搭建博客，定期将阶段性的学习成果push到上面，定期进行过回顾，或者知识梳理，重新编排等</li>
</ul>
</li>
</ol>
<h2 id="8-自身存在的优点"><a href="#8-自身存在的优点" class="headerlink" title="8. 自身存在的优点"></a>8. 自身存在的优点</h2><ol>
<li>乐于沟通，敢于沟通，不管哪个年龄段的人，都能聊到一起去</li>
<li>业务上手能力比较快，热爱大数据这个方向</li>
<li>具有一定的自学能力</li>
<li>坚持一直是我这个人最大的优点</li>
</ol>
<h1 id="归因分析（多渠道归因）"><a href="#归因分析（多渠道归因）" class="headerlink" title="归因分析（多渠道归因）"></a>归因分析（多渠道归因）</h1><h2 id="1-末次归因"><a href="#1-末次归因" class="headerlink" title="1. 末次归因"></a>1. 末次归因</h2><h2 id="2-首次归因"><a href="#2-首次归因" class="headerlink" title="2. 首次归因"></a>2. 首次归因</h2><h2 id="3-位置归因"><a href="#3-位置归因" class="headerlink" title="3.位置归因"></a>3.位置归因</h2><p>首次，末次各占40%；</p>
<p>中间占20%；</p>
<h2 id="4-时间衰减"><a href="#4-时间衰减" class="headerlink" title="4.时间衰减"></a>4.时间衰减</h2><h2 id="5-自定义比重"><a href="#5-自定义比重" class="headerlink" title="5.自定义比重"></a>5.自定义比重</h2><h1 id="-2"><a href="#-2" class="headerlink" title=""></a></h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://xiaowodi.github.io/2022/06/24/Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/24/Spring/" class="post-title-link" itemprop="url">Spring</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-24 08:12:10" itemprop="dateCreated datePublished" datetime="2022-06-24T08:12:10+00:00">2022-06-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h1 id="Spring概述"><a href="#Spring概述" class="headerlink" title="Spring概述"></a>Spring概述</h1><p>Spring是轻量级的开源的J2EE应用程序框架。Spring可以解决企业应用开发的复杂性。</p>
<p>Spring有两个核心部分：IOC和AOP</p>
<p><strong>IOC</strong>：控制反转，把创建对象过程交给Spring进行管理</p>
<p><strong>AOP</strong>：面向切面，不修改原代码进行功能的增强</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>方便解耦，简化开发</li>
<li>AOP编程的支持</li>
<li>方便程序的测试</li>
<li>方便集成各种优秀框架</li>
<li>降低Java EE API的使用难度</li>
<li>Java源码经典学习范例</li>
<li>方便事务的操作</li>
</ol>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><img src="source/Spring/image-20210921155553260-16322109584691.png" alt="image-20210921155553260"></p>
<p><img src="source/Spring/image-20210921155640451-16322110019492.png" alt="image-20210921155640451"></p>
<img src="source/Spring/image-20210921155707674.png" alt="image-20210921155707674" style="zoom:80%;" />

<p><a target="_blank" rel="noopener" href="https://repo.spring.io/ui/native/release">https://repo.spring.io/ui/native/release</a></p>
<p><a target="_blank" rel="noopener" href="https://repo.spring.io/ui/native/release/org/springframework/spring/5.2.6.RELEASE">最终的下载地址：https://repo.spring.io/ui/native/release/org/springframework/spring/5.2.6.RELEASE</a></p>
<p><img src="source/Spring/image-20210921160251342-16322113722623.png" alt="image-20210921160251342"></p>
<h1 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h1><h2 id="IOC底层原理"><a href="#IOC底层原理" class="headerlink" title="IOC底层原理"></a>IOC底层原理</h2><h3 id="1-什么是IOC"><a href="#1-什么是IOC" class="headerlink" title="1. 什么是IOC"></a>1. 什么是IOC</h3><p>IOC：控制反转，是面向对象中的一种设计原则，可以用来降低计算机代码之间的耦合度。其中最常见的方式叫做<strong>依赖注入（DI）</strong>，还有一种方式叫“依赖查找”。通过控制反转，对象在被创建的时候，有一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖注入到对象中。</p>
<p>通俗一点：<strong>把对象创建和对象之间的调用过程，交给Spring进行管理</strong></p>
<p><strong>使用IOC目的</strong>：为了耦合度降低</p>
<h3 id="2-IOC底层原理"><a href="#2-IOC底层原理" class="headerlink" title="2.IOC底层原理"></a>2.IOC底层原理</h3><ol>
<li>XML解析</li>
<li>工厂模式</li>
<li>反射创建对象</li>
</ol>
<h3 id="3-IOC接口"><a href="#3-IOC接口" class="headerlink" title="3. IOC接口"></a>3. IOC接口</h3><ol>
<li><p><font color=red>IOC思想基于IOC容器完成，IOC容器底层就是对象工厂</font></p>
</li>
<li><p><font color=red>Spring提供IOC容器实现两种方式：（两个接口）</font></p>
<ul>
<li><p><strong>BeanFactory</strong></p>
<ul>
<li><p>IOC容器基本实现，是Spring内部的使用接口，一般不提供开发人员使用</p>
</li>
<li><blockquote>
<p>加载配置文件时，不会创建配置文件里面指定的对象；在获取对象（或使用对象）时才创建对象。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>ApplicationContext</strong></p>
<ul>
<li><p>是<strong>BeanFactory</strong>接口的子接口，提供更多更强大的功能，一般有开发人员进行使用</p>
</li>
<li><blockquote>
<p>在加载配置文件时候就会把在配置文件中的对象进行创建。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="4-ApplicationContext接口实现类"><a href="#4-ApplicationContext接口实现类" class="headerlink" title="4. ApplicationContext接口实现类"></a>4. ApplicationContext接口实现类</h3><p><img src="source/Spring/image-20210921220801935-16322332836824.png" alt="image-20210921220801935"></p>
<ul>
<li><strong>FileSystemXmlApplicationContext</strong><ul>
<li>Xml文件实际所在的绝对路径</li>
</ul>
</li>
<li><strong>ClassPathXmlApplicationContext</strong><ul>
<li>Xml文件所在的相对路径位置（相对于scr路径）</li>
</ul>
</li>
</ul>
<h2 id="IOC的Bean管理"><a href="#IOC的Bean管理" class="headerlink" title="IOC的Bean管理"></a>IOC的Bean管理</h2><h3 id="1-什么是Bean管理？"><a href="#1-什么是Bean管理？" class="headerlink" title="1.什么是Bean管理？"></a>1.什么是Bean管理？</h3><p>Bean管理指的是两个操作：<code>Spring创建对象</code>；<code>Spring注入属性</code></p>
<ul>
<li><p>Spring创建对象</p>
</li>
<li><p>Spring注入属性</p>
</li>
</ul>
<h3 id="2-Bean管理操作的两种方式"><a href="#2-Bean管理操作的两种方式" class="headerlink" title="2.Bean管理操作的两种方式"></a>2.Bean管理操作的两种方式</h3><h4 id="IOC操作Bean管理（基于XML）"><a href="#IOC操作Bean管理（基于XML）" class="headerlink" title="IOC操作Bean管理（基于XML）"></a>IOC操作Bean管理（基于XML）</h4><h5 id="1-基于Xml方式创建对象"><a href="#1-基于Xml方式创建对象" class="headerlink" title="1. 基于Xml方式创建对象"></a>1. 基于Xml方式创建对象</h5><p><img src="source/Spring/image-20210921222458472-16322342997055.png" alt="image-20210921222458472"></p>
<p>通过Xml文件中的<code>&lt;bean&gt;&lt;/bean&gt;</code>标签配置类，就可以实现对象的创建</p>
<blockquote>
<p> bean标签中的常用属性：</p>
<ol>
<li>id属性：唯一标识</li>
<li>class属性：类全路径（报名+类）</li>
</ol>
</blockquote>
<p>创建对象时，默认也是执行无参数构造方法完成对象的创建</p>
<h5 id="2-基于Xml方式注入属性"><a href="#2-基于Xml方式注入属性" class="headerlink" title="2. 基于Xml方式注入属性"></a>2. 基于Xml方式注入属性</h5><ol>
<li><p><strong>DI</strong>：依赖注入，就是注入属性</p>
<blockquote>
<p>属性的注入有两种方式：</p>
<ol>
<li><p>使用set方法进行注入</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yulu.demo.Demo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yulu.demo.Beans.Book&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;易筋经&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bauthor&quot;</span> <span class="attr">value</span>=<span class="string">&quot;达摩老祖&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yulu.demo.Beans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String bname;</span><br><span class="line">    <span class="keyword">private</span> String bauthor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBname</span><span class="params">(String bname)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bname = bname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBauthor</span><span class="params">(String bauthor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bauthor = bauthor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bname::&quot;</span>+bname+<span class="string">&quot;\t bauthor::&quot;</span>+bauthor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBook</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 加载spring配置文件</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring-config.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 得到spring配置文件配置的bean对象</span></span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;book&quot;</span>, Book.class);</span><br><span class="line">        System.out.println(book);</span><br><span class="line">        book.printInfo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">com.yulu.demo.Beans.Book@43738a82</span><br><span class="line">bname::易筋经	 bauthor::达摩老祖</span><br></pre></td></tr></table></figure></li>
<li><p>使用有参数构造进行注入</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;order&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.yulu.demo.Beans.Order&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;orderId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;order::1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;orderUser&quot;</span> <span class="attr">value</span>=<span class="string">&quot;yulu&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yulu.demo.Beans;</span><br><span class="line">            </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String orderId;</span><br><span class="line">    <span class="keyword">private</span> String orderUser;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Order</span><span class="params">(String orderId, String orderUser)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.orderId = orderId;</span><br><span class="line">        <span class="built_in">this</span>.orderUser = orderUser;</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;orderId::&quot;</span>+orderId+<span class="string">&quot;\t orderUser::&quot;</span>+orderUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring-config.xml&quot;</span>);</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;order&quot;</span>, Order.class);</span><br><span class="line">        System.out.println(order);</span><br><span class="line">        order.printInfo();</span><br><span class="line">    &#125;</span><br><span class="line">com.yulu.demo.Beans.Order@545997b1</span><br><span class="line">orderId::order::<span class="number">1</span>	 orderUser::yulu</span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
</li>
</ol>
<h4 id="IOC操作Bean管理（基于注解）"><a href="#IOC操作Bean管理（基于注解）" class="headerlink" title="IOC操作Bean管理（基于注解）"></a>IOC操作Bean管理（基于注解）</h4><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h1 id="JDBCTemplate"><a href="#JDBCTemplate" class="headerlink" title="JDBCTemplate"></a>JDBCTemplate</h1><h1 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h1><h1 id="Spring5新特性"><a href="#Spring5新特性" class="headerlink" title="Spring5新特性"></a>Spring5新特性</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://xiaowodi.github.io/2022/06/24/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/24/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-24 08:12:10" itemprop="dateCreated datePublished" datetime="2022-06-24T08:12:10+00:00">2022-06-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Xiaowodi‘s Hexo</a>! </p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://xiaowodi.github.io/2022/06/24/shell%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/24/shell%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Linux 学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-24 08:12:10" itemprop="dateCreated datePublished" datetime="2022-06-24T08:12:10+00:00">2022-06-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h1 id="Shell学习笔记"><a href="#Shell学习笔记" class="headerlink" title="Shell学习笔记"></a>Shell学习笔记</h1><h2 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h2><h3 id="1-标准输入输出"><a href="#1-标准输入输出" class="headerlink" title="1. 标准输入输出"></a>1. 标准输入输出</h3><table>
<thead>
<tr>
<th>设备</th>
<th>设备文件名</th>
<th>文件描述符</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>键盘</td>
<td><code>/dev/stdin</code></td>
<td>0</td>
<td>标准输入</td>
</tr>
<tr>
<td>显示器</td>
<td><code>/dev/sdtout</code></td>
<td>1</td>
<td>标准输出</td>
</tr>
<tr>
<td>显示器</td>
<td><code>/dev/sdterr</code></td>
<td>2</td>
<td>标准错误输出</td>
</tr>
</tbody></table>
<h3 id="2-输出重定向"><a href="#2-输出重定向" class="headerlink" title="2. 输出重定向"></a>2. 输出重定向</h3><table>
<thead>
<tr>
<th>类型</th>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>标准输出重定向</td>
<td>命令 &gt; 文件</td>
<td>以覆盖的方式，把命令的正确输出输出到指定的文件或设备当中</td>
</tr>
<tr>
<td></td>
<td>命令 &gt;&gt; 文件</td>
<td>以追加的方式，把命令的正确输出输出到指定的文件或设备当中</td>
</tr>
<tr>
<td>标准错误输出重定向</td>
<td>错误命令 2&gt; 文件</td>
<td>以覆盖的方式，把命令的错误输出输出到指定的文件或设备当中。</td>
</tr>
<tr>
<td></td>
<td>错误命令 2&gt;&gt; 文件</td>
<td>以追加的方式，把命令的错误输出输出到指定的文件中。</td>
</tr>
<tr>
<td><font color=red>正确输出和错误输出同时保存</font></td>
<td>命令 &gt; 文件 2&gt;&amp;1</td>
<td>以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中</td>
</tr>
<tr>
<td></td>
<td>命令 &gt;&gt; 文件 2&gt;&amp;1</td>
<td>以追加的方式，把正确输出和错误输出都保存到同一个文件当中</td>
</tr>
<tr>
<td></td>
<td>命令 &amp;&gt; 文件</td>
<td>以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中</td>
</tr>
<tr>
<td></td>
<td>命令 &amp;&gt;&gt; 文件</td>
<td>以追加的方式，把正确输出和错误输出都保存到同一个文件中</td>
</tr>
<tr>
<td></td>
<td>命令 &gt;&gt; 文件1 2&gt;&gt; 文件2</td>
<td>把正确的输出追加到文件1中，把错误的输出追加到文件2中</td>
</tr>
</tbody></table>
<p>有一种常用的方式</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &amp;&gt;&gt; /dev/null  #  将命令的正确输出和错误输出都输出到黑洞中</span><br></pre></td></tr></table></figure>





<h3 id="3-输入重定向"><a href="#3-输入重定向" class="headerlink" title="3. 输入重定向"></a>3. 输入重定向</h3><p><code>命令 &lt; 文件</code> 把文件作为命令的输入</p>
<p>例子： wc统计文件中的 行、词、字节</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@kube-master1 Files]$ wc &lt; Demo2.java </span><br><span class="line">  8  20 216</span><br></pre></td></tr></table></figure>



<h2 id="多命令顺序执行与管道符"><a href="#多命令顺序执行与管道符" class="headerlink" title="多命令顺序执行与管道符"></a>多命令顺序执行与管道符</h2><h3 id="命令顺序执行，逻辑与执行，逻辑或执行"><a href="#命令顺序执行，逻辑与执行，逻辑或执行" class="headerlink" title="命令顺序执行，逻辑与执行，逻辑或执行"></a>命令顺序执行，逻辑与执行，逻辑或执行</h3><table>
<thead>
<tr>
<th>多命令执行</th>
<th>格式</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>;</code></td>
<td><code>命令1 ; 命令2</code></td>
<td>多个命令顺序执行，命令之间没有任何逻辑联系</td>
</tr>
<tr>
<td><code>&amp;&amp;</code></td>
<td><code>命令1 &amp;&amp; 命令2</code></td>
<td>逻辑与<br />当命令1正确执行，则命令2才会执行<br />当命令1执行不正确，则命令2不会执行</td>
</tr>
<tr>
<td>`</td>
<td></td>
<td>`</td>
</tr>
</tbody></table>
<p>举例：</p>
<ol>
<li>统计磁盘复制时间</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">dd</span> 命令 复制磁盘</span></span><br><span class="line">dd if=输入文件 of=输出文件 bs=字节数 count=个数</span><br><span class="line">选项：</span><br><span class="line">	if=输入文件		指定源文件或源设备</span><br><span class="line">	of=输出文件		执行目标文件或目标设备</span><br><span class="line">	bs=字节数		 指定一次输入/输出多少字节，即把这些字节看做一个数据块</span><br><span class="line">	count=个数	  指定输入/输出多少个数据块</span><br><span class="line"><span class="meta">root@localhost~]# </span><span class="language-bash"><span class="built_in">date</span>; <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/root/testfile bs=1k count=100000; <span class="built_in">date</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">上述命令可以查看复制磁盘数据所花费的时间</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编译软件(<code>configure</code>完成后才可以<code>make</code>完成后才可以执行<code>make install</code> )</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>例子2：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# 命令 &amp;&amp; echo yes || echo no</span><br><span class="line"><span class="meta"># </span><span class="language-bash">如果 命令执行成功 则输出 <span class="built_in">yes</span> ，如果命令执行失败，则输出 no</span></span><br></pre></td></tr></table></figure>



<h3 id="管道符"><a href="#管道符" class="headerlink" title="管道符"></a>管道符</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@loaclhost ~]# 命令1 | 命令2</span><br><span class="line"><span class="meta"># </span><span class="language-bash">命令1的正确输出作为命令2的操作对象</span></span><br></pre></td></tr></table></figure>



<p><code>grep</code>命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">grep [选项] &quot;搜索内容&quot; 文件</span><br><span class="line">选项：</span><br><span class="line">	-i		忽略大小写</span><br><span class="line">	-n		输出行号</span><br><span class="line">	-v		反向查找（查找处理需要查找关键内容 之外 的 内容）</span><br><span class="line">	--color=auto	搜索出的关键字用颜色显示</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">grep -v &quot;abc&quot; text.java  # 查找除了包含abc之外的内容</span><br></pre></td></tr></table></figure>





<h2 id="通配符和其他特殊符号"><a href="#通配符和其他特殊符号" class="headerlink" title="通配符和其他特殊符号"></a>通配符和其他特殊符号</h2><table>
<thead>
<tr>
<th>通配符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>?</td>
<td>匹配一个任意字符</td>
</tr>
<tr>
<td>*</td>
<td>匹配0个或任意多个任意字符，也就是可以匹配任何内容；例如删除一个文件夹中的所有文件：<code>rm -rf /home/files/*</code></td>
</tr>
<tr>
<td>[]</td>
<td>匹配中括号中的任意一个字符，例如：<code>[abc]</code>代表一定匹配一个字符，要么是<code>a</code>，要么是<code>b</code>，要么是<code>c</code>。</td>
</tr>
<tr>
<td>[-]</td>
<td>匹配中括号中任意一个字符，<code>-</code>代表一个范围，例如<code>[a-z]</code>代表匹配一个a到z的小写字母</td>
</tr>
<tr>
<td>[^]</td>
<td>逻辑非，表示匹配不是中括号内的一个字符</td>
</tr>
</tbody></table>
<p>举几个例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rm -rf *		# 删除所在目录下的所有文件</span><br><span class="line">ls ?abc			# 列出以abc结尾的，名字为4位的所有文件</span><br><span class="line">ls *abc			# 列出以abc结尾的所有文件</span><br><span class="line">ls [0-9]*		# 列出以数字开头的所有文件</span><br><span class="line">ls [^0-9]		# 列出不以数字开头的所有文件</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>特殊符号</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>&#39;&#39;</code></td>
<td>单引号。在单引号中所有的特殊符号，如<code>$</code>和``` `（反引号）都没有特殊含义</td>
</tr>
<tr>
<td><code>&quot;&quot;</code></td>
<td>双引号。在双引号中特殊符号都没有特殊含义，但是<code>$</code>、``` <code>和</code>`是例外，拥有<strong>调用变量的值</strong>、<strong>引用命令</strong>、<strong>转义符</strong>的特殊含义</td>
</tr>
<tr>
<td>``` `</td>
<td>反引号。反引号括起来的内容是系统命令，在Bash中会先执行它。和<code>$()</code>作用一样，不过推荐使用<code>$()</code>，因为反引号非常容易看错</td>
</tr>
<tr>
<td><code>$()</code></td>
<td>和反引号作用一样，用来引用系统命令</td>
</tr>
<tr>
<td><code>#</code></td>
<td>在Shell脚本中，#开头的行代表注释</td>
</tr>
<tr>
<td><code>$</code></td>
<td>用于调用变量的值，如需要调用变量name的值时，需要用<code>$name</code>的方式得到变量的值</td>
</tr>
<tr>
<td><code>\</code></td>
<td>转义符，跟在<code>\</code>之后的特殊符号将失去特殊含义，变为普通字符<br />如<code>\$</code>将输出$符号，而不当做是变量引用。</td>
</tr>
</tbody></table>
<h2 id="Bash变量"><a href="#Bash变量" class="headerlink" title="Bash变量"></a>Bash变量</h2><ul>
<li>在Bash中，变量的<strong>默认</strong>类型都是<strong>字符串</strong>类型，如果要进行数值运算，则必须指定变量类型为<strong>数值型</strong></li>
<li>变量用<code>=</code>连接，等号左右两侧不能有空格</li>
<li>变量的值如果有空格，需要使用单引号<code>``</code>或者<code>&quot;&quot;</code>包括（因为空格在shell中，默认为分割符）</li>
<li>在变量的值中，可以使用<code>\</code>转义符</li>
<li>如果需要增加变量的值，那么可以进行变量值的累加。不过变量需要用<code>&quot;&quot;</code>包含<ul>
<li><code>&quot;$变量名&quot;</code></li>
<li><code>$&#123;变量名&#125;</code></li>
</ul>
</li>
<li>如果把命令的结果作为变量值赋予变量，则需要使用反引号或者<code>$()</code>包含命令</li>
<li>环境变量名建议大写，便于区分</li>
</ul>
<p><strong>变量的分类</strong></p>
<blockquote>
<ul>
<li>用户自定义变量</li>
<li>环境变量：这种变量中主要保存的是和系统操作环境相关的数据</li>
<li>位置参数变量：这种变量主要是用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的。</li>
<li>预定义变量：是Bash中已经定义好的变量，变量名不能自定义，变量作用也是固定的。</li>
</ul>
</blockquote>
<h3 id="用户自定义变量（本地变量）"><a href="#用户自定义变量（本地变量）" class="headerlink" title="用户自定义变量（本地变量）"></a>用户自定义变量（本地变量）</h3><p>用户自定义变量只存在于当前shell中，父Shell和子Shell都访问不到</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">name=$(date)</span><br><span class="line">name2=$&#123;name&#125;abc  # 变量叠加</span><br><span class="line">name3=&quot;$name&quot;abc  # 变量叠加</span><br><span class="line">echo $name2</span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">set</span>命令可以查看所有变量</span></span><br><span class="line">set</span><br><span class="line"><span class="meta"># </span><span class="language-bash">删除变量</span></span><br><span class="line">unset 变量名</span><br></pre></td></tr></table></figure>



<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>用户自定义变量只在当前的Shell中生效，而环境变量会在当前Shell和这个Shell的所有子Shell中生效。如果把环境变量写入相应的配置文件，那么这个环境变量就会在所有的Shell中生效。</p>
<ul>
<li>设置环境变量 <code>export 环境变量名=环境变量值</code></li>
<li>查询环境变量 <code>env</code></li>
<li>删除环境变量 <code>unset</code></li>
</ul>
<p>:bulb:<strong>补充命令</strong></p>
<blockquote>
<p><code>pstree</code>：查看进程树</p>
</blockquote>
<h4 id="系统常见的环境变量"><a href="#系统常见的环境变量" class="headerlink" title="系统常见的环境变量"></a>系统常见的环境变量</h4><ul>
<li><p>PATH：系统查找命令的路径</p>
<ul>
<li><p>PATH用<code>:</code>进行分隔</p>
<ul>
<li><blockquote>
<p>```shell<br>yu@PC:~$ echo $PATH<br>/home/yu/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> - PATH变量叠加</span><br><span class="line"></span><br><span class="line">   - &gt; ```shell</span><br><span class="line">PATH=&quot;$PATH&quot;:/root/sh</span><br><span class="line"></span><br><span class="line">PATH=$&#123;PATH&#125;:/root/sh</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>PS1：定义系统提示符的变量</p>
<ul>
<li><table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>\d</code></td>
<td>显示日期，格式为：“星期  月  日”</td>
</tr>
<tr>
<td><code>\h</code></td>
<td>显示简写主机名。如默认的主机名“localhost”</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>显示24小时制时间，格式为“HH:MM:SS”</td>
</tr>
<tr>
<td><code>\T</code></td>
<td>显示12小时制时间，格式为“HH:MM:SS”</td>
</tr>
<tr>
<td><code>\A</code></td>
<td>显示24小时制时间，格式为“HH:MM”</td>
</tr>
<tr>
<td><code>\u</code></td>
<td>显示当前用户名</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>显示当前所在目录的完整名称</td>
</tr>
<tr>
<td><code>\W</code></td>
<td>显示当前所在目录的最后一个目录</td>
</tr>
<tr>
<td><code>\#</code></td>
<td>执行的第几个命令</td>
</tr>
<tr>
<td><code>\$</code></td>
<td>提示符。如果是root用户会显示提示为”#”，如果是普通用户，会显示提示符为“$”</td>
</tr>
</tbody></table>
</li>
<li><blockquote>
<p>```shell<br>yu@PC:~$ echo $PS1<br>[\e]0;\u@\h: \w\a]${debian_chroot:+($debian_chroot)}\u@\h:\w$</p>
<h1 id="重新设置PS1变量"><a href="#重新设置PS1变量" class="headerlink" title="重新设置PS1变量"></a>重新设置PS1变量</h1><p>yu@PC:~$ PS1=’[\u@\h \t \w]:#$‘<br>[yu@PC 15:53:58 ~]:9$</p>
<h1 id="用户名-主机名-时间-完整目录-执行的第几个命令-提示符"><a href="#用户名-主机名-时间-完整目录-执行的第几个命令-提示符" class="headerlink" title="[用户名@主机名 时间 完整目录]:执行的第几个命令 提示符"></a>[用户名@主机名 时间 完整目录]:执行的第几个命令 提示符</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 位置参数变量</span><br><span class="line"></span><br><span class="line">| 位置参数变量 | 作用                                                         |</span><br><span class="line">| ------------ | ------------------------------------------------------------ |</span><br><span class="line">| `$n`         | n为数字，`$0`代表命令本身（执行的是什么命令，`$0`就是什么），`$1`~`$9`代表第1到第9个参数，十以上的参数需要用大括号包含，如`$&#123;10&#125;` |</span><br><span class="line">| `$*`         | 这个变量代表命令行中所有的参数，`$*`把所有的参数看成一个整体· |</span><br><span class="line">| `$@`         | 这个变量也代表命令行中所有的参数，不过`$@`把每个参数区分对待 |</span><br><span class="line">| `$#`         | 这个变量代表命令行中所有参数的个数                           |</span><br><span class="line"></span><br><span class="line">**求两个数的和**</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">num1=$1</span><br><span class="line">num2=$2</span><br><span class="line"></span><br><span class="line">sum=$(($num1+$num2))</span><br><span class="line">echo -e &quot;\e[1;32m $sum \e[0m&quot;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">yu@PC:~/bin$ cat ./test1.sh </span><br><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo &quot;A total of $# parameters&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;The parameters are : $*&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;The parameters are : $@&quot;</span><br><span class="line">yu@PC:~/bin$ test1.sh 1 2 3 4 5 6</span><br><span class="line">A total of 6 parameters</span><br><span class="line">The parameters are : 1 2 3 4 5 6</span><br><span class="line">The parameters are : 1 2 3 4 5 6</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>$* 与 $@</code>的区别</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for i in &quot;$*&quot;</span><br><span class="line">	do</span><br><span class="line">		echo &quot;The parameter is: $i&quot;</span><br><span class="line">	done</span><br><span class="line">x=1</span><br><span class="line">for y in &quot;$@&quot;</span><br><span class="line">	do</span><br><span class="line">		echo &quot;The parameter$x is : $y&quot;</span><br><span class="line">		x=$(($x + 1))</span><br><span class="line">	done</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><table>
<thead>
<tr>
<th>预定义变量</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>$?</code></td>
<td>最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值非0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了<br />举个具体的例子：<br /><code>命令1&amp;&amp;命令2</code>或者`命令1</td>
</tr>
<tr>
<td><code>$$</code></td>
<td>当前进程的进程号（PID）</td>
</tr>
<tr>
<td><code>$!</code></td>
<td>后台运行的最后一个进程的PID</td>
</tr>
</tbody></table>
<h3 id="接收键盘输入"><a href="#接收键盘输入" class="headerlink" title="接收键盘输入"></a>接收键盘输入</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yu@PC:~$ read [选项] [变量名]</span><br><span class="line">选项：</span><br><span class="line">	-p &quot;提示信息&quot;		在等待read输入时，输出提示信息</span><br><span class="line">	-t 秒数			 read命令会一直等待用户输入，使用此选项可以指定等待时间</span><br><span class="line">	-n 字符数			read命令只要接受指定的字符数，就会执行（不用等待回车）</span><br><span class="line">	-s				  隐藏输入的数据，适用于机密信息的输入</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">yu@PC:~/bin$ cat ./readDemo.sh </span><br><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">提示“请输入姓名”并等待30s，把用户的输入保存在变量name中</span></span><br><span class="line">read -t 30 -p &quot;Please input your name: &quot; name</span><br><span class="line">echo &quot;Name is $name&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">年龄是隐私，所以我们使用 -s 选项来隐藏输入</span></span><br><span class="line">read -s -t 30 -p &quot;Please enter your age&quot; age</span><br><span class="line">echo -e &quot;\n&quot;</span><br><span class="line">echo &quot;Age is $age&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">使用“-n 1”选项只接收输入字符就会执行，（都不用输入回车）</span></span><br><span class="line">read -n 1 -t 30 -p &quot;Please select your gender[M/F]:&quot; gender</span><br><span class="line">echo -e &quot;\n&quot;</span><br><span class="line">echo &quot;Sex is $gender&quot;</span><br><span class="line"></span><br><span class="line">yu@PC:~/bin$ vim readDemo.sh</span><br><span class="line">yu@PC:~/bin$ chmod 755 ./readDemo.sh </span><br><span class="line">yu@PC:~/bin$ readDemo.sh </span><br><span class="line">Please input your name: luyu</span><br><span class="line">Name is luyu</span><br><span class="line">Please enter your age</span><br><span class="line"></span><br><span class="line">Age is 12</span><br><span class="line">Please select your gender[M/F]:M</span><br><span class="line"></span><br><span class="line">Sex is M</span><br></pre></td></tr></table></figure>





<h2 id="数值运算与运算符"><a href="#数值运算与运算符" class="headerlink" title="数值运算与运算符"></a>数值运算与运算符</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">aa=11</span><br><span class="line">bb=22</span><br><span class="line">cc=$aa+$22</span><br><span class="line">echo $cc</span><br><span class="line"></span><br><span class="line">输出： 11+22</span><br><span class="line">原因： shell变量的默认类型全部为 字符串 类型</span><br></pre></td></tr></table></figure>

<h3 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h3><h4 id="declare-声明变量类型"><a href="#declare-声明变量类型" class="headerlink" title="declare 声明变量类型"></a>declare 声明变量类型</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">declare [+/-][选项] 变量名</span><br><span class="line">选项：</span><br><span class="line">	-			给变量设定类型属性</span><br><span class="line">	+			取消变量的类型属性</span><br><span class="line">	-i			将变量声明为正数型（integer）</span><br><span class="line">	-x			将变量声明为环境变量</span><br><span class="line">	-p			显示执行变量的被声明的类型</span><br></pre></td></tr></table></figure>

<h4 id="方法1：declare声明类型"><a href="#方法1：declare声明类型" class="headerlink" title="方法1：declare声明类型"></a>方法1：declare声明类型</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aa=11</span><br><span class="line">bb=22</span><br><span class="line">declare -i cc=$aa+$bb</span><br></pre></td></tr></table></figure>

<h4 id="方法2：expr或let数值运算工具"><a href="#方法2：expr或let数值运算工具" class="headerlink" title="方法2：expr或let数值运算工具"></a>方法2：expr或let数值运算工具</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aa=11</span><br><span class="line">bb=22</span><br><span class="line">dd=$(expr $aa + $bb)  # 注意，这里面加号左右必须有空格</span><br><span class="line">echo $dd</span><br><span class="line">33</span><br></pre></td></tr></table></figure>

<h4 id="方法3：-运算式-或-运算式-推荐"><a href="#方法3：-运算式-或-运算式-推荐" class="headerlink" title="方法3：$((运算式)) 或 $[运算式]   (推荐)"></a>方法3：$((运算式)) 或 $[运算式]   (推荐)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aa=11</span><br><span class="line">bb=22</span><br><span class="line">ff=$(($aa+$bb))</span><br><span class="line">gg=$[$aa+$bb]</span><br></pre></td></tr></table></figure>



<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>13</td>
<td><code>-, +</code></td>
<td>单目负， 单目正</td>
</tr>
<tr>
<td>12</td>
<td><code>!, ~</code></td>
<td>逻辑非，按位取反或补码</td>
</tr>
<tr>
<td>11</td>
<td><code>*, /, %</code></td>
<td>乘、除、取模</td>
</tr>
<tr>
<td>10</td>
<td><code>+, -</code></td>
<td>加、减</td>
</tr>
<tr>
<td>9</td>
<td><code>&lt;&lt; , &gt;&gt;</code></td>
<td>按位左移、按位右移</td>
</tr>
<tr>
<td>8</td>
<td><code>&lt;=, &gt;= &lt; &gt;</code></td>
<td>小于或等于，大于或等于，小于，大于</td>
</tr>
<tr>
<td>7</td>
<td><code>==, !=</code></td>
<td>等于，不等于</td>
</tr>
<tr>
<td>6</td>
<td><code>&amp;</code></td>
<td>按位与</td>
</tr>
<tr>
<td>5</td>
<td><code>^</code></td>
<td>按位异或</td>
</tr>
<tr>
<td>4</td>
<td>`</td>
<td>`</td>
</tr>
<tr>
<td>3</td>
<td><code>&amp;&amp;</code></td>
<td>逻辑与</td>
</tr>
<tr>
<td>2</td>
<td>`</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>`=, +=, -=, *=, /=,%=, &amp;=, ^=,</td>
<td>=, &lt;&lt;=, &gt;&gt;=`</td>
</tr>
</tbody></table>
<h3 id="变量测试-与-内容替换"><a href="#变量测试-与-内容替换" class="headerlink" title="变量测试 与 内容替换"></a>变量测试 与 内容替换</h3><table>
<thead>
<tr>
<th>变量置换方式</th>
<th>变量y没有设置</th>
<th>变量y为空值</th>
<th>变量y设置值</th>
</tr>
</thead>
<tbody><tr>
<td>x=${y-新值}</td>
<td>x= 新值</td>
<td>x 为空（<code>x=&quot;&quot; # &quot;&quot;为空值</code>）</td>
<td>x=$y</td>
</tr>
<tr>
<td>x=${y:-新值}</td>
<td>x= 新值</td>
<td>x= 新值</td>
<td>x=$y</td>
</tr>
<tr>
<td>x=${y+新值}</td>
<td>x 为空</td>
<td>x= 新值</td>
<td>x=新值</td>
</tr>
<tr>
<td>x=${y:+新值}</td>
<td>x 为空</td>
<td>x 为空</td>
<td>x=新值</td>
</tr>
<tr>
<td>x=${y=新值}</td>
<td>x= 新值</td>
<td>x 为空</td>
<td>x=$y</td>
</tr>
<tr>
<td>y= 新值</td>
<td>y 值不变</td>
<td>y值不变</td>
<td></td>
</tr>
<tr>
<td>x=${y:=新值}</td>
<td>x= 新值</td>
<td>X= 新值</td>
<td>x=$y</td>
</tr>
<tr>
<td>y= 新值</td>
<td>y= 新值</td>
<td>y值不变</td>
<td></td>
</tr>
<tr>
<td>x=${y?新值}</td>
<td>新值输出到标准错误输出（屏幕）</td>
<td>x 为空</td>
<td>x=$y</td>
</tr>
<tr>
<td>x=${y:?新值}</td>
<td>新值输出到标准错误输出</td>
<td>新值输出到标准错误输出</td>
<td>x=$y</td>
</tr>
</tbody></table>
<h2 id="环境变量配置文件"><a href="#环境变量配置文件" class="headerlink" title="环境变量配置文件"></a>环境变量配置文件</h2><h3 id="bulb-source-命令"><a href="#bulb-source-命令" class="headerlink" title=":bulb:source 命令"></a>:bulb:source 命令</h3><p><code> source 配置文件</code></p>
<p><code>. 配置文件</code> 和<code>source 配置文件</code>作用一致。</p>
<h3 id="环境变量配置文件简介"><a href="#环境变量配置文件简介" class="headerlink" title="环境变量配置文件简介"></a>环境变量配置文件简介</h3><blockquote>
<p>环境变量配置文件中主要是定义对系统的操作环境生效的系统默认环境变量，比如：<code>PATH</code>,<code>HISTSIZE</code>,<code>PS1</code>,<code>HOSTNAME</code>等默认环境变量</p>
</blockquote>
<ul>
<li><code>/etc/profile</code></li>
<li><code>/etc/profile.d/*.sh</code></li>
<li><code>/etc/bashrc</code></li>
</ul>
<p><font color=green>上述三个<code>etc</code>目录下的三个配置文件对所有登录linux系统的用户全都生效</font></p>
<ul>
<li><code>~/.bash_profile</code></li>
<li><code>~/.bashrc</code></li>
</ul>
<p>上述两个文件，只对当前登录用户生效</p>
<p><strong>配置文件的调用顺序</strong></p>
<p><img src="source/shell%E5%AD%A6%E4%B9%A0/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%96%87%E4%BB%B6%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F-1639209622414.png" alt="环境变量文件调用顺序"></p>
<h3 id="环境变量配置文件作用"><a href="#环境变量配置文件作用" class="headerlink" title="环境变量配置文件作用"></a>环境变量配置文件作用</h3><h4 id="butterfly-etc-profile的作用"><a href="#butterfly-etc-profile的作用" class="headerlink" title=":butterfly:/etc/profile的作用"></a>:butterfly:<code>/etc/profile</code>的作用</h4><ul>
<li>USER变量</li>
<li>LOGNAME变量</li>
<li>MAIL变量</li>
<li>PATH变量</li>
<li>HOSTNAME变量</li>
<li>HISTSIZE变量</li>
<li>umask：系统默认权限</li>
<li>调用<code>/etc/profile.d/*.sh</code></li>
</ul>
<h3 id="其他配置文件和登录信息"><a href="#其他配置文件和登录信息" class="headerlink" title="其他配置文件和登录信息"></a>其他配置文件和登录信息</h3><h4 id="注销时生效的配置文件"><a href="#注销时生效的配置文件" class="headerlink" title="注销时生效的配置文件"></a>注销时生效的配置文件</h4><p><code>~/.bash_logout</code></p>
<h4 id="历史命令保存文件"><a href="#历史命令保存文件" class="headerlink" title="历史命令保存文件"></a>历史命令保存文件</h4><p><code>~/.bash_history</code></p>
<h4 id="Shell-登录信息"><a href="#Shell-登录信息" class="headerlink" title="Shell 登录信息"></a>Shell 登录信息</h4><p><strong>本地终端欢迎信息：<code>/etc/issue</code></strong></p>
<table>
<thead>
<tr>
<th>转义符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>\d</code></td>
<td>显示当前系统日期</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>显示操作系统名称</td>
</tr>
<tr>
<td><code>\l</code></td>
<td>显示登录的终端号，这个比较常用</td>
</tr>
<tr>
<td><code>\m</code></td>
<td>显示硬件体系结构，如i386，i686等</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>显示主机名</td>
</tr>
<tr>
<td><code>\o</code></td>
<td>显示域名</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>显示内核版本</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>显示当前系统时间</td>
</tr>
<tr>
<td><code>\u</code></td>
<td>显示当前登录用户的序列号</td>
</tr>
</tbody></table>
<p><strong>远程终端欢迎信息： <code>/etc/issue.net</code></strong></p>
<ul>
<li>转义符在<code>/etc/issue.net</code>文件中不能使用</li>
<li>是否显示此欢迎信息，有ssh的配置文件<code>/etc/ssh/sshd_config</code>决定，加入<code>Banner /etc/issue.net</code>行才能显示（记得重启SSH服务）</li>
</ul>
<p><strong>登录后 欢迎 信息： <code>/etc/motd</code></strong></p>
<p>不管是本地登录，还是远程登录，都可以显示此欢迎信息</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ul>
<li>正则表达式用来在文件中匹配符合条件的字符串，正则是<font color=blue>包含匹配</font>。<code>grep, awk, sed</code>等命令可以支持正则表达式。</li>
<li>通配符用来匹配符合条件的文件名，通配符是<font color=blue>完全匹配</font>。<code>ls, find, cp</code>这些命令不支持正则表达式，所以只能使用Shell自己的通配符来进行匹配了。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>\</code></td>
<td>转义符，将特殊字符无效，仅当成普通的字符来使用</td>
</tr>
<tr>
<td align="center"><code>^</code></td>
<td>匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。</td>
</tr>
<tr>
<td align="center"><code>$</code></td>
<td>匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。</td>
</tr>
<tr>
<td align="center"><code>*</code></td>
<td>匹配前面的子表达式零次或多次。例如，zo<em>能匹配“z”以及“zoo”。</em>等价于{0,}。</td>
</tr>
<tr>
<td align="center"><code>+</code></td>
<td>匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。</td>
</tr>
<tr>
<td align="center"><code>?</code></td>
<td>匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。</td>
</tr>
<tr>
<td align="center"><code>&#123;n&#125;</code></td>
<td><em>n</em> 是一个非负整数。匹配确定的<em>n</em> 次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。</td>
</tr>
<tr>
<td align="center"><code>&#123;n,&#125;</code></td>
<td><em>n</em> 是一个非负整数。至少匹配<em>n</em> 次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。</td>
</tr>
<tr>
<td align="center"><code>&#123;n,m&#125;</code></td>
<td><em>m</em> 和<em>n</em> 均为非负整数，其中<em>n</em> &lt;=<em>m</em> 。最少匹配<em>n</em> 次且最多匹配<em>m</em> 次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。</td>
</tr>
<tr>
<td align="center"><code>?</code></td>
<td>当该字符紧跟在任何一个其他限制符(*,+,?,{<em>n</em> },{<em>n</em> ,},{<em>n</em> ,<em>m</em> })后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。</td>
</tr>
<tr>
<td align="center"><code>.</code></td>
<td>匹配除“*n* ”之外的任何单个字符。要匹配包括“*n* ”在内的任何字符，请使用像“[.*n* ]”的模式。</td>
</tr>
<tr>
<td align="center"><code>(pattern)</code></td>
<td>匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“(”或“)”。</td>
</tr>
<tr>
<td align="center"><code>(?:pattern)</code></td>
<td>匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用“或”字符(|)来组合一个模式的各个部分是很有用。例如，“industr(?:y|ies)就是一个比”industry|industries’更简略的表达式。</td>
</tr>
<tr>
<td align="center"><code>(?=pattern)</code></td>
<td>正向预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配 “Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td>
</tr>
<tr>
<td align="center"><code>(?!pattern)</code></td>
<td>负向预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如 “Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始</td>
</tr>
<tr>
<td align="center">`x</td>
<td>y`</td>
</tr>
<tr>
<td align="center"><code>[xyz]</code></td>
<td>字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。</td>
</tr>
<tr>
<td align="center"><code>[^xyz]</code></td>
<td>负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“p”。</td>
</tr>
<tr>
<td align="center"><code>[a-z]</code></td>
<td>字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。</td>
</tr>
<tr>
<td align="center"><code>[^a-z]</code></td>
<td>负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。</td>
</tr>
<tr>
<td align="center"><code>\b</code></td>
<td>匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。</td>
</tr>
<tr>
<td align="center"><code>\B</code></td>
<td>匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。</td>
</tr>
<tr>
<td align="center"><code>\cx</code></td>
<td>匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。</td>
</tr>
<tr>
<td align="center"><code>\d</code></td>
<td>匹配一个数字字符。等价于[0-9]。</td>
</tr>
<tr>
<td align="center"><code>\D</code></td>
<td>匹配一个非数字字符。等价于[^0-9]。</td>
</tr>
<tr>
<td align="center"><code>\f</code></td>
<td>匹配一个换页符。等价于\x0c和\cL。</td>
</tr>
<tr>
<td align="center"><code>\n</code></td>
<td>匹配一个换行符。等价于\x0a和\cJ。</td>
</tr>
<tr>
<td align="center"><code>\r</code></td>
<td>匹配一个回车符。等价于\x0d和\cM。</td>
</tr>
<tr>
<td align="center"><code>\s</code></td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于[\f\n\r\t\v]。</td>
</tr>
<tr>
<td align="center"><code>\S</code></td>
<td>匹配任何非空白字符。等价于[^\f\n\r\t\v]。</td>
</tr>
<tr>
<td align="center"><code>\t</code></td>
<td>匹配一个制表符。等价于\x09和\cI。</td>
</tr>
<tr>
<td align="center"><code>\v</code></td>
<td>匹配一个垂直制表符。等价于\x0b和\cK。</td>
</tr>
<tr>
<td align="center"><code>\w</code></td>
<td>匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。</td>
</tr>
<tr>
<td align="center"><code>\W</code></td>
<td>匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。</td>
</tr>
<tr>
<td align="center"><code>\xn</code></td>
<td>匹配<em>n</em> ，其中<em>n</em> 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\x41”匹配“A”。“\x041”则等价于“\x04”&amp;“1”。正则表达式中可以使用ASCII编码。.</td>
</tr>
<tr>
<td align="center"><code>\num</code></td>
<td>匹配<em>num</em> ，其中<em>num</em> 是一个正整数。对所获取的匹配的引用。例如，“(.)\1”匹配两个连续的相同字符。</td>
</tr>
<tr>
<td align="center"><code>n</code></td>
<td>标识一个八进制转义值或一个向后引用。如果*n* 之前至少<em>n</em> 个获取的子表达式，则<em>n</em> 为向后引用。否则，如果<em>n</em> 为八进制数字(0-7)，则<em>n</em> 为一个八进制转义值。</td>
</tr>
<tr>
<td align="center"><code>\nm</code></td>
<td>标识一个八进制转义值或一个向后引用。如果*nm* 之前至少有<em>nm</em> 个获得子表达式，则<em>nm</em> 为向后引用。如果*nm* 之前至少有<em>n</em> 个获取，则<em>n</em> 为一个后跟文字<em>m</em> 的向后引用。如果前面的条件都不满足，若<em>n</em> 和<em>m</em> 均为八进制数字(0-7)，则*nm* 将匹配八进制转义值<em>nm</em> 。</td>
</tr>
<tr>
<td align="center"><code>\nml</code></td>
<td>如果<em>n</em> 为八进制数字(0-3)，且<em>m和l</em> 均为八进制数字(0-7)，则匹配八进制转义值<em>nm</em> l。</td>
</tr>
<tr>
<td align="center"><code>\un</code></td>
<td>匹配<em>n</em> ，其中<em>n</em> 是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（©）。</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;a*&quot; file		# 没有任何意义，匹配所有内容，包括空白行</span><br><span class="line">grep &quot;aa*&quot; file		# 匹配至少包含一个a的行</span><br><span class="line">grep &quot;aaa*&quot; file	# 匹配最少包含两个连续a的字符串</span><br><span class="line"></span><br><span class="line">grep &quot;s..d&quot; test.txt			# 匹配在s和d这两个字母之间一定有两个字符的单词</span><br><span class="line">grep &quot;s.*d&quot; test.txt			# 匹配在s和d之间有任意字符</span><br><span class="line">grep &quot;.*&quot;	text.txt			# 匹配所有内容</span><br><span class="line"></span><br><span class="line">grep &quot;^M&quot; text.txt				# 匹配以大写M开头的行</span><br><span class="line">grep &quot;n$&quot; text.txt				# 匹配以小写n结尾的行</span><br><span class="line">grep -n &quot;^$&quot; text.txt			# 会匹配空白行  (-n选项是为了输出具体的行号)</span><br><span class="line"></span><br><span class="line">grep &quot;s[ao]id&quot; text.txt			# 匹配s和i字母中，要么是a，要么是o</span><br><span class="line">grep &quot;[0-9]&quot; text.txt			# 匹配任意一个数字</span><br><span class="line">grep &quot;^[a-z]&quot; text.txt			# 匹配用小写字母开头的行</span><br><span class="line"></span><br><span class="line">grep &quot;\.$&quot; text.txt				# 匹配以. 结尾的行</span><br><span class="line"></span><br><span class="line">grep &quot;a\&#123;3\&#125;&quot; text.txt			# 匹配a字母连续出现三次的字符串</span><br><span class="line">grep &quot;[0-9]\&#123;3\&#125;&quot; text.txt		# 匹配包含连续的三个数字的字符串</span><br></pre></td></tr></table></figure>





<h2 id="字符截取命令"><a href="#字符截取命令" class="headerlink" title="字符截取命令"></a>字符截取命令</h2><p>grep是提取文本中的行，而cut和awk是提取文本中的列。</p>
<h3 id="black-heart-cut-字段提取命令"><a href="#black-heart-cut-字段提取命令" class="headerlink" title=":black_heart:cut 字段提取命令"></a>:black_heart:<code>cut</code> 字段提取命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">cut [选项] 文件名</span><br><span class="line">选项：</span><br><span class="line">	-f	列号:			提取第几列</span><br><span class="line">	-d  分隔符：	   按照指定分隔符分割列</span><br><span class="line">yu@PC:~/Files$ cat student.txt </span><br><span class="line">ID Name gender Mark</span><br><span class="line">1 Liming M 86</span><br><span class="line">2 Sc M 90</span><br><span class="line">3 Gao F 83</span><br><span class="line">yu@PC:~/Files$ cut -d&#x27; &#x27; -f 2 student.txt </span><br><span class="line">Name</span><br><span class="line">Liming</span><br><span class="line">Sc</span><br><span class="line">Gao</span><br><span class="line">yu@PC:~/Files$ </span><br><span class="line">yu@PC:~/Files$ cut -d&#x27; &#x27; -f 0 student.txt </span><br><span class="line">cut: fields are numbered from 1</span><br><span class="line"><span class="meta"># </span><span class="language-bash">上述命令说明，<span class="built_in">cut</span>截取的列号 起始是从1开始的</span></span><br><span class="line">yu@PC:~/Files$ cut -d&#x27; &#x27; -f 2,3 student.txt  # 列号可以指定多列</span><br><span class="line">Name gender</span><br><span class="line">Liming M</span><br><span class="line">Sc M</span><br><span class="line">Gao F</span><br><span class="line">yu@PC:~/Files$ cut -d&#x27; &#x27; -f 2-4 student.txt # 列号可以指定连续的列</span><br><span class="line">Name gender Mark</span><br><span class="line">Liming M 86</span><br><span class="line">Sc M 90</span><br><span class="line">Gao F 83</span><br><span class="line">yu@PC:~/Files$ </span><br></pre></td></tr></table></figure>

<p>实际的例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">假设之前批量添加了一批用户，现在需要找出这些批量添加的用户名都有哪些</span></span><br><span class="line">root@PC:/home/yu/Files# useradd user1</span><br><span class="line">root@PC:/home/yu/Files# useradd user2</span><br><span class="line">root@PC:/home/yu/Files# useradd user3</span><br><span class="line">root@PC:/home/yu/Files# cat /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</span><br><span class="line">sync:x:4:65534:sync:/bin:/bin/sync</span><br><span class="line">games:x:5:60:games:/usr/games:/usr/sbin/nologin</span><br><span class="line">man:x:6:12:man:/var/cache/man:/usr/sbin/nologin</span><br><span class="line">lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin</span><br><span class="line">mail:x:8:8:mail:/var/mail:/usr/sbin/nologin</span><br><span class="line">news:x:9:9:news:/var/spool/news:/usr/sbin/nologin</span><br><span class="line">uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin</span><br><span class="line">proxy:x:13:13:proxy:/bin:/usr/sbin/nologin</span><br><span class="line">www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin</span><br><span class="line">backup:x:34:34:backup:/var/backups:/usr/sbin/nologin</span><br><span class="line">list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin</span><br><span class="line">irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin</span><br><span class="line">gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin</span><br><span class="line">nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin</span><br><span class="line">systemd-network:x:100:102:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin</span><br><span class="line">systemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin</span><br><span class="line">systemd-timesync:x:102:104:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin</span><br><span class="line">messagebus:x:103:106::/nonexistent:/usr/sbin/nologin</span><br><span class="line">syslog:x:104:110::/home/syslog:/usr/sbin/nologin</span><br><span class="line">_apt:x:105:65534::/nonexistent:/usr/sbin/nologin</span><br><span class="line">tss:x:106:111:TPM software stack,,,:/var/lib/tpm:/bin/false</span><br><span class="line">uuidd:x:107:114::/run/uuidd:/usr/sbin/nologin</span><br><span class="line">tcpdump:x:108:115::/nonexistent:/usr/sbin/nologin</span><br><span class="line">avahi-autoipd:x:109:116:Avahi autoip daemon,,,:/var/lib/avahi-autoipd:/usr/sbin/nologin</span><br><span class="line">usbmux:x:110:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin</span><br><span class="line">rtkit:x:111:117:RealtimeKit,,,:/proc:/usr/sbin/nologin</span><br><span class="line">dnsmasq:x:112:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin</span><br><span class="line">cups-pk-helper:x:113:120:user for cups-pk-helper service,,,:/home/cups-pk-helper:/usr/sbin/nologin</span><br><span class="line">speech-dispatcher:x:114:29:Speech Dispatcher,,,:/run/speech-dispatcher:/bin/false</span><br><span class="line">avahi:x:115:121:Avahi mDNS daemon,,,:/var/run/avahi-daemon:/usr/sbin/nologin</span><br><span class="line">kernoops:x:116:65534:Kernel Oops Tracking Daemon,,,:/:/usr/sbin/nologin</span><br><span class="line">saned:x:117:123::/var/lib/saned:/usr/sbin/nologin</span><br><span class="line">nm-openvpn:x:118:124:NetworkManager OpenVPN,,,:/var/lib/openvpn/chroot:/usr/sbin/nologin</span><br><span class="line">hplip:x:119:7:HPLIP system user,,,:/run/hplip:/bin/false</span><br><span class="line">whoopsie:x:120:125::/nonexistent:/bin/false</span><br><span class="line">colord:x:121:126:colord colour management daemon,,,:/var/lib/colord:/usr/sbin/nologin</span><br><span class="line">geoclue:x:122:127::/var/lib/geoclue:/usr/sbin/nologin</span><br><span class="line">pulse:x:123:128:PulseAudio daemon,,,:/var/run/pulse:/usr/sbin/nologin</span><br><span class="line">gnome-initial-setup:x:124:65534::/run/gnome-initial-setup/:/bin/false</span><br><span class="line">gdm:x:125:130:Gnome Display Manager:/var/lib/gdm3:/bin/false</span><br><span class="line">yu:x:1000:1000:YU,,,:/home/yu:/bin/bash</span><br><span class="line">systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin</span><br><span class="line">sshd:x:126:65534::/run/sshd:/usr/sbin/nologin</span><br><span class="line">user1:x:1001:1001:,,,:/home/user1:/bin/bash</span><br><span class="line">user2:x:1002:1002:,,,:/home/user2:/bin/bash</span><br><span class="line">user3:x:1003:1003:,,,:/home/user3:/bin/bash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">开始筛选出批量添加的用户名</span></span><br><span class="line">root@PC:/home/yu/Files# grep &quot;/bin/bash&quot; /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">yu:x:1000:1000:YU,,,:/home/yu:/bin/bash</span><br><span class="line">user1:x:1001:1001:,,,:/home/user1:/bin/bash</span><br><span class="line">user2:x:1002:1002:,,,:/home/user2:/bin/bash</span><br><span class="line">user3:x:1003:1003:,,,:/home/user3:/bin/bash</span><br><span class="line">root@PC:/home/yu/Files# grep &quot;/bin/bash&quot; /etc/passwd | grep -v &quot;root&quot;  #去掉包含root的行</span><br><span class="line">yu:x:1000:1000:YU,,,:/home/yu:/bin/bash</span><br><span class="line">user1:x:1001:1001:,,,:/home/user1:/bin/bash</span><br><span class="line">user2:x:1002:1002:,,,:/home/user2:/bin/bash</span><br><span class="line">user3:x:1003:1003:,,,:/home/user3:/bin/bash</span><br><span class="line">root@PC:/home/yu/Files# grep &quot;/bin/bash&quot; /etc/passwd | grep -v &quot;root&quot; | cut -d &#x27;:&#x27; -f 1</span><br><span class="line">yu</span><br><span class="line">user1</span><br><span class="line">user2</span><br><span class="line">user3</span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">cut</span>命令 指定分隔符:, 提取第一列用户名的行</span></span><br></pre></td></tr></table></figure>

<p><strong><code>cut</code>命令的局限性</strong></p>
<p><code>df -h | cut -d &quot; &quot; -f 1,3</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">root@PC:/home/yu/Files# df -h</span><br><span class="line">文件系统        容量  已用  可用 已用% 挂载点</span><br><span class="line">udev            3.9G     0  3.9G    0% /dev</span><br><span class="line">tmpfs           794M  1.8M  792M    1% /run</span><br><span class="line">/dev/sda5        49G  7.8G   39G   17% /</span><br><span class="line">tmpfs           3.9G     0  3.9G    0% /dev/shm</span><br><span class="line">tmpfs           5.0M  4.0K  5.0M    1% /run/lock</span><br><span class="line">tmpfs           3.9G     0  3.9G    0% /sys/fs/cgroup</span><br><span class="line">/dev/loop0      128K  128K     0  100% /snap/bare/5</span><br><span class="line">/dev/loop1       55M   55M     0  100% /snap/core18/1705</span><br><span class="line">/dev/loop2       56M   56M     0  100% /snap/core18/2253</span><br><span class="line">/dev/loop4       63M   63M     0  100% /snap/gtk-common-themes/1506</span><br><span class="line">/dev/loop3      241M  241M     0  100% /snap/gnome-3-34-1804/24</span><br><span class="line">/dev/loop5       62M   62M     0  100% /snap/core20/1270</span><br><span class="line">/dev/loop7       66M   66M     0  100% /snap/gtk-common-themes/1519</span><br><span class="line">/dev/loop6      219M  219M     0  100% /snap/gnome-3-34-1804/77</span><br><span class="line">/dev/loop9       43M   43M     0  100% /snap/snapd/14066</span><br><span class="line">/dev/loop8       50M   50M     0  100% /snap/snap-store/433</span><br><span class="line">/dev/loop10      44M   44M     0  100% /snap/snapd/14295</span><br><span class="line">/dev/loop11      55M   55M     0  100% /snap/snap-store/558</span><br><span class="line">/dev/sda1       511M  4.0K  511M    1% /boot/efi</span><br><span class="line">tmpfs           794M   24K  794M    1% /run/user/125</span><br><span class="line">tmpfs           794M  4.0K  794M    1% /run/user/1000</span><br><span class="line">root@PC:/home/yu/Files# df -h | grep sda5 | cut -d &quot; &quot; -f 5 </span><br><span class="line"><span class="meta"># </span><span class="language-bash">这里就有一个问题，<span class="built_in">cut</span>命令是一个忠实的执行者， 分隔符如果是空格， 那么-d后面指定几个空格，就会按照几个空格来进行分割，但是有的分割不一定是固定数量的空格，就此<span class="built_in">cut</span>命令有一定的局限性</span></span><br></pre></td></tr></table></figure>



<h3 id="black-heart-printf-命令"><a href="#black-heart-printf-命令" class="headerlink" title=":black_heart:printf 命令"></a>:black_heart:<code>printf</code> 命令</h3><p>学习awk命令的前提，<code>printf</code>命令会格式化输出。</p>
<blockquote>
<p><code>printf &#39;输出类型输出格式&#39; 输出内容</code></p>
<p>输出类型：</p>
<ul>
<li><code>%ns</code>    : 输出字符串。n是数字指代输出几个字符</li>
<li><code>%ni</code> : 输出整数。n是数字指代输出几个数字</li>
<li>``%m.nf <code>: 输出浮点数。 m和n是数字，指代输出的整数位数和小数位数。如</code>%8.2f`代表共输出8位数，其中2位是小数，6位是整数</li>
</ul>
<p>输出格式</p>
<ul>
<li><code>\a</code>：输出警告声音</li>
<li><code>\b</code>：输出退格键，也就是Backspace</li>
<li><code>\f</code>：清除屏幕</li>
<li><code>\n</code>：换行</li>
<li><code>\r</code>：回车，也就是Enter键</li>
<li><code>\t</code>：水平输出退格键，也就是Tap键</li>
<li><code>\v</code>：垂直输出退格键，也就是Tap键</li>
</ul>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@PC:/home/yu/Files# printf &#x27;%s %s %s\n\a&#x27; 1 2 3 4 5 6 </span><br><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">printf</span> 命令也可以输出文件内容，但是需要匹配执行命令的特殊符来使用，无法配合管道来使用</span></span><br><span class="line">printf &#x27;%s&#x27; $(cat test.txt)</span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="built_in">printf</span> 输出的内容 不像 <span class="built_in">cat</span>命令那样会进行漂亮的格式化</span></span><br></pre></td></tr></table></figure>

<p>:bell:<font color=red>那为什么还需要学习<code>printf</code>命令呢？</font></p>
<blockquote>
<p>因为awk命令中，<strong>不能</strong>直接调用系统命令<code>cat</code>，<strong>也不能</strong>直接调用系统命令<code>echo</code>，但是能调用系统命令<code>print和printf</code>命令。</p>
</blockquote>
<p>在<code>awk</code>命令中，输出支持<code>print</code>和<code>printf</code>命令</p>
<ul>
<li><code>print</code>：print会在每个输出之后自动加入一个换行符（Linux默认没有print命令，只有在awk命令中才有print）</li>
<li><code>printf</code>：printf是标准格式输出命令，并不会自动加入换行符，如果需要换行，需要手工假如换行符</li>
</ul>
<h3 id="black-heart-awk-命令"><a href="#black-heart-awk-命令" class="headerlink" title=":black_heart:awk 命令"></a>:black_heart:<code>awk</code> 命令</h3><p><code>cut</code>命令能够实现的字符串截取列，<code>awk</code>命令都可以实现，但是<code>awk</code>命令要比<code>cut</code>命令复杂的多，所以在实际使用中，<code>cut</code>命令能够实现了，就是用简单的<code>cut</code>命令来实现，<code>cut</code>命令不能实现的，就是用<code>awk</code>命令来实现。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/baichunyu/p/15257904.html">Linux awk 命令详解 参考</a></p>
<p><strong>基础用法</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk [选项] &#x27;匹配条件1 &#123;脚本命令11;脚本命令12;....&#125; 匹配条件2 &#123;脚本命令21;脚本命令22;....&#125;&#x27; 文件名</span><br><span class="line">选项：</span><br><span class="line">	-F fs			# 指定以 fs 作为输入行的分隔符，awk 命令默认分隔符为空格或制表符</span><br></pre></td></tr></table></figure>

<p>另一种说法</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;条件1&#123;动作1&#125; 条件2&#123;动作2&#125; ...&#x27; 文件名</span><br><span class="line">条件（Pattern）</span><br><span class="line">	一般使用关系表达式作为条件</span><br><span class="line"><span class="meta">	x&gt;</span><span class="language-bash">10			判断变量x是否大于10</span></span><br><span class="line"><span class="meta">	x&gt;</span><span class="language-bash">=10			大于等于</span></span><br><span class="line">	x&lt;=10			小于等于</span><br><span class="line">动作（Action）</span><br><span class="line">	格式化输出</span><br><span class="line">	流程控制语句</span><br></pre></td></tr></table></figure>

<p><code>awk</code>命令会对文件中的每一行都会执行一遍<code>awk</code>命令中指定的脚本</p>
<p>简单的例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@PC:/home/yu/Files# awk &#x27;&#123;printf $1 &quot;\t&quot; $2 &quot;\t&quot; $6 &quot;\n&quot;&#125;&#x27; student2.txt </span><br><span class="line">ID	Name	Average</span><br><span class="line">1	Liming	87.66</span><br><span class="line">2	Sc	85.66</span><br><span class="line">3	Gao	91.66</span><br></pre></td></tr></table></figure>

<p>:right_anger_bubble:<code>$0</code> <strong>表示当前内容的一整行</strong></p>
<p>截取 <code>df -h</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop102 Files]$ df -h | awk &#x27;&#123;print $1 &quot;\t&quot; $2 &quot;\t&quot; $3 &quot;\t&quot; $6&#125;&#x27;</span><br><span class="line">文件系统	容量	已用	挂载点</span><br><span class="line">devtmpfs	3.8G	0	/dev</span><br><span class="line">tmpfs	3.9G	0	/dev/shm</span><br><span class="line">tmpfs	3.9G	21M	/run</span><br><span class="line">tmpfs	3.9G	0	/sys/fs/cgroup</span><br><span class="line">/dev/mapper/centos-root	46G	19G	/</span><br><span class="line">/dev/sda1	1014M	233M	/boot</span><br><span class="line">tmpfs	781M	0	/run/user/0</span><br><span class="line">tmpfs	781M	0	/run/user/1000</span><br></pre></td></tr></table></figure>

<p>:baby_chick:小需求：提取df命令显示后的磁盘已用百分比的具体值</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop102 Files]$ df -h</span><br><span class="line">文件系统                 容量  已用  可用 已用% 挂载点</span><br><span class="line">devtmpfs                 3.8G     0  3.8G    0% /dev</span><br><span class="line">tmpfs                    3.9G     0  3.9G    0% /dev/shm</span><br><span class="line">tmpfs                    3.9G   29M  3.8G    1% /run</span><br><span class="line">tmpfs                    3.9G     0  3.9G    0% /sys/fs/cgroup</span><br><span class="line">/dev/mapper/centos-root   46G   19G   27G   42% /</span><br><span class="line">/dev/sda1               1014M  233M  782M   23% /boot</span><br><span class="line">tmpfs                    781M     0  781M    0% /run/user/0</span><br><span class="line">tmpfs                    781M     0  781M    0% /run/user/1000</span><br></pre></td></tr></table></figure>

<p>例如，提取centos-root 已用的<code>23%</code>中的23</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop102 Files]$ df -h | grep centos | awk &#x27;&#123;print $5&#125;&#x27; | awk -F &quot;%&quot; &#x27;&#123;print $1&#125;&#x27;</span><br><span class="line">42</span><br></pre></td></tr></table></figure>

<h4 id="BEGIN条件"><a href="#BEGIN条件" class="headerlink" title="BEGIN条件"></a>BEGIN条件</h4><p>awk中可以通过BEGIN关键字，来实现在执行后续脚本命令<strong>之前</strong>先执行一些操作，换句话说就是<strong>BEGIN</strong>后面紧接着的脚本在开始真正读取数据之前先被执行，而且不管数据内容有多少行，<strong>BEGIN</strong>后面紧跟着的命令仅执行一遍。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop102 Files]$ df -h | awk &#x27;BEGIN&#123;print &quot;最先执行&quot;&#125; &#123;print $5&#125;&#x27;</span><br><span class="line">最先执行</span><br><span class="line">已用%</span><br><span class="line"><span class="meta">0%</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">0%</span></span><br><span class="line"><span class="meta">1%</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">0%</span></span><br><span class="line"><span class="meta">42%</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">23%</span></span><br><span class="line"><span class="meta">0%</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">0%</span></span><br></pre></td></tr></table></figure>

<p>通过<strong>BEGIN</strong>关键字设置<strong>awk</strong>的<strong>分隔符FS变量</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop102 Files]$ cat /etc/passwd | awk &#x27;BEGIN&#123;FS=&quot;:&quot;&#125; &#123;print $1 &quot;\t&quot; $7&#125;&#x27;</span><br><span class="line">root	/bin/bash</span><br><span class="line">bin	/sbin/nologin</span><br><span class="line">daemon	/sbin/nologin</span><br><span class="line">adm	/sbin/nologin</span><br><span class="line">lp	/sbin/nologin</span><br><span class="line">sync	/bin/sync</span><br><span class="line">shutdown	/sbin/shutdown</span><br><span class="line">halt	/sbin/halt</span><br><span class="line">mail	/sbin/nologin</span><br><span class="line">operator	/sbin/nologin</span><br><span class="line">games	/sbin/nologin</span><br><span class="line">ftp	/sbin/nologin</span><br><span class="line">nobody	/sbin/nologin</span><br><span class="line">systemd-network	/sbin/nologin</span><br></pre></td></tr></table></figure>

<h4 id="END条件"><a href="#END条件" class="headerlink" title="END条件"></a>END条件</h4><p><strong>END</strong>条件后面跟着的脚本是在所有数据都处理完之后最后执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;FS=&quot;:&quot;&#125; END&#123;print &quot;数据处理完成！&quot;&#125; &#123;print $1 &quot;\t&quot; $2&#125;&#x27;</span><br></pre></td></tr></table></figure>



<h4 id="关键运算符"><a href="#关键运算符" class="headerlink" title="关键运算符"></a>关键运算符</h4><p>比如有如下<code>student.txt</code>数据，查询出平均成绩大于等于86分的学生姓名</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Name</th>
<th>PHP</th>
<th>Linux</th>
<th>MySql</th>
<th>Average</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Liming</td>
<td>82</td>
<td>95</td>
<td>86</td>
<td>87.66</td>
</tr>
<tr>
<td>2</td>
<td>Sc</td>
<td>74</td>
<td>96</td>
<td>87</td>
<td>85.66</td>
</tr>
<tr>
<td>3</td>
<td>Gao</td>
<td>99</td>
<td>83</td>
<td>93</td>
<td>91.66</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat student.txt | grep -v Name | awk &#x27;$6&gt;=86&#123;print $2&#125;&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop102 Files]$ cat student.txt | grep -v Name</span><br><span class="line">1	Liming	82	95	86	87.66</span><br><span class="line">2	Sc	74	96	87	85.66</span><br><span class="line">3	Gao	99	83	93	91.66</span><br><span class="line">[hadoop@hadoop102 Files]$ cat student.txt | grep -v Name | awk &#x27;$6&gt;=86&#123;print $2&#125;&#x27;</span><br><span class="line">Liming</span><br><span class="line">Gao</span><br></pre></td></tr></table></figure>













<h3 id="black-heart-sed-命令"><a href="#black-heart-sed-命令" class="headerlink" title=":black_heart:sed 命令"></a>:black_heart:<code>sed</code> 命令</h3><p><code>sed</code>是一种几乎包括在所有Unix平台（包括Linux）的轻量级流编辑器。sed主要是用来将数据进行选取，替换，删除，新增的命令，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@PC ~]# sed [-nefr] [动作]</span><br><span class="line">选项与参数：</span><br><span class="line">-n ：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到终端上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。</span><br><span class="line">-e ：直接在命令列模式上进行 sed 的动作编辑,也就是允许对输入数据应用多条sed命令；</span><br><span class="line">-f ：直接将 sed 的动作写在一个文件内， -f filename 则可以运行 filename 内的 sed 动作；</span><br><span class="line">-r ：sed 的动作支持的是延伸型正规表示法的语法。(默认是基础正规表示法语法)</span><br><span class="line">-i ：直接修改读取的文件内容，而不是输出到终端。</span><br><span class="line"></span><br><span class="line">动作说明： [n1[,n2]]function</span><br><span class="line">n1, n2 ：不见得会存在，一般代表『选择进行动作的行数』，举例来说，如果我的动作是需要在 10 到 20 行之间进行的，则[ 10,20[动作行为] ]</span><br><span class="line"></span><br><span class="line">function：</span><br><span class="line">a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～</span><br><span class="line">c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！</span><br><span class="line">d ：删除，因为是删除啊，所以 d 后面通常不接任何内容；</span><br><span class="line">i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</span><br><span class="line">p ：列印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～</span><br><span class="line">s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！</span><br></pre></td></tr></table></figure>

<p>简单例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">yu@PC:~/Files$ sed &#x27;2p&#x27; student2.txt </span><br><span class="line">ID	Name	PHP	Linux	MySql	Average</span><br><span class="line">1	Liming	82	95	86	87.66</span><br><span class="line">1	Liming	82	95	86	87.66</span><br><span class="line">2	Sc	74	96	87	85.66</span><br><span class="line">3	Gao	99	83	93	91.66</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">添加 -n选项后， 只有被sed处理的那一行才会被输出</span></span><br><span class="line">yu@PC:~/Files$ sed -n &#x27;2p&#x27; student2.txt </span><br><span class="line">1	Liming	82	95	86	87.66</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">-d 删除行， 但是不影响源文件， 下面的例子是删除 第1到第3行</span></span><br><span class="line">yu@PC:~/Files$ sed &#x27;1,3d&#x27; student2.txt </span><br><span class="line">3	Gao	99	83	93	91.66</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">-a 内容追加， 下述例子：在student2.txt	文件内容的第2行后插入hello</span></span><br><span class="line">yu@PC:~/Files$ sed &#x27;2a hello&#x27; student2.txt </span><br><span class="line">ID	Name	PHP	Linux	MySql	Average</span><br><span class="line">1	Liming	82	95	86	87.66</span><br><span class="line">hello</span><br><span class="line">2	Sc	74	96	87	85.66</span><br><span class="line">3	Gao	99	83	93	91.66</span><br><span class="line"><span class="meta"># </span><span class="language-bash">下述例子：在student2.txt	文件内容的第2行前插入 4:this is new line</span></span><br><span class="line">yu@PC:~/Files$ sed &#x27;2i 4:this is new line&#x27; student2.txt </span><br><span class="line">ID	Name	PHP	Linux	MySql	Average</span><br><span class="line">4:this is new line</span><br><span class="line">1	Liming	82	95	86	87.66</span><br><span class="line">2	Sc	74	96	87	85.66</span><br><span class="line">3	Gao	99	83	93	91.66</span><br><span class="line"><span class="meta"># </span><span class="language-bash">c 替换</span></span><br><span class="line">yu@PC:~/Files$ sed &#x27;1c no title&#x27; student2.txt </span><br><span class="line">no title</span><br><span class="line">1	Liming	82	95	86	87.66</span><br><span class="line">2	Sc	74	96	87	85.66</span><br><span class="line">3	Gao	99	83	93	91.66</span><br><span class="line"><span class="meta"># </span><span class="language-bash">s 字符串替换  sed <span class="string">&#x27;3s/74/98/g&#x27;</span>  第3行的74 换成 98</span></span><br><span class="line">yu@PC:~/Files$ sed &#x27;3s/74/98/g&#x27; student2.txt </span><br><span class="line">ID	Name	PHP	Linux	MySql	Average</span><br><span class="line">1	Liming	82	95	86	87.66</span><br><span class="line">2	Sc	98	96	87	85.66</span><br><span class="line">3	Gao	99	83	93	91.66</span><br><span class="line"><span class="meta"># </span><span class="language-bash">-i sed操作的数据直接写入文件， -i选项会影响源文件</span></span><br><span class="line">sed -i &#x27;3s/74/98/g&#x27; student2.txt</span><br><span class="line"><span class="meta"># </span><span class="language-bash">同时把Liming 和 Gao 替换成空格</span></span><br><span class="line">sed -e &#x27;s/Liming//g ; s/Gao//g&#x27; student2.txt</span><br></pre></td></tr></table></figure>



<h2 id="字符处理命令"><a href="#字符处理命令" class="headerlink" title="字符处理命令"></a>字符处理命令</h2><h3 id="Sort命令"><a href="#Sort命令" class="headerlink" title="Sort命令"></a><code>Sort</code>命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sort [选项] 文件名</span><br><span class="line">选项：</span><br><span class="line">	-f			忽略大小写</span><br><span class="line">	-n			以数值型进行排序，默认使用字符串型排序</span><br><span class="line">	-r			反向排序</span><br><span class="line">	-t			指定分隔符，默认分隔符是制表符</span><br><span class="line">	-k n[,m]	按照指定的字段范围排序。从第n字段开始，m字段结束（默认到行尾）</span><br></pre></td></tr></table></figure>

<p><strong>简单使用</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">指定分隔符，用第三个字段开头，第3字段结尾排序，就是只用第三字段排序</span></span><br><span class="line">sort -t &quot;:&quot; -k 3,3 /etc/passwd</span><br><span class="line"><span class="meta"># </span><span class="language-bash">默认按照字符的顺序，比较第一个字符，如果相同再比较第二个字符， -n选项指定按照数值进行排序</span></span><br><span class="line">sort -n -t &quot;:&quot; -k 3,3 /etc/passwd</span><br></pre></td></tr></table></figure>



<h3 id="wc-命令"><a href="#wc-命令" class="headerlink" title="wc 命令"></a><code>wc</code> 命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wc [选项] 文件名</span><br><span class="line">选项：</span><br><span class="line">	-l			只统计行数</span><br><span class="line">	-w			只统计单词数</span><br><span class="line">	-m			值统计字符数</span><br><span class="line">	</span><br><span class="line">yu@PC:~/Files$ wc /etc/passwd</span><br><span class="line">  47   82 2775 /etc/passwd   # 表示 有47行， 82个单词， 2775个字符， 文件</span><br></pre></td></tr></table></figure>





<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><h3 id="按照文件类型进行判断"><a href="#按照文件类型进行判断" class="headerlink" title="按照文件类型进行判断"></a>按照文件类型进行判断</h3><table>
<thead>
<tr>
<th>测试选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-b 文件</td>
<td>判断该文件是否存在，并且是否为块设备文件（是块设备文件为真）</td>
</tr>
<tr>
<td>-c 文件</td>
<td>判断该文件是否存在，并且是否为字符设备文件（是字符设备文件为真）</td>
</tr>
<tr>
<td><strong>-d 文件</strong></td>
<td><strong>判断该文件是否存在， 并且是否为目录文件（是目录为真）</strong></td>
</tr>
<tr>
<td><strong>-e 文件</strong></td>
<td><strong>判断该文件是否存在（存在为真）</strong></td>
</tr>
<tr>
<td><strong>-f 文件</strong></td>
<td><strong>判断该文件是否存在，并且是否为普通文件（是普通文件为真）</strong></td>
</tr>
<tr>
<td>-L 文件</td>
<td>判断该文件是否存在，并且是否为符号链接文件（是符号链接文件为真）</td>
</tr>
<tr>
<td>-p 文件</td>
<td>判断该文件是否存在，并且是否为管道文件（是管道文件为真）</td>
</tr>
<tr>
<td>-s 文件</td>
<td>判断该文件是否存在，并且是否为非空（非空为真）</td>
</tr>
<tr>
<td>-S 文件</td>
<td>判断该文件是否存在，并且是否为套接字文件（是套接字文件为真）</td>
</tr>
</tbody></table>
<p><strong>使用格式</strong></p>
<ul>
<li><p><code>test -e /root/install.log</code></p>
<ul>
<li>```shell<br>test -e /root/install.log<br>echo $?   # 查看上一条命令的输出结果， 返回0表示命令执行正确， 非零表示不正确yu@PC:<del>/Files$ test -e /root<br>yu@PC:</del>/Files$ echo $?<br>0<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `[ -e /root/install.log ]` </span><br><span class="line"></span><br><span class="line">  - 上述这种格式，常用与shell脚本中，作为条件进行判断</span><br><span class="line"></span><br><span class="line">但是虽然判断完是否存在之后，还需要$?去查看该命令的输出结果，这样使用也不是很方便，如何解决？？？？</span><br><span class="line"></span><br><span class="line">这时候，之前所学的`&amp;&amp;` 和 `||` 就派上用场了</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">yu@PC:~/Files$ [ -d /root ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">yes</span><br><span class="line">yu@PC:~/Files$ [ -d /root/sdgfdsgfd ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">no</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="按照文件权限进行判断"><a href="#按照文件权限进行判断" class="headerlink" title="按照文件权限进行判断"></a>按照文件权限进行判断</h3><table>
<thead>
<tr>
<th>测试选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>-r 文件</strong></td>
<td><strong>判断该文件是否存在，并且是否改文件拥有读权限（有读权限为真）</strong></td>
</tr>
<tr>
<td><strong>-w 文件</strong></td>
<td><strong>判断该文件是否存在，并且是否该文件拥有写权限（有写权限为真）</strong></td>
</tr>
<tr>
<td><strong>-x 文件</strong></td>
<td><strong>判断该文件是否存在，并且是否该文件拥有执行权限（有执行权限为真）</strong></td>
</tr>
<tr>
<td>-u 文件</td>
<td>判断该文件是否存在，并且是否该文件拥有SUID权限（有SUID权限为真）</td>
</tr>
<tr>
<td>-g 文件</td>
<td>判断该文件是否存在，并且是否该文件拥有SGID权限（有SGID权限为真）</td>
</tr>
<tr>
<td>-k 文件</td>
<td>判断该文件是否存在，并且是否该文件用有SBit权限（有SBit权限为真）</td>
</tr>
</tbody></table>
<p>上述判断文件权限不会区分是那个用户下的，是属主，属组，还是其他用户。</p>
<h3 id="两个文件之间进行比较"><a href="#两个文件之间进行比较" class="headerlink" title="两个文件之间进行比较"></a>两个文件之间进行比较</h3><table>
<thead>
<tr>
<th>测试选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>文件1 -nt 文件2</td>
<td>判断文件1的修改时间是否比文件2的新（如果新则为真）</td>
</tr>
<tr>
<td>文件1 -ot 文件2</td>
<td>判断文件1的修改时间是否比文件2的旧（如果旧则为真）</td>
</tr>
<tr>
<td>文件1 -ef 文件2</td>
<td>判断文件1是否和文件2的Inode号一致，可以理解为两个文件是否为同一个文件。这个判断用于判断硬链接是很的方法。</td>
</tr>
</tbody></table>
<h3 id="两个整数之间的比较"><a href="#两个整数之间的比较" class="headerlink" title="两个整数之间的比较"></a>两个整数之间的比较</h3><table>
<thead>
<tr>
<th>测试选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>整数1 -eq 整数2</code></td>
<td>判断整数1是否和整数2相等</td>
</tr>
<tr>
<td><code>整数1 -ne 整数2</code></td>
<td>判断整数1是否和整数2不相等</td>
</tr>
<tr>
<td><code>整数1 -gt 整数2</code></td>
<td>判断整数1是否大于整数2</td>
</tr>
<tr>
<td><code>整数1 -lt 整数2</code></td>
<td>判断整数1是否小于整数2</td>
</tr>
<tr>
<td><code>整数1 -ge 整数2</code></td>
<td>判断整数1是否大于等于整数2</td>
</tr>
<tr>
<td><code>整数1 -le 整数2</code></td>
<td>判断整数1是否小于等于整数2</td>
</tr>
</tbody></table>
<h3 id="字符串的判断"><a href="#字符串的判断" class="headerlink" title="字符串的判断"></a>字符串的判断</h3><table>
<thead>
<tr>
<th>测试选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-z 字符串 （zero）</td>
<td>判断字符串是否为空</td>
</tr>
<tr>
<td>-n 字符串</td>
<td>判断字符串是否为非空（可以用来判断输入的参数是否非空）</td>
</tr>
<tr>
<td>字符串1  ==  字符串2</td>
<td>判断两个字符串是否相等</td>
</tr>
<tr>
<td>字符串1  !=  字符串2</td>
<td>判断两个字符串是否不相等</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yu@PC:~/Files$ [ &quot;$aa&quot; == &quot;$bb&quot; ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">no</span><br></pre></td></tr></table></figure>

<h3 id="多重条件判断"><a href="#多重条件判断" class="headerlink" title="多重条件判断"></a>多重条件判断</h3><table>
<thead>
<tr>
<th>测试选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>判断1 -a 判断2</td>
<td>逻辑与，判断1和判断2都成立，最终的结果才为真</td>
</tr>
<tr>
<td>判断1 -o 判断2</td>
<td>逻辑或，判断1和判断2有一个成立，最终的结果就位真</td>
</tr>
<tr>
<td>! 判断</td>
<td>逻辑非，使原始的判断式取反</td>
</tr>
</tbody></table>
<blockquote>
<p>判断aa变量是否不为空，如果不为空，就判断aa变量的数值是否大于23</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yu@PC:~/Files$ [ -n &quot;$aa&quot; -a &quot;$aa&quot; -gt 23 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">no</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><h4 id="1-单分支if条件语句"><a href="#1-单分支if条件语句" class="headerlink" title="1. 单分支if条件语句"></a>1. 单分支if条件语句</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断式 ]; then</span><br><span class="line">	程序。。。</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">if [ 条件判断式 ]</span><br><span class="line">	then</span><br><span class="line">		程序。。。</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h5 id="单分支条件语句需要注意几个点"><a href="#单分支条件语句需要注意几个点" class="headerlink" title="单分支条件语句需要注意几个点"></a>单分支条件语句需要注意几个点</h5><ul>
<li>if语句使用fi结尾，和一般语言使用大括号结尾不同</li>
<li>[ 条件判断式 ]就是使用test命令判断，所以中括号和条件判断式之间必须有空格</li>
<li>then后面跟符合条件之后执行的程序，可以放在[  ]之后，用<code>;</code>分割。也可以换行写入，就不需要<code>;</code>了</li>
</ul>
<p><strong>😊实用小例子：判断分区使用率</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">统计分区使用率</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Author: yulu	(Email:XXXX@163.com)</span></span><br><span class="line"></span><br><span class="line">path=$1</span><br><span class="line">threshold=$2</span><br><span class="line">use_rate=$(df -h | grep &quot;$path&quot; | awk &#x27;&#123;print $5&#125;&#x27; | cut -d &#x27;%&#x27; -f 1)</span><br><span class="line"><span class="meta"># </span><span class="language-bash">根据分区使用率作为变量赋值给变量user_rate</span></span><br><span class="line">if [ $use_rate -ge $threshold ]; then</span><br><span class="line">	echo &quot;Warning! /dev/sda5 will be exhausted!!&quot;</span><br><span class="line">fi</span><br><span class="line">yu@PC:~/bin$ chmod +x dfRate.sh</span><br><span class="line">yu@PC:~/bin$ dfRate.sh /dev/sda5 1</span><br><span class="line">Warning! /dev/sda5 will be exhausted!!</span><br></pre></td></tr></table></figure>



<h4 id="2-多分支if条件语句"><a href="#2-多分支if条件语句" class="headerlink" title="2. 多分支if条件语句"></a>2. 多分支if条件语句</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if [ condition ]</span><br><span class="line">	then</span><br><span class="line">		...</span><br><span class="line">	else</span><br><span class="line">		...</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p><strong>❤️实用小需求：备份重要文件</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">  </span><br><span class="line">back_path=$1</span><br><span class="line">date=$(date +%y%m%d)</span><br><span class="line">size=$(du -sh $back_path)</span><br><span class="line"><span class="meta"># </span><span class="language-bash">开始进行备份</span></span><br><span class="line">if [ -d /tmp/back_files ]</span><br><span class="line">        then</span><br><span class="line">                echo &quot;Date is $date&quot; &gt; /tmp/back_files/backInfo.txt  # 覆盖</span><br><span class="line">                echo &quot;Size is $size&quot; &gt;&gt; /tmp/back_files/backInfo.txt # 追加</span><br><span class="line">                cd /tmp/back_files  # tar 压缩，归档的名字不能有/,所以需要提前移动到需要压缩文件的目录下</span><br><span class="line">                tar -zcf etc_$date.tar.gz /etc /tmp/back_files/backInfo.txt &amp;&gt; /dev/null # 把正确和错误输出都输入到黑洞中</span><br><span class="line">                rm -rf /tmp/back_files/backInfo.txt</span><br><span class="line">        else</span><br><span class="line">                echo &quot;备份目录不存在&quot;</span><br><span class="line">                mkdir /tmp/back_files</span><br><span class="line">                echo &quot;创建备份目录 /tmp/back_files&quot;</span><br><span class="line">                echo &quot;Date is $date&quot; &gt; /tmp/back_files/backInfo.txt  # 覆盖</span><br><span class="line">                echo &quot;Size is $size&quot; &gt;&gt; /tmp/back_files/backInfo.txt # 追加</span><br><span class="line">                cd /tmp/back_files</span><br><span class="line">                tar -zcf etc_$date.tar.gz /etc /tmp/back_files/backInfo.txt &amp;&gt; /dev/null # 把正确和错误输出都输入到黑洞中</span><br><span class="line">                rm -rf /tmp/back_files/backInfo.txt</span><br><span class="line">fi</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">root@PC:/home/yu/bin# ./backup.sh </span><br><span class="line">备份目录不存在</span><br><span class="line">创建备份目录 /tmp/back_files</span><br><span class="line">root@PC:/home/yu/bin# ls /tmp/back_files/</span><br><span class="line">etc_211215.tar.gz</span><br><span class="line"><span class="meta"># </span><span class="language-bash">不解压压缩包，只查看里面的内容</span></span><br><span class="line">root@PC:/home/yu/bin# tar -ztvf /tmp/back_files/etc_211215.tar.gz </span><br><span class="line">lrwxrwxrwx root/root         0 2021-12-08 15:01 etc/rc3.d/K01speech-dispatcher -&gt; ../init.d/speech-dispatcher</span><br><span class="line">lrwxrwxrwx root/root         0 2021-12-08 23:20 etc/rc3.d/S01ssh -&gt; ../init.d/ssh</span><br><span class="line">lrwxrwxrwx root/root         0 2021-12-08 15:01 etc/rc3.d/S01pulseaudio-enable-autospawn -&gt; ../init.d/pulseaudio-enable-autospawn</span><br><span class="line">lrwxrwxrwx root/root         0 2021-12-08 15:01 etc/rc3.d/S01cron -&gt; ../init.d/cron</span><br><span class="line">lrwxrwxrwx root/root         0 2021-12-08 15:01 etc/rc3.d/S01dbus -&gt; ../init.d/dbus</span><br><span class="line">lrwxrwxrwx root/root         0 2021-12-08 15:01 etc/rc3.d/S01apport -&gt; ../init.d/apport</span><br><span class="line">lrwxrwxrwx root/root         0 2021-12-08 15:01 etc/rc3.d/S01avahi-daemon -&gt; ../init.d/avahi-daemon</span><br><span class="line">lrwxrwxrwx root/root         0 2021-12-08 15:01 etc/rc3.d/S01saned -&gt; ../init.d/saned</span><br><span class="line">lrwxrwxrwx root/root         0 2021-12-08 15:01 etc/rc3.d/S01acpid -&gt; ../init.d/acpid</span><br><span class="line">lrwxrwxrwx root/root         0 2021-12-08 15:01 etc/rc3.d/S01rsyslog -&gt; ../init.d/rsyslog</span><br><span class="line">lrwxrwxrwx root/root         0 2021-12-08 15:01 etc/rc3.d/S01console-setup.sh -&gt; ../init.d/console-setup.sh</span><br><span class="line">lrwxrwxrwx root/root         0 2021-12-08 15:01 etc/rc3.d/S01spice-vdagent -&gt; ../init.d/spice-vdagent</span><br><span class="line">lrwxrwxrwx root/root         0 2021-12-08 15:01 etc/rc3.d/S01rsync -&gt; ../init.d/rsync</span><br><span class="line">lrwxrwxrwx root/root         0 2021-12-08 15:01 etc/rc3.d/S01unattended-upgrades -&gt; ../init.d/unattended-upgrades</span><br><span class="line">lrwxrwxrwx root/root         0 2021-12-08 15:01 etc/rc3.d/S01gdm3 -&gt; ../init.d/gdm3</span><br><span class="line">lrwxrwxrwx root/root         0 2021-12-08 15:01 etc/rc3.d/S01cups -&gt; ../init.d/cups</span><br><span class="line">lrwxrwxrwx root/root         0 2021-12-08 15:01 etc/rc3.d/S01grub-common -&gt; ../init.d/grub-common</span><br><span class="line">drwxr-xr-x root/root         0 2020-04-23 15:39 etc/update-motd.d/</span><br><span class="line">-rwxr-xr-x root/root      4677 2019-12-05 22:39 etc/update-motd.d/50-motd-news</span><br><span class="line">-rwxr-xr-x root/root      1157 2019-12-05 22:39 etc/update-motd.d/10-help-text</span><br><span class="line">-rwxr-xr-x root/root       165 2020-04-14 06:37 etc/update-motd.d/92-unattended-upgrades</span><br><span class="line">-rwxr-xr-x root/root       299 2019-12-19 04:25 etc/update-motd.d/91-release-upgrade</span><br><span class="line">-rwxr-xr-x root/root      1220 2019-12-05 22:39 etc/update-motd.d/00-header</span><br><span class="line">-rwxr-xr-x root/root       144 2020-04-02 19:25 etc/update-motd.d/98-reboot-required</span><br><span class="line">-rwxr-xr-x root/root       142 2020-04-02 19:25 etc/update-motd.d/98-fsck-at-reboot</span><br><span class="line">-rwxr-xr-x root/root        96 2020-04-02 02:43 etc/update-motd.d/85-fwupd</span><br><span class="line">-rwxr-xr-x root/root       218 2020-04-02 19:25 etc/update-motd.d/90-updates-available</span><br><span class="line">-rwxr-xr-x root/root       129 2020-04-02 19:25 etc/update-motd.d/95-hwe-eol</span><br><span class="line">drwxr-xr-x root/root         0 2020-04-23 15:35 etc/pki/</span><br><span class="line">drwxr-xr-x root/root         0 2020-04-23 15:39 etc/pki/fwupd-metadata/</span><br><span class="line">-rw-r--r-- root/root      2169 2020-03-05 00:18 etc/pki/fwupd-metadata/GPG-KEY-Linux-Foundation-Metadata</span><br><span class="line">-rw-r--r-- root/root       959 2020-03-05 00:18 etc/pki/fwupd-metadata/GPG-KEY-Linux-Vendor-Firmware-Service</span><br><span class="line">-rw-r--r-- root/root      1679 2020-03-05 00:18 etc/pki/fwupd-metadata/LVFS-CA.pem</span><br><span class="line">drwxr-xr-x root/root         0 2020-04-23 15:39 etc/pki/fwupd/</span><br><span class="line">-rw-r--r-- root/root      2169 2020-03-05 00:18 etc/pki/fwupd/GPG-KEY-Linux-Foundation-Firmware</span><br><span class="line">-rw-r--r-- root/root      1702 2020-03-05 00:18 etc/pki/fwupd/GPG-KEY-Hughski-Limited</span><br><span class="line">-rw-r--r-- root/root       959 2020-03-05 00:18 etc/pki/fwupd/GPG-KEY-Linux-Vendor-Firmware-Service</span><br><span class="line">-rw-r--r-- root/root      1679 2020-03-05 00:18 etc/pki/fwupd/LVFS-CA.pem</span><br><span class="line">-rw-r--r-- root/root        29 2021-12-15 21:23 tmp/back_files/backInfo.txt</span><br></pre></td></tr></table></figure>



<p><strong>❤️实用例子：判断apache是否启动？</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">port=$(nmap -sT 192.168.1.156 | grep tcp | grep http | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line"><span class="meta"># </span><span class="language-bash">使用nmap命令扫描服务器，并截取apache服务的状态，赋予变量port</span> </span><br><span class="line">if [ &quot;$port&quot; == &quot;open&quot; ]</span><br><span class="line">	then</span><br><span class="line">		echo &quot;$(date) httpd is ok!&quot; &gt;&gt; /tmp/autostart-acc.log</span><br><span class="line">	else</span><br><span class="line">		/etc/rc.d/init.d/httpd start &amp;&gt; /dev/null</span><br><span class="line">		echo &quot;$(date) restart httpd !!&quot; &gt;&gt; /tmp/autostart-err.log</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<h4 id="3-多分支if条件语句"><a href="#3-多分支if条件语句" class="headerlink" title="3. 多分支if条件语句"></a>3. 多分支if条件语句</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断式1 ]</span><br><span class="line">	then</span><br><span class="line">		...</span><br><span class="line">elif [ 条件判断式2 ]</span><br><span class="line">	then</span><br><span class="line">		...</span><br><span class="line">else</span><br><span class="line">	then</span><br><span class="line">		...</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>例子：判断用户输入的是什么文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">read -p &quot;Please input a filename:&quot; file</span><br><span class="line"><span class="meta"># </span><span class="language-bash">首先判断输入的内容是否为空</span></span><br><span class="line">if [ -z &quot;$file&quot; ]</span><br><span class="line">	then</span><br><span class="line">		echo &quot;Error , please input a filename&quot;</span><br><span class="line">		exit 1</span><br><span class="line"><span class="meta"># </span><span class="language-bash">-e 判断文件是否存在</span></span><br><span class="line">elif [ ! -e &quot;$file&quot; ]</span><br><span class="line">	then</span><br><span class="line">		echo &quot;Your input is no a file or file is not exist !&quot;</span><br><span class="line">		exit 2</span><br><span class="line"><span class="meta"># </span><span class="language-bash">判断是否是普通文件</span></span><br><span class="line">elif [ -f &quot;$file&quot; ]</span><br><span class="line">	then</span><br><span class="line">		echo &quot;$file is a regulare file!&quot;</span><br><span class="line">elif [ -d &quot;$file&quot; ]</span><br><span class="line">	then</span><br><span class="line">		echo &quot;$file is a directory&quot;</span><br><span class="line">else</span><br><span class="line">	echo &quot;$file is an other file!&quot;</span><br><span class="line">fi	</span><br></pre></td></tr></table></figure>



<h3 id="case-语句"><a href="#case-语句" class="headerlink" title="case 语句"></a>case 语句</h3><p><code>case</code>和<code>if...elif...else</code>语句一样都是多分支条件语句，不过和<code>if</code>多分支条件语句不同的是，<code>case</code>语句只能判断一种条件关系，而<code>if</code>语句可以判断多种条件关系。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">case $变量名 in</span><br><span class="line">	&quot;value1&quot;)</span><br><span class="line">		如果变量名的值等于value1，执行程序1</span><br><span class="line">		;;</span><br><span class="line">	&quot;value2&quot;)</span><br><span class="line">		....</span><br><span class="line">		;;</span><br><span class="line">	...</span><br><span class="line">	*)</span><br><span class="line">		如果变量的值都不是以上的值，则执行此程序</span><br><span class="line">		;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>



<h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><h4 id="语法1"><a href="#语法1" class="headerlink" title="语法1"></a><strong>语法1</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for 变量 in 值1 值2 值3 ...</span><br><span class="line">	do</span><br><span class="line">		程序</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">for time in morning noon afternoon evening</span><br><span class="line">	do</span><br><span class="line">		echo &quot;This time is $time!&quot;</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>

<p>批量解压缩脚本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">cd /lamp</span><br><span class="line">ls *.tar.gz &gt; ls.log</span><br><span class="line">for i in $(cat ls.log)</span><br><span class="line">	do</span><br><span class="line">		tar -zxf $i &amp;&gt; /dev/null</span><br><span class="line">	done</span><br><span class="line">rm -rf /lamp/ls.log</span><br></pre></td></tr></table></figure>



<h4 id="语法2"><a href="#语法2" class="headerlink" title="语法2"></a><strong>语法2</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (( 初始值;循环控制条件;变量变化))</span><br><span class="line">	do</span><br><span class="line">		...</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>

<p>例子：从1加到100</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s=0</span><br><span class="line">for (( i=1;i&lt;=100;i=i+1 ))</span><br><span class="line">	do</span><br><span class="line">		s=$(( $s+$i ))</span><br><span class="line">   	done</span><br><span class="line">echo &quot;The sum of 1+2+...+100 is: $s&quot;</span><br></pre></td></tr></table></figure>





<h3 id="while-循环-与-until-循环"><a href="#while-循环-与-until-循环" class="headerlink" title="while 循环 与 until 循环"></a>while 循环 与 until 循环</h3><p>while循环是不定循环，也称作条件循环。只要条件判断式成立，循环就会一直继续，直到条件判断式不成立，循环才会停止。这就和for的固定循环不太一样了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while [ 条件判断式 ]</span><br><span class="line">	do</span><br><span class="line">		...</span><br><span class="line">		条件判断式中的条件改变策略</span><br><span class="line">		...</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">i=1</span><br><span class="line">s=0</span><br><span class="line">while [ $i -le 100 ]</span><br><span class="line">	do</span><br><span class="line">		s=$(( $s+$i ))</span><br><span class="line">		i=$(( $i+1 ))</span><br><span class="line">	done</span><br><span class="line">echo &quot;The Sum is：$s&quot;</span><br></pre></td></tr></table></figure>



<p>until循环，和while循环相反，until循环是只要条件判断式不成立则进入循环，并执行循环程序，一点循环条件成立，则终止循环。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">i=1</span><br><span class="line">s=0</span><br><span class="line">until [ $i -gt 100 ]</span><br><span class="line">	do</span><br><span class="line">		s=$(( $s+$i ))</span><br><span class="line">		i=$(( $i+1 ))</span><br><span class="line">	done</span><br><span class="line">echo &quot;The Sum is：$s&quot;</span><br></pre></td></tr></table></figure>






      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://xiaowodi.github.io/2022/06/24/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/24/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Netty通讯框架</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-24 08:12:10" itemprop="dateCreated datePublished" datetime="2022-06-24T08:12:10+00:00">2022-06-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="source/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/png1-16347221111681.png" alt="png1"></p>
<h1 id="二-Netty-入门"><a href="#二-Netty-入门" class="headerlink" title="二. Netty 入门"></a>二. Netty 入门</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><h3 id="1-1-Netty-是什么？"><a href="#1-1-Netty-是什么？" class="headerlink" title="1.1 Netty 是什么？"></a>1.1 Netty 是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Netty is an asynchronous event-driven network application framework</span><br><span class="line">for rapid development of maintainable high performance protocol servers &amp; clients.</span><br></pre></td></tr></table></figure>

<p>Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端</p>
<h3 id="1-2-Netty-的作者"><a href="#1-2-Netty-的作者" class="headerlink" title="1.2 Netty 的作者"></a>1.2 Netty 的作者</h3><p><img src="source/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0005.png"></p>
<p>他还是另一个著名网络应用框架 Mina 的重要贡献者</p>
<h3 id="1-3-Netty-的地位"><a href="#1-3-Netty-的地位" class="headerlink" title="1.3 Netty 的地位"></a>1.3 Netty 的地位</h3><p>Netty 在 Java 网络应用框架中的地位就好比：Spring 框架在 JavaEE 开发中的地位</p>
<p>以下的框架都使用了 Netty，因为它们有网络通信需求！</p>
<ul>
<li>Cassandra - nosql 数据库</li>
<li>Spark - 大数据分布式计算框架</li>
<li>Hadoop - 大数据分布式存储框架</li>
<li>RocketMQ - ali 开源的消息队列</li>
<li>ElasticSearch - 搜索引擎</li>
<li>gRPC - rpc 框架</li>
<li>Dubbo - rpc 框架</li>
<li>Spring 5.x - flux api 完全抛弃了 tomcat ，使用 netty 作为服务器端</li>
<li>Zookeeper - 分布式协调框架</li>
</ul>
<h3 id="1-4-Netty-的优势"><a href="#1-4-Netty-的优势" class="headerlink" title="1.4 Netty 的优势"></a>1.4 Netty 的优势</h3><ul>
<li>Netty vs NIO，工作量大，bug 多<ul>
<li>需要自己构建协议</li>
<li>解决 TCP 传输问题，如粘包、半包</li>
<li>epoll 空轮询导致 CPU 100%</li>
<li>对 API 进行增强，使之更易用，如 FastThreadLocal =&gt; ThreadLocal，ByteBuf =&gt; ByteBuffer</li>
</ul>
</li>
<li>Netty vs 其它网络应用框架<ul>
<li>Mina 由 apache 维护，将来 3.x 版本可能会有较大重构，破坏 API 向下兼容性，Netty 的开发迭代更迅速，API 更简洁、文档更优秀</li>
<li>久经考验，16年，Netty 版本<ul>
<li>2.x 2004</li>
<li>3.x 2008</li>
<li>4.x 2013</li>
<li>5.x 已废弃（没有明显的性能提升，维护成本高）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-Hello-World"><a href="#2-Hello-World" class="headerlink" title="2. Hello World"></a>2. Hello World</h2><h3 id="2-1-目标"><a href="#2-1-目标" class="headerlink" title="2.1 目标"></a>2.1 目标</h3><p>开发一个简单的服务器端和客户端</p>
<ul>
<li>客户端向服务器端发送 hello, world</li>
<li>服务器仅接收，不返回</li>
</ul>
<p>加入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.39.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h3 id="2-2-服务器端"><a href="#2-2-服务器端" class="headerlink" title="2.2 服务器端"></a>2.2 服务器端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>()) <span class="comment">// 1</span></span><br><span class="line">    .channel(NioServerSocketChannel.class) <span class="comment">// 2</span></span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123; <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>()); <span class="comment">// 5</span></span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;String&gt;() &#123; <span class="comment">// 6</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> &#123;</span><br><span class="line">                    System.out.println(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .bind(<span class="number">8080</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>代码解读</p>
<ul>
<li><p>1 处，创建 NioEventLoopGroup，可以简单理解为 <code>线程池 + Selector</code> 后面会详细展开</p>
</li>
<li><p>2 处，选择服务 Scoket 实现类，其中 NioServerSocketChannel 表示基于 NIO 的服务器端实现，其它实现还有</p>
<p><img src="source/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0006.png"></p>
</li>
<li><p>3 处，为啥方法叫 childHandler，是接下来添加的处理器都是给 SocketChannel 用的，而不是给 ServerSocketChannel。ChannelInitializer 处理器（仅执行一次），它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器</p>
</li>
<li><p>4 处，ServerSocketChannel 绑定的监听端口</p>
</li>
<li><p>5 处，SocketChannel 的处理器，解码 ByteBuf =&gt; String</p>
</li>
<li><p>6 处，SocketChannel 的业务处理器，使用上一个处理器的处理结果</p>
</li>
</ul>
<h3 id="2-3-客户端"><a href="#2-3-客户端" class="headerlink" title="2.3 客户端"></a>2.3 客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>()) <span class="comment">// 1</span></span><br><span class="line">    .channel(NioSocketChannel.class) <span class="comment">// 2</span></span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123; <span class="comment">// 3</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>()); <span class="comment">// 8</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>) <span class="comment">// 4</span></span><br><span class="line">    .sync() <span class="comment">// 5</span></span><br><span class="line">    .channel() <span class="comment">// 6</span></span><br><span class="line">    .writeAndFlush(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;: hello world!&quot;</span>); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<p>代码解读</p>
<ul>
<li><p>1 处，创建 NioEventLoopGroup，同 Server</p>
</li>
<li><p>2 处，选择客户 Socket 实现类，NioSocketChannel 表示基于 NIO 的客户端实现，其它实现还有</p>
<p><img src="source/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0007.png"></p>
</li>
<li><p>3 处，添加 SocketChannel 的处理器，ChannelInitializer 处理器（仅执行一次），它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器</p>
</li>
<li><p>4 处，指定要连接的服务器和端口</p>
</li>
<li><p>5 处，Netty 中很多方法都是异步的，如 connect，这时需要使用 sync 方法等待 connect 建立连接完毕</p>
</li>
<li><p>6 处，<strong>获取 channel 对象，它即为通道抽象，可以进行数据读写操作</strong></p>
</li>
<li><p>7 处，写入消息并清空缓冲区</p>
</li>
<li><p>8 处，消息会经过通道 handler 处理，这里是将 String =&gt; ByteBuf 发出</p>
</li>
<li><p>数据经过网络传输，到达服务器端，服务器端 5 和 6 处的 handler 先后被触发，走完一个流程</p>
</li>
</ul>
<h3 id="2-4-流程梳理"><a href="#2-4-流程梳理" class="headerlink" title="2.4 流程梳理"></a>2.4 流程梳理</h3><p><img src="source/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0040.png"></p>
<h4 id="💡-提示"><a href="#💡-提示" class="headerlink" title="💡 提示"></a>💡 提示</h4><blockquote>
<p>一开始需要树立正确的观念</p>
<ul>
<li>把 channel 理解为数据的通道</li>
<li>把 msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 的加工，会变成其它类型对象，最后输出又变成 ByteBuf</li>
<li>把 handler 理解为数据的处理工序<ul>
<li>工序有多道，合在一起就是 pipeline，pipeline 负责发布事件（读、读取完成…）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）</li>
<li>handler 分 <strong>Inbound（入站）</strong> 和 <strong>Outbound（出站）</strong> 两类</li>
</ul>
</li>
<li>把 eventLoop 理解为处理数据的<strong>工人</strong><ul>
<li><strong>工人</strong>可以管理多个 channel 的 io 操作，并且一旦工人负责了某个 channel，就要负责到底（绑定）</li>
<li>工人既可以执行 io 操作，也可以进行任务处理，每位工人有任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务</li>
<li>工人按照 <strong>pipeline 顺序</strong>，依次按照 <strong>handler 的规划（代码）处理数据</strong>，<strong>可以为每道工序指定不同的工人</strong></li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>演示EventLoopGroup中的EventLoop 与 Channel的绑定效果：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器端</span></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventLoopServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">                .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span> <span class="comment">// 连接建立后会调用一次初始化方法</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="comment">// 初始化后， 往pipeline中添加处理器</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="comment">// 自定义处理器， 处理读事件，</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                                log.info(byteBuf.toString(Charset.defaultCharset()));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"><span class="keyword">import</span> lombok.SneakyThrows;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventLoopClient</span> &#123;</span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 启动类</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                <span class="comment">//2. 添加EventLoop</span></span><br><span class="line">                .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">                <span class="comment">//3. 选择客户端channel实现</span></span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                <span class="comment">//4. 添加处理器</span></span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span>   <span class="comment">// 连接建立后被调用</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel nioSocketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        nioSocketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">//5. 连接服务器</span></span><br><span class="line">                .connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>))</span><br><span class="line">                .sync()</span><br><span class="line">                .channel();</span><br><span class="line">        System.out.println(channel);</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// debug断点调试代码，设置断点为当前线程，避免阻止其他线程的运行</span></span><br></pre></td></tr></table></figure>

<p><img src="source/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211221114731980.png" alt="image-20211221114731980"></p>
<p><strong>运行结果：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span>:<span class="number">57</span>:<span class="number">37</span> [INFO ] [nioEventLoopGroup-<span class="number">2</span>-<span class="number">2</span>] n.c.EventLoopServer - <span class="number">1</span></span><br><span class="line"><span class="number">11</span>:<span class="number">57</span>:<span class="number">40</span> [INFO ] [nioEventLoopGroup-<span class="number">2</span>-<span class="number">2</span>] n.c.EventLoopServer - <span class="number">1</span></span><br><span class="line"><span class="number">11</span>:<span class="number">57</span>:<span class="number">56</span> [INFO ] [nioEventLoopGroup-<span class="number">2</span>-<span class="number">3</span>] n.c.EventLoopServer - <span class="number">2</span></span><br><span class="line"><span class="number">11</span>:<span class="number">57</span>:<span class="number">58</span> [INFO ] [nioEventLoopGroup-<span class="number">2</span>-<span class="number">3</span>] n.c.EventLoopServer - <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>从上述输出信息可以看出，EventLoopGroup中的每个EventLoop都会专门负责一个channel，即每个channel都会被绑定到一个专属的EventLoop上，这个EventLoop就会负责这个Channel的工作。</p>
<p><img src="source/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211221120820730.png" alt="image-20211221120820730"></p>
<p><strong>进一步细分EventLoop</strong></p>
<p><img src="source/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/EventLoop%E8%81%8C%E8%B4%A3%E7%BB%86%E5%88%86-1640067698671.png" alt="EventLoop职责细分"></p>
<h2 id="3-组件"><a href="#3-组件" class="headerlink" title="3. 组件"></a>3. 组件</h2><h3 id="3-1-EventLoop"><a href="#3-1-EventLoop" class="headerlink" title="3.1 EventLoop"></a>3.1 EventLoop</h3><p><strong>事件循环对象</strong></p>
<p><strong>EventLoop</strong> 本质是一个单线程执行器（同时维护了一个 Selector），里面有 run 方法处理 Channel 上源源不断的 io 事件。</p>
<p>它的继承关系比较复杂</p>
<ul>
<li>一条线是继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法</li>
<li>另一条线是继承自 netty 自己的 OrderedEventExecutor，<ul>
<li>提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop</li>
<li>提供了 parent 方法来看看自己属于哪个 EventLoopGroup</li>
</ul>
</li>
</ul>
<p><strong>事件循环组</strong></p>
<p>EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）</p>
<ul>
<li>继承自 netty 自己的 EventExecutorGroup<ul>
<li>实现了 Iterable 接口提供遍历 EventLoop 的能力</li>
<li>另有 next 方法获取集合中下一个 EventLoop</li>
</ul>
</li>
</ul>
<p>以一个简单的实现为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部创建了两个 EventLoop, 每个 EventLoop 维护一个线程</span></span><br><span class="line"><span class="type">DefaultEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoopGroup</span>(<span class="number">2</span>);</span><br><span class="line">System.out.println(group.next());</span><br><span class="line">System.out.println(group.next());</span><br><span class="line">System.out.println(group.next());</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">io.netty.channel.DefaultEventLoop@60f82f98</span><br><span class="line">io.netty.channel.DefaultEventLoop@35f983a6</span><br><span class="line">io.netty.channel.DefaultEventLoop@60f82f98</span><br></pre></td></tr></table></figure>

<p>也可以使用 for 循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoopGroup</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (EventExecutor eventLoop : group) &#123;</span><br><span class="line">    System.out.println(eventLoop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io.netty.channel.DefaultEventLoop@60f82f98</span><br><span class="line">io.netty.channel.DefaultEventLoop@35f983a6</span><br></pre></td></tr></table></figure>



<h4 id="💡-优雅关闭"><a href="#💡-优雅关闭" class="headerlink" title="💡 优雅关闭"></a>💡 优雅关闭</h4><p>优雅关闭 <code>shutdownGracefully</code> 方法。该方法会首先切换 <code>EventLoopGroup</code> 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的</p>
<h4 id="演示-NioEventLoop-处理-io-事件"><a href="#演示-NioEventLoop-处理-io-事件" class="headerlink" title="演示 NioEventLoop 处理 io 事件"></a>演示 NioEventLoop 处理 io 事件</h4><p>服务器端两个 nio worker 工人</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>), <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>))</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> msg <span class="keyword">instanceof</span> ByteBuf ? ((ByteBuf) msg) : <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (byteBuf != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">16</span>];</span><br><span class="line">                        <span class="type">ByteBuf</span> <span class="variable">len</span> <span class="operator">=</span> byteBuf.readBytes(buf, <span class="number">0</span>, byteBuf.readableBytes());</span><br><span class="line">                        log.debug(<span class="keyword">new</span> <span class="title class_">String</span>(buf));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).bind(<span class="number">8080</span>).sync();</span><br></pre></td></tr></table></figure>

<p>客户端，启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">            .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>))</span><br><span class="line">            .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;init...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .channel(NioSocketChannel.class).connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>)</span><br><span class="line">            .sync()</span><br><span class="line">            .channel();</span><br><span class="line"></span><br><span class="line">    channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class="string">&quot;wangwu&quot;</span>.getBytes()));</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class="string">&quot;wangwu&quot;</span>.getBytes()));</span><br></pre></td></tr></table></figure>

<p>最后输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">22:03:34 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan       </span><br><span class="line">22:03:36 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan       </span><br><span class="line">22:05:36 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi           </span><br><span class="line">22:05:38 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi           </span><br><span class="line">22:06:09 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu        </span><br><span class="line">22:06:11 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu         </span><br></pre></td></tr></table></figure>

<p>可以看到两个工人轮流处理 channel，但工人与 channel 之间进行了绑定</p>
<p><img src="source/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0042.png"></p>
<p>再增加两个非 nio 工人</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultEventLoopGroup</span> <span class="variable">normalWorkers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoopGroup</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>), <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>))</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span>  &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">            ch.pipeline().addLast(normalWorkers,<span class="string">&quot;myhandler&quot;</span>,</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> msg <span class="keyword">instanceof</span> ByteBuf ? ((ByteBuf) msg) : <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (byteBuf != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">16</span>];</span><br><span class="line">                        <span class="type">ByteBuf</span> <span class="variable">len</span> <span class="operator">=</span> byteBuf.readBytes(buf, <span class="number">0</span>, byteBuf.readableBytes());</span><br><span class="line">                        log.debug(<span class="keyword">new</span> <span class="title class_">String</span>(buf));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).bind(<span class="number">8080</span>).sync();</span><br></pre></td></tr></table></figure>

<p>客户端代码不变，启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）</p>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] REGISTERED</span><br><span class="line">22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] ACTIVE</span><br><span class="line">22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 7a 68 61 6e 67 73 61 6e                         |zhangsan        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ COMPLETE</span><br><span class="line">22:19:48 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan        </span><br><span class="line">22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 7a 68 61 6e 67 73 61 6e                         |zhangsan        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ COMPLETE</span><br><span class="line">22:19:50 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan        </span><br><span class="line">22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] REGISTERED</span><br><span class="line">22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] ACTIVE</span><br><span class="line">22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ: 4B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 6c 69 73 69                                     |lisi            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ COMPLETE</span><br><span class="line">22:20:25 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi            </span><br><span class="line">22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ: 4B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 6c 69 73 69                                     |lisi            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ COMPLETE</span><br><span class="line">22:20:27 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi            </span><br><span class="line">22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] REGISTERED</span><br><span class="line">22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] ACTIVE</span><br><span class="line">22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ: 6B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 77 61 6e 67 77 75                               |wangwu          |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ COMPLETE</span><br><span class="line">22:20:38 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu          </span><br><span class="line">22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ: 6B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 77 61 6e 67 77 75                               |wangwu          |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ COMPLETE</span><br><span class="line">22:20:40 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu          </span><br></pre></td></tr></table></figure>

<p>可以看到，nio 工人和 非 nio 工人也分别绑定了 channel（LoggingHandler 由 nio 工人执行，而我们自己的 handler 由非 nio 工人执行）</p>
<p><img src="source/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0041.png"></p>
<h4 id="💡-handler-执行中如何换人？"><a href="#💡-handler-执行中如何换人？" class="headerlink" title="💡 handler 执行中如何换人？"></a>💡 handler 执行中如何换人？</h4><p>关键代码 <code>io.netty.channel.AbstractChannelHandlerContext#invokeChannelRead()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">m</span> <span class="operator">=</span> next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="string">&quot;msg&quot;</span>), next);</span><br><span class="line">    <span class="comment">// 下一个 handler 的事件循环是否与当前的事件循环是同一个线程</span></span><br><span class="line">    <span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> next.executor();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是，直接调用（这里就是判断当前handler所在的线程 与 下一个handler所在的线程是否是同一个线程， 如果是，那么就在当前线程中直接调用执行下一个handler，如果不在同一个线程，就往线程池中新增一个任务，切换线程去执行）</span></span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeChannelRead(m);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 不是，将要执行的代码作为任务提交给下一个事件循环处理（换人）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                next.invokeChannelRead(m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果两个 handler 绑定的是同一个线程，那么就直接调用</li>
<li>否则，把要调用的代码封装为一个任务对象，由下一个 handler 的线程来调用</li>
</ul>
<h4 id="演示-NioEventLoop-处理普通任务"><a href="#演示-NioEventLoop-处理普通任务" class="headerlink" title="演示 NioEventLoop 处理普通任务"></a>演示 NioEventLoop 处理普通任务</h4><p>NioEventLoop 除了可以处理 io 事件，同样可以向它提交普通任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NioEventLoopGroup</span> <span class="variable">nioWorkers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">&quot;server start...&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">nioWorkers.execute(()-&gt;&#123;</span><br><span class="line">    log.debug(<span class="string">&quot;normal task...&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">22:30:36 [DEBUG] [main] c.i.o.EventLoopTest2 - server start...</span><br><span class="line">22:30:38 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - normal task...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以用来执行耗时较长的任务</p>
</blockquote>
<h4 id="演示-NioEventLoop-处理定时任务"><a href="#演示-NioEventLoop-处理定时任务" class="headerlink" title="演示 NioEventLoop 处理定时任务"></a>演示 NioEventLoop 处理定时任务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NioEventLoopGroup</span> <span class="variable">nioWorkers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">&quot;server start...&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">nioWorkers.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">22:35:15 [DEBUG] [main] c.i.o.EventLoopTest2 - server start...</span><br><span class="line">22:35:17 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...</span><br><span class="line">22:35:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...</span><br><span class="line">22:35:19 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...</span><br><span class="line">22:35:20 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以用来执行定时任务</p>
</blockquote>
<h3 id="3-2-Channel"><a href="#3-2-Channel" class="headerlink" title="3.2 Channel"></a>3.2 Channel</h3><p>channel 的主要作用</p>
<ul>
<li>close() 可以用来关闭 channel</li>
<li>closeFuture() 用来处理 channel 的关闭<ul>
<li>sync 方法作用是同步等待 channel 关闭</li>
<li>而 addListener 方法是异步等待 channel 关闭</li>
</ul>
</li>
<li>pipeline() 方法添加处理器</li>
<li>write() 方法将数据写入</li>
<li>writeAndFlush() 方法将数据写入并刷出</li>
</ul>
<h4 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h4><p>这时刚才的客户端代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>)</span><br><span class="line">    .sync()</span><br><span class="line">    .channel()</span><br><span class="line">    .writeAndFlush(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;: hello world!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>现在把它拆开来看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">channelFuture.sync().channel().writeAndFlush(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;: hello world!&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>1 处返回的是 ChannelFuture 对象，它的作用是利用 channel() 方法来获取 Channel 对象</li>
</ul>
<p><strong>注意</strong> connect 方法是异步的，意味着不等连接建立，方法执行就返回了。因此 channelFuture 对象中不能【立刻】获得到正确的 Channel 对象</p>
<p>实验如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(channelFuture.channel()); <span class="comment">// 1</span></span><br><span class="line">channelFuture.sync(); <span class="comment">// 2</span></span><br><span class="line">System.out.println(channelFuture.channel()); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>执行到 1 时，连接未建立，打印 <code>[id: 0x2e1884dd]</code></li>
<li>执行到 2 时，sync 方法是同步等待连接建立完成</li>
<li>执行到 3 时，连接肯定建立了，打印 <code>[id: 0x2e1884dd, L:/127.0.0.1:57191 - R:/127.0.0.1:8080]</code></li>
</ul>
<p>除了用 sync 方法可以让异步操作同步以外，还可以使用回调的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">System.out.println(channelFuture.channel()); <span class="comment">// 1</span></span><br><span class="line">channelFuture.addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">    System.out.println(future.channel()); <span class="comment">// 2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>执行到 1 时，连接未建立，打印 <code>[id: 0x749124ba]</code></li>
<li>ChannelFutureListener 会在连接建立时被调用（其中 operationComplete 方法），因此执行到 2 时，连接肯定建立了，打印 <code>[id: 0x749124ba, L:/127.0.0.1:57351 - R:/127.0.0.1:8080]</code></li>
</ul>
<h4 id="CloseFuture"><a href="#CloseFuture" class="headerlink" title="CloseFuture"></a>CloseFuture</h4><p>由于 channel的close方法关闭channel的时候是异步的，即不是在调用者线程中执行，这个时候如果想要在关闭之后执行一些清理操作或者其他操作时，就需要特殊处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloseFutureClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        NioEventLoopGroup group <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                .group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span> <span class="comment">// 在连接建立后被调用</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelFuture.sync().channel();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, channel);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;q&quot;</span>.equals(line)) &#123;</span><br><span class="line">                    channel.close(); <span class="comment">// close 异步操作 1s 之后</span></span><br><span class="line"><span class="comment">//                    log.debug(&quot;处理关闭之后的操作&quot;); // 不能在这里善后</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                channel.writeAndFlush(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;input&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 CloseFuture 对象， 1) 同步处理关闭， 2) 异步处理关闭</span></span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">closeFuture</span> <span class="operator">=</span> channel.closeFuture();</span><br><span class="line">        <span class="comment">/*log.debug(&quot;waiting close...&quot;);</span></span><br><span class="line"><span class="comment">        closeFuture.sync();</span></span><br><span class="line"><span class="comment">        log.debug(&quot;处理关闭之后的操作&quot;);*/</span></span><br><span class="line">        closeFuture.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;处理关闭之后的操作&quot;</span>);</span><br><span class="line">                group.shutdownGracefully();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="💡-异步提升的是什么"><a href="#💡-异步提升的是什么" class="headerlink" title="💡 异步提升的是什么"></a>💡 异步提升的是什么</h4><ul>
<li><p>有些同学看到这里会有疑问：为什么不在一个线程中去执行建立连接、去执行关闭 channel，那样不是也可以吗？非要用这么复杂的异步方式：比如一个线程发起建立连接，另一个线程去真正建立连接</p>
</li>
<li><p>还有同学会笼统地回答，因为 netty 异步方式用了多线程、多线程就效率高。其实这些认识都比较片面，多线程和异步所提升的效率并不是所认为的</p>
</li>
</ul>
<p>思考下面的场景，4 个医生给人看病，每个病人花费 20 分钟，而且医生看病的过程中是以病人为单位的，一个病人看完了，才能看下一个病人。假设病人源源不断地来，可以计算一下 4 个医生一天工作 8 小时，处理的病人总数是：<code>4 * 8 * 3 = 96</code></p>
<p><img src="source/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0044.png"></p>
<p>经研究发现，看病可以细分为四个步骤，经拆分后每个步骤需要 5 分钟，如下</p>
<p><img src="source/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0048.png"></p>
<p>因此可以做如下优化，只有一开始，医生 2、3、4 分别要等待 5、10、15 分钟才能执行工作，但只要后续病人源源不断地来，他们就能够满负荷工作，并且处理病人的能力提高到了 <code>4 * 8 * 12</code> 效率几乎是原来的四倍</p>
<p><img src="source/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0047.png"></p>
<p>要点</p>
<ul>
<li>单线程没法异步提高效率，必须配合多线程、多核 cpu 才能发挥异步的优势</li>
<li>异步并没有缩短响应时间，反而有所增加</li>
<li>合理进行任务拆分，也是利用异步的关键</li>
</ul>
<h3 id="3-3-Future-amp-Promise"><a href="#3-3-Future-amp-Promise" class="headerlink" title="3.3 Future &amp; Promise"></a>3.3 Future &amp; Promise</h3><p>在异步处理时，经常用到这两个接口</p>
<p>首先要说明 netty 中的 Future 与 jdk 中的 Future 同名，但是是两个接口，netty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展</p>
<ul>
<li>jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果</li>
<li>netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但都是要等任务结束</li>
<li>netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，只作为两个线程间传递结果的容器</li>
</ul>
<table>
<thead>
<tr>
<th>功能/名称</th>
<th>jdk Future</th>
<th>netty Future</th>
<th>Promise</th>
</tr>
</thead>
<tbody><tr>
<td>cancel</td>
<td>取消任务</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>isCanceled</td>
<td>任务是否取消</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>isDone</td>
<td>任务是否完成，不能区分成功失败</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>get</td>
<td>获取任务结果，阻塞等待</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>getNow</td>
<td>-</td>
<td>获取任务结果，非阻塞，还未产生结果时返回 null</td>
<td>-</td>
</tr>
<tr>
<td>await</td>
<td>-</td>
<td>等待任务结束，如果任务失败，不会抛异常，而是通过 isSuccess 判断</td>
<td>-</td>
</tr>
<tr>
<td>sync</td>
<td>-</td>
<td>等待任务结束，如果任务失败，抛出异常</td>
<td>-</td>
</tr>
<tr>
<td>isSuccess</td>
<td>-</td>
<td>判断任务是否成功</td>
<td>-</td>
</tr>
<tr>
<td>cause</td>
<td>-</td>
<td>获取失败信息，非阻塞，如果没有失败，返回null</td>
<td>-</td>
</tr>
<tr>
<td>addLinstener</td>
<td>-</td>
<td>添加回调，异步接收结果</td>
<td>-</td>
</tr>
<tr>
<td>setSuccess</td>
<td>-</td>
<td>-</td>
<td>设置成功结果</td>
</tr>
<tr>
<td>setFailure</td>
<td>-</td>
<td>-</td>
<td>设置失败结果</td>
</tr>
</tbody></table>
<h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><p>同步处理任务成功</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultEventLoop</span> <span class="variable">eventExecutors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoop</span>();</span><br><span class="line">DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(eventExecutors);</span><br><span class="line"></span><br><span class="line">eventExecutors.execute(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    log.debug(<span class="string">&quot;set success, &#123;&#125;&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    promise.setSuccess(<span class="number">10</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,promise.getNow()); <span class="comment">// 还没有结果</span></span><br><span class="line">log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,promise.get());</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">11:51:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...</span><br><span class="line">11:51:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null</span><br><span class="line">11:51:54 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set success, 10</span><br><span class="line">11:51:54 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - 10</span><br></pre></td></tr></table></figure>



<h4 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h4><p>异步处理任务成功</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultEventLoop</span> <span class="variable">eventExecutors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoop</span>();</span><br><span class="line">DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(eventExecutors);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置回调，异步接收结果</span></span><br><span class="line">promise.addListener(future -&gt; &#123;</span><br><span class="line">    <span class="comment">// 这里的 future 就是上面的 promise</span></span><br><span class="line">    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,future.getNow());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待 1000 后设置成功结果</span></span><br><span class="line">eventExecutors.execute(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    log.debug(<span class="string">&quot;set success, &#123;&#125;&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    promise.setSuccess(<span class="number">10</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">&quot;start...&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">11:49:30 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...</span><br><span class="line">11:49:31 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set success, 10</span><br><span class="line">11:49:31 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - 10</span><br></pre></td></tr></table></figure>



<h4 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h4><p>同步处理任务失败 - sync &amp; get</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultEventLoop</span> <span class="variable">eventExecutors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoop</span>();</span><br><span class="line">        DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(eventExecutors);</span><br><span class="line"></span><br><span class="line">        eventExecutors.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">RuntimeException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;error...&quot;</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;set failure, &#123;&#125;&quot;</span>, e.toString());</span><br><span class="line">            promise.setFailure(e);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, promise.getNow());</span><br><span class="line">        promise.get(); <span class="comment">// sync() 也会出现异常，只是 get 会再用 ExecutionException 包一层异常</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">12:11:07 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...</span><br><span class="line">12:11:07 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null</span><br><span class="line">12:11:08 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...</span><br><span class="line">Exception in thread &quot;main&quot; java.util.concurrent.ExecutionException: java.lang.RuntimeException: error...</span><br><span class="line">	at io.netty.util.concurrent.AbstractFuture.get(AbstractFuture.java:41)</span><br><span class="line">	at com.itcast.oio.DefaultPromiseTest2.main(DefaultPromiseTest2.java:34)</span><br><span class="line">Caused by: java.lang.RuntimeException: error...</span><br><span class="line">	at com.itcast.oio.DefaultPromiseTest2.lambda$main$0(DefaultPromiseTest2.java:27)</span><br><span class="line">	at io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)</span><br><span class="line">	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)</span><br><span class="line">	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span><br><span class="line">	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure>



<h4 id="例4"><a href="#例4" class="headerlink" title="例4"></a>例4</h4><p>同步处理任务失败 - await</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultEventLoop</span> <span class="variable">eventExecutors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoop</span>();</span><br><span class="line">DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(eventExecutors);</span><br><span class="line"></span><br><span class="line">eventExecutors.execute(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">RuntimeException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;error...&quot;</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;set failure, &#123;&#125;&quot;</span>, e.toString());</span><br><span class="line">    promise.setFailure(e);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, promise.getNow());</span><br><span class="line">promise.await(); <span class="comment">// 与 sync 和 get 区别在于，不会抛异常</span></span><br><span class="line">log.debug(<span class="string">&quot;result &#123;&#125;&quot;</span>, (promise.isSuccess() ? promise.getNow() : promise.cause()).toString());</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">12:18:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...</span><br><span class="line">12:18:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null</span><br><span class="line">12:18:54 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...</span><br><span class="line">12:18:54 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - result java.lang.RuntimeException: error...</span><br></pre></td></tr></table></figure>



<h4 id="例5"><a href="#例5" class="headerlink" title="例5"></a>例5</h4><p>异步处理任务失败</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultEventLoop</span> <span class="variable">eventExecutors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoop</span>();</span><br><span class="line">DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(eventExecutors);</span><br><span class="line"></span><br><span class="line">promise.addListener(future -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;result &#123;&#125;&quot;</span>, (promise.isSuccess() ? promise.getNow() : promise.cause()).toString());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">eventExecutors.execute(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">RuntimeException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;error...&quot;</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;set failure, &#123;&#125;&quot;</span>, e.toString());</span><br><span class="line">    promise.setFailure(e);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">&quot;start...&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">12:04:57 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...</span><br><span class="line">12:04:58 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...</span><br><span class="line">12:04:58 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - result java.lang.RuntimeException: error...</span><br></pre></td></tr></table></figure>



<h4 id="例6"><a href="#例6" class="headerlink" title="例6"></a>例6</h4><p>await 死锁检查</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultEventLoop</span> <span class="variable">eventExecutors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoop</span>();</span><br><span class="line">DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(eventExecutors);</span><br><span class="line"></span><br><span class="line">eventExecutors.submit(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        promise.await();</span><br><span class="line">        <span class="comment">// 注意不能仅捕获 InterruptedException 异常</span></span><br><span class="line">        <span class="comment">// 否则 死锁检查抛出的 BlockingOperationException 会继续向上传播</span></span><br><span class="line">        <span class="comment">// 而提交的任务会被包装为 PromiseTask，它的 run 方法中会 catch 所有异常然后设置为 Promise 的失败结果而不会抛出</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">eventExecutors.submit(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        promise.await();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">io.netty.util.concurrent.BlockingOperationException: DefaultPromise@47499c2a(incomplete)</span><br><span class="line">	at io.netty.util.concurrent.DefaultPromise.checkDeadLock(DefaultPromise.java:384)</span><br><span class="line">	at io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:212)</span><br><span class="line">	at com.itcast.oio.DefaultPromiseTest.lambda$main$0(DefaultPromiseTest.java:27)</span><br><span class="line">	at io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)</span><br><span class="line">	at io.netty.util.concurrent.PromiseTask.run(PromiseTask.java:73)</span><br><span class="line">	at io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)</span><br><span class="line">	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)</span><br><span class="line">	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span><br><span class="line">	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:745)</span><br><span class="line">io.netty.util.concurrent.BlockingOperationException: DefaultPromise@47499c2a(incomplete)</span><br><span class="line">	at io.netty.util.concurrent.DefaultPromise.checkDeadLock(DefaultPromise.java:384)</span><br><span class="line">	at io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:212)</span><br><span class="line">	at com.itcast.oio.DefaultPromiseTest.lambda$main$1(DefaultPromiseTest.java:36)</span><br><span class="line">	at io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)</span><br><span class="line">	at io.netty.util.concurrent.PromiseTask.run(PromiseTask.java:73)</span><br><span class="line">	at io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)</span><br><span class="line">	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)</span><br><span class="line">	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span><br><span class="line">	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:745)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-4-Handler-amp-Pipeline"><a href="#3-4-Handler-amp-Pipeline" class="headerlink" title="3.4 Handler &amp; Pipeline"></a>3.4 Handler &amp; Pipeline</h3><p>ChannelHandler 用来处理 Channel 上的各种事件，分为<strong>入站、出站</strong>两种。所有 ChannelHandler 被连成一串，就是 Pipeline</p>
<ul>
<li>入站处理器通常是 <strong>ChannelInboundHandlerAdapter</strong> 的子类，主要用来读取客户端数据，写回结果</li>
<li>出站处理器通常是 <strong>ChannelOutboundHandlerAdapter</strong> 的子类，主要对写回结果进行加工</li>
</ul>
<p>打个比喻，每个 Channel 是一个产品的加工车间，Pipeline 是车间中的流水线，ChannelHandler 就是流水线上的各道工序，而后面要讲的 ByteBuf 是原材料，经过很多工序的加工：先经过一道道入站工序，再经过一道道出站工序最终变成产品</p>
<p>先搞清楚顺序，服务端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">1</span>);</span><br><span class="line">                    ctx.fireChannelRead(msg); <span class="comment">// 1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">2</span>);</span><br><span class="line">                    ctx.fireChannelRead(msg); <span class="comment">// 2</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">3</span>);</span><br><span class="line">                    ctx.channel().write(msg); <span class="comment">// 3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, </span></span><br><span class="line"><span class="params">                                  ChannelPromise promise)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">4</span>);</span><br><span class="line">                    ctx.write(msg, promise); <span class="comment">// 4</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, </span></span><br><span class="line"><span class="params">                                  ChannelPromise promise)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">5</span>);</span><br><span class="line">                    ctx.write(msg, promise); <span class="comment">// 5</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, </span></span><br><span class="line"><span class="params">                                  ChannelPromise promise)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">6</span>);</span><br><span class="line">                    ctx.write(msg, promise); <span class="comment">// 6</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .bind(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>)</span><br><span class="line">    .addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">        future.channel().writeAndFlush(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>服务器端打印：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>可以看到，ChannelInboundHandlerAdapter 是按照 addLast 的顺序执行的，而 ChannelOutboundHandlerAdapter 是按照 addLast 的逆序执行的。ChannelPipeline 的实现是一个 ChannelHandlerContext（包装了 ChannelHandler） 组成的双向链表</p>
<p><img src="source/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0008.png"></p>
<ul>
<li>入站处理器中，ctx.fireChannelRead(msg) 是 <strong>调用下一个入站处理器</strong><ul>
<li>如果注释掉 1 处代码，则仅会打印 1</li>
<li>如果注释掉 2 处代码，则仅会打印 1 2</li>
</ul>
</li>
<li>3 处的 ctx.channel().write(msg) 会 <strong>从尾部开始触发</strong> 后续出站处理器的执行<ul>
<li>如果注释掉 3 处代码，则仅会打印 1 2 3</li>
</ul>
</li>
<li>类似的，出站处理器中，ctx.write(msg, promise) 的调用也会 <strong>触发上一个出站处理器</strong><ul>
<li>如果注释掉 6 处代码，则仅会打印 1 2 3 6</li>
</ul>
</li>
<li>ctx.channel().write(msg) vs ctx.write(msg)<ul>
<li>都是触发出站处理器的执行</li>
<li>ctx.channel().write(msg) 从尾部开始查找出站处理器</li>
<li>ctx.write(msg) 是从当前节点找上一个出站处理器</li>
<li>3 处的 ctx.channel().write(msg) 如果改为 ctx.write(msg) 仅会打印 1 2 3，因为节点3 之前没有其它出站处理器了</li>
<li>6 处的 ctx.write(msg, promise) 如果改为 ctx.channel().write(msg) 会打印 1 2 3 6 6 6… 因为 ctx.channel().write() 是从尾部开始查找，结果又是节点6 自己</li>
</ul>
</li>
</ul>
<p>图1 - 服务端 pipeline 触发的原始流程，图中数字代表了处理步骤的先后次序</p>
<p><img src="source/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0009.png"></p>
<p><strong>netty内部提供的测试Channel： EmbeddedChannel</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBufAllocator;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOutboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPromise;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.embedded.EmbeddedChannel;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestEmbeddedChannel</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 先创建几个handler</span></span><br><span class="line">        <span class="type">ChannelInboundHandlerAdapter</span> <span class="variable">h1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;h1&quot;</span>);</span><br><span class="line">                <span class="built_in">super</span>.channelRead(ctx, msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChannelInboundHandlerAdapter</span> <span class="variable">h2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;h2&quot;</span>);</span><br><span class="line">                <span class="built_in">super</span>.channelRead(ctx, msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChannelOutboundHandlerAdapter</span> <span class="variable">h3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;h3&quot;</span>);</span><br><span class="line">                <span class="built_in">super</span>.write(ctx, msg, promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChannelOutboundHandlerAdapter</span> <span class="variable">h4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;h4&quot;</span>);</span><br><span class="line">                <span class="built_in">super</span>.write(ctx, msg, promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">EmbeddedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmbeddedChannel</span>(h1, h2, h3, h4);</span><br><span class="line">        <span class="comment">// 模拟入站操作</span></span><br><span class="line">        channel.writeInbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class="string">&quot;hello&quot;</span>.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">        <span class="comment">// 模拟出站操作</span></span><br><span class="line">        channel.writeOutbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class="string">&quot;world&quot;</span>.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-5-ByteBuf"><a href="#3-5-ByteBuf" class="headerlink" title="3.5 ByteBuf"></a>3.5 ByteBuf</h3><p>是对字节数据的封装</p>
<h4 id="1）创建"><a href="#1）创建" class="headerlink" title="1）创建"></a>1）创建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">10</span>);</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure>

<p>上面代码创建了一个默认的 ByteBuf（池化基于直接内存的 ByteBuf），初始容量是 10</p>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read index:0 write index:0 capacity:10</span><br></pre></td></tr></table></figure>

<p>其中 log 方法参考如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(ByteBuf buffer)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> buffer.readableBytes();</span><br><span class="line">    <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> length / <span class="number">16</span> + (length % <span class="number">15</span> == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>) + <span class="number">4</span>;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(rows * <span class="number">80</span> * <span class="number">2</span>)</span><br><span class="line">        .append(<span class="string">&quot;read index:&quot;</span>).append(buffer.readerIndex())</span><br><span class="line">        .append(<span class="string">&quot; write index:&quot;</span>).append(buffer.writerIndex())</span><br><span class="line">        .append(<span class="string">&quot; capacity:&quot;</span>).append(buffer.capacity())</span><br><span class="line">        .append(NEWLINE);</span><br><span class="line">    appendPrettyHexDump(buf, buffer);</span><br><span class="line">    System.out.println(buf.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2）直接内存-vs-堆内存"><a href="#2）直接内存-vs-堆内存" class="headerlink" title="2）直接内存 vs 堆内存"></a>2）直接内存 vs 堆内存</h4><p>可以使用下面的代码来创建池化基于堆的 ByteBuf</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.heapBuffer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>也可以使用下面的代码来创建池化基于直接内存的 ByteBuf</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.directBuffer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用</li>
<li>直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放</li>
</ul>
<h4 id="3）池化-vs-非池化"><a href="#3）池化-vs-非池化" class="headerlink" title="3）池化 vs 非池化"></a>3）池化 vs 非池化</h4><p>池化的最大意义在于可以重用 ByteBuf，优点有</p>
<ul>
<li>没有池化，则每次都得创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力</li>
<li>有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率</li>
<li>高并发时，池化功能更节约内存，减少内存溢出的可能</li>
</ul>
<p>池化功能是否开启，可以通过下面的系统环境变量来设置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dio.netty.allocator.type=&#123;unpooled|pooled&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>4.1 以后，非 Android 平台默认启用池化实现，Android 平台启用非池化实现</li>
<li>4.1 之前，池化功能还不成熟，默认是非池化实现</li>
</ul>
<blockquote>
<p> 个人理解：</p>
<p>池化后，ByteBuf就只需要分配一次，然后在以后使用ByteBuf的时候就直接使用这个分配好的Buf即可，用完之后及时归还内存空间，达到复用ByteBuf的目的，这样就可以节省Buf创建与回收的时间</p>
</blockquote>
<h4 id="4）组成"><a href="#4）组成" class="headerlink" title="4）组成"></a>4）组成</h4><p>ByteBuf 由四部分组成</p>
<p><img src="source/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0010.png"></p>
<p>最开始读写指针都在 0 位置</p>
<blockquote>
<p>与NIO中的ByteBuffer的区别：</p>
<ul>
<li>NIO中的ByteBuffer，读写共用一个position指针，读之前需要调用<code>flip</code>方法切换到读模式，写之前需要调用<code>clear/compact</code>方法切换到写模式</li>
<li>Netty中的ByteBuf对于NIO中的ByteBuffer有一定的增强实现，使用<code>read index</code>和<code>write index</code>双指针实现了，读或者写不用切换模式，而且还支持buffer的动态扩容。</li>
</ul>
</blockquote>
<h4 id="5）写入"><a href="#5）写入" class="headerlink" title="5）写入"></a>5）写入</h4><p>方法列表，省略一些不重要的方法</p>
<table>
<thead>
<tr>
<th>方法签名</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>writeBoolean(boolean value)</td>
<td>写入 boolean 值</td>
<td>用一字节 01|00 代表 true|false</td>
</tr>
<tr>
<td>writeByte(int value)</td>
<td>写入 byte 值</td>
<td></td>
</tr>
<tr>
<td>writeShort(int value)</td>
<td>写入 short 值</td>
<td></td>
</tr>
<tr>
<td>writeInt(int value)</td>
<td>写入 int 值</td>
<td>Big Endian，即 0x250，写入后 00 00 02 50<br />先写高位，再写低位</td>
</tr>
<tr>
<td>writeIntLE(int value)</td>
<td>写入 int 值</td>
<td>Little Endian，即 0x250，写入后 50 02 00 00</td>
</tr>
<tr>
<td>writeLong(long value)</td>
<td>写入 long 值</td>
<td></td>
</tr>
<tr>
<td>writeChar(int value)</td>
<td>写入 char 值</td>
<td></td>
</tr>
<tr>
<td>writeFloat(float value)</td>
<td>写入 float 值</td>
<td></td>
</tr>
<tr>
<td>writeDouble(double value)</td>
<td>写入 double 值</td>
<td></td>
</tr>
<tr>
<td>writeBytes(ByteBuf src)</td>
<td>写入 netty 的 ByteBuf</td>
<td></td>
</tr>
<tr>
<td>writeBytes(byte[] src)</td>
<td>写入 byte[]</td>
<td></td>
</tr>
<tr>
<td>writeBytes(ByteBuffer src)</td>
<td>写入 nio 的 ByteBuffer</td>
<td>可以将NIO中的ByteBuffer写入到netty中的ByteBuf中</td>
</tr>
<tr>
<td>int writeCharSequence(CharSequence sequence, Charset charset)</td>
<td>写入字符串</td>
<td>String、StringBuffer、StringBuilder的父类都是CharSequence，所以可以直接将字符串写入到ByteBuf中</td>
</tr>
</tbody></table>
<blockquote>
<p>注意</p>
<ul>
<li>这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用</li>
<li>网络传输，默认习惯是 <strong>Big Endian</strong></li>
</ul>
</blockquote>
<p>先写入 4 个字节</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buffer.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure>

<p>结果是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">read index:0 write index:4 capacity:10</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04                                     |....            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>再写入一个 int 整数，也是 4 个字节</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buffer.writeInt(<span class="number">5</span>);</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure>

<p>结果是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">read index:0 write index:8 capacity:10</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 00 00 00 05                         |........        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>



<p>还有一类方法是 set 开头的一系列方法，也可以写入数据，但不会改变写指针位置</p>
<h4 id="6）扩容"><a href="#6）扩容" class="headerlink" title="6）扩容"></a>6）扩容</h4><p>再写入一个 int 整数时，容量不够了（初始容量是 10），这时会引发扩容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buffer.writeInt(<span class="number">6</span>);</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure>

<p><strong>扩容规则是</strong></p>
<ul>
<li><font color=red>如何写入后数据大小未超过 512，则选择下一个 16 的整数倍，例如写入后大小为 12 ，则扩容后 capacity 是 16</font><ul>
<li>比如：16、32、 48、 64 、80 。。。。</li>
</ul>
</li>
<li><font color=red>如果写入后数据大小超过 512，则选择下一个 2^n，例如写入后大小为 513，则扩容后 capacity 是 2^10=1024（2^9=512 已经不够了）</font></li>
<li><font color=red>扩容不能超过 max capacity 会报错</font></li>
</ul>
<p>结果是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">read index:0 write index:12 capacity:16</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 00 00 00 05 00 00 00 06             |............    |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>



<h4 id="7）读取"><a href="#7）读取" class="headerlink" title="7）读取"></a>7）读取</h4><p>例如读了 4 次，每次一个字节</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure>

<p>读过的内容，就属于废弃部分了，再读只能读那些尚未读取的部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">read index:4 write index:12 capacity:16</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 00 00 05 00 00 00 06                         |........        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p><font color=red>如果需要重复读取 int 整数 5，怎么办？</font></p>
<p><strong>可以在 read 前先做个标记 mark</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buffer.markReaderIndex();  <span class="comment">// 在读之前，做一个读指针的标记mark， 虽然读取之后，读指针会继续往后移动，但是可以通过resetReaderIndex恢复读指针的位置</span></span><br><span class="line">System.out.println(buffer.readInt());</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">read index:8 write index:12 capacity:16</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 00 00 06                                     |....            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>这时要重复读取的话，重置到标记位置 reset</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buffer.resetReaderIndex();</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure>

<p>这时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">read index:4 write index:12 capacity:16</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 00 00 05 00 00 00 06                         |........        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p><strong>还有种办法是采用 get 开头的一系列方法，这些方法不会改变 read index</strong></p>
<h4 id="8）retain-amp-release"><a href="#8）retain-amp-release" class="headerlink" title="8）retain &amp; release"></a>8）retain &amp; release</h4><p><strong>由于 Netty 中有堆外内存的 ByteBuf 实现，堆外内存最好是手动来释放，而不是等 GC 垃圾回收。</strong></p>
<ul>
<li><font color=green>UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可</font></li>
<li><font color=green>UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存</font></li>
<li><font color=green>PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存</font></li>
</ul>
<blockquote>
<p>回收内存的源码实现，请关注下面方法的不同实现</p>
<p><code>protected abstract void deallocate()</code></p>
</blockquote>
<p>Netty 这里采用了引用计数法来控制回收内存，每个 ByteBuf 都实现了 ReferenceCounted 接口</p>
<ul>
<li>每个 ByteBuf 对象的初始计数为 1</li>
<li>调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收</li>
<li>调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收</li>
<li>当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用</li>
</ul>
<p>谁来负责 release 呢？</p>
<p>不是我们想象的（一般情况下）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ...</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    buf.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请思考，因为 pipeline 的存在，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果在 finally 中 release 了，就失去了传递性（当然，如果在这个 ChannelHandler 内这个 ByteBuf 已完成了它的使命，那么便无须再传递）</p>
<p>基本规则是，<strong>谁是最后使用者，谁负责 release</strong>，详细分析如下</p>
<ul>
<li>起点，对于 NIO 实现来讲，在 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read 方法中首次创建 ByteBuf 放入 pipeline（line 163 pipeline.fireChannelRead(byteBuf)）</li>
<li><strong>入站 ByteBuf 处理原则</strong><ul>
<li>对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release</li>
<li>将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，必须 release</li>
<li>如果不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release</li>
<li>注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release</li>
<li>假设消息一直向后传，那么 TailContext (<strong>管道的尾处理器Tail</strong>)会负责释放未处理消息（原始的 ByteBuf）</li>
</ul>
</li>
<li><strong>出站 ByteBuf 处理原则</strong><ul>
<li>出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext （<strong>管道的头处理器Head</strong>）flush 后 release</li>
</ul>
</li>
<li>异常处理原则<ul>
<li>有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以循环调用 release 直到返回 true</li>
</ul>
</li>
</ul>
<blockquote>
<p>tip:</p>
<p>Ctrl+F12 ： 查看当前文件的结构：File Structure</p>
<p>Ctrl+Alt+B（鼠标左键）： 查找抽象类中的抽象方法的具体实现</p>
</blockquote>
<p>TailContext 释放未处理消息逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.channel.DefaultChannelPipeline#onUnhandledInboundMessage(java.lang.Object)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onUnhandledInboundMessage</span><span class="params">(Object msg)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        logger.debug(</span><br><span class="line">            <span class="string">&quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. &quot;</span> +</span><br><span class="line">            <span class="string">&quot;Please check your pipeline configuration.&quot;</span>, msg);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.util.ReferenceCountUtil#release(java.lang.Object)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(Object msg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> ReferenceCounted) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((ReferenceCounted) msg).release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>HeadContext 释放未处理消息逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> &#123;</span><br><span class="line">    unsafe.write(msg, promise);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractChannel</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(Object msg, ChannelPromise promise)</span> &#123;</span><br><span class="line">    assertEventLoop();</span><br><span class="line"></span><br><span class="line">    <span class="type">ChannelOutboundBuffer</span> <span class="variable">outboundBuffer</span> <span class="operator">=</span> <span class="built_in">this</span>.outboundBuffer;  <span class="comment">// 出站的缓冲区</span></span><br><span class="line">    <span class="keyword">if</span> (outboundBuffer == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If the outboundBuffer is null we know the channel was closed and so</span></span><br><span class="line">        <span class="comment">// need to fail the future right away. If it is not null the handling of the rest</span></span><br><span class="line">        <span class="comment">// will be done in flush0()</span></span><br><span class="line">        <span class="comment">// See https://github.com/netty/netty/issues/2362</span></span><br><span class="line">        safeSetFailure(promise, newClosedChannelException(initialCloseCause));</span><br><span class="line">        <span class="comment">// release message now to prevent resource-leak</span></span><br><span class="line">        ReferenceCountUtil.release(msg);  <span class="comment">// 如果没有出站缓冲区，就释放一次引用计数</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        msg = filterOutboundMessage(msg);</span><br><span class="line">        size = pipeline.estimatorHandle().size(msg);</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    outboundBuffer.addMessage(msg, size, promise);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="9）slice"><a href="#9）slice" class="headerlink" title="9）slice"></a>9）slice</h4><p>【零拷贝】的体现之一，对原始 ByteBuf 进行切片成多个 ByteBuf，切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存，切片后的 <code>slice</code> ByteBuf <strong>维护独立的 read，write 指针</strong></p>
<p><img src="source/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0011.png"></p>
<p>例，原始 ByteBuf 进行一些初始操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">origin</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">10</span>);</span><br><span class="line">origin.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">origin.readByte();</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(origin));</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 02 03 04                                        |...             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>这时调用 slice 进行切片，无参 slice 是从原始 ByteBuf 的 read index 到 write index 之间的内容进行切片，切片后的 max capacity 被固定为这个区间的大小，因此不能追加 write</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">slice</span> <span class="operator">=</span> origin.slice();</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(slice));</span><br><span class="line"><span class="comment">// slice.writeByte(5); 如果执行，会报 IndexOutOfBoundsException 异常</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 02 03 04                                        |...             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>如果原始 ByteBuf 再次读操作（又读了一个字节）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">origin.readByte();</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(origin));</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 03 04                                           |..              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>这时的 slice 不受影响，因为它有独立的读写指针</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ByteBufUtil.prettyHexDump(slice));</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 02 03 04                                        |...             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>如果 slice 的内容发生了更改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slice.setByte(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(slice));</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 02 03 05                                        |...             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>这时，原始 ByteBuf 也会受影响，因为底层都是同一块内存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ByteBufUtil.prettyHexDump(origin));</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 03 05                                           |..              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>



<h4 id="10）duplicate"><a href="#10）duplicate" class="headerlink" title="10）duplicate"></a>10）duplicate</h4><p>【零拷贝】的体现之一，就好比截取了原始 ByteBuf 所有内容，并且没有 max capacity 的限制，也是与原始 ByteBuf 使用同一块底层内存，只是读写指针是独立的</p>
<p><img src="source/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0012.png"></p>
<h4 id="11）copy"><a href="#11）copy" class="headerlink" title="11）copy"></a>11）copy</h4><p>会将底层内存数据进行深拷贝，因此无论读写，都与原始 ByteBuf 无关</p>
<h4 id="12）CompositeByteBuf"><a href="#12）CompositeByteBuf" class="headerlink" title="12）CompositeByteBuf"></a>12）CompositeByteBuf</h4><p>【零拷贝】的体现之一，可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf，避免拷贝</p>
<p>有两个 ByteBuf 如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf1</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf1.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf2</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf2.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;);</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf1));</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf2));</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05                                  |.....           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 06 07 08 09 0a                                  |.....           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>现在需要一个新的 ByteBuf，内容来自于刚才的 buf1 和 buf2，如何实现？</p>
<p>方法1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf3</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT</span><br><span class="line">    .buffer(buf1.readableBytes()+buf2.readableBytes());</span><br><span class="line">buf3.writeBytes(buf1);</span><br><span class="line">buf3.writeBytes(buf2);</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf3));</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>这种方法好不好？回答是不太好，因为进行了数据的内存复制操作</p>
<p>方法2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CompositeByteBuf</span> <span class="variable">buf3</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.compositeBuffer();</span><br><span class="line"><span class="comment">// true 表示增加新的 ByteBuf 自动递增 write index, 否则 write index 会始终为 0</span></span><br><span class="line">buf3.addComponents(<span class="literal">true</span>, buf1, buf2);</span><br></pre></td></tr></table></figure>

<p>结果是一样的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>CompositeByteBuf 是一个组合的 ByteBuf，它内部维护了一个 Component 数组，每个 Component 管理一个 ByteBuf，记录了这个 ByteBuf 相对于整体偏移量等信息，代表着整体中某一段的数据。</p>
<ul>
<li>优点，对外是一个虚拟视图，组合这些 ByteBuf 不会产生内存复制</li>
<li>缺点，复杂了很多，多次操作会带来性能的损耗</li>
</ul>
<h4 id="13）Unpooled"><a href="#13）Unpooled" class="headerlink" title="13）Unpooled"></a>13）Unpooled</h4><p>Unpooled 是一个工具类，类如其名，提供了非池化的 ByteBuf 创建、组合、复制等操作</p>
<p>这里仅介绍其跟【零拷贝】相关的 wrappedBuffer 方法，可以用来包装 ByteBuf</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf1</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf1.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf2</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf2.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当包装 ByteBuf 个数超过一个时, 底层使用了 CompositeByteBuf</span></span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf3</span> <span class="operator">=</span> Unpooled.wrappedBuffer(buf1, buf2);</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf3));</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>也可以用来包装普通字节数组，底层也不会有拷贝操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf4</span> <span class="operator">=</span> Unpooled.wrappedBuffer(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, <span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;);</span><br><span class="line">System.out.println(buf4.getClass());</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf4));</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class io.netty.buffer.CompositeByteBuf</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05 06                               |......          |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>



<h4 id="💡-ByteBuf-优势"><a href="#💡-ByteBuf-优势" class="headerlink" title="💡 ByteBuf 优势"></a>💡 ByteBuf 优势</h4><ol>
<li><p>池化 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能</p>
</li>
<li><p>读写指针分离，不需要像 ByteBuffer 一样切换读写模式</p>
</li>
<li><p>可以自动扩容</p>
</li>
<li><p>支持链式调用，使用更流畅</p>
</li>
<li><p>很多地方体现<strong>零拷贝</strong>，例如 slice、duplicate、CompositeByteBuf</p>
</li>
</ol>
<h2 id="4-双向通信"><a href="#4-双向通信" class="headerlink" title="4. 双向通信"></a>4. 双向通信</h2><h3 id="4-1-练习"><a href="#4-1-练习" class="headerlink" title="4.1 练习"></a>4.1 练习</h3><p>实现一个 echo server</p>
<p>编写 server</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                    System.out.println(buffer.toString(Charset.defaultCharset()));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 建议使用 ctx.alloc() 创建 ByteBuf</span></span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">response</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                    response.writeBytes(buffer);</span><br><span class="line">                    ctx.writeAndFlush(response);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 思考：需要释放 buffer 吗</span></span><br><span class="line">                    <span class="comment">// 思考：需要释放 response 吗</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).bind(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure>

<p>编写 client</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(group)</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                    System.out.println(buffer.toString(Charset.defaultCharset()));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 思考：需要释放 buffer 吗</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>).sync().channel();</span><br><span class="line"></span><br><span class="line">channel.closeFuture().addListener(future -&gt; &#123;</span><br><span class="line">    group.shutdownGracefully();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;q&quot;</span>.equals(line)) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        channel.writeAndFlush(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>



<h3 id="💡-读和写的误解"><a href="#💡-读和写的误解" class="headerlink" title="💡 读和写的误解"></a>💡 读和写的误解</h3><p>我最初在认识上有这样的误区，认为只有在 netty，nio 这样的多路复用 IO 模型时，读写才不会相互阻塞，才可以实现高效的双向通信，但实际上，Java Socket 是全双工的：在任意时刻，线路上存在<code>A 到 B</code> 和 <code>B 到 A</code> 的双向信号传输。即使是阻塞 IO，读和写是可以同时进行的，只要分别采用读线程和写线程即可，读不会阻塞写、写也不会阻塞读</p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(s.getInputStream()));</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    System.out.println(reader.readLine());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(s.getOutputStream()));</span><br><span class="line">                <span class="comment">// 例如在这个位置加入 thread 级别断点，可以发现即使不写入数据，也不妨碍前面线程读取客户端数据</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    writer.write(String.valueOf(i));</span><br><span class="line">                    writer.newLine();</span><br><span class="line">                    writer.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(s.getInputStream()));</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    System.out.println(reader.readLine());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(s.getOutputStream()));</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    writer.write(String.valueOf(i));</span><br><span class="line">                    writer.newLine();</span><br><span class="line">                    writer.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="三-Netty-进阶"><a href="#三-Netty-进阶" class="headerlink" title="三. Netty 进阶"></a>三. Netty 进阶</h1><h2 id="1-粘包与半包"><a href="#1-粘包与半包" class="headerlink" title="1. 粘包与半包"></a>1. 粘包与半包</h2><h3 id="1-1-粘包现象"><a href="#1-1-粘包现象" class="headerlink" title="1.1 粘包现象"></a>1.1 粘包现象</h3><p>服务端代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldServer</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldServer.class);</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            serverBootstrap.group(boss, worker);</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;connected &#123;&#125;&quot;</span>, ctx.channel());</span><br><span class="line">                            <span class="built_in">super</span>.channelActive(ctx);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;disconnect &#123;&#125;&quot;</span>, ctx.channel());</span><br><span class="line">                            <span class="built_in">super</span>.channelInactive(ctx);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;&#123;&#125; binding...&quot;</span>, channelFuture.channel());</span><br><span class="line">            channelFuture.sync();</span><br><span class="line">            log.debug(<span class="string">&quot;&#123;&#125; bound...&quot;</span>, channelFuture.channel());</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;server error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">            log.debug(<span class="string">&quot;stoped&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HelloWorldServer</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端代码希望发送 10 个消息，每个消息是 16 字节</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;connetted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">                            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                                <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                                buffer.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;);</span><br><span class="line">                                ctx.writeAndFlush(buffer);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器端的某次输出，可以看到一次就接收了 160 个字节，而非分 10 次接收</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5] binding...</span><br><span class="line">08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5, L:/0:0:0:0:0:0:0:0:8080] bound...</span><br><span class="line">08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] REGISTERED</span><br><span class="line">08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] ACTIVE</span><br><span class="line">08:24:55 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177]</span><br><span class="line">08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] READ: 160B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000010| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000020| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000030| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000040| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000050| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000060| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000070| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000080| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000090| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] READ COMPLETE</span><br></pre></td></tr></table></figure>



<h3 id="1-2-半包现象"><a href="#1-2-半包现象" class="headerlink" title="1.2 半包现象"></a>1.2 半包现象</h3><p>客户端代码希望发送 1 个消息，这个消息是 160 字节，代码改为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    buffer.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line">ctx.writeAndFlush(buffer);</span><br></pre></td></tr></table></figure>

<p>为现象明显，服务端修改一下接收缓冲区，其它代码不变</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.option(ChannelOption.SO_RCVBUF, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>服务器端的某次输出，可以看到接收的消息被分为两节，第一次 20 字节，第二次 140 字节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84] binding...</span><br><span class="line">08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84, L:/0:0:0:0:0:0:0:0:8080] bound...</span><br><span class="line">08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] REGISTERED</span><br><span class="line">08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] ACTIVE</span><br><span class="line">08:44:23 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221]</span><br><span class="line">08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ: 20B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000010| 00 01 02 03                                     |....            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ COMPLETE</span><br><span class="line">08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ: 140B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000020| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000030| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000040| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000050| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000060| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000070| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000080| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f             |............    |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ COMPLETE</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong></p>
<p>serverBootstrap.option(ChannelOption.SO_RCVBUF, 10) 影响的底层接收缓冲区（即滑动窗口）大小，仅决定了 netty 读取的最小单位，netty 实际每次读取的一般是它的整数倍</p>
</blockquote>
<h3 id="1-3-现象分析"><a href="#1-3-现象分析" class="headerlink" title="1.3 现象分析"></a>1.3 现象分析</h3><p>粘包</p>
<ul>
<li>现象，发送 abc def，接收 abcdef</li>
<li>原因<ul>
<li>应用层：<strong>接收方 ByteBuf 设置太大（Netty 默认 1024）</strong></li>
<li>滑动窗口：假设发送方 256 bytes 表示一个完整报文，<strong>但由于接收方处理不及时且窗口大小足够大</strong>，这 256 bytes 字节就会缓冲在接收方的滑动窗口中，当滑动窗口中缓冲了多个报文就会粘包</li>
<li>Nagle 算法：会造成粘包<ul>
<li> <font color=green>IP报文存在20个字节的报头， tcp报文会在IP报文的基础上还会添加20个字节的报头</font></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>半包</p>
<ul>
<li>现象，发送 abcdef，接收 abc def</li>
<li>原因<ul>
<li>应用层：<strong>接收方 ByteBuf 小于实际发送数据量</strong></li>
<li>滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时放不下了，只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</li>
<li>MSS 限制：当发送的数据<strong>超过 MSS 限制后</strong>，会将数据切分发送，就会造成半包</li>
</ul>
</li>
</ul>
<p>本质是因为 TCP 是流式协议，消息无边界</p>
<p>IP报文分片是因为<strong>MTU</strong>，TCP报文分段是因为<strong>MSS</strong></p>
<blockquote>
<p>滑动窗口</p>
<ul>
<li><p>TCP 以一个段（segment）为单位，每发送一个段就需要进行一次确认应答（ack）处理，但如果这么做，缺点是包的往返时间越长性能就越差</p>
<p><img src="source/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0049.png"></p>
</li>
</ul>
<ul>
<li><p>为了解决此问题，引入了窗口概念，窗口大小即决定了无需等待应答而可以继续发送的数据最大值</p>
<p><img src="source/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/0051.png"></p>
</li>
<li><p>窗口实际就起到一个<strong>缓冲区</strong>的作用，同时也能起到<strong>流量控制</strong>的作用</p>
<ul>
<li>图中深色的部分即要发送的数据，高亮的部分即窗口</li>
<li>窗口内的数据才允许被发送，当应答未到达前，窗口必须停止滑动</li>
<li>如果 1001~2000 这个段的数据 ack 回来了，窗口就可以向前滑动</li>
<li><strong>接收方也会维护一个窗口，只有落在窗口内的数据才能允许接收</strong></li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p> <strong>MSS 限制</strong></p>
<ul>
<li><p><strong>链路层对一次能够发送的最大数据有限制</strong>，这个限制称之为 <strong>MTU</strong>（maximum transmission unit），不同的链路设备的 <strong>MTU</strong> 值也有所不同，例如</p>
</li>
<li><p>以太网的 MTU 是 1500</p>
</li>
<li><p>FDDI（光纤分布式数据接口）的 MTU 是 4352</p>
</li>
<li><p>本地回环地址的 MTU 是 65535 - 本地测试不走网卡</p>
</li>
<li><p>MSS 是最大段长度（maximum segment size），它是 MTU 刨去 tcp 头和 ip 头后剩余能够作为数据传输的字节数</p>
</li>
<li><p>ipv4 tcp 头占用 20 bytes，ip 头占用 20 bytes，因此以太网 MSS 的值为 1500 - 40 = 1460</p>
</li>
<li><p>TCP 在传递大量数据时，会按照 MSS 大小将数据进行分割发送</p>
</li>
<li><p>MSS 的值在三次握手时通知对方自己 MSS 的值，然后在两者之间选择一个小值作为 MSS</p>
</li>
</ul>
  <img src="../../../../../../陆宇的学习资料/Java框架/Netty/Netty教程源码资料/讲义/Netty-讲义/img/0031.jpg" style="zoom:50%;" />
</blockquote>
<blockquote>
<p>Nagle 算法</p>
<ul>
<li>即使发送一个字节，也需要加入 tcp 头和 ip 头，也就是总字节数会使用 41 bytes，非常不经济。因此为了提高网络利用率，tcp 希望尽可能发送足够大的数据，这就是 Nagle 算法产生的缘由</li>
<li>该算法是指发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送<ul>
<li>如果 SO_SNDBUF 的数据达到 MSS，则需要发送</li>
<li>如果 SO_SNDBUF 中含有 FIN（表示需要连接关闭）这时将剩余数据发送，再关闭</li>
<li>如果 TCP_NODELAY = true，则需要发送</li>
<li>已发送的数据都收到 ack 时，则需要发送</li>
<li>上述条件不满足，但发生超时（一般为 200ms）则需要发送</li>
<li>除上述情况，延迟发送</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="1-4-解决方案"><a href="#1-4-解决方案" class="headerlink" title="1.4 解决方案"></a>1.4 解决方案</h3><ol>
<li><strong>短链接</strong><ul>
<li>发一个包建立一次连接，这样连接建立到连接断开之间就是消息的边界，缺点效率太低</li>
</ul>
</li>
<li><strong>固定消息长度</strong><ul>
<li>每一条消息采用固定长度，缺点浪费空间</li>
</ul>
</li>
<li><strong>分隔符</strong><ul>
<li>每一条消息采用分隔符，例如 \n，缺点需要转义 </li>
</ul>
</li>
<li><strong>head body</strong><ul>
<li>每一条消息分为 head 和 body，head 中包含 body 的长度  </li>
</ul>
</li>
</ol>
<h4 id="方法1，短链接"><a href="#方法1，短链接" class="headerlink" title="方法1，短链接"></a>方法1，短链接</h4><p>以解决粘包为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 分 10 次发送</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            send();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;conneted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                            buffer.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;);</span><br><span class="line">                            ctx.writeAndFlush(buffer);</span><br><span class="line">                            <span class="comment">// 发完即关</span></span><br><span class="line">                            ctx.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出，略</p>
<blockquote>
<p>半包用这种办法还是不好解决，因为接收方的缓冲区大小是有限的</p>
</blockquote>
<p>Server端调小netty的接收缓冲区</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.AdaptiveRecvByteBufAllocator;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LogLevel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldServer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.group(boss, worker);</span><br><span class="line">            <span class="comment">// option是全局的配置，调整系统的接收缓冲器（滑动窗口）</span></span><br><span class="line"><span class="comment">//            serverBootstrap.option(ChannelOption.SO_RCVBUF, 10);        // 将服务器端的接收缓冲区设置小点，就会出现半包现象, 这个参数即可配置TCP 传输过程中的 滑动窗口的大小</span></span><br><span class="line">            <span class="comment">// childOption 是调整Netty的接收缓冲区（byteBuf）</span></span><br><span class="line">            serverBootstrap.childOption(ChannelOption.RCVBUF_ALLOCATOR, <span class="keyword">new</span> <span class="title class_">AdaptiveRecvByteBufAllocator</span>(<span class="number">16</span>,<span class="number">16</span>,<span class="number">16</span>));</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;客户端：&quot;</span>+ch.remoteAddress()+<span class="string">&quot; 连接到服务器端：&quot;</span>+ ch.localAddress());</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            log.error(<span class="string">&quot;server error&quot;</span>,e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HelloWorldServer</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client端每次发送18个字节</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO 短连接解决 黏包现象</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            send();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.group(group)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                                <span class="comment">// 会在连接 Channel 建立成功之后，会触发active 事件</span></span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="comment">// TODO 短连接解决 黏包现象</span></span><br><span class="line">                                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                    log.debug(<span class="string">&quot;成功连接到服务器端: &quot;</span> + ctx.channel().remoteAddress());</span><br><span class="line">                                    <span class="type">ByteBuf</span> <span class="variable">buffer1</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                                    buffer1.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>&#125;);</span><br><span class="line">                                    ctx.writeAndFlush(buffer1);  <span class="comment">// 黏包：客户端本想着向服务器端发送10次 16个字节的数据，但是服务器端一次性接收到160个字节的数据</span></span><br><span class="line">                                    ctx.close();</span><br><span class="line">                                    <span class="built_in">super</span>.channelActive(ctx);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>)).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span> + e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x1734cd77</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9566</span>] READ: 16B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> 08 09 0a 0b 0c <span class="number">0d</span> 0e <span class="number">0f</span> |................|</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] i.n.c.DefaultChannelPipeline - Discarded inbound message <span class="title function_">PooledUnsafeDirectByteBuf</span><span class="params">(ridx: <span class="number">0</span>, widx: <span class="number">16</span>, cap: <span class="number">16</span>)</span> that reached at the tail of the pipeline. Please check your pipeline configuration.</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] i.n.c.DefaultChannelPipeline - Discarded message pipeline : [LoggingHandler#<span class="number">0</span>, DefaultChannelPipeline$TailContext#<span class="number">0</span>]. Channel : [id: <span class="number">0x1734cd77</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9566</span>].</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x1734cd77</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9566</span>] READ COMPLETE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x1734cd77</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9566</span>] READ: 2B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">10</span> <span class="number">11</span>                                           |..              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] i.n.c.DefaultChannelPipeline - Discarded inbound message <span class="title function_">PooledUnsafeDirectByteBuf</span><span class="params">(ridx: <span class="number">0</span>, widx: <span class="number">2</span>, cap: <span class="number">16</span>)</span> that reached at the tail of the pipeline. Please check your pipeline configuration.</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] i.n.c.DefaultChannelPipeline - Discarded message pipeline : [LoggingHandler#<span class="number">0</span>, DefaultChannelPipeline$TailContext#<span class="number">0</span>]. Channel : [id: <span class="number">0x1734cd77</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9566</span>].</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x1734cd77</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9566</span>] READ COMPLETE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x1734cd77</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9566</span>] READ COMPLETE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x1734cd77</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> ! R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9566</span>] INACTIVE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x1734cd77</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> ! R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9566</span>] UNREGISTERED</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">2</span>] n.i.HelloWorldServer - 客户端：/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9631</span> 连接到服务器端：/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span></span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">2</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x5c5adb45</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9631</span>] REGISTERED</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">2</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x5c5adb45</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9631</span>] ACTIVE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">2</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x5c5adb45</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9631</span>] READ: 16B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> 08 09 0a 0b 0c <span class="number">0d</span> 0e <span class="number">0f</span> |................|</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">2</span>] i.n.c.DefaultChannelPipeline - Discarded inbound message <span class="title function_">PooledUnsafeDirectByteBuf</span><span class="params">(ridx: <span class="number">0</span>, widx: <span class="number">16</span>, cap: <span class="number">16</span>)</span> that reached at the tail of the pipeline. Please check your pipeline configuration.</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">2</span>] i.n.c.DefaultChannelPipeline - Discarded message pipeline : [LoggingHandler#<span class="number">0</span>, DefaultChannelPipeline$TailContext#<span class="number">0</span>]. Channel : [id: <span class="number">0x5c5adb45</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9631</span>].</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">2</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x5c5adb45</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9631</span>] READ COMPLETE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">2</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x5c5adb45</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9631</span>] READ: 2B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">10</span> <span class="number">11</span>                                           |..              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">2</span>] i.n.c.DefaultChannelPipeline - Discarded inbound message <span class="title function_">PooledUnsafeDirectByteBuf</span><span class="params">(ridx: <span class="number">0</span>, widx: <span class="number">2</span>, cap: <span class="number">16</span>)</span> that reached at the tail of the pipeline. Please check your pipeline configuration.</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">2</span>] i.n.c.DefaultChannelPipeline - Discarded message pipeline : [LoggingHandler#<span class="number">0</span>, DefaultChannelPipeline$TailContext#<span class="number">0</span>]. Channel : [id: <span class="number">0x5c5adb45</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9631</span>].</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">2</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x5c5adb45</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9631</span>] READ COMPLETE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">2</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x5c5adb45</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9631</span>] READ COMPLETE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">2</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x5c5adb45</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> ! R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9631</span>] INACTIVE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">2</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x5c5adb45</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> ! R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9631</span>] UNREGISTERED</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">3</span>] n.i.HelloWorldServer - 客户端：/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9696</span> 连接到服务器端：/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span></span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">3</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x4169b95a</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9696</span>] REGISTERED</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">3</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x4169b95a</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9696</span>] ACTIVE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">3</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x4169b95a</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9696</span>] READ: 16B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> 08 09 0a 0b 0c <span class="number">0d</span> 0e <span class="number">0f</span> |................|</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">3</span>] i.n.c.DefaultChannelPipeline - Discarded inbound message <span class="title function_">PooledUnsafeDirectByteBuf</span><span class="params">(ridx: <span class="number">0</span>, widx: <span class="number">16</span>, cap: <span class="number">16</span>)</span> that reached at the tail of the pipeline. Please check your pipeline configuration.</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">3</span>] i.n.c.DefaultChannelPipeline - Discarded message pipeline : [LoggingHandler#<span class="number">0</span>, DefaultChannelPipeline$TailContext#<span class="number">0</span>]. Channel : [id: <span class="number">0x4169b95a</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9696</span>].</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">3</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x4169b95a</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9696</span>] READ COMPLETE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">3</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x4169b95a</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9696</span>] READ: 2B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">10</span> <span class="number">11</span>                                           |..              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">3</span>] i.n.c.DefaultChannelPipeline - Discarded inbound message <span class="title function_">PooledUnsafeDirectByteBuf</span><span class="params">(ridx: <span class="number">0</span>, widx: <span class="number">2</span>, cap: <span class="number">16</span>)</span> that reached at the tail of the pipeline. Please check your pipeline configuration.</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">3</span>] i.n.c.DefaultChannelPipeline - Discarded message pipeline : [LoggingHandler#<span class="number">0</span>, DefaultChannelPipeline$TailContext#<span class="number">0</span>]. Channel : [id: <span class="number">0x4169b95a</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9696</span>].</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">3</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x4169b95a</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9696</span>] READ COMPLETE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">3</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x4169b95a</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9696</span>] READ COMPLETE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">3</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x4169b95a</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> ! R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9696</span>] INACTIVE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">3</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x4169b95a</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> ! R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9696</span>] UNREGISTERED</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">4</span>] n.i.HelloWorldServer - 客户端：/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9761</span> 连接到服务器端：/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span></span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">4</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0xbbece47c</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9761</span>] REGISTERED</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">4</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0xbbece47c</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9761</span>] ACTIVE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">4</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0xbbece47c</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9761</span>] READ: 16B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> 08 09 0a 0b 0c <span class="number">0d</span> 0e <span class="number">0f</span> |................|</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">4</span>] i.n.c.DefaultChannelPipeline - Discarded inbound message <span class="title function_">PooledUnsafeDirectByteBuf</span><span class="params">(ridx: <span class="number">0</span>, widx: <span class="number">16</span>, cap: <span class="number">16</span>)</span> that reached at the tail of the pipeline. Please check your pipeline configuration.</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">4</span>] i.n.c.DefaultChannelPipeline - Discarded message pipeline : [LoggingHandler#<span class="number">0</span>, DefaultChannelPipeline$TailContext#<span class="number">0</span>]. Channel : [id: <span class="number">0xbbece47c</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9761</span>].</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">4</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0xbbece47c</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9761</span>] READ COMPLETE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">4</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0xbbece47c</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9761</span>] READ: 2B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">10</span> <span class="number">11</span>                                           |..              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">4</span>] i.n.c.DefaultChannelPipeline - Discarded inbound message <span class="title function_">PooledUnsafeDirectByteBuf</span><span class="params">(ridx: <span class="number">0</span>, widx: <span class="number">2</span>, cap: <span class="number">16</span>)</span> that reached at the tail of the pipeline. Please check your pipeline configuration.</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">4</span>] i.n.c.DefaultChannelPipeline - Discarded message pipeline : [LoggingHandler#<span class="number">0</span>, DefaultChannelPipeline$TailContext#<span class="number">0</span>]. Channel : [id: <span class="number">0xbbece47c</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9761</span>].</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">4</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0xbbece47c</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9761</span>] READ COMPLETE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">4</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0xbbece47c</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9761</span>] READ COMPLETE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">4</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0xbbece47c</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> ! R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9761</span>] INACTIVE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">4</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0xbbece47c</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> ! R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9761</span>] UNREGISTERED</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">5</span>] n.i.HelloWorldServer - 客户端：/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9826</span> 连接到服务器端：/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span></span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">5</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0xdeea9009</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9826</span>] REGISTERED</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">5</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0xdeea9009</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9826</span>] ACTIVE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">5</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0xdeea9009</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9826</span>] READ: 16B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> 08 09 0a 0b 0c <span class="number">0d</span> 0e <span class="number">0f</span> |................|</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">5</span>] i.n.c.DefaultChannelPipeline - Discarded inbound message <span class="title function_">PooledUnsafeDirectByteBuf</span><span class="params">(ridx: <span class="number">0</span>, widx: <span class="number">16</span>, cap: <span class="number">16</span>)</span> that reached at the tail of the pipeline. Please check your pipeline configuration.</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">5</span>] i.n.c.DefaultChannelPipeline - Discarded message pipeline : [LoggingHandler#<span class="number">0</span>, DefaultChannelPipeline$TailContext#<span class="number">0</span>]. Channel : [id: <span class="number">0xdeea9009</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9826</span>].</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">5</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0xdeea9009</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9826</span>] READ COMPLETE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">5</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0xdeea9009</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9826</span>] READ: 2B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">10</span> <span class="number">11</span>                                           |..              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">5</span>] i.n.c.DefaultChannelPipeline - Discarded inbound message <span class="title function_">PooledUnsafeDirectByteBuf</span><span class="params">(ridx: <span class="number">0</span>, widx: <span class="number">2</span>, cap: <span class="number">16</span>)</span> that reached at the tail of the pipeline. Please check your pipeline configuration.</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">5</span>] i.n.c.DefaultChannelPipeline - Discarded message pipeline : [LoggingHandler#<span class="number">0</span>, DefaultChannelPipeline$TailContext#<span class="number">0</span>]. Channel : [id: <span class="number">0xdeea9009</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9826</span>].</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">5</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0xdeea9009</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9826</span>] READ COMPLETE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">5</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0xdeea9009</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9826</span>] READ COMPLETE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">5</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0xdeea9009</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> ! R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9826</span>] INACTIVE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">5</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0xdeea9009</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> ! R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9826</span>] UNREGISTERED</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">6</span>] n.i.HelloWorldServer - 客户端：/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9891</span> 连接到服务器端：/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span></span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">6</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x7c65484d</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9891</span>] REGISTERED</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">6</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x7c65484d</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9891</span>] ACTIVE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">6</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x7c65484d</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9891</span>] READ: 16B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> 08 09 0a 0b 0c <span class="number">0d</span> 0e <span class="number">0f</span> |................|</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">6</span>] i.n.c.DefaultChannelPipeline - Discarded inbound message <span class="title function_">PooledUnsafeDirectByteBuf</span><span class="params">(ridx: <span class="number">0</span>, widx: <span class="number">16</span>, cap: <span class="number">16</span>)</span> that reached at the tail of the pipeline. Please check your pipeline configuration.</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">6</span>] i.n.c.DefaultChannelPipeline - Discarded message pipeline : [LoggingHandler#<span class="number">0</span>, DefaultChannelPipeline$TailContext#<span class="number">0</span>]. Channel : [id: <span class="number">0x7c65484d</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9891</span>].</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">6</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x7c65484d</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9891</span>] READ COMPLETE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">6</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x7c65484d</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9891</span>] READ: 2B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">10</span> <span class="number">11</span>                                           |..              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">6</span>] i.n.c.DefaultChannelPipeline - Discarded inbound message <span class="title function_">PooledUnsafeDirectByteBuf</span><span class="params">(ridx: <span class="number">0</span>, widx: <span class="number">2</span>, cap: <span class="number">16</span>)</span> that reached at the tail of the pipeline. Please check your pipeline configuration.</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">6</span>] i.n.c.DefaultChannelPipeline - Discarded message pipeline : [LoggingHandler#<span class="number">0</span>, DefaultChannelPipeline$TailContext#<span class="number">0</span>]. Channel : [id: <span class="number">0x7c65484d</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9891</span>].</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">6</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x7c65484d</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9891</span>] READ COMPLETE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">6</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x7c65484d</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9891</span>] READ COMPLETE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">6</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x7c65484d</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> ! R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9891</span>] INACTIVE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">6</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x7c65484d</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> ! R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9891</span>] UNREGISTERED</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">7</span>] n.i.HelloWorldServer - 客户端：/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9956</span> 连接到服务器端：/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span></span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">7</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x736472be</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9956</span>] REGISTERED</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">7</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x736472be</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9956</span>] ACTIVE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">7</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x736472be</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9956</span>] READ: 16B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> 08 09 0a 0b 0c <span class="number">0d</span> 0e <span class="number">0f</span> |................|</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">7</span>] i.n.c.DefaultChannelPipeline - Discarded inbound message <span class="title function_">PooledUnsafeDirectByteBuf</span><span class="params">(ridx: <span class="number">0</span>, widx: <span class="number">16</span>, cap: <span class="number">16</span>)</span> that reached at the tail of the pipeline. Please check your pipeline configuration.</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">7</span>] i.n.c.DefaultChannelPipeline - Discarded message pipeline : [LoggingHandler#<span class="number">0</span>, DefaultChannelPipeline$TailContext#<span class="number">0</span>]. Channel : [id: <span class="number">0x736472be</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9956</span>].</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">7</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x736472be</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9956</span>] READ COMPLETE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">7</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x736472be</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9956</span>] READ: 2B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">10</span> <span class="number">11</span>                                           |..              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">7</span>] i.n.c.DefaultChannelPipeline - Discarded inbound message <span class="title function_">PooledUnsafeDirectByteBuf</span><span class="params">(ridx: <span class="number">0</span>, widx: <span class="number">2</span>, cap: <span class="number">16</span>)</span> that reached at the tail of the pipeline. Please check your pipeline configuration.</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">7</span>] i.n.c.DefaultChannelPipeline - Discarded message pipeline : [LoggingHandler#<span class="number">0</span>, DefaultChannelPipeline$TailContext#<span class="number">0</span>]. Channel : [id: <span class="number">0x736472be</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9956</span>].</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">7</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x736472be</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9956</span>] READ COMPLETE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">7</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x736472be</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9956</span>] READ COMPLETE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">7</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x736472be</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> ! R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9956</span>] INACTIVE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">7</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x736472be</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> ! R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9956</span>] UNREGISTERED</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">8</span>] n.i.HelloWorldServer - 客户端：/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10021</span> 连接到服务器端：/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span></span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">8</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0xdc6e0d14</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10021</span>] REGISTERED</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">8</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0xdc6e0d14</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10021</span>] ACTIVE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">8</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0xdc6e0d14</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10021</span>] READ: 16B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> 08 09 0a 0b 0c <span class="number">0d</span> 0e <span class="number">0f</span> |................|</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">8</span>] i.n.c.DefaultChannelPipeline - Discarded inbound message <span class="title function_">PooledUnsafeDirectByteBuf</span><span class="params">(ridx: <span class="number">0</span>, widx: <span class="number">16</span>, cap: <span class="number">16</span>)</span> that reached at the tail of the pipeline. Please check your pipeline configuration.</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">8</span>] i.n.c.DefaultChannelPipeline - Discarded message pipeline : [LoggingHandler#<span class="number">0</span>, DefaultChannelPipeline$TailContext#<span class="number">0</span>]. Channel : [id: <span class="number">0xdc6e0d14</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10021</span>].</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">8</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0xdc6e0d14</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10021</span>] READ COMPLETE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">8</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0xdc6e0d14</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10021</span>] READ: 2B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">10</span> <span class="number">11</span>                                           |..              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">8</span>] i.n.c.DefaultChannelPipeline - Discarded inbound message <span class="title function_">PooledUnsafeDirectByteBuf</span><span class="params">(ridx: <span class="number">0</span>, widx: <span class="number">2</span>, cap: <span class="number">16</span>)</span> that reached at the tail of the pipeline. Please check your pipeline configuration.</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">8</span>] i.n.c.DefaultChannelPipeline - Discarded message pipeline : [LoggingHandler#<span class="number">0</span>, DefaultChannelPipeline$TailContext#<span class="number">0</span>]. Channel : [id: <span class="number">0xdc6e0d14</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10021</span>].</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">8</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0xdc6e0d14</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10021</span>] READ COMPLETE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">8</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0xdc6e0d14</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10021</span>] READ COMPLETE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">8</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0xdc6e0d14</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> ! R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10021</span>] INACTIVE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">8</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0xdc6e0d14</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> ! R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10021</span>] UNREGISTERED</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">9</span>] n.i.HelloWorldServer - 客户端：/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10086</span> 连接到服务器端：/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span></span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">9</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x6aed6c42</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10086</span>] REGISTERED</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">9</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x6aed6c42</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10086</span>] ACTIVE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">9</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x6aed6c42</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10086</span>] READ: 16B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> 08 09 0a 0b 0c <span class="number">0d</span> 0e <span class="number">0f</span> |................|</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">9</span>] i.n.c.DefaultChannelPipeline - Discarded inbound message <span class="title function_">PooledUnsafeDirectByteBuf</span><span class="params">(ridx: <span class="number">0</span>, widx: <span class="number">16</span>, cap: <span class="number">16</span>)</span> that reached at the tail of the pipeline. Please check your pipeline configuration.</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">9</span>] i.n.c.DefaultChannelPipeline - Discarded message pipeline : [LoggingHandler#<span class="number">0</span>, DefaultChannelPipeline$TailContext#<span class="number">0</span>]. Channel : [id: <span class="number">0x6aed6c42</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10086</span>].</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">9</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x6aed6c42</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10086</span>] READ COMPLETE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">9</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x6aed6c42</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10086</span>] READ: 2B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">10</span> <span class="number">11</span>                                           |..              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">9</span>] i.n.c.DefaultChannelPipeline - Discarded inbound message <span class="title function_">PooledUnsafeDirectByteBuf</span><span class="params">(ridx: <span class="number">0</span>, widx: <span class="number">2</span>, cap: <span class="number">16</span>)</span> that reached at the tail of the pipeline. Please check your pipeline configuration.</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">9</span>] i.n.c.DefaultChannelPipeline - Discarded message pipeline : [LoggingHandler#<span class="number">0</span>, DefaultChannelPipeline$TailContext#<span class="number">0</span>]. Channel : [id: <span class="number">0x6aed6c42</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10086</span>].</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">9</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x6aed6c42</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10086</span>] READ COMPLETE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">9</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x6aed6c42</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10086</span>] READ COMPLETE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">9</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x6aed6c42</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> ! R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10086</span>] INACTIVE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">9</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x6aed6c42</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> ! R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10086</span>] UNREGISTERED</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">10</span>] n.i.HelloWorldServer - 客户端：/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10151</span> 连接到服务器端：/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span></span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">10</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x4193801e</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10151</span>] REGISTERED</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">10</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x4193801e</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10151</span>] ACTIVE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">10</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x4193801e</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10151</span>] READ: 16B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> 08 09 0a 0b 0c <span class="number">0d</span> 0e <span class="number">0f</span> |................|</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">10</span>] i.n.c.DefaultChannelPipeline - Discarded inbound message <span class="title function_">PooledUnsafeDirectByteBuf</span><span class="params">(ridx: <span class="number">0</span>, widx: <span class="number">16</span>, cap: <span class="number">16</span>)</span> that reached at the tail of the pipeline. Please check your pipeline configuration.</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">10</span>] i.n.c.DefaultChannelPipeline - Discarded message pipeline : [LoggingHandler#<span class="number">0</span>, DefaultChannelPipeline$TailContext#<span class="number">0</span>]. Channel : [id: <span class="number">0x4193801e</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10151</span>].</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">10</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x4193801e</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10151</span>] READ COMPLETE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">10</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x4193801e</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10151</span>] READ: 2B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">10</span> <span class="number">11</span>                                           |..              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">10</span>] i.n.c.DefaultChannelPipeline - Discarded inbound message <span class="title function_">PooledUnsafeDirectByteBuf</span><span class="params">(ridx: <span class="number">0</span>, widx: <span class="number">2</span>, cap: <span class="number">16</span>)</span> that reached at the tail of the pipeline. Please check your pipeline configuration.</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">10</span>] i.n.c.DefaultChannelPipeline - Discarded message pipeline : [LoggingHandler#<span class="number">0</span>, DefaultChannelPipeline$TailContext#<span class="number">0</span>]. Channel : [id: <span class="number">0x4193801e</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10151</span>].</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">10</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x4193801e</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10151</span>] READ COMPLETE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">10</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x4193801e</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10151</span>] READ COMPLETE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">10</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x4193801e</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> ! R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10151</span>] INACTIVE</span><br><span class="line"><span class="number">10</span>:08:<span class="number">49</span> [DEBUG] [nioEventLoopGroup-<span class="number">3</span>-<span class="number">10</span>] i.n.h.l.LoggingHandler - [id: <span class="number">0x4193801e</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> ! R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10151</span>] UNREGISTERED</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><font color=red>短连接虽然可以解决黏包问题，但是没办法解决半包问题</font></p>
<blockquote>
<p>快捷键：</p>
<p>​            Ctrl+Alt +M   抽方法</p>
</blockquote>
<h4 id="方法2，固定长度"><a href="#方法2，固定长度" class="headerlink" title="方法2，固定长度"></a>方法2，固定长度</h4><p>让所有数据包长度固定（假设长度为 8 字节），服务器端加入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">FixedLengthFrameDecoder</span>(<span class="number">8</span>));</span><br></pre></td></tr></table></figure>

<p>客户端测试代码，注意, 采用这种方法后，客户端什么时候 flush 都可以</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;connetted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            <span class="comment">// 发送内容随机的数据包</span></span><br><span class="line">                            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">                            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                                <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];</span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; r.nextInt(<span class="number">8</span>); j++) &#123;</span><br><span class="line">                                    bytes[j] = (<span class="type">byte</span>) c;</span><br><span class="line">                                &#125;</span><br><span class="line">                                c++;</span><br><span class="line">                                buffer.writeBytes(bytes);</span><br><span class="line">                            &#125;</span><br><span class="line">                            ctx.writeAndFlush(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;192.168.0.103&quot;</span>, <span class="number">9090</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] REGISTERED</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] CONNECT: /192.168.0.103:9090</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] ACTIVE</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] WRITE: 80B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 61 61 61 61 00 00 00 00 62 00 00 00 00 00 00 00 |aaaa....b.......|</span><br><span class="line">|00000010| 63 63 00 00 00 00 00 00 64 00 00 00 00 00 00 00 |cc......d.......|</span><br><span class="line">|00000020| 00 00 00 00 00 00 00 00 66 66 66 66 00 00 00 00 |........ffff....|</span><br><span class="line">|00000030| 67 67 67 00 00 00 00 00 68 00 00 00 00 00 00 00 |ggg.....h.......|</span><br><span class="line">|00000040| 69 69 69 69 69 00 00 00 6a 6a 6a 6a 00 00 00 00 |iiiii...jjjj....|</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] FLUSH</span><br></pre></td></tr></table></figure>

<p>服务端输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f] binding...</span><br><span class="line">12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f, L:/192.168.0.103:9090] bound...</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] REGISTERED</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] ACTIVE</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155]</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 61 61 61 61 00 00 00 00                         |aaaa....        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 62 00 00 00 00 00 00 00                         |b.......        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 63 63 00 00 00 00 00 00                         |cc......        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 64 00 00 00 00 00 00 00                         |d.......        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 00 00 00 00 00 00 00                         |........        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 66 66 66 66 00 00 00 00                         |ffff....        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 67 67 67 00 00 00 00 00                         |ggg.....        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 68 00 00 00 00 00 00 00                         |h.......        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 69 69 69 69 69 00 00 00                         |iiiii...        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 6a 6a 6a 6a 00 00 00 00                         |jjjj....        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ COMPLETE</span><br></pre></td></tr></table></figure>

<p>缺点是，数据包的大小不好把握</p>
<ul>
<li>长度定的太大，浪费</li>
<li>长度定的太小，对某些数据包又显得不够</li>
</ul>
<h4 id="方法3，固定分隔符"><a href="#方法3，固定分隔符" class="headerlink" title="方法3，固定分隔符"></a>方法3，固定分隔符</h4><p><code>LineBasedFrameDecoder</code>和<code>DelimiterBasedFrameDecoder</code>, 后者是可以自定义分隔符</p>
<p>服务端加入，默认以 \n 或 \r\n 作为分隔符，如果超出指定长度仍未出现分隔符，则抛出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LineBasedFrameDecoder</span>(<span class="number">1024</span>));</span><br></pre></td></tr></table></figure>



<p>客户端在每条消息之后，加入 \n 分隔符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;connetted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">                            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= r.nextInt(<span class="number">16</span>)+<span class="number">1</span>; j++) &#123;</span><br><span class="line">                                    buffer.writeByte((<span class="type">byte</span>) c);</span><br><span class="line">                                &#125;</span><br><span class="line">                                buffer.writeByte(<span class="number">10</span>);</span><br><span class="line">                                c++;</span><br><span class="line">                            &#125;</span><br><span class="line">                            ctx.writeAndFlush(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;192.168.0.103&quot;</span>, <span class="number">9090</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] REGISTERED</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] CONNECT: /192.168.0.103:9090</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] ACTIVE</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] WRITE: 60B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 61 0a 62 62 62 0a 63 63 63 0a 64 64 0a 65 65 65 |a.bbb.ccc.dd.eee|</span><br><span class="line">|00000010| 65 65 65 65 65 65 65 0a 66 66 0a 67 67 67 67 67 |eeeeeee.ff.ggggg|</span><br><span class="line">|00000020| 67 67 0a 68 68 68 68 0a 69 69 69 69 69 69 69 0a |gg.hhhh.iiiiiii.|</span><br><span class="line">|00000030| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 0a             |jjjjjjjjjjj.    |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] FLUSH</span><br></pre></td></tr></table></figure>



<p>服务端输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] c.i.n.HelloWorldServer - connected [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641]</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 1B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 61                                              |a               |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 3B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 62 62 62                                        |bbb             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 3B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 63 63 63                                        |ccc             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 2B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 64 64                                           |dd              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 10B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 65 65 65 65 65 65 65 65 65 65                   |eeeeeeeeee      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 2B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 66 66                                           |ff              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 7B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 67 67 67 67 67 67 67                            |ggggggg         |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 4B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 68 68 68 68                                     |hhhh            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 7B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 69 69 69 69 69 69 69                            |iiiiiii         |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 11B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a                |jjjjjjjjjjj     |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ COMPLETE</span><br></pre></td></tr></table></figure>

<p>缺点，处理字符数据比较合适，但如果内容本身包含了分隔符（字节数据常常会有此情况），那么就会解析错误</p>
<h4 id="方法4，预设长度（类似于协议，-LTC解码）"><a href="#方法4，预设长度（类似于协议，-LTC解码）" class="headerlink" title="方法4，预设长度（类似于协议， LTC解码）"></a>方法4，预设长度（类似于协议， LTC解码）</h4><p>在发送消息前，先约定用定长字节表示接下来数据的长度（<strong>基于长度字段的解码器</strong>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大长度，长度偏移，长度占用字节，长度调整，剥离字节数</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(<span class="number">1024</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>客户端代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;connetted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">                            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                                <span class="type">byte</span> <span class="variable">length</span> <span class="operator">=</span> (<span class="type">byte</span>) (r.nextInt(<span class="number">16</span>) + <span class="number">1</span>);</span><br><span class="line">                                <span class="comment">// 先写入长度</span></span><br><span class="line">                                buffer.writeByte(length);</span><br><span class="line">                                <span class="comment">// 再</span></span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= length; j++) &#123;</span><br><span class="line">                                    buffer.writeByte((<span class="type">byte</span>) c);</span><br><span class="line">                                &#125;</span><br><span class="line">                                c++;</span><br><span class="line">                            &#125;</span><br><span class="line">                            ctx.writeAndFlush(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;192.168.0.103&quot;</span>, <span class="number">9090</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>客户端输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8] REGISTERED</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8] CONNECT: /192.168.0.103:9090</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] ACTIVE</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] WRITE: 97B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 09 61 61 61 61 61 61 61 61 61 09 62 62 62 62 62 |.aaaaaaaaa.bbbbb|</span><br><span class="line">|00000010| 62 62 62 62 06 63 63 63 63 63 63 08 64 64 64 64 |bbbb.cccccc.dddd|</span><br><span class="line">|00000020| 64 64 64 64 0f 65 65 65 65 65 65 65 65 65 65 65 |dddd.eeeeeeeeeee|</span><br><span class="line">|00000030| 65 65 65 65 0d 66 66 66 66 66 66 66 66 66 66 66 |eeee.fffffffffff|</span><br><span class="line">|00000040| 66 66 02 67 67 02 68 68 0e 69 69 69 69 69 69 69 |ff.gg.hh.iiiiiii|</span><br><span class="line">|00000050| 69 69 69 69 69 69 69 09 6a 6a 6a 6a 6a 6a 6a 6a |iiiiiii.jjjjjjjj|</span><br><span class="line">|00000060| 6a                                              |j               |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] FLUSH</span><br></pre></td></tr></table></figure>



<p>服务端输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">14:36:50 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xdff439d3] binding...</span><br><span class="line">14:36:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xdff439d3, L:/192.168.0.103:9090] bound...</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] REGISTERED</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] ACTIVE</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979]</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 61 61 61 61 61 61 61 61 61                      |aaaaaaaaa       |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 62 62 62 62 62 62 62 62 62                      |bbbbbbbbb       |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 6B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 63 63 63 63 63 63                               |cccccc          |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 64 64 64 64 64 64 64 64                         |dddddddd        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 15B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 65 65 65 65 65 65 65 65 65 65 65 65 65 65 65    |eeeeeeeeeeeeeee |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 13B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 66 66 66 66 66 66 66 66 66 66 66 66 66          |fffffffffffff   |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 2B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 67 67                                           |gg              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 2B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 68 68                                           |hh              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 14B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 69 69 69 69 69 69 69 69 69 69 69 69 69 69       |iiiiiiiiiiiiii  |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 6a 6a 6a 6a 6a 6a 6a 6a 6a                      |jjjjjjjjj       |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ COMPLETE</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id=""><a href="#" class="headerlink" title=""></a></h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://xiaowodi.github.io/2022/06/24/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/24/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Git学习随手记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-24 08:12:10" itemprop="dateCreated datePublished" datetime="2022-06-24T08:12:10+00:00">2022-06-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Git介绍"><a href="#Git介绍" class="headerlink" title="Git介绍"></a>Git介绍</h3><p>分布式版本控制工具 VS 集中式版本控制</p>
<h3 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h3><h3 id="Git命令"><a href="#Git命令" class="headerlink" title="Git命令"></a>Git命令</h3><p>基于开发案例，详细讲解git 的常用命令</p>
<h3 id="版本穿梭"><a href="#版本穿梭" class="headerlink" title="版本穿梭"></a>版本穿梭</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">命令git reflog 可以查看当前本地库的版本提交状态， 每个版本的地址引用，通过这个地址，我们可以进行版本穿梭</span><br><span class="line">== git reflog （简略信息版）</span><br><span class="line"></span><br><span class="line">b7a61e6 (HEAD -&gt; master) HEAD@&#123;0&#125;: checkout: moving from hot-fix to master</span><br><span class="line">c813c2a (hot-fix) HEAD@&#123;1&#125;: checkout: moving from master to hot-fix</span><br><span class="line">b7a61e6 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit (merge): merge</span><br><span class="line">98c9077 HEAD@&#123;3&#125;: checkout: moving from hot-fix to master</span><br><span class="line">c813c2a (hot-fix) HEAD@&#123;4&#125;: commit: hot-fix commit</span><br><span class="line">aeb4bd5 HEAD@&#123;5&#125;: checkout: moving from master to hot-fix</span><br><span class="line">98c9077 HEAD@&#123;6&#125;: commit: master test</span><br><span class="line">aeb4bd5 HEAD@&#123;7&#125;: merge hot-fix: Fast-forward</span><br><span class="line">1a3ca2e HEAD@&#123;8&#125;: checkout: moving from hot-fix to master</span><br><span class="line">aeb4bd5 HEAD@&#123;9&#125;: commit: hot-fix first commit hello.txt</span><br><span class="line">1a3ca2e HEAD@&#123;10&#125;: checkout: moving from master to hot-fix</span><br><span class="line">1a3ca2e HEAD@&#123;11&#125;: reset: moving to 1a3ca2e</span><br><span class="line">087386a HEAD@&#123;12&#125;: commit: third commit hello.txt</span><br><span class="line">1a3ca2e HEAD@&#123;13&#125;: commit: second commit hello.txt</span><br><span class="line">afdb66a HEAD@&#123;14&#125;: commit (initial): first commit hello.txt</span><br><span class="line"></span><br><span class="line">== git log  (详细信息版)</span><br><span class="line">commit b7a61e67ea93e3705b06d47baaab95456caf03ab (HEAD -&gt; master)</span><br><span class="line">Merge: 98c9077 c813c2a</span><br><span class="line">Author: yulu &lt;2723946289@qq.com&gt;</span><br><span class="line">Date:   Sun May 9 01:11:53 2021 +0800</span><br><span class="line"></span><br><span class="line">    merge</span><br><span class="line"></span><br><span class="line">commit c813c2a329b9ca158421ddb9178c2d4111678cc8 (hot-fix)</span><br><span class="line">Author: yulu &lt;2723946289@qq.com&gt;</span><br><span class="line">Date:   Sun May 9 01:08:02 2021 +0800</span><br><span class="line"></span><br><span class="line">    hot-fix commit</span><br><span class="line"></span><br><span class="line">commit 98c9077bfe85e15065502271722f0731fd7d7c81</span><br><span class="line">Author: yulu &lt;2723946289@qq.com&gt;</span><br><span class="line">Date:   Sun May 9 01:07:01 2021 +0800</span><br><span class="line"></span><br><span class="line">    master test</span><br><span class="line"></span><br><span class="line">commit aeb4bd56e09974ebc1499531eb7caefbc03010c6</span><br><span class="line">Author: yulu &lt;2723946289@qq.com&gt;</span><br><span class="line">Date:   Sun May 9 01:01:48 2021 +0800</span><br><span class="line"></span><br><span class="line">    hot-fix first commit hello.txt</span><br><span class="line"></span><br><span class="line">commit 1a3ca2e393f832c36b02bbdffef7896b48826e0a</span><br><span class="line">Author: yulu &lt;2723946289@qq.com&gt;</span><br><span class="line">Date:   Sun May 9 00:39:40 2021 +0800</span><br><span class="line"></span><br><span class="line">    second commit hello.txt</span><br><span class="line"></span><br><span class="line">commit afdb66ab517b91b429e68dd181ca8ed00f7e05e5</span><br><span class="line">Author: yulu &lt;2723946289@qq.com&gt;</span><br><span class="line">Date:   Sun May 9 00:35:50 2021 +0800</span><br><span class="line"></span><br><span class="line">    first commit hello.txt</span><br><span class="line"></span><br><span class="line">通过 git reset --hard 穿梭的版本地址 可以进行版本穿梭</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h3><p>分支特性、分支创建、分支转换、分支合并、代码合并冲突解决</p>
<p>git的分支操作其实实际上就是操纵两个重要的指针：</p>
<ol>
<li>HEAD指向分支的指针</li>
<li>Master（具体分支）指向版本的指针</li>
</ol>
<blockquote>
<p>在分支merge时， 我们当前所在的分支为我们的目标的分支， 通过git merge命令可以将指定的分支合并到 <strong>当前所在的分支</strong></p>
</blockquote>
<h4 id="分支冲突"><a href="#分支冲突" class="headerlink" title="分支冲突"></a>分支冲突</h4><p>当两个分支进行合并时，如果两个分支在<font color=red>同一文件的同一个位置</font>有两套完全不同的修改，git无法替我们决定使用哪一个。必须人为决定新代码的内容。（需要人为修改当前分支下的产生冲突的文件）</p>
<p>例如：</p>
<ol>
<li>master 分支 当前版本 的hello.txt文件的内容：</li>
</ol>
<blockquote>
<p>hello world    10</p>
<p>hello world    20</p>
<p>hello world</p>
<p>hello world</p>
<p>hello world</p>
<p>hello world master test</p>
<p>hello world</p>
</blockquote>
<ol start="2">
<li>Hot-fix 分支 当前版本 的hello.txt文件的内容：</li>
</ol>
<blockquote>
<p>hello world    10</p>
<p>hello world    20</p>
<p>hello world</p>
<p>hello world</p>
<p>hello world</p>
<p>hello world</p>
<p>hello world hot-fix test</p>
</blockquote>
<p>这样这两个分支在合并的时候，就会产生合并冲突，无法自动进行分支合并，我们需要在执行 git merge hot-fix之后，人为的修改master分支下的hello.txt文件</p>
<p>执行完命令之后，hello.txt文件中会多出两个版本的信息，我们人为的修改我们想要保留的信息，然后add，commit（不加文件名）即可</p>
<h3 id="Git-团队协作机制"><a href="#Git-团队协作机制" class="headerlink" title="Git 团队协作机制"></a>Git 团队协作机制</h3><h4 id="团队内协作"><a href="#团队内协作" class="headerlink" title="团队内协作"></a>团队内协作</h4><p><img src="https://github.com/xiaowodi/Resources/blob/main/images/gitImages/1.png?raw=true" alt="1.png"></p>
<p>形象的比喻：</p>
<p>岳不群，将自己本地库的<strong>华山剑法 <strong>push（推送）到</strong>远程库</strong></p>
<p>令狐冲就可以从<strong>自己团队的远程库中</strong>==clone==这套华山剑法到自己的<strong>本地库</strong>进行剑法的修炼，在练剑的同时，令狐冲有新研究出两招剑式，添加到自己的本地库中，令狐冲通过push，再将修改后的代码push到团队的远程库中(<font color=red>需要团队内的权限才可以push成功</font>)</p>
<p>岳不群再从远程库pull拉去修改后的华山剑法</p>
<h4 id="跨团队协作"><a href="#跨团队协作" class="headerlink" title="跨团队协作"></a>跨团队协作</h4><p><img src="https://github.com/xiaowodi/Resources/blob/main/images/gitImages/2.png?raw=true" alt="2.png"></p>
<p>形象的例子：</p>
<p>令狐冲和岳不群：都觉得华山剑法不太精妙， 于是令狐冲找来了东方不败，将<strong>华山剑法</strong>升级为<strong>辟邪剑法</strong></p>
<p>这就会有两种情况：</p>
<p>​        1：将东方不败加入到自己的团队（<font color=green>东方不败有自己的团队，堂堂日月神教CEO岂能加入到小小的华山派</font>）</p>
<p>​        2: 东方不败跨团队协助令狐冲完成华山剑法的升级</p>
<p>针对第二种情况：</p>
<p>​    首先：东方不败需要从<strong>岳不群的远程库</strong> <font color=red>fork</font>出一份岳不群的远程库， fork成自己的远程库</p>
<p>​    然后：东方不败从自己的远程库 将华山剑法 clone下来，升级完成之后，在push到自己的远程库</p>
<p>​    接下来：提交pr：pull request拉去请求（东方不败的远程库向岳不群的远程库<strong>提交pr请求</strong>，待岳不群进行<strong>审核</strong>完成之后进行两个远程库的<strong>合并</strong>）</p>
<p>​    最后：两个不同团队之间的远程库合并完成之后，岳不群就可以拉去 <strong>辟邪剑法</strong>，进行<strong>自宫修炼</strong></p>
<h4 id="远程库创建别名"><a href="#远程库创建别名" class="headerlink" title="远程库创建别名"></a>远程库创建别名</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git remote -v 查看当前已经配置的远程库别名</span><br><span class="line"></span><br><span class="line">git remote add 别名 地址</span><br><span class="line">	例如： git remote add gitDemo https://github.com/xiaowodi/gitDemo.git</span><br><span class="line">didi@bogon gitDemo$ git remote -v</span><br><span class="line">didi@bogon gitDemo$ git remote add gitDemo https://github.com/xiaowodi/gitDemo.git</span><br><span class="line">didi@bogon gitDemo$ git remote -v</span><br><span class="line">gitDemo	https://github.com/xiaowodi/gitDemo.git (fetch)</span><br><span class="line">gitDemo	https://github.com/xiaowodi/gitDemo.git (push)</span><br></pre></td></tr></table></figure>



<h4 id="本地库-push-代码-到-远程库"><a href="#本地库-push-代码-到-远程库" class="headerlink" title="本地库 push 代码 到 远程库"></a>本地库 push 代码 到 远程库</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push 远程库https 远程库分支</span><br><span class="line">didi@bogon gitDemo$ git push gitDemo master</span><br></pre></td></tr></table></figure>



<h4 id="拉去远程库到本地库（拉取需要登录账号）"><a href="#拉去远程库到本地库（拉取需要登录账号）" class="headerlink" title="拉去远程库到本地库（拉取需要登录账号）"></a>拉去远程库到本地库（拉取需要登录账号）</h4><p>当远程库进行修改了之后，而本地库没有被修改时，可以通过pull，将远程库拉取到本地</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">git pull 远程库地址 分支</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">git pull gitDemo	master</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong><font color=red>pull 可以将远程库下修改之后的文件内容 拉去到本地</font>  可以将远程库与本地库保持同步，使得<strong>本地库的转态保持最新状态</strong></p>
<p>​            <font color=red>而clone + 远程地址：这种方式只能表面的文件，如果原始文件存在，那么 即使远程库修改了内容，通过clone也不会将变化的内容克隆到本地</font></p>
<p>git pull 作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。</p>
<blockquote>
<p>eg:$ git pull ##远程主机（origin） #远程分支(next)#：#本地分支(master)#</p>
<p>如果远程分支是与当前分支合并，则冒号后面的部分可以省略。 eg:$ git pull #远程主机(origin)#　 #远程分之(next)#</p>
</blockquote>
<h4 id="克隆远程库"><a href="#克隆远程库" class="headerlink" title="克隆远程库"></a>克隆远程库</h4><p>克隆公共仓库的代码，不需要登录账号的</p>
<p>克隆可以在任意的文件夹下，将远程库的代码克隆到本地库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">mkdir</span> newgitDemo</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">cd</span> newgitDemo</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/xiaowodi/gitDemo.git</span></span><br></pre></td></tr></table></figure>

<p>克隆之后，克隆下来的文件夹就自动的配置了git的配置，就连远程库的别名都已经起好了</p>
<p>克隆大致会经历的三个步骤：</p>
<pre><code>1. 拉去代码
2. 初始化本地仓库
3. 创建远程库地址别名
</code></pre>
<h3 id="日常push的主要步骤"><a href="#日常push的主要步骤" class="headerlink" title="日常push的主要步骤"></a>日常push的主要步骤</h3><p>如果本地库的想要push的版本，低于远程库的版本，那么push是被拒绝的，</p>
<p>一定要保证本地库的版本要高于远程库的版本</p>
<p><font color=red>一般需要先pull远程库的代码，将远程库最新的版本拉取到本地库，然后在此基础上进行修改，提交，最后在push到远程库进行合并</font></p>
<p><font color=green>在拉取远程库代码的过程中：如果远程库的代码与本地库的代码不一致，会自动合并，如果自动合并失败，还会涉及到手动解决冲突的问题</font></p>
<h3 id="Git内部原理"><a href="#Git内部原理" class="headerlink" title="Git内部原理"></a>Git内部原理</h3><h4 id="git目录结构"><a href="#git目录结构" class="headerlink" title=".git目录结构"></a>.git目录结构</h4><p>4个重要的条目：HEAD文件、（尚未创建的）index文件、objects目录、refs目录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">didi@localhost LeetCode-Daily$ ls -al .git</span><br><span class="line">total 64</span><br><span class="line">drwxr-xr-x  16 didi  staff   512  5 23 14:33 .</span><br><span class="line">drwxr-xr-x   8 didi  staff   256  5 23 11:35 ..</span><br><span class="line">-rw-r--r--   1 didi  staff    12  5 23 11:58 COMMIT_EDITMSG</span><br><span class="line">-rw-r--r--   1 didi  staff   205  5 23 00:44 FETCH_HEAD</span><br><span class="line">-rw-r--r--   1 didi  staff    25  5 23 10:59 HEAD							#####   HEAD文件指向目前被检出的分支   #####</span><br><span class="line">-rw-r--r--   1 didi  staff    41  5 23 11:09 ORIG_HEAD</span><br><span class="line">-rw-r--r--   1 didi  staff   483  5 23 11:35 config						#	config文件包含项目特有的配置选项。</span><br><span class="line">-rw-r--r--   1 didi  staff    73  5 23 00:24 description			#	description文件仅供gitWeb程序使用</span><br><span class="line">drwxr-xr-x  15 didi  staff   480  5 23 00:24 hooks						# hooks目录包含客户端或服务端的钩子脚本（hook script）</span><br><span class="line">-rw-r--r--   1 didi  staff   916  5 23 11:58 index						#</span><br><span class="line">drwxr-xr-x   3 didi  staff    96  5 23 14:34 info							# info 目录包含一个全局性排除（global exclude）文件，用以放置那些不希望被记录在.gitignore文件中的忽略模式（ignored patterns）。</span><br><span class="line">drwxr-xr-x   4 didi  staff   128  5 23 00:24 logs</span><br><span class="line">drwxr-xr-x   3 didi  staff    96  5 23 11:35 modules</span><br><span class="line">drwxr-xr-x  55 didi  staff  1760  5 23 11:58 objects					#####   objects目录存储所有数据内容   #####</span><br><span class="line">-rw-r--r--   1 didi  staff   182  5 23 00:24 packed-refs</span><br><span class="line">drwxr-xr-x   6 didi  staff   192  5 23 11:11 refs							#####   refs目录存储指向数据（分支、远程仓库和标签等）   #####</span><br></pre></td></tr></table></figure>



<h4 id="Git对象（objects）"><a href="#Git对象（objects）" class="headerlink" title="Git对象（objects）"></a>Git对象（objects）</h4><p>==git对象主要包括三种：数据对象（blob），树对象（tree），提交对象（commit）==</p>
<h5 id="数据对象：blob"><a href="#数据对象：blob" class="headerlink" title="数据对象：blob"></a>数据对象：blob</h5><blockquote>
<p>数据对象记录index（暂存区中的文件数据）</p>
</blockquote>
<p>Git是一个内容寻址文件系统，Git的核心部分是一个简单的键值对数据库（key-value data store）。可以想Git仓库中插入任意类型的内容，他会返回一个唯一的建，通过该键可以在任意时刻再次取回该内容。</p>
<p><strong>git hash-objec</strong>t 可以将任意数据保存与.git/objects目录（即<strong>对象数据库</strong>，一般我们commit 对象之后的存储位置）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &#x27;test content&#x27; | git hash-object -w --stdin</span><br><span class="line">d670460b4b4aece5915caf5c68d12f560a9fe3e4</span><br></pre></td></tr></table></figure>

<p>在这种最简单的形式中，<code>git hash-object</code>会接受你传给它的东西，而它只会返回可以存储在Git仓库中的唯一键。<code>-w Actually write the object into the object database.</code>选项会指示该命令不要只返回键，还要将该对象写入数据库中。<code>--stdin</code>选项则指示该命令从标准输入读取内容；若不指定，则需在命令尾部给出待存储文件的路径。</p>
<p>此命令输出一个长度为40个字符的校验和。这是一个SHA-1哈希值– 一个将待存储的数据外加一个头部信息（header）一起做SHA-1校验运算而得的校验和。</p>
<p>校验和的前两个字符用于命名子目录，余下的38个字符则用作文件名。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4</span></span><br><span class="line">test content</span><br></pre></td></tr></table></figure>

<p>一旦你将内容存储在了对象数据库中，那么可以通过 <code>cat-file</code>命令从git那里取回数据。<code>-p</code>选项可指示该命令自动判断内容的类型。</p>
<p>至此，目前已经介绍了如何向git中存入内容，以及如何将他们取出。接下来，模拟对一个文件进行简单的版本控制。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">1.首先创建一个新文件并将其内容存入数据库：</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;version 1&#x27;</span> &gt; test.txt</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">git hash-object -w test.txt</span></span><br><span class="line">83baae61804e65cc73a7201a7252750c76066a30	</span><br><span class="line"><span class="meta"># </span><span class="language-bash">2.向文件中添加内容并将其内容存入数据库</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;version 2&#x27;</span> &gt; test.txt</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">git hash-object -w test.txt</span></span><br><span class="line">1f7a7a472abf3dd9643fd615f6da379c4acb3e3a	# 文件内容发生改变，其键值对的键值就会发生改变</span><br><span class="line"><span class="meta"># </span><span class="language-bash">3.从新提交为改变的文件，测试结果如何</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">git hash-object -w test.txt</span></span><br><span class="line">1f7a7a472abf3dd9643fd615f6da379c4acb3e3a	# 如果文件没有发生变化，内容没有变化，重新添加文件，会返回和上次相同的key</span><br><span class="line"><span class="meta"># </span><span class="language-bash">再来看看.git的目录变化</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">tree .git/</span></span><br><span class="line">.git/</span><br><span class="line">├── HEAD</span><br><span class="line">├── config</span><br><span class="line">├── description</span><br><span class="line">├── hooks</span><br><span class="line">│   ├── applypatch-msg.sample</span><br><span class="line">│   ├── commit-msg.sample</span><br><span class="line">│   ├── fsmonitor-watchman.sample</span><br><span class="line">│   ├── post-update.sample</span><br><span class="line">│   ├── pre-applypatch.sample</span><br><span class="line">│   ├── pre-commit.sample</span><br><span class="line">│   ├── pre-merge-commit.sample</span><br><span class="line">│   ├── pre-push.sample</span><br><span class="line">│   ├── pre-rebase.sample</span><br><span class="line">│   ├── pre-receive.sample</span><br><span class="line">│   ├── prepare-commit-msg.sample</span><br><span class="line">│   ├── push-to-checkout.sample</span><br><span class="line">│   └── update.sample</span><br><span class="line">├── info</span><br><span class="line">│   └── exclude</span><br><span class="line">├── objects																					# objects目录下多出了两个目录 1f 和 83，这两个目录的名字对应40位校验和的前两个字符</span><br><span class="line">│   ├── 1f</span><br><span class="line">│   │   └── 7a7a472abf3dd9643fd615f6da379c4acb3e3a  # 对象实际存放的位置</span><br><span class="line">│   ├── 83</span><br><span class="line">│   │   └── baae61804e65cc73a7201a7252750c76066a30	# 对象实际存放的位置</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── pack</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    └── tags</span><br><span class="line"></span><br><span class="line">10 directories, 19 files</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">4.然后我们在本地删除这个文件</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">test.txt</span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">rm</span> test.txt</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">5.接下来我们可以从git数据库中恢复任意的版本；使用git cat-file</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">这里从第一个版本恢复</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 &gt; test.txt</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">cat</span> test.txt</span> </span><br><span class="line">version 1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>然而，记住文件的每个版本所对应的SHA-1值并不现实；另一个问题是，在这个（简单的版本控制）系统中，文件名并没有被保存–我们仅保存了文件的内容。</p>
<p>上述类型的对象我们称之为<strong>数据对象（blob object）</strong>。利用<code>git cat-file -t</code>命令，可以让Git告诉我们其内部存储的任何对象的类型，我们只需提供该对象的SHA-1值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</span></span><br><span class="line">blob</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="树对象"><a href="#树对象" class="headerlink" title="树对象"></a>树对象</h5><p>树对象能解决文件名保存的问题，也允许我们将多个文件组织到一起。所有内容均以树对象<strong>tree</strong>和数据对象<strong>blob</strong>的形式存储，其中树对象对应了unix中的目录项。</p>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">git cat-file -p master^&#123;tree&#125;</span></span><br><span class="line">100644 blob a906cb2a4a904a152e80877d4088654daad0c859		README		# 数据对象	代表一个文件数据</span><br><span class="line">100644 blob 8f94139338f9404f26296befa88755fc2598c289		Rakefile	# 数据对象</span><br><span class="line">040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0		lib				# tree 树对象 	代表一个目录</span><br></pre></td></tr></table></figure>

<p><font color=green>master^{tree}</font> 语法表示<font color=green> master </font>分支上最新的提交所指向的树对象</p>
<p>第一列为文件模式：</p>
<table>
<thead>
<tr>
<th>文件模式</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>100644</td>
<td>表明这是一个普通文件</td>
<td></td>
</tr>
<tr>
<td>100755</td>
<td>表示一个可执行 文件</td>
<td></td>
</tr>
<tr>
<td>120000</td>
<td>表示一个符号链接</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>上述三种文件模式即为git文件的所有模式（参考unix的文件格式）</td>
</tr>
<tr>
<td>040000</td>
<td>表示一个目录项</td>
<td></td>
</tr>
</tbody></table>
<p>第二列表示树对象中节点的类型</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>blob</td>
<td>节点数据，表示该节点是一个文件数据</td>
<td></td>
</tr>
<tr>
<td>tree</td>
<td>树数据，表示该节点是一个目录项</td>
<td></td>
</tr>
</tbody></table>
<h6 id="Git-内部存储的数据（tree对象）"><a href="#Git-内部存储的数据（tree对象）" class="headerlink" title="Git 内部存储的数据（tree对象）"></a>Git 内部存储的数据（tree对象）</h6><p><img src="https://github.com/xiaowodi/Resources/blob/main/images/gitImages/3.png?raw=true" alt="3.png"></p>
<h6 id="底层命令"><a href="#底层命令" class="headerlink" title="底层命令"></a>底层命令</h6><p><font color=blue>特此说明：</font></p>
<ul>
<li>我们每次commit提交后的数据，都会存储成树对象，每次提交后会自动的在objects目录下创建两个对象（tree对象 和 commit对象）</li>
<li>添加到暂存区中的数据，会在objects下创建一个blob类型的数据对象，记录文件的内容</li>
</ul>
<table>
<thead>
<tr>
<th>blob对象</th>
<th>记录index暂存区中文件的实际内容</th>
<th><strong>$</strong> git cat-file -p 3b18e512dba79e4c8300dd08aeb37f8e728b8dad<br />hello world</th>
</tr>
</thead>
<tbody><tr>
<td>树对象</td>
<td>记录了提交的暂存区中的文件信息（包括类型，SHA-1值和文件名）</td>
<td><strong>$</strong> git cat-file -p c3b8bb102afeca86037d5b5dd89ceeb0090eae9d<br />100644 blob 3b18e512dba79e4c8300dd08aeb37f8e728b8dad    test.txt</td>
</tr>
<tr>
<td>commit对象</td>
<td>记录了提交信息</td>
<td><strong>$</strong> git cat-file -p 27edfec26df5483fc78e009e446fc063891989e3<br />tree c3b8bb102afeca86037d5b5dd89ceeb0090eae9d<br />author yulu <a href="mailto:&#50;&#x37;&#50;&#x33;&#x39;&#52;&#x36;&#x32;&#x38;&#57;&#x40;&#113;&#113;&#46;&#x63;&#111;&#x6d;">&#50;&#x37;&#50;&#x33;&#x39;&#52;&#x36;&#x32;&#x38;&#57;&#x40;&#113;&#113;&#46;&#x63;&#111;&#x6d;</a> 1623757703 +0800<br />committer yulu <a href="mailto:&#50;&#55;&#50;&#x33;&#x39;&#52;&#54;&#50;&#x38;&#x39;&#x40;&#x71;&#113;&#x2e;&#99;&#x6f;&#x6d;">&#50;&#55;&#50;&#x33;&#x39;&#52;&#54;&#50;&#x38;&#x39;&#x40;&#x71;&#113;&#x2e;&#99;&#x6f;&#x6d;</a> 1623757703 +0800<br /><br />first commit</td>
</tr>
</tbody></table>
<p>代码小结：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash"><span class="comment">#############################</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">数据对象</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash"><span class="comment">#############################</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">1. 创建gitTest目录 并 切换到次目录</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">2. git init初始化一个git项目</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">3. tree命令查看.git目录</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">tree .git/</span></span><br><span class="line">.git/</span><br><span class="line">├── HEAD</span><br><span class="line">├── config</span><br><span class="line">├── description</span><br><span class="line">├── hooks</span><br><span class="line">│   ├── ...........</span><br><span class="line">├── info</span><br><span class="line">│   └── exclude</span><br><span class="line">├── objects</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── pack</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    └── tags</span><br><span class="line"></span><br><span class="line">8 directories, 17 files</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">4. 通过git hash-object 创建 数据对象blob</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;version 1&#x27;</span> &gt; test.txt <span class="comment"># 先创建一个文件（相当于我们在工作区创建了一个文件）</span></span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">git hash-object -w test.txt	<span class="comment"># -w 选项表示 将对象写入git的对象数据库</span></span></span><br><span class="line">83baae61804e65cc73a7201a7252750c76066a30  # 对象的SHA-1编码：前两位 83 代表对象存储的实际目录</span><br><span class="line"><span class="meta">$ </span><span class="language-bash">git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30	<span class="comment"># git cat-file 查看实际对象数据库中的对象，-p 显示内容</span></span></span><br><span class="line">version 1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">接下来，我们往工作区总的test.txt中添加一段内容</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;version 2&#x27;</span> &gt; test.txt</span> </span><br><span class="line"><span class="meta"># </span><span class="language-bash">5. 再通过git hash-object将更改后的文件存储到对象数据库中</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">git hash-object -w test.txt</span></span><br><span class="line">1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">我们来看看底层是如何存储对象的</span></span><br><span class="line">.git/</span><br><span class="line">├── HEAD</span><br><span class="line">├── config</span><br><span class="line">├── description</span><br><span class="line">├── hooks</span><br><span class="line">│   ├── .....................</span><br><span class="line">├── info</span><br><span class="line">│   └── exclude</span><br><span class="line">├── objects</span><br><span class="line">│   ├── 1f</span><br><span class="line">│   │   └── 7a7a472abf3dd9643fd615f6da379c4acb3e3a  # 对应于我们更改后的第二个版本的test.txt文件</span><br><span class="line">│   ├── 83</span><br><span class="line">│   │   └── baae61804e65cc73a7201a7252750c76066a30	# 对应于我们更改后的第一个版本的test.txt文件</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── pack</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    └── tags</span><br><span class="line"></span><br><span class="line">10 directories, 19 files</span><br><span class="line"><span class="meta"># </span><span class="language-bash">通过上述存储在对象数据库中的信息，可以随时恢复工作区中的内容</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">6. 例如：我们将工作区中的第二版的test.txt删除，然后恢复至第一个版本</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">rm</span> test.txt</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash">git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 &gt; test.txt</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">cat</span> test.txt</span>   </span><br><span class="line">version 1    # 恢复至第一个版本</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">cat-file -t 选项可以查看对象的类型</span></span><br><span class="line">git cat-file -t 83baae61804e65cc73a7201a7252750c76066a30</span><br><span class="line">blob		# blob 数据对象</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash"><span class="comment">#############################</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">树对象： 能够解决文件名保存的问题 <span class="comment">#</span></span> </span><br><span class="line"><span class="meta"># </span><span class="language-bash">通常情况下，Git根据某一时刻暂存区所表示的状态创建并记录一个对象的树对象；换句话说，创建一个树对象，我们首先要暂存一些文件（对象）</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash"><span class="comment">#############################</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">暂存对象数据库中的对象，通过 git update-index命令来实现</span></span><br><span class="line"> --add                 不忽略新的文件</span><br><span class="line">--cacheinfo &lt;存取模式&gt;,&lt;对象&gt;,&lt;路径&gt;</span><br><span class="line">                          添加指定的条目到索引区</span><br><span class="line"><span class="meta">$ </span><span class="language-bash">git update-index --add --cacheinfo 100644 83baae61804e65cc73a7201a7252750c76066a30 test.txt <span class="comment"># 将第一个版本的数据添加到暂存区test.txt文件中</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">通过status来验证暂存区中的内容</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">git status</span></span><br><span class="line">位于分支 master</span><br><span class="line"></span><br><span class="line">尚无提交</span><br><span class="line"></span><br><span class="line">要提交的变更：</span><br><span class="line">  （使用 &quot;git rm --cached &lt;文件&gt;...&quot; 以取消暂存）</span><br><span class="line">	新文件：   test.txt	# 暂存区中新增了test.txt文件</span><br><span class="line"><span class="meta"># </span><span class="language-bash">7. 调用git write-tree 命令，自动将暂存区中的内容写入一个树对象中</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">git write-tree</span></span><br><span class="line">d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line"><span class="meta">$ </span><span class="language-bash">git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span></span><br><span class="line">100644 blob 83baae61804e65cc73a7201a7252750c76066a30	test.txt  # 树对象内容的基本格式</span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看一下这个对象的git对象类型</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span></span><br><span class="line">tree</span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看objects目录</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">tree .git/</span></span><br><span class="line">.git/</span><br><span class="line">├── HEAD</span><br><span class="line">├── config</span><br><span class="line">├── description</span><br><span class="line">├── hooks</span><br><span class="line">│   ├── ............................</span><br><span class="line">├── index</span><br><span class="line">├── info</span><br><span class="line">│   └── exclude</span><br><span class="line">├── objects</span><br><span class="line">│   ├── 1f</span><br><span class="line">│   │   └── 7a7a472abf3dd9643fd615f6da379c4acb3e3a</span><br><span class="line">│   ├── 83</span><br><span class="line">│   │   └── baae61804e65cc73a7201a7252750c76066a30 </span><br><span class="line">│   ├── d8</span><br><span class="line">│   │   └── 329fc1cc938780ffdd9f94e0d364e0ea74f579 # 树对象跟blob对象都是以相同的形式存储在objects中</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── pack</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    └── tags</span><br><span class="line"></span><br><span class="line">11 directories, 21 files</span><br><span class="line"><span class="meta"># </span><span class="language-bash">接下来创建一个新的树对象，它包括 test.txt 文件的第二个版本，以及一个新的文件：</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;new file&#x27;</span> &gt; new.txt</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">git update-index --add --cacheinfo 100644 \ 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">git update-index --add new.txt</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看git的当前状态</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">git status   <span class="comment"># 包括一个修改的test.txt和一个新文件new.txt</span></span></span><br><span class="line">位于分支 master</span><br><span class="line"></span><br><span class="line">尚无提交</span><br><span class="line"></span><br><span class="line">要提交的变更：</span><br><span class="line">  （使用 &quot;git rm --cached &lt;文件&gt;...&quot; 以取消暂存）</span><br><span class="line">	新文件：   new.txt</span><br><span class="line">	新文件：   test.txt</span><br><span class="line"></span><br><span class="line">尚未暂存以备提交的变更：</span><br><span class="line">  （使用 &quot;git add &lt;文件&gt;...&quot; 更新要提交的内容）</span><br><span class="line">  （使用 &quot;git restore &lt;文件&gt;...&quot; 丢弃工作区的改动）</span><br><span class="line">	修改：     test.txt</span><br><span class="line"><span class="meta"># </span><span class="language-bash">8.创建新的tree对象，这个对象中包含两个暂存区中的文件</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">git write-tree</span></span><br><span class="line">0155eb4229851634a0f03eb265b69f5a2d56f341</span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看它的内容</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341			<span class="comment"># 一个tree对象包含了两个blob对象</span></span></span><br><span class="line">100644 blob fa49b077972391ad58037050f2a75f74e3671e92	new.txt</span><br><span class="line">100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a	test.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">git read-tree 是write-tree的反向操作，可将一个树对象读取到暂存区中</span></span><br><span class="line"> --prefix &lt;子目录&gt;/    读取树对象到索引的 &lt;子目录&gt;/ 下</span><br><span class="line"><span class="meta"># </span><span class="language-bash">9. 通过read-tree命令将第一个版本test.txt对应的树对象d8329fc1cc938780ffdd9f94e0d364e0ea74f579 读取到暂存区bak目录下</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">git status</span></span><br><span class="line">位于分支 master</span><br><span class="line"></span><br><span class="line">尚无提交</span><br><span class="line"></span><br><span class="line">要提交的变更：</span><br><span class="line">  （使用 &quot;git rm --cached &lt;文件&gt;...&quot; 以取消暂存）</span><br><span class="line">	新文件：   bak/test.txt</span><br><span class="line">	新文件：   new.txt</span><br><span class="line">	新文件：   test.txt</span><br><span class="line"><span class="meta"># </span><span class="language-bash">此时暂存区中有三个文件，其中test.txt一版的存储在bak目录下</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">10.再创建树对象</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">git write-tree</span></span><br><span class="line">3c4e9cd789d88d8d89c1073707c3585e41b0e614</span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看这个树对象的内容</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614</span></span><br><span class="line">040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579	bak  		# 如果存在目录，那么就会再创建一个树对象</span><br><span class="line">100644 blob fa49b077972391ad58037050f2a75f74e3671e92	new.txt</span><br><span class="line">100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a	test.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>代码中第10步的树对象3c4e9cd789d88d8d89c1073707c3585e41b0e614对应的结构示意图</p>
<p><img src="https://github.com/xiaowodi/Resources/blob/main/images/gitImages/4.png?raw=true" alt="4.png"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash"><span class="comment">#########################</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">虽然此时，底层已经通过树对象把对象保存起来了，但是是不是感觉缺了点什么？</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">正常我们提交一次暂存区中的内容，不只是把对象存储起来而已，我们还会附带一些提交信息，这些提交信息Git通过提交对象进行存储。</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">提交对象commit</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash"><span class="comment">#########################</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">创建提交对象commit，可以通过 git commit-tree SHA-1值进行创建</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;first commit&#x27;</span> | git commit-tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span></span><br><span class="line">f5f0cda7464b026ddb429129224cd58138555bfb</span><br><span class="line"><span class="meta">$ </span><span class="language-bash">git cat-file -p f5f0cda7464b026ddb429129224cd58138555bfb</span></span><br><span class="line">tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579</span><br><span class="line">author yulu &lt;2723946289@qq.com&gt; 1623930083 +0800</span><br><span class="line">committer yulu &lt;2723946289@qq.com&gt; 1623930083 +0800</span><br><span class="line"></span><br><span class="line">first commit</span><br><span class="line"><span class="meta"># </span><span class="language-bash">第二次提交， -p 选项指定父提交</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;second commit&#x27;</span> | git commit-tree 0155eb -p f5f0cda7464b026ddb429129224cd58138555bfb</span></span><br><span class="line">cbeda08bbfc505e2f029fe7bdd4e32af8f60a33c</span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看第二次提交的对象</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">git cat-file -p cbeda08bbfc505e2f029fe7bdd4e32af8f60a33c</span></span><br><span class="line">tree 0155eb4229851634a0f03eb265b69f5a2d56f341</span><br><span class="line">parent f5f0cda7464b026ddb429129224cd58138555bfb</span><br><span class="line">author yulu &lt;2723946289@qq.com&gt; 1623930720 +0800</span><br><span class="line">committer yulu &lt;2723946289@qq.com&gt; 1623930720 +0800</span><br><span class="line"></span><br><span class="line">second commit</span><br><span class="line"><span class="meta"># </span><span class="language-bash">第三次提交的对象</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;third commit&#x27;</span>  | git commit-tree 3c4e9c -p cbeda0</span></span><br><span class="line">c759b5a289338e9d55333ff7900fdc4ee0526c33</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash"><span class="comment">## ###</span></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">通过上述操作，已经创建了3个commit对象</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash"><span class="comment">## ###</span></span></span><br></pre></td></tr></table></figure>


















































































































































































































      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://xiaowodi.github.io/2022/06/24/Docker%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/24/Docker%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Docker入门学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-24 08:12:10" itemprop="dateCreated datePublished" datetime="2022-06-24T08:12:10+00:00">2022-06-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h1 id="Docker-入门学习"><a href="#Docker-入门学习" class="headerlink" title="Docker 入门学习"></a>Docker 入门学习</h1><p>docker（容器化技术）</p>
<p><img src="C:\Users\LuYu\AppData\Roaming\Typora\typora-user-images\image-20210605153338347.png" alt="image-20210605153338347"></p>
<h3 id="docker和虚拟机技术的不同"><a href="#docker和虚拟机技术的不同" class="headerlink" title="docker和虚拟机技术的不同"></a>docker和虚拟机技术的不同</h3><ul>
<li>传统虚拟机，虚拟出一台硬件环境，运行一个完整的操作系统，然后在这个系统上安装和运行软件</li>
<li>容器内的应用直接运行在  <code>宿主机</code>  的内核中的，容器是没有自己的内核的，也没有虚拟我们的硬件，所以就轻便</li>
<li>每个容器间是互相隔离，每个容器内都有一个属于自己的文件系统，互不影响、</li>
</ul>
<blockquote>
<p>举个例子：之前使用虚拟机，电脑装了3个hadoop节点的集群，电脑就开始卡了</p>
<p>​                    使用容器后，你可能会装到30个（有点夸张了啊！）</p>
</blockquote>
<blockquote>
<p>DevOps（开发、运维）</p>
</blockquote>
<p>应用更快速的交付和部署、</p>
<p><strong>更快速的交付和部署</strong></p>
<p>传统：一堆帮助文档，安装程序</p>
<p>Docker：一键运行打包镜像发布测试，一键运行</p>
<p><strong>更便捷的升级和扩缩容</strong></p>
<p>使用了Docker之后，我们部署应用就和搭积木一样！！！</p>
<p>项目打包为一个镜像，扩展 服务器A！服务器B</p>
<p><strong>更简单的系统运维</strong></p>
<p>在容器化之后，我们的开发，测试环境都是高度一致的。（不会再出现在我的电脑上可以使用，再别人的电脑上就不可以使用了）</p>
<p><strong>更高效的计算资源利用：</strong></p>
<p>Docker是内核级别的虚拟化，可以再一个物理机上运行很多的容器实例！服务器的性能可以被压榨到极致。</p>
<h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><h3 id="Docker-的基本组成"><a href="#Docker-的基本组成" class="headerlink" title="Docker 的基本组成"></a>Docker 的基本组成</h3><p><img src="https://www.runoob.com/wp-content/uploads/2016/04/576507-docker1.png" alt="img"></p>
<ul>
<li><strong>镜像</strong>：Docker镜像（image），就相当于一个root文件系统。比如官方镜像ubuntu16.04就包含了完整的一套ubuntu16.04最下系统的root文件系统</li>
<li>**容器(Container)**：镜像和容器的关系，就像是面向对象程序设计中的类和对象一样，镜像是静态的定义，容器是镜像运行时的实例。容器可以被创建、启动、停止、删除、暂定等等。</li>
<li><strong>仓库（Repository）</strong>：仓库可看成一个代码控制中心，用来保存镜像。</li>
</ul>
<table>
<thead>
<tr>
<th>概念</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Docker镜像（Image）</strong></td>
<td>Docker镜像是用于创建Docker容器的模板，比如Ubuntu系统。</td>
</tr>
<tr>
<td><strong>Docker容器（Container）</strong></td>
<td>容器是独立运行的一个或一组应用，是镜像运行时的实体</td>
</tr>
<tr>
<td><strong>Docker客户端（Client）</strong></td>
<td>Docker客服端通过命令或者其他工具Docker SDK 与 Docker的守护进程通信。</td>
</tr>
<tr>
<td><strong>Docker主机（Host）</strong></td>
<td>一个物理或者虚拟的机器用于执行Docker守护进程和容器</td>
</tr>
<tr>
<td><strong>Docker Registry</strong></td>
<td>Docker仓库用来保存镜像，可以理解为代码控制中的代码仓库、<br />Docker Hub（<a target="_blank" rel="noopener" href="https://hub.docker.com)提供了庞大的镜像集合供使用(但是在国内,我们需要**配置镜像加速**)/">https://hub.docker.com）提供了庞大的镜像集合供使用（但是在国内，我们需要**配置镜像加速**）</a><br />一个Docker Registry中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（tag）；每个标签对应一个镜像。<br />通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应软件的各个版本。我们可以通过**&lt;仓库名&gt;:&lt;标签&gt;**的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以latest作为默认标签</td>
</tr>
<tr>
<td><strong>Docker Machine</strong></td>
<td>Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令即可在相应的平台上安装Docker。<br />比如VirtualBox。Digital Ocean、Microsoft Azure</td>
</tr>
</tbody></table>
<h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><p>参考官方文档<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p>
<p>在centos7下安装docker</p>
<h4 id="卸载旧版"><a href="#卸载旧版" class="headerlink" title="卸载旧版"></a>卸载旧版</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>

<h4 id="安装yum-yum-utils基础工具"><a href="#安装yum-yum-utils基础工具" class="headerlink" title="安装yum yum-utils基础工具"></a>安装yum yum-utils基础工具</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">   --add-repo \</span><br><span class="line">   https://download.docker.com/linux/centos/docker-ce.repo  -- 配置docker的yum源，由于是国外的地址，我们需要配合国内的镜像</span><br><span class="line">   </span><br><span class="line">sudo yum install -y yum-utils</span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">   --add-repo \</span><br><span class="line">   http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<h4 id="更新yum索引"><a href="#更新yum索引" class="headerlink" title="更新yum索引"></a>更新yum索引</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure>

<h4 id="安装Docker引擎"><a href="#安装Docker引擎" class="headerlink" title="安装Docker引擎"></a>安装Docker引擎</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>

<h4 id="启动Docker服务"><a href="#启动Docker服务" class="headerlink" title="启动Docker服务"></a>启动Docker服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>

<h4 id="设置开机自启"><a href="#设置开机自启" class="headerlink" title="设置开机自启"></a>设置开机自启</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable docker.service	</span><br></pre></td></tr></table></figure>

<h4 id="设置docker镜像源"><a href="#设置docker镜像源" class="headerlink" title="设置docker镜像源"></a>设置docker镜像源</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">vim /etc/docker/daemon.json</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://iqckan08.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">$ </span><span class="language-bash">sudo systemctl daemon-reload 重载</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">sudo systemctl restart docker 最后检查是否·成功</span></span><br></pre></td></tr></table></figure>





<p>docker安装成功之后，输入docker version 可以查看docker是否安装成功</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop102 ~]$ sudo docker version</span><br><span class="line">Client: Docker Engine - Community</span><br><span class="line"> Version:           20.10.7</span><br><span class="line"> API version:       1.41</span><br><span class="line"> Go version:        go1.13.15</span><br><span class="line"> Git commit:        f0df350</span><br><span class="line"> Built:             Wed Jun  2 11:58:10 2021</span><br><span class="line"> OS/Arch:           linux/amd64</span><br><span class="line"> Context:           default</span><br><span class="line"> Experimental:      true</span><br><span class="line"></span><br><span class="line">Server: Docker Engine - Community</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          20.10.7</span><br><span class="line">  API version:      1.41 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.13.15</span><br><span class="line">  Git commit:       b0f5bc3</span><br><span class="line">  Built:            Wed Jun  2 11:56:35 2021</span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     false</span><br><span class="line"> containerd:</span><br><span class="line">  Version:          1.4.6</span><br><span class="line">  GitCommit:        d71fcd7d8303cbf684402823e425e9dd2e99285d</span><br><span class="line"> runc:</span><br><span class="line">  Version:          1.0.0-rc95</span><br><span class="line">  GitCommit:        b9ee9c6314599f1b4a7f497e1f1f856fe433d3b7</span><br><span class="line"> docker-init:</span><br><span class="line">  Version:          0.19.0</span><br><span class="line">  GitCommit:        de40ad0</span><br></pre></td></tr></table></figure>

<h3 id="Docker底层原理"><a href="#Docker底层原理" class="headerlink" title="Docker底层原理"></a>Docker底层原理</h3><h4 id="Docker是怎么工作的？"><a href="#Docker是怎么工作的？" class="headerlink" title="Docker是怎么工作的？"></a>Docker是怎么工作的？</h4><p>Docker是一个Client-Server结构的系统，Docker的守护进程运行在主机上，通过Socket从客户端访问！</p>
<p>Docker-Server接收到Docker-Client的指令，就会执行这些指令<img src="C:\Users\LuYu\AppData\Roaming\Typora\typora-user-images\image-20210605185400973.png" alt="image-20210605185400973"></p>
<img src="https://img-blog.csdnimg.cn/20200411132031597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0ODkxMjk1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;" />







<h4 id="Docker为什么比VM快？"><a href="#Docker为什么比VM快？" class="headerlink" title="Docker为什么比VM快？"></a>Docker为什么比VM快？</h4><img src="https://img1.baidu.com/it/u=3114630737,3916130790&fm=26&fmt=auto&gp=0.jpg" alt="img" style="zoom:150%;" />

<ol>
<li>Docker有着比虚拟机更少的抽象层</li>
<li>Docker利用的是宿主机的内核（kernel，只有一个）<ol>
<li>而VM需要Guest OS。</li>
</ol>
</li>
</ol>
<p>所以说，新建一个容器的时候，，docker不需要像虚拟机一样重新加载一个操作系统内核，避免引导。虚拟机是加载Guest OS的，是分钟级别；而docker是利用宿主机的操作系统，省略了Guest OS那一层的加载，启动时秒级的。</p>
<p><strong>Host OS 与 Guest OS</strong></p>
<blockquote>
<p>Host OS(主人操作系统）就是安装在你硬件设备上的系统，而Guest OS(客人操作系统）则是安装在虚拟机（VM）上面的系统。</p>
</blockquote>
<blockquote>
<blockquote>
<p>例如你的电脑上的Windows系统就是作为Host OS,如果在你的电脑设备上拓展出一些虚拟机，并在虚拟机上安裝了 Windows XP，那么Windows XP 就叫做 Guest OS。</p>
</blockquote>
</blockquote>
<h2 id="Docker的常用命令"><a href="#Docker的常用命令" class="headerlink" title="Docker的常用命令"></a>Docker的常用命令</h2><h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker version			# 显示docker的版本信息</span><br><span class="line">docker info			    # 显示docker的系统信息，包括镜像和容器的数量</span><br><span class="line">docker 命令 --help	   # 帮助信息</span><br></pre></td></tr></table></figure>

<p>帮助文档的地址：<a target="_blank" rel="noopener" href="https://docs.docker.com/reference/">https://docs.docker.com/reference/</a></p>
<h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><h4 id="docker-images-查看所有本地的主机上的镜像"><a href="#docker-images-查看所有本地的主机上的镜像" class="headerlink" title="docker images 查看所有本地的主机上的镜像"></a><strong>docker images</strong> 查看所有本地的主机上的镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">1. docker images</span></span><br><span class="line">[hadoop@hadoop102 ~]$ sudo docker images</span><br><span class="line">[sudo] hadoop 的密码：</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">hello-world   latest    d1165f221234   3 months ago   13.3kB</span><br><span class="line"><span class="meta">#</span><span class="language-bash">解释</span></span><br><span class="line">REPOSITORY		镜像的仓库名</span><br><span class="line">TAG				镜像的标签</span><br><span class="line">IMAGE ID		镜像的ID</span><br><span class="line">CREATED			镜像的创建时间</span><br><span class="line">SIZE			镜像的大小</span><br><span class="line"><span class="meta"># </span><span class="language-bash">可选项</span></span><br><span class="line">	-a，--all	#列出所有镜像</span><br><span class="line">	-q，--quiet  # 只显示镜像的ID</span><br><span class="line"><span class="meta"># </span><span class="language-bash">测试</span></span><br><span class="line">[hadoop@hadoop102 ~]$ sudo docker images -a</span><br><span class="line">[sudo] hadoop 的密码：</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">hello-world   latest    d1165f221234   3 months ago   13.3kB</span><br><span class="line">[hadoop@hadoop102 ~]$ sudo docker images -aq</span><br><span class="line">d1165f221234</span><br><span class="line">[hadoop@hadoop102 ~]$</span><br></pre></td></tr></table></figure>

<h4 id="docker-search搜索镜像"><a href="#docker-search搜索镜像" class="headerlink" title="docker search搜索镜像"></a><strong>docker search</strong>搜索镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop102 ~]$ sudo docker search mysql</span><br><span class="line">NAME                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mysql                             MySQL is a widely used, open-source relation…   10957     [OK]</span><br><span class="line">mariadb                           MariaDB Server is a high performing open sou…   4142      [OK]</span><br><span class="line">mysql/mysql-server                Optimized MySQL Server Docker images. Create…   814                  [OK]</span><br><span class="line">percona                           Percona Server is a fork of the MySQL relati…   539       [OK]</span><br><span class="line">centos/mysql-57-centos7           MySQL 5.7 SQL database server                   88</span><br><span class="line">mysql/mysql-cluster               Experimental MySQL Cluster Docker images. Cr…   85</span><br><span class="line">centurylink/mysql                 Image containing mysql. Optimized to be link…   59                   [OK]</span><br><span class="line">bitnami/mysql                     Bitnami MySQL Docker Image                      52                   [OK]</span><br><span class="line">databack/mysql-backup             Back up mysql databases to... anywhere!         43</span><br><span class="line">deitch/mysql-backup               REPLACED! Please use http://hub.docker.com/r…   41                   [OK]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="docker-pull-tag-下载镜像"><a href="#docker-pull-tag-下载镜像" class="headerlink" title="docker pull[:tag] 下载镜像"></a><strong>docker pull[:tag]</strong> 下载镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop102 ~]$ sudo docker pull --help</span><br><span class="line">[sudo] hadoop 的密码：</span><br><span class="line"></span><br><span class="line">Usage:  docker pull [OPTIONS] NAME[:TAG|@DIGEST]</span><br><span class="line"></span><br><span class="line">Pull an image or a repository from a registry</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -a, --all-tags                Download all tagged images in the repository</span><br><span class="line">      --disable-content-trust   Skip image verification (default true)</span><br><span class="line">      --platform string         Set platform if server is multi-platform capable</span><br><span class="line">  -q, --quiet                   Suppress verbose output</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">pull Mysql 镜像</span></span><br><span class="line">[hadoop@hadoop102 ~]$ sudo docker pull mysql</span><br><span class="line">Using default tag: latest			# 不指定tag， 默认最新版本</span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">69692152171a: Downloading			# 分层下载，docker image的核心  联合文件系统</span><br><span class="line">1651b0be3df3: Downloading</span><br><span class="line">951da7386bc8: Downloading</span><br><span class="line">0f86c95aa242: Waiting</span><br><span class="line">37ba2d8bd4fe: Waiting</span><br><span class="line">6d278bb05e94: Downloading</span><br><span class="line">497efbd93a3e: Waiting</span><br><span class="line">f7fddf10c2c2: Waiting</span><br><span class="line">16415d159dfb: Waiting</span><br><span class="line">0e530ffc6b73: Waiting</span><br><span class="line">b0a4a1a77178: Waiting</span><br><span class="line">cd90f92aa9ef: Waiting</span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">69692152171a: Pull complete</span><br><span class="line">1651b0be3df3: Pull complete</span><br><span class="line">951da7386bc8: Pull complete</span><br><span class="line">0f86c95aa242: Pull complete</span><br><span class="line">37ba2d8bd4fe: Pull complete</span><br><span class="line">6d278bb05e94: Pull complete</span><br><span class="line">497efbd93a3e: Pull complete</span><br><span class="line">f7fddf10c2c2: Pull complete</span><br><span class="line">16415d159dfb: Pull complete</span><br><span class="line">0e530ffc6b73: Pull complete</span><br><span class="line">b0a4a1a77178: Pull complete</span><br><span class="line">cd90f92aa9ef: Pull complete</span><br><span class="line">Digest: sha256:d50098d7fcb25b1fcb24e2d3247cae3fc55815d64fec640dc395840f8fa80969	# 签名</span><br><span class="line">Status: Downloaded newer image for mysql:lates</span><br><span class="line">docker.io/library/mysql:latest	# 真实地址</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">说明</span></span><br><span class="line">docker pull mysql</span><br><span class="line">docker pull docker.io/library/mysql:latest </span><br><span class="line"><span class="meta"># </span><span class="language-bash">上述这两条命令是等价的</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="docker-rmi-imageID-删除镜像、"><a href="#docker-rmi-imageID-删除镜像、" class="headerlink" title="docker rmi imageID:删除镜像、"></a><strong>docker rmi imageID</strong>:删除镜像、</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop102 ~]$ sudo docker rmi --help</span><br><span class="line"></span><br><span class="line">Usage:  docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br><span class="line"></span><br><span class="line">Remove one or more images</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -f, --force      Force removal of the image</span><br><span class="line">      --no-prune   Do not delete untagged parents</span><br><span class="line"><span class="meta"># </span><span class="language-bash">删除一个镜像</span></span><br><span class="line">[hadoop@hadoop102 ~]$ sudo docker rmi -f d1165f221234</span><br><span class="line">Untagged: hello-world:latest</span><br><span class="line">Untagged: hello-world@sha256:5122f6204b6a3596e048758cabba3c46b1c937a46b5be6225b835d091b90e46c</span><br><span class="line">Deleted: sha256:d1165f2212346b2bab48cb01c1e39ee8ad1be46b87873d9ca7a4e434980a7726</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">批量删除</span></span><br><span class="line">sudo docker rmi -f 镜像ID1 镜像ID2 镜像ID3	# 删除多个镜像，中间使用空格分隔</span><br><span class="line">sudo docker rmi -f `sudo docker images -aq` #删除全部镜像</span><br><span class="line">sudo docker rmi -f $(sudo docker images -aq) #删除全部镜像</span><br><span class="line">[hadoop@hadoop102 ~]$ sudo docker rmi -f `sudo docker images -aq`  # 查找出所有的images的ID</span><br><span class="line">Untagged: mysql:5.7</span><br><span class="line">Untagged: mysql@sha256:a682e3c78fc5bd941e9db080b4796c75f69a28a8cad65677c23f7a9f18ba21fa</span><br><span class="line">Deleted: sha256:2c9028880e5814e8923c278d7e2059f9066d56608a21cd3f83a01e3337bacd68</span><br><span class="line">Deleted: sha256:c49c5c776f1bc87cdfff451ef39ce16a1ef45829e10203f4d9a153a6889ec15e</span><br><span class="line">Deleted: sha256:8345316eca77700e62470611446529113579712a787d356e5c8656a41c244aee</span><br><span class="line">Deleted: sha256:8ae51b87111404bd3e3bde4115ea2fe3fd2bb2cf67158460423c361a24df156b</span><br><span class="line">Deleted: sha256:9d5afda6f6dcf8dd59aef5c02099f1d3b3b0c9ae4f2bb7a61627613e8cdfe562</span><br><span class="line">Untagged: mysql:latest</span><br><span class="line">Untagged: mysql@sha256:d50098d7fcb25b1fcb24e2d3247cae3fc55815d64fec640dc395840f8fa80969</span><br><span class="line">Deleted: sha256:c0cdc95609f1fc1daf2c7cae05ebd6adcf7b5c614b4f424949554a24012e3c09</span><br><span class="line">Deleted: sha256:137bebc5ea278e61127e13cc7312fd83874cd19e392ee87252b532f0162fbd56</span><br><span class="line">Deleted: sha256:7ed0de2ad4e43c97f58fa9e81fba73700167ef9f8a9970685059e0109749a56b</span><br><span class="line">Deleted: sha256:9375660fbff871cd29c86b8643be60e376bfc96e99a3d7e8f93d74cd61500705</span><br><span class="line">Deleted: sha256:d8a47065d005ac34d81017677330ce096eb5562eeb971e2db12b0e200fdb1cb6</span><br><span class="line">Deleted: sha256:ca13c8ad9df5d824d5a259a927eaa6c04a60f022bc2abe8fc7866cf4b2b366f4</span><br><span class="line">Deleted: sha256:7af1865d5c19316c3dc0829a2ee2b3a744ae756f7fec9c213d3afc5f1f6ed306</span><br><span class="line">Deleted: sha256:f205c8f3c8aaa6376442b34c0c2062738461d37e0aa16ba021cd7e09c67213c2</span><br><span class="line">Deleted: sha256:d690e8a8242cf13cbe98c5b2faffdd0fc7e6c4c13425b5da31de991aa1f89a76</span><br><span class="line">Deleted: sha256:24efeee958e9f3d859fe15540e9296d5aaa6d3eb3b5f5494a2e8370608a4cfaa</span><br><span class="line">Deleted: sha256:654f2ffede3bb536fd62d04c9c7b7826e890828bec92182634e38684959b2498</span><br><span class="line">Deleted: sha256:de478a06eaa676052e665faa0b07d86a007f4b87cf82eb46a258742dc2d32260</span><br><span class="line">Deleted: sha256:02c055ef67f5904019f43a41ea5f099996d8e7633749b6e606c400526b2c4b33</span><br><span class="line">[hadoop@hadoop102 ~]$ sudo docker images</span><br><span class="line">REPOSITORY   TAG       IMAGE ID   CREATED   SIZE</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h3><h4 id="新建容器并启动：docker-run"><a href="#新建容器并启动：docker-run" class="headerlink" title="新建容器并启动：docker run"></a>新建容器并启动：docker run</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop102 ~]$ sudo docker run --help</span><br><span class="line"></span><br><span class="line">Usage:  docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line">Run a command in a new container</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --add-host list                  Add a custom host-to-IP mapping (host:ip)</span><br><span class="line">  -a, --attach list                    Attach to STDIN, STDOUT or STDERR</span><br><span class="line">      --blkio-weight uint16            Block IO (relative weight), between 10 and 1000, or 0 to disable (default 0)</span><br><span class="line">      --blkio-weight-device list       Block IO weight (relative device weight) (default [])</span><br><span class="line">      --cap-add list                   Add Linux capabilities</span><br><span class="line">      --cap-drop list                  Drop Linux capabilities</span><br><span class="line">      --cgroup-parent string           Optional parent cgroup for the container</span><br><span class="line">      --cgroupns string                Cgroup namespace to use (host|private)</span><br><span class="line">                                       &#x27;host&#x27;:    Run the container in the Docker host&#x27;s cgroup namespace</span><br><span class="line">                                       &#x27;private&#x27;: Run the container in its own private cgroup namespace</span><br><span class="line">                                       &#x27;&#x27;:        Use the cgroup namespace as configured by the</span><br><span class="line">                                                  default-cgroupns-mode option on the daemon (default)</span><br><span class="line">      --cidfile string                 Write the container ID to the file</span><br><span class="line">      --cpu-period int                 Limit CPU CFS (Completely Fair Scheduler) period</span><br><span class="line">      --cpu-quota int                  Limit CPU CFS (Completely Fair Scheduler) quota</span><br><span class="line">      --cpu-rt-period int              Limit CPU real-time period in microseconds</span><br><span class="line">      --cpu-rt-runtime int             Limit CPU real-time runtime in microseconds</span><br><span class="line">  -c, --cpu-shares int                 CPU shares (relative weight)</span><br><span class="line">      --cpus decimal                   Number of CPUs</span><br><span class="line">      --cpuset-cpus string             CPUs in which to allow execution (0-3, 0,1)</span><br><span class="line">      --cpuset-mems string             MEMs in which to allow execution (0-3, 0,1)</span><br><span class="line">  -d, --detach                         Run container in background and print container ID</span><br><span class="line">      --detach-keys string             Override the key sequence for detaching a container</span><br><span class="line">      --device list                    Add a host device to the container</span><br><span class="line">      --device-cgroup-rule list        Add a rule to the cgroup allowed devices list</span><br><span class="line">      --device-read-bps list           Limit read rate (bytes per second) from a device (default [])</span><br><span class="line">      --device-read-iops list          Limit read rate (IO per second) from a device (default [])</span><br><span class="line">      --device-write-bps list          Limit write rate (bytes per second) to a device (default [])</span><br><span class="line">      --device-write-iops list         Limit write rate (IO per second) to a device (default [])</span><br><span class="line">      --disable-content-trust          Skip image verification (default true)</span><br><span class="line">      --dns list                       Set custom DNS servers</span><br><span class="line">      --dns-option list                Set DNS options</span><br><span class="line">      --dns-search list                Set custom DNS search domains</span><br><span class="line">      --domainname string              Container NIS domain name</span><br><span class="line">      --entrypoint string              Overwrite the default ENTRYPOINT of the image</span><br><span class="line">  -e, --env list                       Set environment variables</span><br><span class="line">      --env-file list                  Read in a file of environment variables</span><br><span class="line">      --expose list                    Expose a port or a range of ports</span><br><span class="line">      --gpus gpu-request               GPU devices to add to the container (&#x27;all&#x27; to pass all GPUs)</span><br><span class="line">      --group-add list                 Add additional groups to join</span><br><span class="line">      --health-cmd string              Command to run to check health</span><br><span class="line">      --health-interval duration       Time between running the check (ms|s|m|h) (default 0s)</span><br><span class="line">      --health-retries int             Consecutive failures needed to report unhealthy</span><br><span class="line">      --health-start-period duration   Start period for the container to initialize before starting health-retries countdown (ms|s|m|h) (default 0s)</span><br><span class="line">      --health-timeout duration        Maximum time to allow one check to run (ms|s|m|h) (default 0s)</span><br><span class="line">      --help                           Print usage</span><br><span class="line">  -h, --hostname string                Container host name</span><br><span class="line">      --init                           Run an init inside the container that forwards signals and reaps processes</span><br><span class="line">  -i, --interactive                    Keep STDIN open even if not attached</span><br><span class="line">      --ip string                      IPv4 address (e.g., 172.30.100.104)</span><br><span class="line">      --ip6 string                     IPv6 address (e.g., 2001:db8::33)</span><br><span class="line">      --ipc string                     IPC mode to use</span><br><span class="line">      --isolation string               Container isolation technology</span><br><span class="line">      --kernel-memory bytes            Kernel memory limit</span><br><span class="line">  -l, --label list                     Set meta data on a container</span><br><span class="line">      --label-file list                Read in a line delimited file of labels</span><br><span class="line">      --link list                      Add link to another container</span><br><span class="line">      --link-local-ip list             Container IPv4/IPv6 link-local addresses</span><br><span class="line">      --log-driver string              Logging driver for the container</span><br><span class="line">      --log-opt list                   Log driver options</span><br><span class="line">      --mac-address string             Container MAC address (e.g., 92:d0:c6:0a:29:33)</span><br><span class="line">  -m, --memory bytes                   Memory limit</span><br><span class="line">      --memory-reservation bytes       Memory soft limit</span><br><span class="line">      --memory-swap bytes              Swap limit equal to memory plus swap: &#x27;-1&#x27; to enable unlimited swap</span><br><span class="line">      --memory-swappiness int          Tune container memory swappiness (0 to 100) (default -1)</span><br><span class="line">      --mount mount                    Attach a filesystem mount to the container</span><br><span class="line">      --name string                    Assign a name to the container</span><br><span class="line">      --network network                Connect a container to a network</span><br><span class="line">      --network-alias list             Add network-scoped alias for the container</span><br><span class="line">      --no-healthcheck                 Disable any container-specified HEALTHCHECK</span><br><span class="line">      --oom-kill-disable               Disable OOM Killer</span><br><span class="line">      --oom-score-adj int              Tune host&#x27;s OOM preferences (-1000 to 1000)</span><br><span class="line">      --pid string                     PID namespace to use</span><br><span class="line">      --pids-limit int                 Tune container pids limit (set -1 for unlimited)</span><br><span class="line">      --platform string                Set platform if server is multi-platform capable</span><br><span class="line">      --privileged                     Give extended privileges to this container</span><br><span class="line">  -p, --publish list                   Publish a container&#x27;s port(s) to the host</span><br><span class="line">  -P, --publish-all                    Publish all exposed ports to random ports</span><br><span class="line">      --pull string                    Pull image before running (&quot;always&quot;|&quot;missing&quot;|&quot;never&quot;) (default &quot;missing&quot;)</span><br><span class="line">      --read-only                      Mount the container&#x27;s root filesystem as read only</span><br><span class="line">      --restart string                 Restart policy to apply when a container exits (default &quot;no&quot;)</span><br><span class="line">      --rm                             Automatically remove the container when it exits</span><br><span class="line">      --runtime string                 Runtime to use for this container</span><br><span class="line">      --security-opt list              Security Options</span><br><span class="line">      --shm-size bytes                 Size of /dev/shm</span><br><span class="line">      --sig-proxy                      Proxy received signals to the process (default true)</span><br><span class="line">      --stop-signal string             Signal to stop a container (default &quot;SIGTERM&quot;)</span><br><span class="line">      --stop-timeout int               Timeout (in seconds) to stop a container</span><br><span class="line">      --storage-opt list               Storage driver options for the container</span><br><span class="line">      --sysctl map                     Sysctl options (default map[])</span><br><span class="line">      --tmpfs list                     Mount a tmpfs directory</span><br><span class="line">  -t, --tty                            Allocate a pseudo-TTY</span><br><span class="line">      --ulimit ulimit                  Ulimit options (default [])</span><br><span class="line">  -u, --user string                    Username or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;])</span><br><span class="line">      --userns string                  User namespace to use</span><br><span class="line">      --uts string                     UTS namespace to use</span><br><span class="line">  -v, --volume list                    Bind mount a volume</span><br><span class="line">      --volume-driver string           Optional volume driver for the container</span><br><span class="line">      --volumes-from list              Mount volumes from the specified container(s)</span><br><span class="line">  -w, --workdir string                 Working directory inside the container</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">docker run [可选参数] image   常用参数说明</span></span><br><span class="line">--name=&quot;Name&quot;			# 容器的名字，给容器起个名字，用来区分容器</span><br><span class="line">-d						# 后台方式运行，类似于nohup</span><br><span class="line">-it						# 使用交互式方式运行，进入容器查看内容</span><br><span class="line">-p						# 指定容器的端口， -p 8080:8080</span><br><span class="line">						-p ip:主机端口:容器端口</span><br><span class="line">						-p 主机端口:容器端口（常用）</span><br><span class="line">						-p 容器端口</span><br><span class="line">						容器端口</span><br><span class="line">-P						# 随机指定端口</span><br><span class="line"><span class="meta"># </span><span class="language-bash">测试使用，启动并进入容器  -i 交互式方式  -t 终端   /bin/bash 交互式方式</span></span><br><span class="line">[hadoop@hadoop102 ~]$ sudo docker run -it centos /bin/bash</span><br><span class="line">[root@713702cc6293 /]# ls</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="退出容器：exit"><a href="#退出容器：exit" class="headerlink" title="退出容器：exit"></a>退出容器：exit</h4><p>exit退出容器后，容器就停止了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+p+q  退出后，容器不停止</span><br></pre></td></tr></table></figure>



<h4 id="查看运行的容器：docker-ps"><a href="#查看运行的容器：docker-ps" class="headerlink" title="查看运行的容器：docker ps"></a>查看运行的容器：docker ps</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">查看正在运行的容器有哪些</span></span><br><span class="line">docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">docker ps</span></span><br><span class="line"><span class="meta">		# </span><span class="language-bash">不带任何选项，列出正在运行的容器</span></span><br><span class="line">-a		# 列出正在运行的容器+历史运行过的容器</span><br><span class="line">-a -n=? # 显示最近使用的？个容器</span><br><span class="line">-q		# 只显示</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看曾经所有运行过的容器有哪些</span></span><br><span class="line">docker pa -a</span><br><span class="line">[hadoop@hadoop102 ~]$ sudo docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE          COMMAND       CREATED          STATUS                      PORTS     NAMES</span><br><span class="line">713702cc6293   centos         &quot;/bin/bash&quot;   23 seconds ago   Exited (0) 8 seconds ago              goofy_fermat</span><br><span class="line">fa6d40911878   300e315adb2f   &quot;/bin/bash&quot;   34 minutes ago   Exited (0) 34 minutes ago             Centos_OS</span><br><span class="line">06b202339143   d1165f221234   &quot;/hello&quot;      5 hours ago      Exited (0) 5 hours ago                jolly_perlman</span><br><span class="line">4b43a5cdbedc   d1165f221234   &quot;/hello&quot;      5 hours ago      Exited (0) 5 hours ago                lucid_brahmagupta</span><br></pre></td></tr></table></figure>

<h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器id				# 删除指定的容器 不能删除正在运行的容器</span><br><span class="line">docker rm -f $(docker ps -aq)	# 删除所有的容器</span><br><span class="line">docker ps -aq | xargs docker rm  # 利用linux的管道进行删除所有的容器</span><br></pre></td></tr></table></figure>

<h4 id="启动和停止容器的操作"><a href="#启动和停止容器的操作" class="headerlink" title="启动和停止容器的操作"></a>启动和停止容器的操作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器id</span><br><span class="line">docker restart 容器id</span><br><span class="line">docker stop 容器id</span><br><span class="line">docker kill 容器id  # 强制杀掉容器</span><br></pre></td></tr></table></figure>

<h3 id="常用其他命令"><a href="#常用其他命令" class="headerlink" title="常用其他命令"></a>常用其他命令</h3><h4 id="后台启动-容器"><a href="#后台启动-容器" class="headerlink" title="后台启动+容器"></a>后台启动+容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">命令 docker run -d 镜像名</span></span><br><span class="line">[hadoop@hadoop102 ~]$ sudo docker run -d centos</span><br><span class="line">6aeb3d547f3ecfdc38c27148fe59033fb7cd74b49acd61c2b236bc422e0b3d85</span><br><span class="line">[hadoop@hadoop102 ~]$ sudo docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br><span class="line">[hadoop@hadoop102 ~]$</span><br><span class="line"><span class="meta"># </span><span class="language-bash">问题：docker ps 发现 刚刚后台启动的容器停止了</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">常见的坑：docker 容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">nginx，容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了。</span></span><br></pre></td></tr></table></figure>

<h4 id="显示日志"><a href="#显示日志" class="headerlink" title="显示日志"></a>显示日志</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop102 ~]$ sudo docker logs --help</span><br><span class="line"></span><br><span class="line">Usage:  docker logs [OPTIONS] CONTAINER</span><br><span class="line"></span><br><span class="line">Fetch the logs of a container</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --details        Show extra details provided to logs</span><br><span class="line">  -f, --follow         Follow log output</span><br><span class="line">      --since string   Show logs since timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)</span><br><span class="line">  -n, --tail string    Number of lines to show from the end of the logs (default &quot;all&quot;)</span><br><span class="line">  -t, --timestamps     Show timestamps</span><br><span class="line">      --until string   Show logs before a timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">docker logs -tf --<span class="built_in">tail</span> 10 容器<span class="built_in">id</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">创建一个容器，并执行一段shell脚本命令</span></span><br><span class="line">[hadoop@hadoop102 ~]$ sudo docker run -d 300e315adb2f /bin/sh -c &quot;while true;do echo luyu;sleep 1;done&quot;</span><br><span class="line">aac0df3b1f54b0ed7b637423d1800d363ebeb20901f5cb17b2d33597c3b3fe0d</span><br><span class="line">[hadoop@hadoop102 ~]$ sudo docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS          PORTS     NAMES</span><br><span class="line">aac0df3b1f54   300e315adb2f   &quot;/bin/sh -c &#x27;while t…&quot;   12 seconds ago   Up 11 seconds             upbeat_blackburn</span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看容器aac0df3b1f54的日志</span></span><br><span class="line">[hadoop@hadoop102 ~]$ sudo docker logs -ft --tail 10  aac0df3b1f54</span><br><span class="line">2021-06-08T14:46:13.046146963Z luyu</span><br><span class="line">2021-06-08T14:46:14.051677179Z luyu</span><br><span class="line">2021-06-08T14:46:15.054572203Z luyu</span><br><span class="line">2021-06-08T14:46:16.061439230Z luyu</span><br><span class="line">2021-06-08T14:46:17.065692351Z luyu</span><br><span class="line">2021-06-08T14:46:18.069007728Z luyu</span><br><span class="line">2021-06-08T14:46:19.073717192Z luyu</span><br><span class="line">2021-06-08T14:46:20.079255001Z luyu</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="查看容器中的进程信息（top）"><a href="#查看容器中的进程信息（top）" class="headerlink" title="查看容器中的进程信息（top）"></a>查看容器中的进程信息（top）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">docker top 容器<span class="built_in">id</span></span></span><br><span class="line">[hadoop@hadoop102 ~]$ sudo docker top aac0df3b1f54</span><br><span class="line">UID                 PID(父id)           PPID(进程id)         C                   STIME </span><br><span class="line">root                5604                5584                0                   22:56</span><br><span class="line">root                5720                5604                0                   22:57</span><br></pre></td></tr></table></figure>

<h4 id="查看镜像的元数据-inspect"><a href="#查看镜像的元数据-inspect" class="headerlink" title="查看镜像的元数据(inspect)"></a>查看镜像的元数据(inspect)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop102 ~]$ sudo docker inspect --help</span><br><span class="line">[sudo] hadoop 的密码：</span><br><span class="line"></span><br><span class="line">Usage:  docker inspect [OPTIONS] NAME|ID [NAME|ID...]</span><br><span class="line"></span><br><span class="line">Return low-level information on Docker objects</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -f, --format string   Format the output using the given Go template</span><br><span class="line">  -s, --size            Display total file sizes if the type is container</span><br><span class="line">      --type string     Return JSON for specified type</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">使用docker inspect 容器<span class="built_in">id</span> 可以查看容器的元数据</span></span><br><span class="line">[hadoop@hadoop102 ~]$ sudo docker inspect aac0df3b1f54</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: &quot;aac0df3b1f54b0ed7b637423d1800d363ebeb20901f5cb17b2d33597c3b3fe0d&quot;, # id</span><br><span class="line">        &quot;Created&quot;: &quot;2021-06-08T14:41:33.14773429Z&quot;, # 创建时间</span><br><span class="line">        &quot;Path&quot;: &quot;/bin/sh&quot;,		# sh控制台</span><br><span class="line">        &quot;Args&quot;: [				# 传递的参数</span><br><span class="line">            &quot;-c&quot;,</span><br><span class="line">            &quot;while true;do echo luyu;sleep 1;done&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;State&quot;: &#123;				# 该容器的状态</span><br><span class="line">            &quot;Status&quot;: &quot;exited&quot;,</span><br><span class="line">            &quot;Running&quot;: false,</span><br><span class="line">            &quot;Paused&quot;: false,</span><br><span class="line">            &quot;Restarting&quot;: false,</span><br><span class="line">            &quot;OOMKilled&quot;: false,</span><br><span class="line">            &quot;Dead&quot;: false,</span><br><span class="line">            &quot;Pid&quot;: 0,				# 父进程的id</span><br><span class="line">            &quot;ExitCode&quot;: 137,</span><br><span class="line">            &quot;Error&quot;: &quot;&quot;,</span><br><span class="line">            &quot;StartedAt&quot;: &quot;2021-06-08T14:56:40.814242482Z&quot;,</span><br><span class="line">            &quot;FinishedAt&quot;: &quot;2021-06-08T15:17:58.965385381Z&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        # 从哪个镜像创建的</span><br><span class="line">        &quot;Image&quot;: &quot;sha256:300e315adb2f96afe5f0b2780b87f28ae95231fe3bdd1e16b9ba606307728f55&quot;,</span><br><span class="line">        &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/aac0df3b1f54b0ed7b637423d1800d363ebeb20901f5cb17b2d33597c3b3fe0d/resolv.conf&quot;,  </span><br><span class="line">        &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/aac0df3b1f54b0ed7b637423d1800d363ebeb20901f5cb17b2d33597c3b3fe0d/hostname&quot;,</span><br><span class="line">        &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/aac0df3b1f54b0ed7b637423d1800d363ebeb20901f5cb17b2d33597c3b3fe0d/hosts&quot;,</span><br><span class="line">        &quot;LogPath&quot;: &quot;/var/lib/docker/containers/aac0df3b1f54b0ed7b637423d1800d363ebeb20901f5cb17b2d33597c3b3fe0d/aac0df3b1f54b0ed7b637423d1800d363ebeb2090</span><br><span class="line">1f5cb17b2d33597c3b3fe0d-json.log&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;/upbeat_blackburn&quot;,</span><br><span class="line">        &quot;RestartCount&quot;: 0,</span><br><span class="line">        &quot;Driver&quot;: &quot;overlay2&quot;,</span><br><span class="line">        &quot;Platform&quot;: &quot;linux&quot;,</span><br><span class="line">        &quot;MountLabel&quot;: &quot;&quot;,</span><br><span class="line">        &quot;ProcessLabel&quot;: &quot;&quot;,</span><br><span class="line">        &quot;AppArmorProfile&quot;: &quot;&quot;,</span><br><span class="line">        &quot;ExecIDs&quot;: null,</span><br><span class="line">        &quot;HostConfig&quot;: &#123;</span><br><span class="line">            &quot;Binds&quot;: null,</span><br><span class="line">            &quot;ContainerIDFile&quot;: &quot;&quot;,</span><br><span class="line">            &quot;LogConfig&quot;: &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;json-file&quot;,</span><br><span class="line">                &quot;Config&quot;: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;NetworkMode&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;PortBindings&quot;: &#123;&#125;,</span><br><span class="line">            &quot;RestartPolicy&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;no&quot;,</span><br><span class="line">                &quot;MaximumRetryCount&quot;: 0</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;AutoRemove&quot;: false,</span><br><span class="line">            &quot;VolumeDriver&quot;: &quot;&quot;,</span><br><span class="line">            &quot;VolumesFrom&quot;: null,</span><br><span class="line">            &quot;CapAdd&quot;: null,</span><br><span class="line">            &quot;CapDrop&quot;: null,</span><br><span class="line">            &quot;CgroupnsMode&quot;: &quot;host&quot;,</span><br><span class="line">            &quot;Dns&quot;: [],</span><br><span class="line">            &quot;DnsOptions&quot;: [],</span><br><span class="line">            &quot;DnsSearch&quot;: [],</span><br><span class="line">            &quot;ExtraHosts&quot;: null,</span><br><span class="line">            &quot;GroupAdd&quot;: null,</span><br><span class="line">            &quot;IpcMode&quot;: &quot;private&quot;,</span><br><span class="line">            &quot;Cgroup&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Links&quot;: null,</span><br><span class="line">            &quot;OomScoreAdj&quot;: 0,</span><br><span class="line">            &quot;PidMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Privileged&quot;: false,</span><br><span class="line">            &quot;PublishAllPorts&quot;: false,</span><br><span class="line">            &quot;ReadonlyRootfs&quot;: false,</span><br><span class="line">            &quot;SecurityOpt&quot;: null,</span><br><span class="line">            &quot;UTSMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;UsernsMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;ShmSize&quot;: 67108864,</span><br><span class="line">            &quot;Runtime&quot;: &quot;runc&quot;,</span><br><span class="line">            &quot;ConsoleSize&quot;: [</span><br><span class="line">                0,</span><br><span class="line">                0</span><br><span class="line">            ],</span><br><span class="line">            &quot;Isolation&quot;: &quot;&quot;,</span><br><span class="line">            &quot;CpuShares&quot;: 0,</span><br><span class="line">            &quot;Memory&quot;: 0,</span><br><span class="line">            &quot;NanoCpus&quot;: 0,</span><br><span class="line">            &quot;CgroupParent&quot;: &quot;&quot;,</span><br><span class="line">            &quot;BlkioWeight&quot;: 0,</span><br><span class="line">            &quot;BlkioWeightDevice&quot;: [],</span><br><span class="line">            &quot;BlkioDeviceReadBps&quot;: null,</span><br><span class="line">            &quot;BlkioDeviceWriteBps&quot;: null,</span><br><span class="line">            &quot;BlkioDeviceReadIOps&quot;: null,</span><br><span class="line">            &quot;BlkioDeviceWriteIOps&quot;: null,</span><br><span class="line">            &quot;CpuPeriod&quot;: 0,</span><br><span class="line">            &quot;CpuQuota&quot;: 0,</span><br><span class="line">            &quot;CpuRealtimePeriod&quot;: 0,</span><br><span class="line">            &quot;CpuRealtimeRuntime&quot;: 0,</span><br><span class="line">            &quot;CpusetCpus&quot;: &quot;&quot;,</span><br><span class="line">            &quot;CpusetMems&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Devices&quot;: [],</span><br><span class="line">            &quot;DeviceCgroupRules&quot;: null,</span><br><span class="line">            &quot;DeviceRequests&quot;: null,</span><br><span class="line">            &quot;KernelMemory&quot;: 0,</span><br><span class="line">            &quot;KernelMemoryTCP&quot;: 0,</span><br><span class="line">            &quot;MemoryReservation&quot;: 0,</span><br><span class="line">            &quot;MemorySwap&quot;: 0,</span><br><span class="line">            &quot;MemorySwappiness&quot;: null,</span><br><span class="line">            &quot;OomKillDisable&quot;: false,</span><br><span class="line">            &quot;PidsLimit&quot;: null,</span><br><span class="line">            &quot;Ulimits&quot;: null,</span><br><span class="line">            &quot;CpuCount&quot;: 0,</span><br><span class="line">            &quot;CpuPercent&quot;: 0,</span><br><span class="line">            &quot;IOMaximumIOps&quot;: 0,</span><br><span class="line">            &quot;IOMaximumBandwidth&quot;: 0,</span><br><span class="line">            &quot;MaskedPaths&quot;: [</span><br><span class="line">                &quot;/proc/asound&quot;,</span><br><span class="line">                &quot;/proc/acpi&quot;,</span><br><span class="line">                &quot;/proc/kcore&quot;,</span><br><span class="line">                &quot;/proc/keys&quot;,</span><br><span class="line">                &quot;/proc/latency_stats&quot;,</span><br><span class="line">                &quot;/proc/timer_list&quot;,</span><br><span class="line">                &quot;/proc/timer_stats&quot;,</span><br><span class="line">                &quot;/proc/sched_debug&quot;,</span><br><span class="line">                &quot;/proc/scsi&quot;,</span><br><span class="line">                &quot;/sys/firmware&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;ReadonlyPaths&quot;: [</span><br><span class="line">                &quot;/proc/bus&quot;,</span><br><span class="line">                &quot;/proc/fs&quot;,</span><br><span class="line">                &quot;/proc/irq&quot;,</span><br><span class="line">                &quot;/proc/sys&quot;,</span><br><span class="line">                &quot;/proc/sysrq-trigger&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;GraphDriver&quot;: &#123;</span><br><span class="line">            &quot;Data&quot;: &#123;</span><br><span class="line">                &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/f9dc718957db90b4588e60aeced6060e6f0fc605521724e94513c0133f136914-init/diff:/var/lib/docker/overlay2</span><br><span class="line">/ccb1f6f2f87f8be6415039fc26c9997728911e9792b6e13c11633ab40bfb4fdb/diff&quot;,</span><br><span class="line">                &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/f9dc718957db90b4588e60aeced6060e6f0fc605521724e94513c0133f136914/merged&quot;,</span><br><span class="line">                &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/f9dc718957db90b4588e60aeced6060e6f0fc605521724e94513c0133f136914/diff&quot;,</span><br><span class="line">                &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/f9dc718957db90b4588e60aeced6060e6f0fc605521724e94513c0133f136914/work&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;Name&quot;: &quot;overlay2&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Mounts&quot;: [],</span><br><span class="line">        &quot;Config&quot;: &#123;					# 该容器的配置信息</span><br><span class="line">            &quot;Hostname&quot;: &quot;aac0df3b1f54&quot;,		# hostname</span><br><span class="line">            &quot;Domainname&quot;: &quot;&quot;,</span><br><span class="line">            &quot;User&quot;: &quot;&quot;,</span><br><span class="line">            &quot;AttachStdin&quot;: false,</span><br><span class="line">            &quot;AttachStdout&quot;: false,</span><br><span class="line">            &quot;AttachStderr&quot;: false,</span><br><span class="line">            &quot;Tty&quot;: false,</span><br><span class="line">            &quot;OpenStdin&quot;: false,</span><br><span class="line">            &quot;StdinOnce&quot;: false,</span><br><span class="line">            &quot;Env&quot;: [				# 环境变量</span><br><span class="line">                &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Cmd&quot;: [</span><br><span class="line">                &quot;/bin/sh&quot;,</span><br><span class="line">                &quot;-c&quot;,</span><br><span class="line">                &quot;while true;do echo luyu;sleep 1;done&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Image&quot;: &quot;300e315adb2f&quot;,</span><br><span class="line">            &quot;Volumes&quot;: null,</span><br><span class="line">            &quot;WorkingDir&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Entrypoint&quot;: null,</span><br><span class="line">            &quot;OnBuild&quot;: null,</span><br><span class="line">            &quot;Labels&quot;: &#123;</span><br><span class="line">                &quot;org.label-schema.build-date&quot;: &quot;20201204&quot;,</span><br><span class="line">                &quot;org.label-schema.license&quot;: &quot;GPLv2&quot;,</span><br><span class="line">                &quot;org.label-schema.name&quot;: &quot;CentOS Base Image&quot;,</span><br><span class="line">                &quot;org.label-schema.schema-version&quot;: &quot;1.0&quot;,</span><br><span class="line">                &quot;org.label-schema.vendor&quot;: &quot;CentOS&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;NetworkSettings&quot;: &#123;   # 关于网络的一些元数据</span><br><span class="line">            &quot;Bridge&quot;: &quot;&quot;,</span><br><span class="line">            &quot;SandboxID&quot;: &quot;f064098b6957297393ae82fffe032e3aa6d1295c5818e195d2221546e520ffa4&quot;,</span><br><span class="line">            &quot;HairpinMode&quot;: false,</span><br><span class="line">            &quot;LinkLocalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">            &quot;LinkLocalIPv6PrefixLen&quot;: 0,</span><br><span class="line">            &quot;Ports&quot;: &#123;&#125;,</span><br><span class="line">            &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/f064098b6957&quot;,</span><br><span class="line">            &quot;SecondaryIPAddresses&quot;: null,</span><br><span class="line">            &quot;SecondaryIPv6Addresses&quot;: null,</span><br><span class="line">            &quot;EndpointID&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Gateway&quot;: &quot;&quot;,</span><br><span class="line">            &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">            &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">            &quot;IPAddress&quot;: &quot;&quot;,</span><br><span class="line">            &quot;IPPrefixLen&quot;: 0,</span><br><span class="line">            &quot;IPv6Gateway&quot;: &quot;&quot;,</span><br><span class="line">            &quot;MacAddress&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Networks&quot;: &#123;</span><br><span class="line">                &quot;bridge&quot;: &#123;</span><br><span class="line">                    &quot;IPAMConfig&quot;: null,</span><br><span class="line">                    &quot;Links&quot;: null,</span><br><span class="line">                    &quot;Aliases&quot;: null,</span><br><span class="line">                    &quot;NetworkID&quot;: &quot;69c5ae2719e4d97b668a69acd2d4e85e66cf6688825c768f8975d3a7eadfa1e8&quot;,</span><br><span class="line">                    &quot;EndpointID&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;IPAddress&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;IPPrefixLen&quot;: 0,</span><br><span class="line">                    &quot;IPv6Gateway&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">                    &quot;MacAddress&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;DriverOpts&quot;: null</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="进入当前正在运行的容器"><a href="#进入当前正在运行的容器" class="headerlink" title="进入当前正在运行的容器"></a>进入当前正在运行的容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 容器id /bin/bash     # 进入容器后开启一个新的终端，可以在里面操作（常用）</span><br><span class="line">									# exit后不会停止当前容器</span><br><span class="line"></span><br><span class="line">docker attach 容器id				   # 进入容器正在执行的终端，不会启动新的进程</span><br><span class="line">									# exit后，会立即停止当前的容器</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="从容器内拷贝文件到主机上（反向拷贝也是可以的）"><a href="#从容器内拷贝文件到主机上（反向拷贝也是可以的）" class="headerlink" title="从容器内拷贝文件到主机上（反向拷贝也是可以的）"></a>从容器内拷贝文件到主机上（反向拷贝也是可以的）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器id:容器内的路径 主机目标路径            # 是在主机上完成的，而不是在容器内部</span><br><span class="line"><span class="meta"># </span><span class="language-bash">在home目录下创建File目录，</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">进入容器，并切换到home目录下创建hello.java文件</span></span><br><span class="line">[hadoop@hadoop102 File]$ sudo docker exec -it e3a5ccb43497 /bin/bash</span><br><span class="line">[root@e3a5ccb43497 /]# ls</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">[root@e3a5ccb43497 /]# cd home/</span><br><span class="line">[root@e3a5ccb43497 home]# vi hello.java</span><br><span class="line"><span class="meta">#</span><span class="language-bash">退出容器，进入到主机中，进行文件拷贝</span></span><br><span class="line">[hadoop@hadoop102 File]$ sudo docker cp e3a5ccb43497:/home/hello.java ~/File/</span><br><span class="line"><span class="meta"># </span><span class="language-bash">也可以直接拷贝目录</span></span><br><span class="line">[hadoop@hadoop102 File]$ sudo docker cp e3a5ccb43497:/home ~/File/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">将文件拷贝出来到主机，这是一个手动的过程</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">未来我们使用 -v 卷的技术，可以实现  自动同步  容器内的home目录  与主机的home  连通，打通</span></span><br></pre></td></tr></table></figure>

<h3 id="常用命令小结"><a href="#常用命令小结" class="headerlink" title="常用命令小结"></a>常用命令小结</h3><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Finews.gtimg.com%2Fnewsapp_match%2F0%2F10379248343%2F0.jpg&refer=http%3A%2F%2Finews.gtimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1626488404&t=24a45ef82f2f339faeffe9c9a29caea6" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/202007171706264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NlZV95b3VfWVU=,size_16,color_FFFFFF,t_70" alt="Docker关系命令图"></p>
<h4 id="容器生命周期管理"><a href="#容器生命周期管理" class="headerlink" title="容器生命周期管理"></a>容器生命周期管理</h4><ul>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-run-command.html">run</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-start-stop-restart-command.html">start/stop/restart</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-kill-command.html">kill</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-rm-command.html">rm</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-pause-unpause-command.html">pause/unpause</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-create-command.html">create</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-exec-command.html">exec</a></li>
</ul>
<h4 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h4><ul>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-ps-command.html">ps</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-inspect-command.html">inspect</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-top-command.html">top</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-attach-command.html">attach</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-events-command.html">events</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-logs-command.html">logs</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-wait-command.html">wait</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-export-command.html">export</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-port-command.html">port</a></li>
</ul>
<h4 id="容器rootfs命令"><a href="#容器rootfs命令" class="headerlink" title="容器rootfs命令"></a>容器rootfs命令</h4><ul>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-commit-command.html">commit</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-cp-command.html">cp</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-diff-command.html">diff</a></li>
</ul>
<h4 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h4><ul>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-login-command.html">login</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-pull-command.html">pull</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-push-command.html">push</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-search-command.html">search</a></li>
</ul>
<h4 id="本地镜像管理"><a href="#本地镜像管理" class="headerlink" title="本地镜像管理"></a>本地镜像管理</h4><ul>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-images-command.html">images</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-rmi-command.html">rmi</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-tag-command.html">tag</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-build-command.html">build</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-history-command.html">history</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-save-command.html">save</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-load-command.html">load</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-import-command.html">import</a></li>
</ul>
<h4 id="info-version"><a href="#info-version" class="headerlink" title="info|version"></a>info|version</h4><ul>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-info-command.html">info</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/docker/docker-version-command.html">version</a></li>
</ul>
<h2 id="Docker镜像讲解"><a href="#Docker镜像讲解" class="headerlink" title="Docker镜像讲解"></a>Docker镜像讲解</h2><h3 id="镜像是什么？"><a href="#镜像是什么？" class="headerlink" title="镜像是什么？"></a>镜像是什么？</h3><p>镜像是一种轻量级，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码，运行时、库、环境变量和配置文件。</p>
<p>所有的应用，直接打包docker镜像，就可以直接跑起来！</p>
<p>如何得到镜像：</p>
<ul>
<li>从远程仓库下载</li>
<li>朋友拷贝给你</li>
<li>自己制作一个镜像DockerFile</li>
</ul>
<h3 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a>Docker镜像加载原理</h3><blockquote>
<p>UnionFS（联合文件系统）</p>
</blockquote>
<p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层，轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂在到同一个虚拟文件系统。Union文件系统是Docker镜像的基础，镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
<p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p>
<blockquote>
<p>Docker镜像加载原理</p>
</blockquote>
<p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统称为UnionFS。</p>
<p>==bootfs==（boot file system）主要包含bootloader和kernel；bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核，当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转将给内核，此时系统哦也会卸载bootfs。</p>
<p>==rootfs==在bootfs之上。包含的就是典型Linux系统中的/dev, /proc, /bin, /etc等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</p>
<p><img src="https://s4.51cto.com/images/blog/201711/27/462718f3cd35608c20481b33b09db020.jpg?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="Docker镜像的内部结构(四)"></p>
<p>对于一个精简的OS，rootfs可以很小，只需要包含最基本的命令，工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供rootfs就可以了。由此可见对于不同的linux发行版，bootfs基本是一致的，rootfs会有差别，因此不同的发行版可以共用bootfs。</p>
<h3 id="镜像的分层"><a href="#镜像的分层" class="headerlink" title="镜像的分层"></a>镜像的分层</h3><p>通过查看镜像的元数据信息，可以查看到镜像的分层信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">docker inspect ubuntu</span></span><br><span class="line">&quot;RootFS&quot;: &#123;</span><br><span class="line">            &quot;Type&quot;: &quot;layers&quot;,</span><br><span class="line">            &quot;Layers&quot;: [</span><br><span class="line">                &quot;sha256:ccdbb80308cc5ef43b605ac28fac29c6a597f89f5a169bbedbb8dec29c987439&quot;,</span><br><span class="line">                &quot;sha256:63c99163f47292f80f9d24c5b475751dbad6dc795596e935c5c7f1c73dc08107&quot;,</span><br><span class="line">                &quot;sha256:2f140462f3bcf8cf3752461e27dfd4b3531f266fa10cda716166bd3a78a19103&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta"># </span><span class="language-bash">可以看到，rootfs下面显示了镜像的分层信息。</span></span><br></pre></td></tr></table></figure>

<p><strong>理解</strong></p>
<p>所有的Docker镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之上，创建新的镜像层。举一个简单的例子，假如基于Ubuntu Linux16.04创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加了Python包，就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创建第三个镜像层。</p>
<p>再添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合，理解这一点非常重点。</p>
<blockquote>
<p>特点</p>
</blockquote>
<p>Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部！</p>
<p>这一层就是我们通常说的容器层，容器之下的都叫镜像层！</p>
<h3 id="Commit镜像"><a href="#Commit镜像" class="headerlink" title="Commit镜像"></a>Commit镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">docker commit 提交容器称为一个新的副本</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">命令 和 git原理类似</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">docker commit -m=<span class="string">&quot;提交的描述信息&quot;</span> -a=<span class="string">&quot;作者&quot;</span> 容器<span class="built_in">id</span>	目标镜像名:[TAG]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">进入容器 ubuntu1</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">docker <span class="built_in">exec</span> -it ubuntu1 /bin/bash</span> </span><br><span class="line">root@53f02879b24f:/# ls</span><br><span class="line">bin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line"><span class="meta"># </span><span class="language-bash">home目录增加文件</span></span><br><span class="line">root@53f02879b24f:/# ls home/</span><br><span class="line">root@53f02879b24f:/# echo &quot;hello world&quot; &gt; home/helloworld.txt</span><br><span class="line">root@53f02879b24f:/# ls home/</span><br><span class="line">helloworld.txt</span><br><span class="line">root@53f02879b24f:/# exit</span><br><span class="line">exit</span><br><span class="line"><span class="meta"># </span><span class="language-bash">提交当前容器，本地会新增一个镜像</span></span><br><span class="line">didi@bogon ~$ docker commit -m=&quot;first commit&quot; -a=&quot;yulu&quot; 53f02879b24f myubuntu:0.1</span><br><span class="line">sha256:cb1d9e8a66a511c5639a5d47a42a0f8949c6ac1e06a96cb9d665036e85609bc9</span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看镜像</span></span><br><span class="line">didi@bogon ~$ docker images</span><br><span class="line">REPOSITORY                TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">myubuntu                  0.1       cb1d9e8a66a5   8 seconds ago   72.7MB # 这就是我们修改后提交的镜像</span><br><span class="line">ubuntu                    latest    7e0aa2d69a15   7 weeks ago     72.7MB</span><br></pre></td></tr></table></figure>

<p><code>如果你想保存当前容器的状态，就可以通过commit来提交，获得一个镜像，就好比VM中的快照</code></p>
<h1 id="Docker进阶学习"><a href="#Docker进阶学习" class="headerlink" title="Docker进阶学习"></a>Docker进阶学习</h1><h2 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h2><h3 id="什么是容器数据卷"><a href="#什么是容器数据卷" class="headerlink" title="什么是容器数据卷"></a>什么是容器数据卷</h3><p>将应用和环境打包成一个镜像！</p>
<p>数据？如果数据都在容器中，那么我们容器删除之后，这些数据就会丢失！<font color=red>需求：数据可以持久化</font></p>
<p>比如：我们在容器中安装了mysql，存储了一大堆重要的数据，当容器被删除之后，mysql中的数据就随之删除了（删库跑路）==需求：MySql数据可以存储在本地==</p>
<p>容器之间可以有一个数据共享的技术！Docker容器中产生的数据，同步到本地！</p>
<p>这就是卷技术！目录的挂载，将我们容器内的目录，挂在到Linux上面！</p>
<p><font color=green>总结：卷技术可以将容器中的数据持久化和同步到主机上，方便我们对其容器内容的配置文件进行配置和数据备份;容器之间也可以共享数据</font></p>
<h3 id="使用数据卷（-v）"><a href="#使用数据卷（-v）" class="headerlink" title="使用数据卷（-v）"></a>使用数据卷（-v）</h3><blockquote>
<p>方式1：指定文件目录挂载（数据同步是双向的）</p>
<p>主机上被指定的目录应该不存在</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">docker run -it -v 主机目录:容器内目录</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">举个例子：将ubuntu2容器中的home目录挂载到主机的~/docker/data/unbuntu1/home上</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">docker run -it --name ubuntu2 -v ~/docker/data/ubuntu1/home:/home ubuntu</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">容器内的home目录</span></span><br><span class="line">root@5bf887e2b9e0:/# ls home</span><br><span class="line"><span class="meta"># </span><span class="language-bash">容器外主机上的挂载目录</span></span><br><span class="line">didi@bogon ~$ ls ~/docker/data/ubuntu1/home/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">接下来在容器中添加一个hello.java文件</span></span><br><span class="line">root@5bf887e2b9e0:/# echo &#x27;System.out.println(&quot;hello world!&quot;);&#x27; &gt; home/hello.java</span><br><span class="line">root@5bf887e2b9e0:/# ls home</span><br><span class="line">hello.java</span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看主机上挂载的目录</span></span><br><span class="line">didi@bogon ~$ cat docker/data/ubuntu1/home/hello.java </span><br><span class="line">System.out.println(&quot;hello world!&quot;);</span><br><span class="line"><span class="meta"># </span><span class="language-bash">通过docker inspect 容器<span class="built_in">id</span>  查看容器的元数据信息</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">docker inspect 5bf887e2b9e0</span></span><br><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;volume&quot;,				# 卷</span><br><span class="line">                &quot;Name&quot;: &quot;ubuntu3_volume&quot;,		# 卷名</span><br><span class="line">                &quot;Source&quot;: &quot;/var/lib/docker/volumes/ubuntu3_volume/_data&quot;,	# 主机挂载地址</span><br><span class="line">                &quot;Destination&quot;: &quot;/home&quot;,																		# 容器内地址</span><br><span class="line">                &quot;Driver&quot;: &quot;local&quot;,				</span><br><span class="line">                &quot;Mode&quot;: &quot;z&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br></pre></td></tr></table></figure>

<h3 id="具名挂载-与-匿名挂载"><a href="#具名挂载-与-匿名挂载" class="headerlink" title="具名挂载 与 匿名挂载"></a>具名挂载 与 匿名挂载</h3><p>具名挂载和匿名挂载都不需要指定主机的挂载路径。</p>
<p><font color=green>不指定主机的挂载地址，但需要指定容器内需要挂载的地址，如果不存在，会自动创建该目录（文件）</font></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">匿名挂载</span></span><br><span class="line">didi@bogon ~$ docker run -d --name ubuntu4 -v /etc ubuntu</span><br><span class="line">b79600ad36d982e88f18e70059dcb75c8b2ef1e0c646809fff0a526b86199ca7</span><br><span class="line">didi@bogon ~$ docker volume ls</span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     c123ec3d50d8cc96802041d60e8a8fcefe03c9d82d23ab7a47a768217380507f  # 匿名卷，没有指定卷的名字</span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看容器的元数据</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">docker inspect b79600ad36d982e88f18e70059dcb75c8b2ef1e0c646809fff0a526b86199ca7</span></span><br><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">                &quot;Name&quot;: &quot;c123ec3d50d8cc96802041d60e8a8fcefe03c9d82d23ab7a47a768217380507f&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;/var/lib/docker/volumes/c123ec3d50d8cc96802041d60e8a8fcefe03c9d82d23ab7a47a768217380507f/_data&quot;,</span><br><span class="line">                &quot;Destination&quot;: &quot;/etc&quot;,</span><br><span class="line">                &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="meta"># </span><span class="language-bash">具名挂载</span></span><br><span class="line">didi@bogon ~$ docker run -d --name ubuntu5 -v ubuntu5_volume:/etc ubuntu</span><br><span class="line">37de88fb243838b931e797ceb271a1bd70e887fb8c399c8f22d70099af770cd2</span><br><span class="line">didi@bogon ~$ docker volume ls</span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     ubuntu5_volume</span><br><span class="line">didi@bogon ~$ docker inspect 37de88fb243838b931e797ceb271a1bd70e887fb8c399c8f22d70099af770cd2</span><br><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">                &quot;Name&quot;: &quot;ubuntu5_volume&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;/var/lib/docker/volumes/ubuntu5_volume/_data&quot;,</span><br><span class="line">                &quot;Destination&quot;: &quot;/etc&quot;,</span><br><span class="line">                &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;z&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看卷的元数据信息</span></span><br><span class="line">didi@bogon ~$ docker volume inspect ubuntu5_volume</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2021-06-16T14:12:33Z&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: null,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/ubuntu5_volume/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;ubuntu5_volume&quot;,</span><br><span class="line">        &quot;Options&quot;: null,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"><span class="meta"># </span><span class="language-bash">挂载的时候，可以指定读写权限；ro：只读； rw：读写</span></span><br></pre></td></tr></table></figure>



<p>DockerFile的方式也可以指定数据卷，将容器内的目录挂载到主机上（宿主机上）</p>
<h3 id="数据卷容器（容器与容器之间共享数据卷）"><a href="#数据卷容器（容器与容器之间共享数据卷）" class="headerlink" title="数据卷容器（容器与容器之间共享数据卷）"></a>数据卷容器（容器与容器之间共享数据卷）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">数据卷选项   --volume-from</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">docker run -it --name docker2 --volume-from docker1 ubuntu  <span class="comment">#  容器docker2 同步（继承）容器docker1的数据卷，docker1就是数据卷容器</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>==数据共享，如果数据卷容器停止了且删除了，你猜其他挂载这个容器的中的数据还会存在吗？？？？？  答案是肯定存在啊==</p>
<p><font color=red>特别说明：</font></p>
<blockquote>
<p>docker中的数据共享，数据卷技术是通过拷贝的技术来实现，如果其中挂载的容器被删除了，但是被挂载的目录因为复制了容器中的数据，所以在容器被删除之后，还是会存才相应的数据的。</p>
</blockquote>
<p><strong>小结</strong></p>
<p>容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止。</p>
<p>但是你一旦持久化到了本地，这个时候，本地的数据是不会删除的。</p>
<h2 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h2><h3 id="DockerFile介绍"><a href="#DockerFile介绍" class="headerlink" title="DockerFile介绍"></a>DockerFile介绍</h3><p>dockerfile是用来构建docker镜像的文件！命令参数脚本！</p>
<p><strong>构建步骤：</strong></p>
<ol>
<li>编写一个dockerfile文件</li>
<li>使用docker build 构建成为一个镜像</li>
<li>docker run 运行镜像</li>
<li>docker push 发布镜像（DockerHub、阿里云镜像仓库！）</li>
</ol>
<blockquote>
<p>很多官方镜像都是基础包，很多功能没有（常用的命令也可能没有），我们通常会自己搭建自己的镜像！</p>
</blockquote>
<h3 id="DockerFile构建过程"><a href="#DockerFile构建过程" class="headerlink" title="DockerFile构建过程"></a>DockerFile构建过程</h3><p><strong>基础知识</strong></p>
<ol>
<li>每个保留关键字（指令）都必须是大写字母</li>
<li>执行从上到下顺序执行</li>
<li>#：表示注释</li>
<li>每一个指令都会创建提交一个新的镜像层，并提交</li>
</ol>
<img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.liuhaihua.cn%2Fwp-content%2Fuploads%2F2016%2F08%2FMFB3Yjf.jpg&refer=http%3A%2F%2Fwww.liuhaihua.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1626488126&t=67aeecd77f39cae1d12bb367c661085f" alt="img" style="zoom:50%;" />

<p>dockerfile是面向开发的，我们以后要发布项目，做镜像，就需要编写dockerfile文件，这个文件十分简单！</p>
<p>Docker镜像逐渐成为企业交付的标准，必须要掌握！</p>
<p><strong>三部曲</strong>：开发、部署、运维</p>
<ol>
<li>DockerFile：构建文件，定义了一切的步骤，源代码</li>
<li>DockerImages：通过DockerFile构建生成的镜像，最终发布和运行的产品</li>
<li>Docker容器：容器就是镜像运行起来提供服务器</li>
</ol>
<h3 id="DockerFile指令"><a href="#DockerFile指令" class="headerlink" title="DockerFile指令"></a>DockerFile指令</h3><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.dongcoder.com%2Fup%2Finfo%2F201912%2F20191201213114965392.png&refer=http%3A%2F%2Fimg.dongcoder.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1626488249&t=cd0fff660b8407d3f0dbf318766d3a1f" alt="img" style="zoom:%;" />



<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM					# 基础镜像，一切从这里开始构建</span><br><span class="line">MAINTAINER		# 镜像是谁写的， 姓名+邮箱</span><br><span class="line">RUN						# 镜像构建的时候需要运行的命令</span><br><span class="line">ADD						# 步骤，tomcat镜像，这个tomcat压缩包！   自动解压</span><br><span class="line">WORKDIR				# 镜像的工作目录   进入容器的时候，默认的工作空间</span><br><span class="line">VOLUME				# 挂载的目录</span><br><span class="line">EXPOSE				# 保留端口配置</span><br><span class="line">CMD						# 指定这个容器启动的时候要执行的命令。只有最后一个会生效，可被替代</span><br><span class="line">ENTRYPOINT		# 指定这个容器启动的时候要运行的命令。可以追加命</span><br><span class="line">ONBUILD				# 当构建一个被继承DockerFile 这个时候就会运行 ONBUILD 的指令。 触发指令</span><br><span class="line">COPY					# 累计ADD，将文件拷贝到镜像中   仅仅拷贝，不解压</span><br><span class="line">ENV						# 构建的时候设置环境变量！</span><br></pre></td></tr></table></figure>

<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fseo-1255598498.file.myqcloud.com%2Ffull%2F4455082961bc017cb7c87a3463bb326e021013ce.jpg&refer=http%3A%2F%2Fseo-1255598498.file.myqcloud.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1626488342&t=d082a7ddde61f3208268b222179c264f" alt="img"></p>
<h4 id="构建DockerFile之前的说明"><a href="#构建DockerFile之前的说明" class="headerlink" title="构建DockerFile之前的说明"></a><strong>构建DockerFile之前的说明</strong></h4><blockquote>
<p>Docker 通过DockerFile构建镜像的时候，Docker的守护进程会将当前目录下的所有文件打包到镜像中；就像我们使用git add .  会将当前目录下的所有文件加入到暂存区。但是可以通过指定.ignore文件进行选择性忽略。</p>
<p>Docker也支持类似的操作；</p>
<p>可以通过编写 <code>.dockerignore</code>文件来进行选择过滤掉一些我们不想打包到镜像中的文件，尽量保证镜像的精简。</p>
</blockquote>
<h4 id="Docker构建DockerFile命令"><a href="#Docker构建DockerFile命令" class="headerlink" title="Docker构建DockerFile命令"></a>Docker构建DockerFile命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">1. 通常我们会创建一个空的目录，这个目录下我们存放一些我们需要构建的文件，比如MySql，tomcat等的安装包， 还有一些必备的文件</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">2. 我们可以自定义DockerFile的文件名，但是如果直接定义成DockerFile，我们在执行build命令的时候，就不需要指定改文件的路径位置，否则需要通过-f选项执行具体的DockerFile文件的路径</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">docker build -f DockerFile_Path -t luyu/myapp:1.0.2 -t luyu/myapp:latest</span></span><br><span class="line">-f: 指定DockerFile文件的路径</span><br><span class="line">-t: 指定生成的image镜像的目标位置</span><br></pre></td></tr></table></figure>

<h4 id="DockerFile-Centos官方样例"><a href="#DockerFile-Centos官方样例" class="headerlink" title="DockerFile Centos官方样例"></a>DockerFile Centos官方样例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">官方centos的DockerFile</span></span><br><span class="line">FROM scratch</span><br><span class="line">ADD centos-7-x86_64-docker.tar.xz /</span><br><span class="line"></span><br><span class="line">LABEL \</span><br><span class="line">    org.label-schema.schema-version=&quot;1.0&quot; \</span><br><span class="line">    org.label-schema.name=&quot;CentOS Base Image&quot; \</span><br><span class="line">    org.label-schema.vendor=&quot;CentOS&quot; \</span><br><span class="line">    org.label-schema.license=&quot;GPLv2&quot; \</span><br><span class="line">    org.label-schema.build-date=&quot;20201113&quot; \</span><br><span class="line">    org.opencontainers.image.title=&quot;CentOS Base Image&quot; \</span><br><span class="line">    org.opencontainers.image.vendor=&quot;CentOS&quot; \</span><br><span class="line">    org.opencontainers.image.licenses=&quot;GPL-2.0-only&quot; \</span><br><span class="line">    org.opencontainers.image.created=&quot;2020-11-13 00:00:00+00:00&quot;</span><br><span class="line"></span><br><span class="line">CMD [&quot;/bin/bash&quot;]</span><br></pre></td></tr></table></figure>

<p><font color=green>通常情况下，build DockerFile，都会指定这个要构建的镜像的bootfs的来源（换句话说，就是要指定这个镜像是从哪个基础镜像构建的, 也就是指定 <strong>父镜像</strong>）</font></p>
<h4 id="DockerFile中的关键字说明"><a href="#DockerFile中的关键字说明" class="headerlink" title="DockerFile中的关键字说明"></a>DockerFile中的关键字说明</h4><p>虽然在dockerfile中支持关键字小写，但是为了区分参数，尽量保持关键字大写，参数小写</p>
<h5 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h5><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> [--platform=&lt;platform&gt;] &lt;image&gt; [AS &lt;name&gt;]</span><br><span class="line"><span class="keyword">FROM</span> [--platform=&lt;platform&gt;] &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]</span><br><span class="line"><span class="keyword">FROM</span> [--platform=&lt;platform&gt;] &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]</span><br></pre></td></tr></table></figure>

<h6 id="ARG和FROM"><a href="#ARG和FROM" class="headerlink" title="ARG和FROM"></a>ARG和FROM</h6><p>虽然说DockerFile都是一FROM关键字开头的，但是可以在FROM前声明一个或者多个ARG指令。ARG指令可以定义变量，例如TAG信息</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ARG</span>  CODE_VERSION=latest</span><br><span class="line"><span class="keyword">FROM</span> base:$&#123;CODE_VERSION&#125;</span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash">  /code/run-app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> extras:$&#123;CODE_VERSION&#125;</span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash">  /code/run-extras</span></span><br></pre></td></tr></table></figure>

<p>==特别说明==</p>
<p>FROM在同一个DockerFile文件中可以出现一次或多次</p>
<p>当出现多次的时候，可以构建多个镜像；或者一个镜像作为另一个镜像的<strong>父依赖</strong>。可以通过AS关键字为FROM起一个别名</p>
<h5 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h5><p>镜像构建的时时候运行指定命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">一般RUN 有两种格式运行命令   shell format  和  <span class="built_in">exec</span> format</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">第一种方式可通过 \ 进行换行</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">RUN /bin/bash -c <span class="string">&#x27;source $HOME/.bashrc; \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">echo $HOME&#x27;</span></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash"><span class="comment">#########################</span></span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">RUN [<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo hello&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p><font color=red>关于RUN关键字执行命令的时候的注意事项</font></p>
<p>镜像构建的时候，是按照层级构建的。如果构建到当前层的时候，发现之前已经构建过相同的层，这时就会复用历史层，而不会再执行当前层了！</p>
<p>如果使用 <code>apt-get update</code> 与 <code>apt-get install</code>命令就需要特别注意，尽量将<code>apt-get update</code> 与 <code>apt-get install</code> 放到一个RUN层。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="language-bash">    aufs-tools \</span></span><br><span class="line"><span class="language-bash">    automake \</span></span><br><span class="line"><span class="language-bash">    build-essential \</span></span><br><span class="line"><span class="language-bash">    curl \</span></span><br><span class="line"><span class="language-bash">    dpkg-sig \</span></span><br><span class="line"><span class="language-bash">    libcap-dev \</span></span><br><span class="line"><span class="language-bash">    libsqlite3-dev \</span></span><br><span class="line"><span class="language-bash">    mercurial \</span></span><br><span class="line"><span class="language-bash">    reprepro \</span></span><br><span class="line"><span class="language-bash">    ruby1.9.1 \</span></span><br><span class="line"><span class="language-bash">    ruby1.9.1-dev \</span></span><br><span class="line"><span class="language-bash">    s3cmd=1.1.* \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br></pre></td></tr></table></figure>

<p>如果不放到同一个RUN中，例如下面这段dockerfile</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 刚开始的时候，我们通过以下命令，进行构建，但是还想安装nginx，</span></span><br><span class="line"><span class="comment"># syntax=docker/dockerfile:1</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y curl</span></span><br><span class="line"><span class="comment"># 又在右面添加</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y curl nginx</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述两端命令，第二段命令中的 <code>apt-get update</code> 不会再执行了，因为在Docker的缓存看来，这一层之前已经构建过了，就复用了之前层的 <code>apt-get update</code></p>
<p>这就有可能导致之前的update之后没有nginx，这就会导致<code>RUN apt-get install -y curl nginx</code>运行失败！</p>
<p>所及尽量保证在一层RUN中执行，避免这种情况的发生。</p>
</blockquote>
<h5 id="CMD-与-ENTRYPOINT"><a href="#CMD-与-ENTRYPOINT" class="headerlink" title="CMD 与 ENTRYPOINT"></a>CMD 与 ENTRYPOINT</h5><p>CMD 与 ENTRYPOINT关键字都可能指定以该DockerFile构建的镜像创建的容器在启动的时候要执行的命令。</p>
<p>区别在于：CMD指定的命令，会因为我们在执行<code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code>时人为指定的<code>COMMAND</code>要执行命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">创建一个DockerFile文件，末尾指定一个CMD [<span class="string">&#x27;ls&#x27;</span>]</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">cat</span> DockerFile</span> </span><br><span class="line">FROM	centos</span><br><span class="line">RUN		echo &quot;hello world&quot;;</span><br><span class="line">CMD		[&#x27;ls&#x27;]</span><br><span class="line"><span class="meta"># </span><span class="language-bash">然后build dockerfile文件</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">docker build -f ./DockerFile -t luyu/firstimages:1.0.1 .</span></span><br><span class="line">[+] Building 0.1s (6/6) FINISHED                                                                                                     </span><br><span class="line"> =&gt; [internal] load build definition from DockerFile                                                                            0.0s</span><br><span class="line"> =&gt; =&gt; transferring dockerfile: 91B                                                                                             0.0s</span><br><span class="line"> =&gt; [internal] load .dockerignore                                                                                               0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 2B                                                                                                 0.0s</span><br><span class="line"> =&gt; [internal] load metadata for docker.io/library/centos:latest                                                                0.0s</span><br><span class="line"> =&gt; [1/2] FROM docker.io/library/centos                                                                                         0.0s</span><br><span class="line"> =&gt; CACHED [2/2] RUN  ECHO &quot;hello world&quot;;                                                                                       0.0s</span><br><span class="line"> =&gt; exporting to image                                                                                                          0.0s</span><br><span class="line"> =&gt; =&gt; exporting layers                                                                                                         0.0s</span><br><span class="line"> =&gt; =&gt; writing image sha256:c3e7f267d07123989d20e73d1772247cc1d7a83b068225f507f6f639d5e5ec70                                    0.0s</span><br><span class="line"> =&gt; =&gt; naming to docker.io/luyu/firstimages:1.0.1                                                                               0.0s</span><br><span class="line"></span><br><span class="line">Use &#x27;docker scan&#x27; to run Snyk tests against images to find vulnerabilities and learn how to fix them</span><br><span class="line"><span class="meta"># </span><span class="language-bash">后台启动一个该镜像的容器</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">docker run -d c3e7f267d07123989d20e73d1772247cc1d7a83b068225f507f6f639d5e5ec70</span></span><br><span class="line">4fead54e8978e1a4be2f2457845d144ec428135b3367ccfc1a47ef9ab0ba49dc</span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看该容器的日志</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">docker logs 4fead54e8978e1a4be2f2457845d144ec428135b3367ccfc1a47ef9ab0ba49dc</span></span><br><span class="line">/bin/sh: [ls]: command not found   # 这行证明CMD内的指令已经执行了，但是提示没有找到ls命令</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">然后后台再启动一个容器。并指定要执行的命令  <span class="built_in">ls</span> -al</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">docker run -d c3e7f267d07123989d20e73d1772247cc1d7a83b068225f507f6f639d5e5ec70 <span class="built_in">ls</span> -al</span></span><br><span class="line">a19557b0b538ba0cb75579d0e81d1fccf8d03053dff717bc670de0e6889ae467</span><br><span class="line"><span class="meta"># </span><span class="language-bash">再次查看容器日志</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">docker logs a19557b0b538ba0cb75579d0e81d1fccf8d03053dff717bc670de0e6889ae467</span></span><br><span class="line">total 56</span><br><span class="line">drwxr-xr-x   1 root root 4096 Jun 18 09:40 .</span><br><span class="line">drwxr-xr-x   1 root root 4096 Jun 18 09:40 ..</span><br><span class="line">-rwxr-xr-x   1 root root    0 Jun 18 09:40 .dockerenv</span><br><span class="line">lrwxrwxrwx   1 root root    7 Nov  3  2020 bin -&gt; usr/bin</span><br><span class="line">drwxr-xr-x   5 root root  340 Jun 18 09:40 dev</span><br><span class="line">drwxr-xr-x   1 root root 4096 Jun 18 09:40 etc</span><br><span class="line">drwxr-xr-x   2 root root 4096 Nov  3  2020 home</span><br><span class="line">lrwxrwxrwx   1 root root    7 Nov  3  2020 lib -&gt; usr/lib</span><br><span class="line">lrwxrwxrwx   1 root root    9 Nov  3  2020 lib64 -&gt; usr/lib64</span><br><span class="line">drwx------   2 root root 4096 Dec  4  2020 lost+found</span><br><span class="line">drwxr-xr-x   2 root root 4096 Nov  3  2020 media</span><br><span class="line">drwxr-xr-x   2 root root 4096 Nov  3  2020 mnt</span><br><span class="line">drwxr-xr-x   2 root root 4096 Nov  3  2020 opt</span><br><span class="line">dr-xr-xr-x 185 root root    0 Jun 18 09:40 proc</span><br><span class="line">dr-xr-x---   2 root root 4096 Dec  4  2020 root</span><br><span class="line">drwxr-xr-x  11 root root 4096 Dec  4  2020 run</span><br><span class="line">lrwxrwxrwx   1 root root    8 Nov  3  2020 sbin -&gt; usr/sbin</span><br><span class="line">drwxr-xr-x   2 root root 4096 Nov  3  2020 srv</span><br><span class="line">dr-xr-xr-x  13 root root    0 Jun 18 09:40 sys</span><br><span class="line">drwxrwxrwt   7 root root 4096 Dec  4  2020 tmp</span><br><span class="line">drwxr-xr-x  12 root root 4096 Dec  4  2020 usr</span><br><span class="line">drwxr-xr-x  20 root root 4096 Dec  4  2020 var</span><br><span class="line"><span class="meta"># </span><span class="language-bash">从上述结果可以看出，启动容器的时候， 人为指定的命令  覆盖了DockerFile文件中指定的  CMD命令</span></span><br></pre></td></tr></table></figure>

<p>而<strong>ENTRYPOINT</strong>关键字指定的命令不会被覆盖，人为指定的命令会追加到后面</p>
<p>可以使用<strong>ENTRYPOINT</strong>作为镜像的主命令，然后<strong>CMD</strong>作为默认命令</p>
<p>例子：</p>
<p>本地有一个shell脚本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">set -e</span><br><span class="line"></span><br><span class="line">if [ &quot;$1&quot; = &#x27;postgres&#x27; ]; then</span><br><span class="line">    chown -R postgres &quot;$PGDATA&quot;</span><br><span class="line"></span><br><span class="line">    if [ -z &quot;$(ls -A &quot;$PGDATA&quot;)&quot; ]; then</span><br><span class="line">        gosu postgres initdb</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    exec gosu postgres &quot;$@&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">exec &quot;$@&quot;</span><br></pre></td></tr></table></figure>

<p>复制脚本至容器内</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./docker-entrypoint.sh \</span></span><br><span class="line"><span class="language-bash">ENTRYPOINT [<span class="string">&quot;/docker-entrypoint.sh&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;postgres&quot;</span>]</span></span><br></pre></td></tr></table></figure>



<h5 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h5><p>EXPOSE 可以人为的暴露容器的端口，方便在启动容器的时候，进行端口随机映射</p>
<h5 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h5><p>ENV可以设置容器内部的环境变量，例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> PATH=/usr/local/nginx/bin:$PATH  <span class="comment"># 以确保CMD [&quot;nginx&quot;] 正常工作</span></span><br></pre></td></tr></table></figure>



<h5 id="ADD和COPY"><a href="#ADD和COPY" class="headerlink" title="ADD和COPY"></a>ADD和COPY</h5><p>ADD和COPY都可以将文件添加到容器内，虽然二者相似，但又有不同之处；</p>
<ul>
<li>COPY是单纯的将本地文件复制到容器内</li>
<li>ADD条件本地文件时，如果是压缩包，会自动解压</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> requirements.txt /tmp/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install --requirement /tmp/requirements.txt</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /tmp/</span></span><br></pre></td></tr></table></figure>

<p><font color=red>注意：实际使用过程中</font></p>
<p><font color=blue>ADD相对于COPY来说，不透明，实际使用应该避免使用ADD关键</font></p>
<p>​        <font color=red>替代方案：</font></p>
<p>​                        可以先COPY到容器内，然后通过RUN进行解压，或者通过<code>curl</code>或<code>wget</code>将压缩包下载到本地之后在进行解压</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> big.tar.xz /tmp/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash">  tar -xJf /tmp/big.tar.xz -C /usr/src/things \</span></span><br><span class="line"><span class="language-bash">			&amp;&amp; make -C /usr/src/things all</span></span><br></pre></td></tr></table></figure>

<p>对于不需要ADD tar自动提取功能的其他项目（文件、目录），应该始终使用 COPY</p>
<h5 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h5><p>dockerfile中的<code>VOLUME</code>关键字可以挂载容器内目录到主机目录，通过匿名挂载的方式。可以通过<code>docker inspect 容器id</code>查看挂载到主机的实际目录在哪里</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /myvol</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span> &gt; /myvol/greeting</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> /myvol  <span class="comment"># 通过匿名挂载的方式挂载容器内   /myvol 目录</span></span></span><br></pre></td></tr></table></figure>























































<h2 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/22a7032bb7bd">Docker的四种网络模式</a></p>
<p>docker的网络模式支持4种：</p>
<ol>
<li>host模式（仅主机模式）</li>
<li>container模式（用的少！局限性很大）</li>
<li>none模式：不配置网络</li>
<li>bridge模式（默认的模式）</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">docker network <span class="built_in">ls</span> <span class="comment"># 可以查看docker的所有网络信息</span></span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">docker network <span class="built_in">ls</span></span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">37f1233b03fe   bridge    bridge    local</span><br><span class="line">dddd641e9fee   host      host      local</span><br><span class="line">1bd165c33f9d   none      null      local</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">docker network --<span class="built_in">help</span></span></span><br><span class="line"></span><br><span class="line">Usage:  docker network COMMAND</span><br><span class="line"></span><br><span class="line">Manage networks</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  connect     Connect a container to a network</span><br><span class="line">  create      Create a network</span><br><span class="line">  disconnect  Disconnect a container from a network</span><br><span class="line">  inspect     Display detailed information on one or more networks</span><br><span class="line">  ls          List networks</span><br><span class="line">  prune       Remove all unused networks</span><br><span class="line">  rm          Remove one or more networks</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="理解Docker0"><a href="#理解Docker0" class="headerlink" title="理解Docker0"></a>理解Docker0</h3><p>清空所有环境</p>
<p>Docker是如何处理容器网络访问的?</p>
<h4 id="bridge模式"><a href="#bridge模式" class="headerlink" title="bridge模式"></a>bridge模式</h4><img src="https://upload-images.jianshu.io/upload_images/13618762-f1643a51d313a889.png?imageMogr2/auto-orient/strip|imageView2/2/w/1083/format/webp" alt="img" style="zoom:50%;" />



<ol>
<li>先查看本机网卡信息</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">主机ip信息</span></span><br><span class="line">[root@hadoop102 hadoop]# ip addr</span><br><span class="line"><span class="meta"># </span><span class="language-bash">自环地址</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:50:e3:01 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    # ens33 网卡ip地址</span><br><span class="line">    inet 192.168.70.102/24 brd 192.168.70.255 scope global noprefixroute ens33</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::20c:29ff:fe50:e301/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: virbr0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noqueue state DOWN group default qlen 1000</span><br><span class="line">    link/ether 52:54:00:f2:8e:d9 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">4: virbr0-nic: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc pfifo_fast master virbr0 state DOWN group default qlen 1000</span><br><span class="line">    link/ether 52:54:00:f2:8e:d9 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">5: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default </span><br><span class="line">    link/ether 02:42:2f:c2:0c:74 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    # docker0 网络</span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:2fff:fec2:c74/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="meta"># </span><span class="language-bash">容器内的ip地址信息</span></span><br><span class="line">[root@hadoop102 hadoop]# docker exec -it tomcat01 ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="meta"># </span><span class="language-bash">evth-pair  34--35</span></span><br><span class="line">34: eth0@if35: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </span><br><span class="line">    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">容器开启后，主机多出一块网卡   35 -- 34</span></span><br><span class="line">35: veth35da31e@if34: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default </span><br><span class="line">    link/ether 0e:cc:1b:7b:3b:27 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet6 fe80::ccc:1bff:fe7b:3b27/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们发现，容器带来的网卡，都是成对出现的（成对儿的虚拟设备接口）</p>
<p>veth-pair 就是一对的虚拟设备接口，它们都是成对儿出现的，一端连着协议，一端彼此相连</p>
<p>正因为这个特性，veth-pair充当一个桥梁，连接各种虚拟网络设备的</p>
<p>docker 中的所有网络接口都是虚拟的，虚拟的转发效率高</p>
</blockquote>
<p><strong>小总结</strong>：容器都是公用一个路由器的，就是这个docke0，在bridge模式下也称之为桥</p>
<h3 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h3><h4 id="–link（不推荐使用）"><a href="#–link（不推荐使用）" class="headerlink" title="–link（不推荐使用）"></a>–link（不推荐使用）</h4><blockquote>
<p>思考一个场景，我们编写一个微服务， database url=ip:端口号 ，项目重启时，ip地址就会变化，可不可以通过名字来访问容器的ip地址，这样就可以保证虽然ip地址在变化，但是名字一直不会变？</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop102 hadoop]# docker exec -it tomcat02 ping tomcat01</span><br><span class="line">ping: tomcat01: Name or service not known</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">通过 --<span class="built_in">link</span>可以连通两个容器，进而通过容器名就可以相互ping同</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">docker run -d --name tomcat03 --<span class="built_in">link</span> tomcat01 tomcat</span></span><br><span class="line">11145388c943701718c7baa9c2b291a1c2f72b9845709fe098066d7bd3005038</span><br><span class="line"><span class="meta">$ </span><span class="language-bash">docker <span class="built_in">exec</span> -it tomcat03 ping tomcat01</span></span><br><span class="line">PING tomcat01 (172.17.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcat01 (172.17.0.2): icmp_seq=1 ttl=64 time=0.168 ms</span><br><span class="line">64 bytes from tomcat01 (172.17.0.2): icmp_seq=2 ttl=64 time=0.061 ms</span><br><span class="line">64 bytes from tomcat01 (172.17.0.2): icmp_seq=3 ttl=64 time=0.061 ms</span><br><span class="line"><span class="meta"># </span><span class="language-bash">反向ping 却ping不通</span></span><br><span class="line">docker exec -it tomcat01 ping tomcat03</span><br><span class="line">ping: tomcat03: Name or service not known</span><br></pre></td></tr></table></figure>

<p><strong>底层探究</strong></p>
<p>–link 选项可以更改容器的hosts文件，将被链接的容器的ip与容器名字和 ip进行<strong>映射</strong>；但是这个过程是<strong>单向的</strong></p>
<p><font color=red>–link已经不推荐使用了</font>，可以通过自定义网络，不直接使用docker0.</p>
<p>例如docker0的问题： 不支持容器名链接访问</p>
<h4 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">docker run 的时候，默认会添加一个 --net bridge的选项，这里的bridge就是创建的网络名</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">docker run -d --name tomcat01 --net bridge tomcat</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">docker0特点： 默认、域名不能访问、 --<span class="built_in">link</span>可以打通连接，但是笨重，不灵活</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">通过自定义网络，可实现容器的域名连接</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">接下来创建一个网络mynet</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span></span><br><span class="line">bb4918b73768c514519787fe74308638384ea49d79f1cc55b9df330b5a36a0ad</span><br><span class="line"><span class="meta">$ </span><span class="language-bash">docker network <span class="built_in">ls</span></span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">37f1233b03fe   bridge    bridge    local</span><br><span class="line">dddd641e9fee   host      host      local</span><br><span class="line">bb4918b73768   mynet     bridge    local # 自定义创建的网络，相当于我们自己创建了一个桥</span><br><span class="line">1bd165c33f9d   none      null      local</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">启动两个容器，都指定相同的网络</span></span><br><span class="line">[root@hadoop102 hadoop]$ docker run -d --name tomcat01 --net mynet tomcat</span><br><span class="line">3dc2a40323a1272adca27ea381a1038a27a176dc3dbdc07ab7a1a03ed83ef5b7</span><br><span class="line">[root@hadoop102 hadoop]$ docker run -d --name tomcat02 --net mynet tomcat</span><br><span class="line">9c0be98e171d19eb4d1db49f11b8936a79f41d8aa91052b96572a917de668bdd</span><br><span class="line">[root@hadoop102 hadoop]$ docker network inspect mynet</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;mynet&quot;,</span><br><span class="line">        &quot;Id&quot;: &quot;bb4918b73768c514519787fe74308638384ea49d79f1cc55b9df330b5a36a0ad&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2021-06-19T10:54:35.743318807+08:00&quot;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;192.168.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;192.168.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Internal&quot;: false,</span><br><span class="line">        &quot;Attachable&quot;: false,</span><br><span class="line">        &quot;Ingress&quot;: false,</span><br><span class="line">        &quot;ConfigFrom&quot;: &#123;</span><br><span class="line">            &quot;Network&quot;: &quot;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;ConfigOnly&quot;: false,</span><br><span class="line">        &quot;Containers&quot;: &#123;</span><br><span class="line">            &quot;3dc2a40323a1272adca27ea381a1038a27a176dc3dbdc07ab7a1a03ed83ef5b7&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;tomcat01&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;c76434e3d13f2b5b279404afa70b088eb5f054fb30701b14218d77fdf46f46c8&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:02&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;192.168.0.2/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;9c0be98e171d19eb4d1db49f11b8936a79f41d8aa91052b96572a917de668bdd&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;tomcat02&quot;,</span><br><span class="line">                &quot;EndpointID&quot;: &quot;68b1c4c037eae586663d693447d49fe29736ebc0fcf1c89e1407c3c651a4d79f&quot;,</span><br><span class="line">                &quot;MacAddress&quot;: &quot;02:42:c0:a8:00:03&quot;,</span><br><span class="line">                &quot;IPv4Address&quot;: &quot;192.168.0.3/16&quot;,</span><br><span class="line">                &quot;IPv6Address&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"><span class="meta"># </span><span class="language-bash">使用自定义网络之后，不仅可以自动的能进行域名的映射，而且还能双向ping通</span></span><br><span class="line">[root@hadoop102 hadoop]$ docker exec -it tomcat01 ping tomcat02</span><br><span class="line">PING tomcat02 (192.168.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcat02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.172 ms</span><br><span class="line">64 bytes from tomcat02.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.117 ms</span><br><span class="line">64 bytes from tomcat02.mynet (192.168.0.3): icmp_seq=3 ttl=64 time=0.088 ms</span><br><span class="line">^C</span><br><span class="line">--- tomcat02 ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 6ms</span><br><span class="line">rtt min/avg/max/mdev = 0.088/0.125/0.172/0.037 ms</span><br><span class="line">[root@hadoop102 hadoop]$ docker exec -it tomcat02 ping tomcat01</span><br><span class="line">PING tomcat01 (192.168.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from tomcat01.mynet (192.168.0.2): icmp_seq=1 ttl=64 time=0.206 ms</span><br><span class="line">64 bytes from tomcat01.mynet (192.168.0.2): icmp_seq=2 ttl=64 time=0.061 ms</span><br><span class="line">64 bytes from tomcat01.mynet (192.168.0.2): icmp_seq=3 ttl=64 time=0.062 ms</span><br><span class="line">^C</span><br><span class="line">--- tomcat01 ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 4ms</span><br><span class="line">rtt min/avg/max/mdev = 0.061/0.109/0.206/0.069 ms</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用自定义网络的好处：</p>
<ol>
<li>redis - 不同的集群使用不同的网络，保证集群是安全和健康的 </li>
<li>mysql - 不同的集群使用不同的网络，保证集群是安全和健康的</li>
</ol>
<h4 id="网络连通"><a href="#网络连通" class="headerlink" title="网络连通"></a>网络连通</h4><p>处于不同网桥下的两个容器如何连通？</p>
<p>   <img src="C:\Users\LuYu\AppData\Roaming\Typora\typora-user-images\image-20210619121627000.png" alt="image-20210619121627000"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">docker network --<span class="built_in">help</span></span></span><br><span class="line"></span><br><span class="line">Usage:  docker network COMMAND</span><br><span class="line"></span><br><span class="line">Manage networks</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  connect     Connect a container to a network  # 连接一个容器到一个网络</span><br><span class="line">  create      Create a network</span><br><span class="line">  disconnect  Disconnect a container from a network</span><br><span class="line">  inspect     Display detailed information on one or more networks</span><br><span class="line">  ls          List networks</span><br><span class="line">  prune       Remove all unused networks</span><br><span class="line">  rm          Remove one or more networks</span><br><span class="line"><span class="meta"># </span><span class="language-bash">用法</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">docker network connect --<span class="built_in">help</span></span></span><br><span class="line"></span><br><span class="line">Usage:  docker network connect [OPTIONS] NETWORK CONTAINER</span><br><span class="line"></span><br><span class="line">Connect a container to a network</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --alias strings           Add network-scoped alias for the container</span><br><span class="line">      --driver-opt strings      driver options for the network</span><br><span class="line">      --ip string               IPv4 address (e.g., 172.30.100.104)</span><br><span class="line">      --ip6 string              IPv6 address (e.g., 2001:db8::33)</span><br><span class="line">      --link list               Add link to another container</span><br><span class="line">      --link-local-ip strings   Add a link-local address for the container</span><br><span class="line"><span class="meta"># </span><span class="language-bash">假设有两个不同网桥 docker0  和  mynet</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">docker0上有一个容器 tomcat01   mynet上有一个容器tomcat-net-01</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">网络连通这两个容器</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">docker network connect mynet tomcat01</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">实质上是把容器tomcat01的网络信息添加到了网桥mynet中，因此这个过程是单向，tomcat01能ping通tomcat-net-01</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">但是tomcat-net-01 ping不通tomcat01</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">产生的效果就是：tomcat01这个容器会有两个ip地址，一个是公网ip地址，一个是内网IP地址</span></span><br></pre></td></tr></table></figure>





<h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><blockquote>
<p>官方介绍</p>
</blockquote>
<p>Compose使用一个用于<strong>定义</strong>和<strong>运行</strong>多个容器应用的工具</p>
<p>使用YAML文件配置应用的服务，通过这个配置文件可<strong>实现一条命令</strong>启动所有的<strong>应用服务</strong></p>
<blockquote>
<p>使用Compose的三个基础步骤</p>
</blockquote>
<ol>
<li><code>DockerFile</code>，保证项目在任何地方都可以运行</li>
<li>编写<code>docker-compose.yml</code>,</li>
<li> 启动项目<code>docker-compose up</code></li>
</ol>
<blockquote>
<p>作用：基本的容器编排</p>
</blockquote>
<p>Compose是Docker官方的开源项目。需要安装！</p>
<p><code>DockerFile</code>让程序在任何地方运行。web服务，redis，mysql，nginx等多个容器,这么多容器一个一个手动的去run非常的麻烦，通过Compose我们就可以直接一条命令解决！！！</p>
<p>Compose: docker-compose.yml</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.9&quot;</span>  <span class="comment"># optional since v1.27.0</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5000:5000&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">.:/code</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">logvolume01:/var/log</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">logvolume01:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>Compose：重要的概念</p>
<ul>
<li>服务services，容器。应用。（web、redis、mysql）</li>
<li>项目project。一组关联的容器。博客、web、mysql</li>
</ul>
<h5 id="docker-Compose安装"><a href="#docker-Compose安装" class="headerlink" title="docker Compose安装"></a>docker Compose安装</h5><ol>
<li>Run this command to download the current stable release of Docker Compose:</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Apply executable permissions to the binary:</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>ln软连接</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>测试安装是否完成</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">docker-compose --version</span></span><br><span class="line">docker-compose version 1.29.2, build 1110ad01</span><br></pre></td></tr></table></figure>



<h5 id="测试案例"><a href="#测试案例" class="headerlink" title="测试案例"></a>测试案例</h5><p>python应用：计数器； redis！</p>
<p>compose一般使用的步骤：</p>
<ol>
<li>创建应用文件 app.py</li>
<li>DockerFile（应用打包成镜像）</li>
<li>Docker-compose.yaml文件（定义整个服务，需要的环境、web、redis） 完整的上线服务</li>
<li>启动compose项目（docker-compose up）</li>
</ol>
<blockquote>
<p> Step1:Setup</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">1.Create a directory <span class="keyword">for</span> the project:</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">mkdir</span> composetest</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">cd</span> composetest</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">2.Create a file called app.py <span class="keyword">in</span> your project directory and <span class="built_in">paste</span> this <span class="keyword">in</span>:</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">vim app.py</span></span><br><span class="line"></span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">import redis</span><br><span class="line">from flask import Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">cache = redis.Redis(host=&#x27;redis&#x27;, port=6379)</span><br><span class="line"></span><br><span class="line">def get_hit_count():</span><br><span class="line">    retries = 5</span><br><span class="line">    while True:</span><br><span class="line">        try:</span><br><span class="line">            return cache.incr(&#x27;hits&#x27;)</span><br><span class="line">        except redis.exceptions.ConnectionError as exc:</span><br><span class="line">            if retries == 0:</span><br><span class="line">                raise exc</span><br><span class="line">            retries -= 1</span><br><span class="line">            time.sleep(0.5)</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/&#x27;)</span><br><span class="line">def hello():</span><br><span class="line">    count = get_hit_count()</span><br><span class="line">    return &#x27;Hello World! I have been seen &#123;&#125; times.\n&#x27;.format(count)</span><br><span class="line"><span class="meta"># </span><span class="language-bash">3.Create another file called requirements.txt <span class="keyword">in</span> your project directory and <span class="built_in">paste</span> this <span class="keyword">in</span>:</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">vim requirements.txt</span></span><br><span class="line">flask</span><br><span class="line">redis</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Step2: Create a Dockerfile</p>
</blockquote>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># syntax=docker/dockerfile:1</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.7</span>-alpine</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i -e <span class="string">&#x27;s/http:/https:/&#x27;</span> /etc/apk/repositories</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /code</span></span><br><span class="line"><span class="keyword">ENV</span> FLASK_APP=app.py</span><br><span class="line"><span class="keyword">ENV</span> FLASK_RUN_HOST=<span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add --no-cache gcc musl-dev linux-headers</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> requirements.txt requirements.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">5000</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;flask&quot;</span>, <span class="string">&quot;run&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Step 3: Define services in a Compose file  docker-compose.yml</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.9&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5000:5000&quot;</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&quot;redis:alpine&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Step 4: Build and run your app with Compose  </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">docker-compose up</span></span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop102 hadoop]# curl localhost:5000</span><br><span class="line">Hello World! I have been seen 1 times.</span><br><span class="line">[root@hadoop102 hadoop]# curl localhost:5000</span><br><span class="line">Hello World! I have been seen 2 times.</span><br><span class="line"></span><br><span class="line">[root@hadoop102 hadoop]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE             COMMAND                  CREATED         STATUS         PORTS                                       NAMES</span><br><span class="line">feace8f427c9   redis:alpine      &quot;docker-entrypoint.s…&quot;   5 minutes ago   Up 5 minutes   6379/tcp                                    composetest_redis_1</span><br><span class="line">68a9e5a7c4e4   composetest_web   &quot;flask run&quot;              5 minutes ago   Up 5 minutes   0.0.0.0:5000-&gt;5000/tcp, :::5000-&gt;5000/tcp   composetest_web_1</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="Yaml-规则"><a href="#Yaml-规则" class="headerlink" title="Yaml 规则"></a>Yaml 规则</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3 层</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;&#x27;</span>  <span class="comment"># 版本</span></span><br><span class="line"><span class="attr">services:</span> <span class="comment"># 服务</span></span><br><span class="line">	<span class="string">服务1</span> <span class="attr">web:</span></span><br><span class="line">		<span class="string">images</span></span><br><span class="line">		<span class="string">build</span></span><br><span class="line">		<span class="string">network</span></span><br><span class="line">	<span class="string">服务2</span> <span class="string">redis</span></span><br><span class="line">		<span class="string">....</span></span><br><span class="line">	<span class="string">服务3</span></span><br><span class="line"><span class="comment"># 其他配置</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">configs:</span></span><br><span class="line">		</span><br></pre></td></tr></table></figure>

<p>用的时候，可以查看官方文档<a target="_blank" rel="noopener" href="https://docs.docker.com/compose/compose-file/compose-file-v3/">https://docs.docker.com/compose/compose-file/compose-file-v3/</a></p>
<h5 id="使用Compose一键部署WP博客"><a href="#使用Compose一键部署WP博客" class="headerlink" title="使用Compose一键部署WP博客"></a>使用Compose一键部署WP博客</h5><p>（WP、HEXO）</p>
<ol>
<li>创建wordpress目录并进入</li>
<li>创建docker-compose.yml</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.9&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db_data:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">somewordpress</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">wordpress</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">wordpress</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">wordpress</span></span><br><span class="line">    </span><br><span class="line">  <span class="attr">wordpress:</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wordpress:latest</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">wordpress_data:/var/www/html</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8000:80&quot;</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_HOST:</span> <span class="string">db:3306</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_USER:</span> <span class="string">wordpress</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_PASSWORD:</span> <span class="string">wordpress</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_NAME:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">db_data:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">wordpress_data:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>docker-compose up 启动</li>
</ol>
<h2 id="Docker-Swarm"><a href="#Docker-Swarm" class="headerlink" title="Docker Swarm"></a>Docker Swarm</h2><h2 id="CI-CD-Jenkins-流水线！"><a href="#CI-CD-Jenkins-流水线！" class="headerlink" title="CI/CD Jenkins 流水线！"></a>CI/CD Jenkins 流水线！</h2><p>企业实战</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://xiaowodi.github.io/2022/06/24/Kubernetes%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/24/Kubernetes%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Kubernetes学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-24 08:12:10" itemprop="dateCreated datePublished" datetime="2022-06-24T08:12:10+00:00">2022-06-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h1 id="Kubernetes学习笔记"><a href="#Kubernetes学习笔记" class="headerlink" title="Kubernetes学习笔记"></a>Kubernetes学习笔记</h1><h2 id="第一部分：K8s概念和架构"><a href="#第一部分：K8s概念和架构" class="headerlink" title="第一部分：K8s概念和架构"></a>第一部分：K8s概念和架构</h2><h3 id="1-K8S概述和特性"><a href="#1-K8S概述和特性" class="headerlink" title="1. K8S概述和特性"></a>1. K8S概述和特性</h3><h4 id="Kubernetes-基本介绍"><a href="#Kubernetes-基本介绍" class="headerlink" title="Kubernetes 基本介绍"></a>Kubernetes 基本介绍</h4><p>kubernetes，简称   开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes 的应用简单并且高（powerful）,Kubernetes ，更新，维护的一种机制。</p>
<p>传统的应用部署方式是通过插件或脚本来安装应用。这样做的缺点是应用的运行、配置、管理、所有生存周期将与当前操作系统绑定，这样做并不利于应用的升级更新/回滚等操作，当然也可以通过创建虚拟机的方式来实现某些功能，但是虚拟机非常重，并不利于可移性。</p>
<p>新的方式是通过部署容器方式实现，每个容器之间互相隔离，每个容器有自己的文件系统 资源。相对于虚拟机，容器能快速部署，由于容器与底层设施、机器文件系统解耦的，所以它能在不同云、不同版本操作系统间进行迁移。</p>
<p>容器占用资源少、部署快，每个应用可以被打包成一个容器镜像，每个应用与容器间成一对一关系也使容器有更大优势，使用容器可以在  建容器镜像，因为每个应用不需要与其余的应用堆栈组合，也不依赖于生产环境基础结构，这使得从研发到测试、生产能提供一致环境。类似地，容器比虚拟机轻量、更“透明”，这更便于监控和管理。</p>
<p>Kubernetes  动化部署、大规模可伸缩、应用容器化管理。在生产环境中部署一个应用程序时，通常要部署该应用的多个实例以便对应用请求进行负载均衡。</p>
<p>在 个容器里面运行一个应用实例，然后通过内置的负载均衡策略，实现对这一组应用实例的管理、发现、访问，而这些细节都不需要运维人员去进行复杂的手工配置和处理。</p>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><p>Kubernetes是一个轻便的和可扩展的开源平台，用于管理容器化应用和服务。通过Kubernetes能够进行应用的自动化部署和扩缩容。在Kubernetes中，会将组成应用的容器组合在一个逻辑单元以更易管理和发现。Kubernetes累积了Google生产环境运行工作负载15年的经验，并吸收了来组社区的最佳想法和实践。</p>
<h3 id="2-K8S架构组件"><a href="#2-K8S架构组件" class="headerlink" title="2.K8S架构组件"></a>2.K8S架构组件</h3><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimage.mamicode.com%2Finfo%2F201811%2F20181121230758563675.png&refer=http%3A%2F%2Fimage.mamicode.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1627273055&t=80481fe36bc98fabdad850e85819c4b8" alt="img" style="zoom:80%;" />

<ol>
<li><strong>主控节点Master节点中的组件</strong><ul>
<li><strong>API Server</strong><ul>
<li>集群统一入口，以restful方式，交给etcd存储</li>
</ul>
</li>
<li><strong>scheduler</strong><ul>
<li>节点调度，选择node节点应用部署</li>
</ul>
</li>
<li><strong>controller-manager</strong><ul>
<li>处理集群中常规后台任务，一个资源对应一个控制器<ul>
<li>举个例子：部署一个订单的应用，那么订单这个应用就会对应一个controller；如果还有一个购物车的应用，那么购物车也会对应一个controller。</li>
</ul>
</li>
</ul>
</li>
<li><strong>etcd</strong><ul>
<li>存储系统，用于保存集群相关的数据。</li>
</ul>
</li>
</ul>
</li>
<li><strong>工作节点node节点中的组件</strong><ul>
<li><strong>kubelet</strong><ul>
<li>master派到node节点中的代表，管理本机的容器</li>
</ul>
</li>
<li><strong>kube-proxy</strong><ul>
<li>提供网络代理，可实现负载均衡等操作</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="3-K8S核心概念初识"><a href="#3-K8S核心概念初识" class="headerlink" title="3.K8S核心概念初识"></a>3.K8S核心概念初识</h3><ol>
<li><strong>Pod</strong><ul>
<li>k8s中最小的部署单元（一个pod中可以包含多个容器）</li>
<li>一组容器的集合</li>
<li>一个Pod中的容器是共享网络的</li>
<li>Pod的生命周期是短暂的</li>
</ul>
</li>
<li><strong>controller</strong>（通过controller创建pod，部署pod）<ul>
<li>确保预期的pod副本数量</li>
<li>无状态的应用部署</li>
<li>有状态的应用部署</li>
<li>确保所有的node运行同一个pod</li>
<li>一次性任务和定时任务</li>
</ul>
</li>
<li><strong>Service</strong>（统一部署）<ul>
<li>定义一组pod的访问规则</li>
</ul>
</li>
</ol>
<h2 id="第二部分：从零搭建K8s集群、"><a href="#第二部分：从零搭建K8s集群、" class="headerlink" title="第二部分：从零搭建K8s集群、"></a>第二部分：从零搭建K8s集群、</h2><h3 id="前置准备工作"><a href="#前置准备工作" class="headerlink" title="前置准备工作"></a>前置准备工作</h3><h4 id="1-搭建k8s环境平台规划"><a href="#1-搭建k8s环境平台规划" class="headerlink" title="1. 搭建k8s环境平台规划"></a>1. 搭建k8s环境平台规划</h4><blockquote>
<p>平台规划</p>
</blockquote>
<ol>
<li>单master集群</li>
</ol>
<img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fassets.sumologic.com%2Fapplication-content%2Fkubernetes_cluster.png%3Fmtime%3D20191022144431&refer=http%3A%2F%2Fassets.sumologic.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1627274979&t=28ae11eca3968dbc42570f385274a6b6" alt="img" style="zoom:60%;" />



<ol start="2">
<li>多master集群（高可用 ）</li>
</ol>
<img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F9620980-be963c83b5952fca.png&refer=http%3A%2F%2Fupload-images.jianshu.io&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1627274636&t=99675bcc0d1a3562958f3b6ab768b79d" alt="img" style="zoom:60%;" />



<h4 id="2-服务器硬件配置要求"><a href="#2-服务器硬件配置要求" class="headerlink" title="2. 服务器硬件配置要求"></a>2. 服务器硬件配置要求</h4><h4 id="硬件要求"><a href="#硬件要求" class="headerlink" title="硬件要求"></a>硬件要求</h4><p>测试环境下：</p>
<table>
<thead>
<tr>
<th>节点类型</th>
<th>CPU</th>
<th>内存</th>
<th>硬盘</th>
</tr>
</thead>
<tbody><tr>
<td>Master</td>
<td>2核</td>
<td>4G</td>
<td>20G</td>
</tr>
<tr>
<td>node</td>
<td>4核</td>
<td>8G</td>
<td>40G</td>
</tr>
</tbody></table>
<h4 id="3-搭建k8s集群部署方式"><a href="#3-搭建k8s集群部署方式" class="headerlink" title="3. 搭建k8s集群部署方式"></a>3. 搭建k8s集群部署方式</h4><p>搭建k8s集群有多种部署方式，常用的有以下两种方式：</p>
<ol>
<li><strong>基于客户端工具（kubeadm）</strong></li>
</ol>
<blockquote>
<p>Kubeadm是一个k8s部署工具，提供kubeadm init 和 kubeadm join， 用于快速部署Kubernetes集群</p>
<p>官方地址：<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/">https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/</a></p>
</blockquote>
<ol start="2">
<li><strong>基于二进制包方式</strong></li>
</ol>
<blockquote>
<p>从github下载发行版的二进制包，手动部署每个组件，组成 Kubernetes集群。<br>Kubeadm 蔽了很多细节，遇到问题很难排查。如果想更容易可控，推荐使用二进制包部署 期间可以学习很多工作原理，也利于后期维护。</p>
</blockquote>
<h3 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h3><p>虚拟机硬件配置：一台master，两台node</p>
<ul>
<li>硬件配置<ul>
<li>2GB或更多RAM，2个CPU或更多CPU，硬盘30G或更多</li>
</ul>
</li>
<li>集群中所有机器之间网络互通</li>
<li>可以访问外网，需要拉取镜像</li>
<li>禁止swap分区</li>
</ul>
<p>cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOF<br>net.bridge.bridge-nf-call-ip6tables = 1<br>net.bridge.bridge-nf-call-iptables = 1<br>net.ipv4.ip_forward = 1<br>EOF</p>
<p>cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF<br>[kubernetes]<br>name=Kubernetes<br>baseurl=<a target="_blank" rel="noopener" href="https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64">https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</a><br>enabled=1<br>gpgcheck=0<br>repo_gpgcheck=0<br>gpgkey=<a target="_blank" rel="noopener" href="https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg">https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</a> <a target="_blank" rel="noopener" href="https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg">https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</a><br>EOF</p>
<p>baseurl=<a target="_blank" rel="noopener" href="https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64">https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</a></p>
<p>wget <a target="_blank" rel="noopener" href="https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo">https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</a>  /etc/yum.repos.d/docker-ce.repo</p>
<h4 id="基于二进制包方式"><a href="#基于二进制包方式" class="headerlink" title="基于二进制包方式"></a><strong>基于二进制包方式</strong></h4><h5 id="搭建etcd集群"><a href="#搭建etcd集群" class="headerlink" title="搭建etcd集群"></a>搭建etcd集群</h5><p>Etcd是一个分布式键值存储系统，Kubernetes使用Etcd进行数据存储，所以先准备一个Etcd数据库，为解决Etcd单点故障，应采用集群方式部署，这里使用3台组建集群，可容忍1台机器故障。</p>
<table>
<thead>
<tr>
<th>节点名称</th>
<th>IP</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>etcd-1</td>
<td>192.168.0.110</td>
<td></td>
</tr>
<tr>
<td>etcd-2</td>
<td>192.168.0.111</td>
<td></td>
</tr>
<tr>
<td>etcd-3</td>
<td>192.168.0.112</td>
<td></td>
</tr>
</tbody></table>
<h6 id="1-准备cfssl证书生成工具"><a href="#1-准备cfssl证书生成工具" class="headerlink" title="1.准备cfssl证书生成工具"></a>1.准备cfssl证书生成工具</h6><p>cfssl是一个开源的证书管理工具，使用json文件生成证书，相比openssl更方便使用。</p>
<p>在Master节点上，执行下列命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64</span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64</span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64</span><br><span class="line">chmod +x cfssl_linux-amd64 cfssljson_linux-amd64 cfssl-certinfo_linux-amd64</span><br><span class="line">mv cfssl_linux-amd64 /usr/local/bin/cfssl</span><br><span class="line">mv cfssljson_linux-amd64 /usr/local/bin/cfssljson</span><br><span class="line">mv cfssl-certinfo_linux-amd64 /usr/bin/cfssl-certinfo</span><br></pre></td></tr></table></figure>

<h6 id="2-生成Etcd证书"><a href="#2-生成Etcd证书" class="headerlink" title="2. 生成Etcd证书"></a>2. 生成Etcd证书</h6><p>（1）自签证书颁发机构（CA）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">创建工作目录</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">mkdir</span> -p ~/TLS/&#123;etcd,k8s&#125;</span> </span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">cd</span> TLS/etcd</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">自签CA</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">cat</span> &gt; ca-config.json&lt;&lt; <span class="string">EOF</span></span></span><br><span class="line">&#123;</span><br><span class="line">	&quot;signing&quot;:&#123;</span><br><span class="line">		&quot;default&quot;:&#123;</span><br><span class="line">			&quot;expiry&quot;:&quot;87600h&quot;</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;profiles&quot;:&#123;</span><br><span class="line">			&quot;www&quot;:[</span><br><span class="line">				&quot;signing&quot;,</span><br><span class="line">				&quot;key encipherment&quot;,</span><br><span class="line">				&quot;server auth&quot;,</span><br><span class="line">				&quot;client auth&quot;</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="string">cat  &gt; ca-csr.json&lt;&lt; EOF</span></span></span><br><span class="line">&#123;</span><br><span class="line">	&quot;CN&quot;:&quot;etcd CA&quot;,</span><br><span class="line">	&quot;key&quot;:&#123;</span><br><span class="line">		&quot;algo&quot;:&quot;rsa&quot;,</span><br><span class="line">		&quot;size&quot;:&quot;2048&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;names&quot;:[</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;C&quot;:&quot;CN&quot;,</span><br><span class="line">			&quot;L&quot;:&quot;Beijing&quot;,</span><br><span class="line">			&quot;ST&quot;:&quot;Beijing&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">生成证书：</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">cfssl gencert -initca ca-csr.json | cfssljson -bare ca -</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">ls</span> *pem</span></span><br><span class="line">ca-key.pem	ca.pem</span><br></pre></td></tr></table></figure>

<p>（2）使用自签CA签发Etcd Https证书</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">创建证书申请文件</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">cat</span> &gt; server-csr.json&lt;&lt; <span class="string">EOF</span></span></span><br><span class="line">&#123;</span><br><span class="line">	&quot;CN&quot;:&quot;etcd&quot;,</span><br><span class="line">	&quot;hosts&quot;: [</span><br><span class="line">		&quot;192.168.0.110&quot;,</span><br><span class="line">		&quot;192.168.0.111&quot;,</span><br><span class="line">		&quot;192.168.0.112&quot;</span><br><span class="line">	],</span><br><span class="line">	&quot;key&quot;:&#123;</span><br><span class="line">		&quot;algo&quot;:&quot;rsa&quot;,</span><br><span class="line">		&quot;size&quot;:2048</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;names&quot;:[</span><br><span class="line">		&#123;</span><br><span class="line">			&quot;C&quot;:&quot;CN&quot;,</span><br><span class="line">			&quot;L&quot;:&quot;Beijing&quot;,</span><br><span class="line">			&quot;ST&quot;:&quot;Beijing&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="string">注： 上述文件hosts字段中ip为所有etcd节点的集群内部通信IP，一个都不能少！为了方便后期扩容可以多写几个预留的IP</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="string">生成证书</span></span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="string">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=www server-csr.json | cfssljson -bare server</span></span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="string">ls server*pem</span></span></span><br><span class="line">server-key.pem	server.pem</span><br></pre></td></tr></table></figure>

<h6 id="3-从github下载二进制文件"><a href="#3-从github下载二进制文件" class="headerlink" title="3.从github下载二进制文件"></a>3.从github下载二进制文件</h6><p>下载地址：<a target="_blank" rel="noopener" href="https://github.com/etcd-io/etcd/releases/download/v3.4.9/etcd-v3.4.9-linux-amd64.tar.gz">https://github.com/etcd-io/etcd/releases/download/v3.4.9/etcd-v3.4.9-linux-amd64.tar.gz</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">1. 创建工作目录并解压etcd二进制包</span></span><br><span class="line">mkdir /opt/etcd/&#123;bin,cfg,ssl&#125; -p</span><br><span class="line">tar zxvf etcd-v3.4.14-linux-amd64.tar.gz</span><br><span class="line">mv etcd-v3.4.14-linux-amd64/&#123;etcd,etcdctl&#125; /opt/etcd/bin/</span><br><span class="line"><span class="meta">#</span><span class="language-bash">2.建etcd.conf（修改对应的master的ip地址）</span></span><br><span class="line">cat &gt; /opt/etcd/cfg/etcd.conf &lt;&lt; EOF</span><br><span class="line"><span class="meta">#</span><span class="language-bash">[Member]</span></span><br><span class="line">ETCD_NAME=&quot;etcd-1&quot;</span><br><span class="line">ETCD_DATA_DIR=&quot;/var/lib/etcd/default.etcd&quot;</span><br><span class="line">ETCD_LISTEN_PEER_URLS=&quot;https://192.168.0.110:2380&quot;</span><br><span class="line">ETCD_LISTEN_CLIENT_URLS=&quot;https://192.168.0.110:2379&quot;</span><br><span class="line"><span class="meta">#</span><span class="language-bash">[Clustering]</span></span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS=&quot;https://192.168.0.110:2380&quot;</span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS=&quot;https://192.168.0.110:2379&quot;</span><br><span class="line">ETCD_INITIAL_CLUSTER=&quot;etcd-1=https://192.168.0.110:2380,etcd-2=https://192.168.0.111:2380,etcd-3=https://192.168.0.112:2380&quot;</span><br><span class="line">ETCD_INITIAL_CLUSTER_TOKEN=&quot;etcd-cluster&quot;</span><br><span class="line">ETCD_INITIAL_CLUSTER_STATE=&quot;new&quot;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta"># </span><span class="language-bash">ETCD_NAME：节点名称，集群中唯一</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">ETCD_DATA_DIR：数据目录</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">ETCD_LISTEN_PEER_URLS：集群通信监听地址</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">ETCD_LISTEN_CLIENT_URLS：客户端访问监听地址</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">ETCD_INITIAL_ADVERTISE_PEER_URLS：集群通告地址</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">ETCD_ADVERTISE_CLIENT_URLS：客户端通告地址</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">ETCD_INITIAL_CLUSTER：集群节点地址</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">ETCD_INITIAL_CLUSTER_TOKEN：集群 Token</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">ETCD_INITIAL_CLUSTER_STATE：加入集群的当前状态，new 是新集群，existing 表示加入 已有集群</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">3. systemd 管理 etcd  创建etcd.service</span></span><br><span class="line">cat &gt; /usr/lib/systemd/system/etcd.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Etcd Server</span><br><span class="line">After=network.target</span><br><span class="line">After=network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">EnvironmentFile=/opt/etcd/cfg/etcd.conf</span><br><span class="line">ExecStart=/opt/etcd/bin/etcd \</span><br><span class="line">--cert-file=/opt/etcd/ssl/server.pem \</span><br><span class="line">--key-file=/opt/etcd/ssl/server-key.pem \</span><br><span class="line">--peer-cert-file=/opt/etcd/ssl/server.pem \</span><br><span class="line">--peer-key-file=/opt/etcd/ssl/server-key.pem \</span><br><span class="line">--trusted-ca-file=/opt/etcd/ssl/ca.pem \</span><br><span class="line">--peer-trusted-ca-file=/opt/etcd/ssl/ca.pem \</span><br><span class="line">--logger=zap</span><br><span class="line">Restart=on-failure</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">4. 拷贝刚才生成的证书 到 配置文件的路径</span></span><br><span class="line">cp ~/TLS/etcd/ca*pem ~/TLS/etcd/server*pem /opt/etcd/ssl/</span><br><span class="line"><span class="meta"># </span><span class="language-bash">5. 启动并设置开机启动(稍后执行，待从节点文件同步后再一起执行)</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start etcd  # 启动后会卡住因为需要和node节点一起执行改命令</span><br><span class="line">systemctl enable etcd</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">6. 将上面节点 1 所有生成的文件拷贝到节点 2 和节点 3</span></span><br><span class="line">scp -r /opt/etcd/ root@192.168.0.111:/opt/</span><br><span class="line">scp /usr/lib/systemd/system/etcd.service root@192.168.0.111:/usr/lib/systemd/system/</span><br><span class="line">scp -r /opt/etcd/ root@192.168.0.112:/opt/</span><br><span class="line">scp /usr/lib/systemd/system/etcd.service root@192.168.0.112:/usr/lib/systemd/system/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">7. 然后在节点 2 和节点 3 分别修改 etcd.conf 配置文件中的节点名称和当前服务器 IP</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">节点 2 改为 etcd-2，节点 3 改为 etcd-3</span></span><br><span class="line">vim /opt/etcd/cfg/etcd.conf</span><br><span class="line"><span class="meta"># </span><span class="language-bash">同时需要更改etcd.conf 中的当前所在机器对应的ip地址</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">8.然后三台节点同时执行 步骤5的指令</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">9. 查看集群状态</span></span><br><span class="line">ETCDCTL_API=3 /opt/etcd/bin/etcdctl --cacert=/opt/etcd/ssl/ca.pem --cert=/opt/etcd/ssl/server.pem --key=/opt/etcd/ssl/server-key.pem --endpoints=&quot;https://192.168.0.110:2379,https://192.168.0.111:2379,https://192.168.0.112:2379&quot; endpoint health</span><br><span class="line"><span class="meta"># </span><span class="language-bash">输出：</span></span><br><span class="line">https://192.168.0.112:2379 is healthy: successfully committed proposal: took = 57.453222ms</span><br><span class="line">https://192.168.0.110:2379 is healthy: successfully committed proposal: took = 55.09686ms</span><br><span class="line">https://192.168.0.111:2379 is healthy: successfully committed proposal: took = 61.813391ms</span><br><span class="line"><span class="meta"># </span><span class="language-bash">etcd 集群搭建成功！</span></span><br></pre></td></tr></table></figure>

<p>如果输出上面信息，就说明集群部署成功。如果有问题第一步先看日志：<br>/var/log/message  或 journalctl  -u etcd</p>
<p><font color=red>如果服务器死机，宕机，故障，导致etcd集群中个节点的数据不同步，进而导致k8s集群异常：可参考以下这2个帖子</font></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dudu/p/12161010.html">https://www.cnblogs.com/dudu/p/12161010.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42883074/article/details/112789206">https://blog.csdn.net/qq_42883074/article/details/112789206</a></p>
<p>这里列出我遇到的问题：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">突遇电脑死机，整个用虚拟机搭建的集群突然宕掉</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">重启后，运行kubectl get nodes 卡住，最后报错：Unable to connect to the server</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看3台节点上的etcd服务， 有两台服务状态为faild</span></span><br><span class="line">journalctl -f -u kubelet.service # 报错，找不到节点</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weiyongle1996/article/details/75128239?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.base&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.base">https://blog.csdn.net/weiyongle1996/article/details/75128239?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.base&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.base</a></p>
<p>enss3无法使用ip地址</p>
<h5 id="安装Docker（三台节点都需要安装）"><a href="#安装Docker（三台节点都需要安装）" class="headerlink" title="安装Docker（三台节点都需要安装）"></a>安装Docker（三台节点都需要安装）</h5><p>下载地址：<a target="_blank" rel="noopener" href="https://download.docker.com/linux/static/stable/x86_64/docker-19.03.9.tgz">https://download.docker.com/linux/static/stable/x86_64/docker-19.03.9.tgz</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">1. 先卸载旧版本的docker</span></span><br><span class="line">yum list installed | grep docker # 查找之前安装过的软件</span><br><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">2. 解压并移动</span></span><br><span class="line">tar zxvf docker-19.03.9.tgz </span><br><span class="line">mv docker/* /usr/bin</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">3. systemd管理docker服务</span></span><br><span class="line">cat &gt; /usr/lib/systemd/system/docker.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Docker Application Container Engine</span><br><span class="line">Documentation=https://docs.docker.com</span><br><span class="line">After=network-online.target firewalld.service</span><br><span class="line">Wants=network-online.target</span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">ExecStart=/usr/bin/dockerd</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line">LimitNOFILE=infinity</span><br><span class="line">LimitNPROC=infinity</span><br><span class="line">LimitCORE=infinity</span><br><span class="line">TimeoutStartSec=0</span><br><span class="line">Delegate=yes</span><br><span class="line">KillMode=process</span><br><span class="line">Restart=on-failure</span><br><span class="line">StartLimitBurst=3</span><br><span class="line">StartLimitInterval=60s</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">启动服务</span></span><br><span class="line">[root@K8s-Node2 software]# systemctl daemon-reload</span><br><span class="line">[root@K8s-Node2 software]# systemctl start docker</span><br><span class="line">[root@K8s-Node2 software]# systemctl enable docker</span><br></pre></td></tr></table></figure>

<h5 id="部署Master-Node"><a href="#部署Master-Node" class="headerlink" title="部署Master Node"></a>部署Master Node</h5><p>在Master节点上操作</p>
<h6 id="1-生成kube-apiserver证书"><a href="#1-生成kube-apiserver证书" class="headerlink" title="1. 生成kube-apiserver证书"></a>1. 生成kube-apiserver证书</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">1. 自签证书颁发机构（CA）</span></span><br><span class="line">cd TLS/k8s</span><br><span class="line">cat &gt; ca-config.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;signing&quot;: &#123;</span><br><span class="line">    &quot;default&quot;: &#123;</span><br><span class="line">      &quot;expiry&quot;: &quot;87600h&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;profiles&quot;: &#123;</span><br><span class="line">      &quot;kubernetes&quot;: &#123;</span><br><span class="line">         &quot;expiry&quot;: &quot;87600h&quot;,</span><br><span class="line">         &quot;usages&quot;: [</span><br><span class="line">            &quot;signing&quot;,</span><br><span class="line">            &quot;key encipherment&quot;,</span><br><span class="line">            &quot;server auth&quot;,</span><br><span class="line">            &quot;client auth&quot;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">cat &gt; ca-csr.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;CN&quot;: &quot;kubernetes&quot;,</span><br><span class="line">    &quot;key&quot;: &#123;</span><br><span class="line">        &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">        &quot;size&quot;: 2048</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;names&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">            &quot;L&quot;: &quot;Beijing&quot;,</span><br><span class="line">            &quot;ST&quot;: &quot;Beijing&quot;,</span><br><span class="line">            &quot;O&quot;: &quot;k8s&quot;,</span><br><span class="line">            &quot;OU&quot;: &quot;System&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">2. 生成证书</span></span><br><span class="line">cfssl gencert -initca ca-csr.json | cfssljson -bare ca -</span><br><span class="line">ls *pem</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">3. 使用自签CA签发kube-apiserver HTTPS证书</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">创建证书申请文件：</span></span><br><span class="line">cat &gt; server-csr.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;CN&quot;: &quot;kubernetes&quot;,</span><br><span class="line">    &quot;hosts&quot;: [</span><br><span class="line">      &quot;10.0.0.1&quot;,</span><br><span class="line">      &quot;127.0.0.1&quot;,</span><br><span class="line">      &quot;192.168.0.110&quot;,</span><br><span class="line">      &quot;192.168.0.111&quot;,</span><br><span class="line">      &quot;192.168.0.112&quot;,</span><br><span class="line">      &quot;192.168.0.113&quot;,</span><br><span class="line">      &quot;192.168.0.114&quot;,</span><br><span class="line">      &quot;192.168.0.115&quot;,</span><br><span class="line">      &quot;192.168.0.116&quot;,</span><br><span class="line">      &quot;kubernetes&quot;,</span><br><span class="line">      &quot;kubernetes.default&quot;,</span><br><span class="line">      &quot;kubernetes.default.svc&quot;,</span><br><span class="line">      &quot;kubernetes.default.svc.cluster&quot;,</span><br><span class="line">      &quot;kubernetes.default.svc.cluster.local&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;key&quot;: &#123;</span><br><span class="line">        &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">        &quot;size&quot;: 2048</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;names&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">            &quot;L&quot;: &quot;BeiJing&quot;,</span><br><span class="line">            &quot;ST&quot;: &quot;BeiJing&quot;,</span><br><span class="line">            &quot;O&quot;: &quot;k8s&quot;,</span><br><span class="line">            &quot;OU&quot;: &quot;System&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta"># </span><span class="language-bash">生成证书</span></span><br><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes server-csr.json | cfssljson -bare server</span><br><span class="line"></span><br><span class="line">ls server*pem</span><br></pre></td></tr></table></figure>

<h6 id="2-从github下载二进制文件"><a href="#2-从github下载二进制文件" class="headerlink" title="2. 从github下载二进制文件"></a>2. 从github下载二进制文件</h6><p>下载地址：<br><a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.18.md#v1183">https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.18.md#v1183</a></p>
<p>下载kubernetes-server-linux-amd64.tar.gz即可</p>
<h6 id="3-解压kubernetes-server-linux-amd64-tar-gz文件并移动到相应目录下"><a href="#3-解压kubernetes-server-linux-amd64-tar-gz文件并移动到相应目录下" class="headerlink" title="3.解压kubernetes-server-linux-amd64.tar.gz文件并移动到相应目录下"></a>3.解压kubernetes-server-linux-amd64.tar.gz文件并移动到相应目录下</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /opt/kubernetes/&#123;bin,cfg,ssl,logs&#125;</span><br><span class="line">tar zxvf kubernetes-server-linux-amd64.tar.gz</span><br><span class="line">cd kubernetes/server/bin</span><br><span class="line">cp kube-apiserver kube-scheduler kube-controller-manager /opt/kubernetes/bin</span><br><span class="line">cp kubectl /usr/bin/</span><br></pre></td></tr></table></figure>

<h6 id="4-部署kube-apiserver"><a href="#4-部署kube-apiserver" class="headerlink" title="4. 部署kube-apiserver"></a>4. 部署kube-apiserver</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">1. 创建配置文件</span></span><br><span class="line">cat &gt; /opt/kubernetes/cfg/kube-apiserver.conf &lt;&lt; EOF</span><br><span class="line">KUBE_APISERVER_OPTS=&quot;--logtostderr=false \\</span><br><span class="line">--v=2 \\</span><br><span class="line">--log-dir=/opt/kubernetes/logs \\</span><br><span class="line">--etcd-servers=https://192.168.0.110:2379,https://192.168.0.111:2379,https://192.168.0.112:2379 \\</span><br><span class="line">--bind-address=192.168.0.110 \\</span><br><span class="line">--secure-port=6443 \\</span><br><span class="line">--advertise-address=192.168.0.110 \\</span><br><span class="line">--allow-privileged=true \\</span><br><span class="line">--service-cluster-ip-range=10.0.0.0/24 \\</span><br><span class="line">--enable-admission-plugins=NamespaceLifecycle,LimitRanger,ServiceAccount,ResourceQuota,NodeRestriction \\</span><br><span class="line">--authorization-mode=RBAC,Node \\</span><br><span class="line">--enable-bootstrap-token-auth=true \\</span><br><span class="line">--token-auth-file=/opt/kubernetes/cfg/token.csv \\</span><br><span class="line">--service-node-port-range=30000-32767 \\</span><br><span class="line">--kubelet-client-certificate=/opt/kubernetes/ssl/server.pem \\</span><br><span class="line">--kubelet-client-key=/opt/kubernetes/ssl/server-key.pem \\</span><br><span class="line">--tls-cert-file=/opt/kubernetes/ssl/server.pem  \\</span><br><span class="line">--tls-private-key-file=/opt/kubernetes/ssl/server-key.pem \\</span><br><span class="line">--client-ca-file=/opt/kubernetes/ssl/ca.pem \\</span><br><span class="line">--service-account-key-file=/opt/kubernetes/ssl/ca-key.pem \\</span><br><span class="line">--etcd-cafile=/opt/etcd/ssl/ca.pem \\</span><br><span class="line">--etcd-certfile=/opt/etcd/ssl/server.pem \\</span><br><span class="line">--etcd-keyfile=/opt/etcd/ssl/server-key.pem \\</span><br><span class="line">--audit-log-maxage=30 \\</span><br><span class="line">--audit-log-maxbackup=3 \\</span><br><span class="line">--audit-log-maxsize=100 \\</span><br><span class="line">--audit-log-path=/opt/kubernetes/logs/k8s-audit.log&quot;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash"><span class="comment">######################</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">参数说明</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">注：上面两个\ \ 第一个是转义符，第二个是换行符，使用转义符是为了使用 EOF 保留换 行符。</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">–logtostderr：启用日志</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">—v：日志等级</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">–log-dir：日志目录</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">–etcd-servers：etcd 集群地址</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">–bind-address：监听地址</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">–secure-port：https 安全端口</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">–advertise-address：集群通告地址</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">–allow-privileged：启用授权</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">–service-cluster-ip-range：Service 虚拟 IP 地址段</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">–enable-admission-plugins：准入控制模块</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">–authorization-mode：认证授权，启用 RBAC 授权和节点自管理</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">–enable-bootstrap-token-auth：启用 TLS bootstrap 机制</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">–token-auth-file：bootstrap token 文件</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">–service-node-port-range：Service nodeport 类型默认分配端口范围</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">–kubelet-client-xxx：apiserver 访问 kubelet 客户端证书</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">–tls-xxx-file：apiserver https 证书</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">–etcd-xxxfile：连接 Etcd 集群证书</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">–audit-log-xxx：审计日志</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash"><span class="comment">######################</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">2. 拷贝刚才生成的证书 到 kubernetes配置文件中的路径</span></span><br><span class="line">cp ~/TLS/k8s/ca*pem ~/TLS/k8s/server*pem /opt/kubernetes/ssl/</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="3">
<li><strong>启用 TSL Bootstrapping机制</strong></li>
</ol>
<p>TSL Bootstrapping：Master apiserver启动TLS认证后，Node节点kubelet和kube-proxy要与kube-apiserver进行通信，必须使用CA签发的有效证书才可以，当Node节点很多时，这种客户端证书颁发需要大量工作，同样也会增加集群扩展复杂度。为了简化流程，Kubernetes引入了TLS bootstrapping机制来自动颁发客户端证书，kubelet会以一个低权限用户自动向apiserver申请证书，kubelet的证书有apiserver动态签署</p>
<p>所以强烈建议在Node上使用这种方式，目前主要用于kubelet；kube-proxy还是由我们统一颁发一个证书。</p>
<p>TLS bootstraping工作流程：</p>
<img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.52wzj.com%2Fwp-content%2Fuploads%2F2020%2F6%2FjQjeAr.png&refer=http%3A%2F%2Fwww.52wzj.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1627316875&t=0fd6871c7e84397a9e2e51cd1e6daacb" alt="img" style="zoom:50%;" />

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">1. 创建上述配置文件中的token文件</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">生成 一串 随机的 32位串，作为用户组token</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">head</span> -c 16 /dev/urandom | <span class="built_in">od</span> -An -t x | <span class="built_in">tr</span> -d <span class="string">&#x27; &#x27;</span></span></span><br><span class="line">220ee81becf461cfc2d2b0e983d4347c</span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">cat</span> &gt; /opt/kubernetes/cfg/token.csv &lt;&lt; <span class="string">EOF</span></span></span><br><span class="line">220ee81becf461cfc2d2b0e983d4347c,kubelet-bootstrap,10001,&quot;system:node-bootstrapper&quot;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta">#</span><span class="language-bash"><span class="string">说明： 格式：token，用户名，UID，用户组 token 也可自行生成替换：</span></span></span><br></pre></td></tr></table></figure>


</blockquote>
<blockquote>
<ol start="4">
<li><strong>systemd管理apiserver</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /usr/lib/systemd/system/kube-apiserver.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes API Server</span><br><span class="line">Documentation=https://github.com/kubernetes/kubernetes</span><br><span class="line">[Service]</span><br><span class="line">EnvironmentFile=/opt/kubernetes/cfg/kube-apiserver.conf</span><br><span class="line">ExecStart=/opt/kubernetes/bin/kube-apiserver \$KUBE_APISERVER_OPTS</span><br><span class="line">Restart=on-failure</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>启动并设置开机自启</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start kube-apiserver</span><br><span class="line">systemctl enable kube-apiserver</span><br><span class="line">systemctl status kube-apiserver </span><br></pre></td></tr></table></figure>

<ol start="6">
<li><strong>授权kubelet-bootstrap用户允许请求证书</strong></li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl create clusterrolebinding kubelet-bootstrap \</span><br><span class="line">--clusterrole=system:node-bootstrapper \</span><br><span class="line">--user=kubelet-bootstrap</span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="5-部署kube-controller-manager"><a href="#5-部署kube-controller-manager" class="headerlink" title="5.部署kube-controller-manager"></a>5.部署kube-controller-manager</h6><blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /opt/kubernetes/cfg/kube-controller-manager.conf &lt;&lt; EOF</span><br><span class="line">KUBE_CONTROLLER_MANAGER_OPTS=&quot;--logtostderr=false \\</span><br><span class="line">--v=2 \\</span><br><span class="line">--log-dir=/opt/kubernetes/logs \\</span><br><span class="line">--leader-elect=true \\</span><br><span class="line">--master=127.0.0.1:8080 \\</span><br><span class="line">--bind-address=127.0.0.1 \\</span><br><span class="line">--allocate-node-cidrs=true \\</span><br><span class="line">--cluster-cidr=10.244.0.0/16 \\</span><br><span class="line">--service-cluster-ip-range=10.0.0.0/24 \\</span><br><span class="line">--cluster-signing-cert-file=/opt/kubernetes/ssl/ca.pem \\</span><br><span class="line">--cluster-signing-key-file=/opt/kubernetes/ssl/ca-key.pem  \\</span><br><span class="line">--root-ca-file=/opt/kubernetes/ssl/ca.pem \\</span><br><span class="line">--service-account-private-key-file=/opt/kubernetes/ssl/ca-key.pem \\</span><br><span class="line">--experimental-cluster-signing-duration=87600h0m0s&quot;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta"># </span><span class="language-bash">说明</span></span><br><span class="line">–master：通过本地非安全本地端口 8080 连接 apiserver。</span><br><span class="line"></span><br><span class="line">–leader-elect：当该组件启动多个时，自动选举（HA）</span><br><span class="line"></span><br><span class="line">–cluster-signing-cert-file/–cluster-signing-key-file：自动为 kubelet 颁发证书的 CA，与 apiserver 保持一致</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">systemd管理controller-manager</span></span><br><span class="line">cat &gt; /usr/lib/systemd/system/kube-controller-manager.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes Controller Manager</span><br><span class="line">Documentation=https://github.com/kubernetes/kubernetes</span><br><span class="line">[Service]</span><br><span class="line">EnvironmentFile=/opt/kubernetes/cfg/kube-controller-manager.conf</span><br><span class="line">ExecStart=/opt/kubernetes/bin/kube-controller-manager \$KUBE_CONTROLLER_MANAGER_OPTS</span><br><span class="line">Restart=on-failure</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">启动并开机自启</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start kube-controller-manager</span><br><span class="line">systemctl enable kube-controller-manager</span><br><span class="line">systemctl status kube-controller-manager</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h6 id="6-部署kuber-scheduler"><a href="#6-部署kuber-scheduler" class="headerlink" title="6.部署kuber-scheduler"></a>6.部署kuber-scheduler</h6><blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">1. 创建kuber-scheduler配置文件</span></span><br><span class="line">cat &gt; /opt/kubernetes/cfg/kube-scheduler.conf &lt;&lt; EOF</span><br><span class="line">KUBE_SCHEDULER_OPTS=&quot;--logtostderr=false \</span><br><span class="line">--v=2 \</span><br><span class="line">--log-dir=/opt/kubernetes/logs \</span><br><span class="line">--leader-elect \</span><br><span class="line">--master=127.0.0.1:8080 \</span><br><span class="line">--bind-address=127.0.0.1&quot;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">–master：通过本地非安全本地端口 8080 连接 apiserver。</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">–leader-elect：当该组件启动多个时，自动选举（HA）</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">2. systemd管理kuber-scheduler</span></span><br><span class="line">cat &gt; /usr/lib/systemd/system/kube-scheduler.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes Scheduler</span><br><span class="line">Documentation=https://github.com/kubernetes/kubernetes</span><br><span class="line">[Service]</span><br><span class="line">EnvironmentFile=/opt/kubernetes/cfg/kube-scheduler.conf</span><br><span class="line">ExecStart=/opt/kubernetes/bin/kube-scheduler \$KUBE_SCHEDULER_OPTS</span><br><span class="line">Restart=on-failure</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br><span class="line"><span class="meta"># </span><span class="language-bash">启动并设置开机自启</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start kube-scheduler</span><br><span class="line">systemctl enable kube-scheduler</span><br><span class="line">systemctl status kube-scheduler</span><br></pre></td></tr></table></figure>


</blockquote>
<h6 id="7-查看集群状态"><a href="#7-查看集群状态" class="headerlink" title="7. 查看集群状态"></a>7. <strong>查看集群状态</strong></h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">kubectl get cs</span></span><br><span class="line">NAME                 STATUS    MESSAGE             ERROR</span><br><span class="line">scheduler            Healthy   ok                  </span><br><span class="line">controller-manager   Healthy   ok                  </span><br><span class="line">etcd-0               Healthy   &#123;&quot;health&quot;:&quot;true&quot;&#125;   </span><br><span class="line">etcd-2               Healthy   &#123;&quot;health&quot;:&quot;true&quot;&#125;   </span><br><span class="line">etcd-1               Healthy   &#123;&quot;health&quot;:&quot;true&quot;&#125;   </span><br></pre></td></tr></table></figure>

<h5 id="部署Worker-Node"><a href="#部署Worker-Node" class="headerlink" title="部署Worker Node"></a>部署Worker Node</h5><p>下面还是在Master Node上操作，即同时作为Worker Node</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">1. 所有的worker node创建工作目录</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">mkdir</span> -p /opt/kubernetes/&#123;bin,cfg,ssl,logs&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">2.从master节点拷贝</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">cd</span> kubernetes/server/bin</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">cp</span> kubelet kube-proxy /opt/kubernetes/bin</span></span><br></pre></td></tr></table></figure>

<h6 id="1-部署kubelet"><a href="#1-部署kubelet" class="headerlink" title="1.部署kubelet"></a>1.部署kubelet</h6><ol>
<li>创建配置文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /opt/kubernetes/cfg/kubelet.conf &lt;&lt; EOF</span><br><span class="line">KUBELET_OPTS=&quot;--logtostderr=false \\</span><br><span class="line">--v=2 \\</span><br><span class="line">--log-dir=/opt/kubernetes/logs \\</span><br><span class="line">--hostname-override=K8s-Master \\</span><br><span class="line">--network-plugin=cni \\</span><br><span class="line">--kubeconfig=/opt/kubernetes/cfg/kubelet.kubeconfig \\</span><br><span class="line">--bootstrap-kubeconfig=/opt/kubernetes/cfg/bootstrap.kubeconfig \\</span><br><span class="line">--config=/opt/kubernetes/cfg/kubelet-config.yml \\</span><br><span class="line">--cert-dir=/opt/kubernetes/ssl \\</span><br><span class="line">--pod-infra-container-image=lizhenliang/pause-amd64:3.0&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>–hostname-override：显示名称，集群中唯一<br>–network-plugin：启用CNI<br>–kubeconfig：空路径，会自动生成，后面用于连接apiserver<br>–bootstrap-kubeconfig：首次启动向apiserver申请证书<br>–config：配置参数文件<br>–cert-dir：kubelet证书生成目录<br>–pod-infra-container-image：管理Pod网络容器的镜像</p>
<ol start="2">
<li>配置参数文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /opt/kubernetes/cfg/kubelet-config.yml &lt;&lt; EOF</span><br><span class="line">kind: KubeletConfiguration</span><br><span class="line">apiVersion: kubelet.config.k8s.io/v1beta1</span><br><span class="line">address: 0.0.0.0</span><br><span class="line">port: 10250</span><br><span class="line">readOnlyPort: 10255</span><br><span class="line">cgroupDriver: cgroupfs</span><br><span class="line">clusterDNS:</span><br><span class="line">- 10.0.0.2</span><br><span class="line">clusterDomain: cluster.local </span><br><span class="line">failSwapOn: false</span><br><span class="line">authentication:</span><br><span class="line">  anonymous:</span><br><span class="line">    enabled: false</span><br><span class="line">  webhook:</span><br><span class="line">    cacheTTL: 2m0s</span><br><span class="line">    enabled: true</span><br><span class="line">  x509:</span><br><span class="line">    clientCAFile: /opt/kubernetes/ssl/ca.pem </span><br><span class="line">authorization:</span><br><span class="line">  mode: Webhook</span><br><span class="line">  webhook:</span><br><span class="line">    cacheAuthorizedTTL: 5m0s</span><br><span class="line">    cacheUnauthorizedTTL: 30s</span><br><span class="line">evictionHard:</span><br><span class="line">  imagefs.available: 15%</span><br><span class="line">  memory.available: 100Mi</span><br><span class="line">  nodefs.available: 10%</span><br><span class="line">  nodefs.inodesFree: 5%</span><br><span class="line">maxOpenFiles: 1000000</span><br><span class="line">maxPods: 110</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>生成bootstrap.kubeconfig文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KUBE_APISERVER=&quot;https://192.168.0.110:6443&quot; # apiserver IP:PORT</span><br><span class="line">TOKEN=&quot;220ee81becf461cfc2d2b0e983d4347c&quot; # 与token.csv里保持一致</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">生成kubelet bootstrap kubeconfig配置文件</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">kubectl config set-cluster kubernetes \</span></span><br><span class="line"><span class="language-bash">  --certificate-authority=/opt/kubernetes/ssl/ca.pem \</span></span><br><span class="line"><span class="language-bash">  --embed-certs=<span class="literal">true</span> \</span></span><br><span class="line"><span class="language-bash">  --server=<span class="variable">$&#123;KUBE_APISERVER&#125;</span> \</span></span><br><span class="line"><span class="language-bash">  --kubeconfig=bootstrap.kubeconfig</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">kubectl config set-credentials <span class="string">&quot;kubelet-bootstrap&quot;</span> \</span></span><br><span class="line"><span class="language-bash">  --token=<span class="variable">$&#123;TOKEN&#125;</span> \</span></span><br><span class="line"><span class="language-bash">  --kubeconfig=bootstrap.kubeconfig</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">kubectl config set-context default \</span></span><br><span class="line"><span class="language-bash">  --cluster=kubernetes \</span></span><br><span class="line"><span class="language-bash">  --user=<span class="string">&quot;kubelet-bootstrap&quot;</span> \</span></span><br><span class="line"><span class="language-bash">  --kubeconfig=bootstrap.kubeconfig</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">kubectl config use-context default --kubeconfig=bootstrap.kubeconfig</span></span><br><span class="line"></span><br><span class="line">mv bootstrap.kubeconfig /opt/kubernetes/cfg</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>systemd管理kubelet</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /usr/lib/systemd/system/kubelet.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes Kubelet</span><br><span class="line">After=docker.service</span><br><span class="line">[Service]</span><br><span class="line">EnvironmentFile=/opt/kubernetes/cfg/kubelet.conf</span><br><span class="line">ExecStart=/opt/kubernetes/bin/kubelet \$KUBELET_OPTS</span><br><span class="line">Restart=on-failure</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start kubelet</span><br><span class="line">systemctl enable kubelet</span><br></pre></td></tr></table></figure>

<p><font color=red>kubelet 服务启动不起来</font></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -xefu kubelet  # 查看日志</span><br></pre></td></tr></table></figure>

<p>通常情况，再使用二进制搭建集群的时候，我们需要卸载之前我们安装的历史版本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum list installed | grep kube</span><br><span class="line"><span class="meta"># </span><span class="language-bash">把历史版本卸载干净之后再进行配置</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>批准kubelet证书请求</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kubectl get csr  # 查看还未认证的节点，如果节点启动失败，则不会显示任何信息</span><br><span class="line">NAME                                                   AGE     SIGNERNAME                                    REQUESTOR           CONDITION</span><br><span class="line">node-csr-m-RuMCihhrALjCJWwNQBKIP2JprawKzyZ6VWQPrOzCQ   6m37s   kubernetes.io/kube-apiserver-client-kubelet   kubelet-bootstrap   Pending</span><br><span class="line"><span class="meta"># </span><span class="language-bash">批准申请</span></span><br><span class="line">kubectl certificate approve node-csr-m-RuMCihhrALjCJWwNQBKIP2JprawKzyZ6VWQPrOzCQ</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看节点</span></span><br><span class="line">[root@K8s-Master bin]# kubectl get nodes</span><br><span class="line">NAME         STATUS     ROLES    AGE   VERSION</span><br><span class="line">k8s-master   NotReady   &lt;none&gt;   3s    v1.18.3</span><br><span class="line"><span class="meta"># </span><span class="language-bash">由于网络插件还没有部署，节点会没有准备就绪 NotReady</span></span><br></pre></td></tr></table></figure>

<h6 id="2-部署kube-proxy"><a href="#2-部署kube-proxy" class="headerlink" title="2. 部署kube-proxy"></a>2. 部署kube-proxy</h6><ol>
<li>创建配置文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /opt/kubernetes/cfg/kube-proxy.conf &lt;&lt; EOF</span><br><span class="line">KUBE_PROXY_OPTS=&quot;--logtostderr=false \\</span><br><span class="line">--v=2 \\</span><br><span class="line">--log-dir=/opt/kubernetes/logs \\</span><br><span class="line">--config=/opt/kubernetes/cfg/kube-proxy-config.yml&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建参数文件、</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /opt/kubernetes/cfg/kube-proxy-config.yml &lt;&lt; EOF</span><br><span class="line">kind: KubeProxyConfiguration</span><br><span class="line">apiVersion: kubeproxy.config.k8s.io/v1alpha1</span><br><span class="line">bindAddress: 0.0.0.0</span><br><span class="line">metricsBindAddress: 0.0.0.0:10249</span><br><span class="line">clientConnection:</span><br><span class="line">  kubeconfig: /opt/kubernetes/cfg/kube-proxy.kubeconfig</span><br><span class="line">hostnameOverride: K8s-Master</span><br><span class="line">clusterCIDR: 10.0.0.0/24</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>生成kube-proxy.kubeconfig</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">Master生成，然后再上传到Node节点上</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">切换工作目录</span></span><br><span class="line">cd TLS/k8s</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">创建证书请求文件</span></span><br><span class="line">cat &gt; kube-proxy-csr.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;CN&quot;: &quot;system:kube-proxy&quot;,</span><br><span class="line">  &quot;hosts&quot;: [],</span><br><span class="line">  &quot;key&quot;: &#123;</span><br><span class="line">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="line">    &quot;size&quot;: 2048</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;names&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;C&quot;: &quot;CN&quot;,</span><br><span class="line">      &quot;L&quot;: &quot;BeiJing&quot;,</span><br><span class="line">      &quot;ST&quot;: &quot;BeiJing&quot;,</span><br><span class="line">      &quot;O&quot;: &quot;k8s&quot;,</span><br><span class="line">      &quot;OU&quot;: &quot;System&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">生成证书</span></span><br><span class="line">cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kube-proxy-csr.json | cfssljson -bare kube-proxy</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>生成kube-proxy.kubeconfig文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">KUBE_APISERVER=<span class="string">&quot;https://192.168.0.110:6443&quot;</span></span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">kubectl config set-cluster kubernetes \</span></span><br><span class="line"><span class="language-bash">  --certificate-authority=/opt/kubernetes/ssl/ca.pem \</span></span><br><span class="line"><span class="language-bash">  --embed-certs=<span class="literal">true</span> \</span></span><br><span class="line"><span class="language-bash">  --server=<span class="variable">$&#123;KUBE_APISERVER&#125;</span> \</span></span><br><span class="line"><span class="language-bash">  --kubeconfig=kube-proxy.kubeconfig</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">kubectl config set-credentials kube-proxy \</span></span><br><span class="line"><span class="language-bash">  --client-certificate=./kube-proxy.pem \</span></span><br><span class="line"><span class="language-bash">  --client-key=./kube-proxy-key.pem \</span></span><br><span class="line"><span class="language-bash">  --embed-certs=<span class="literal">true</span> \</span></span><br><span class="line"><span class="language-bash">  --kubeconfig=kube-proxy.kubeconfig</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">kubectl config set-context default \</span></span><br><span class="line"><span class="language-bash">  --cluster=kubernetes \</span></span><br><span class="line"><span class="language-bash">  --user=kube-proxy \</span></span><br><span class="line"><span class="language-bash">  --kubeconfig=kube-proxy.kubeconfig</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">kubectl config use-context default --kubeconfig=kube-proxy.kubeconfig</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">cp</span> kube-proxy.kubeconfig /opt/kubernetes/cfg/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>systemd管理kube-proxy</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /usr/lib/systemd/system/kube-proxy.service &lt;&lt; EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=Kubernetes Proxy</span><br><span class="line">After=network.target</span><br><span class="line">[Service]</span><br><span class="line">EnvironmentFile=/opt/kubernetes/cfg/kube-proxy.conf</span><br><span class="line">ExecStart=/opt/kubernetes/bin/kube-proxy \$KUBE_PROXY_OPTS</span><br><span class="line">Restart=on-failure</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start kube-proxy</span><br><span class="line">systemctl enable kube-proxy</span><br><span class="line">systemctl status kube-proxy</span><br></pre></td></tr></table></figure>

<h6 id="3-部署CNI网络"><a href="#3-部署CNI网络" class="headerlink" title="3. 部署CNI网络"></a>3. 部署CNI网络</h6><p>下载地址：<br><a target="_blank" rel="noopener" href="https://github.com/containernetworking/plugins/releases/download/v0.8.6/cni-plugins-linux-amd64-v0.8.6.tgz">https://github.com/containernetworking/plugins/releases/download/v0.8.6/cni-plugins-linux-amd64-v0.8.6.tgz</a></p>
<ol>
<li>解压二进制文件并移动到默认工作目录</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">mkdir</span> -p /opt/cni/bin</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">tar -zxvf cni-plugins-linux-amd64-v0.8.6.tgz -C /opt/cni/bin/</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>部署CNI网络</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/cni</span><br><span class="line">wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">更改kube-flannel.yml文件的镜像源为 lizhenliang/flannel:v0.12.0-amd64</span></span><br><span class="line">- name: install-cni</span><br><span class="line">        # image: quay.io/coreos/flannel:v0.14.0</span><br><span class="line">        image: lizhenliang/flannel:v0.12.0-amd64</span><br><span class="line">containers:</span><br><span class="line">      - name: kube-flannel</span><br><span class="line">        # image: quay.io/coreos/flannel:v0.14.0</span><br><span class="line">        image: lizhenliang/flannel:v0.12.0-amd64</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>应用CNI网络</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f kube-flannel.yml</span><br><span class="line"></span><br><span class="line">[root@K8s-Master cni]# kubectl get pods -n kube-system</span><br><span class="line">NAME                    READY   STATUS     RESTARTS   AGE</span><br><span class="line">kube-flannel-ds-pctmp   0/1     Init:0/1   0          27s</span><br><span class="line"><span class="meta"># </span><span class="language-bash">稍稍等那么一小会，待网络启动后，node的状态会变为ready</span></span><br><span class="line">[root@K8s-Master cni]# kubectl get node</span><br><span class="line">NAME         STATUS   ROLES    AGE   VERSION</span><br><span class="line">k8s-master   Ready    &lt;none&gt;   45m   v1.18.3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>授权apiserver访问kubelet</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; apiserver-to-kubelet-rbac.yaml&lt;&lt; EOF </span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRole</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    rbac.authorization.kubernetes.io/autoupdate: &quot;true&quot;</span><br><span class="line">  labels:</span><br><span class="line">    kubernetes.io/bootstrapping: rbac-defaults</span><br><span class="line">  name: system:kube-apiserver-to-kubelet</span><br><span class="line">rules:</span><br><span class="line">  - apiGroups:</span><br><span class="line">      - &quot;&quot;</span><br><span class="line">    resources:</span><br><span class="line">      - nodes/proxy</span><br><span class="line">      - nodes/stats</span><br><span class="line">      - nodes/log</span><br><span class="line">      - nodes/spec</span><br><span class="line">      - nodes/metrics</span><br><span class="line">      - pods/log</span><br><span class="line">    verbs:</span><br><span class="line">      - &quot;*&quot;</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: system:kube-apiserver</span><br><span class="line">  namespace: &quot;&quot;</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: system:kube-apiserver-to-kubelet</span><br><span class="line">subjects:</span><br><span class="line">  - apiGroup: rbac.authorization.k8s.io</span><br><span class="line">    kind: User</span><br><span class="line">    name: kubernetes</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">kubectl apply -f apiserver-to-kubelet-rbac.yaml</span><br></pre></td></tr></table></figure>

<p><font color=green>以上操作都是在Master节点操作的，即Master机器即使Master有时Worker Node</font></p>
<p>接下来介绍如何新增Worker Node</p>
<h6 id="4-新增加Worker-Node"><a href="#4-新增加Worker-Node" class="headerlink" title="4. 新增加Worker Node"></a>4. 新增加Worker Node</h6><ol>
<li>拷贝已部署好的Node相关文件到新节点</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">scp -r /opt/kubernetes root@192.168.0.111:/opt</span><br><span class="line">scp -r /opt/kubernetes root@192.168.0.112:/opt</span><br><span class="line"></span><br><span class="line">scp -r /usr/lib/systemd/system/&#123;kubelet,kube-proxy&#125;.service root@192.168.0.111:/usr/lib/systemd/system</span><br><span class="line">scp -r /usr/lib/systemd/system/&#123;kubelet,kube-proxy&#125;.service root@192.168.0.112:/usr/lib/systemd/system</span><br><span class="line"></span><br><span class="line"> scp -r /opt/cni/ root@192.168.0.111:/opt/</span><br><span class="line"> scp -r /opt/cni/ root@192.168.0.112:/opt/</span><br><span class="line"></span><br><span class="line">scp /opt/kubernetes/ssl/ca.pem root@192.168.0.111:/opt/kubernetes/ssl/</span><br><span class="line"></span><br><span class="line">scp /opt/kubernetes/ssl/ca.pem root@192.168.0.112:/opt/kubernetes/ssl/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>删除kubelet证书和kubeconfig文件</li>
</ol>
<p>这几个文件是证书申请审批后自动生成的，每个Node不同，必须删除重新生成</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">Node1 和 Node2 都需要删除</span></span><br><span class="line">rm /opt/kubernetes/cfg/kubelet.kubeconfig</span><br><span class="line">rm -rf /opt/kubernetes/ssl/kubelet*</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>修改配置文件中的主机名</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vim /opt/kubernetes/cfg/kubelet.conf </span><br><span class="line">--hostname-override=K8s-Node1</span><br><span class="line"></span><br><span class="line">vim /opt/kubernetes/cfg/kube-proxy-config.yml </span><br><span class="line">hostnameOverride: K8s-Node1</span><br><span class="line"></span><br><span class="line">vim /opt/kubernetes/cfg/kubelet.conf </span><br><span class="line">--hostname-override=K8s-Node2</span><br><span class="line"></span><br><span class="line">vim /opt/kubernetes/cfg/kube-proxy-config.yml </span><br><span class="line">hostnameOverride: K8s-Node2</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">重启服务，并设置开机启动</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start kubelet</span><br><span class="line">systemctl enable kubelet</span><br><span class="line">systemctl start kube-proxy</span><br><span class="line">systemctl enable kube-proxy</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在Master上批准新Node kubelet证书申请</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ca.pem                                                                                                      100% 1359   241.8KB/s   00:00    </span><br><span class="line">[root@K8s-Master cni]# kubectl get csr</span><br><span class="line">NAME                                                   AGE    SIGNERNAME                                    REQUESTOR           CONDITION</span><br><span class="line">node-csr-0WbEBs72A03Y-WhgrPvbd91b9T8vw8hwmaQ_t4FiIJ4   96s    kubernetes.io/kube-apiserver-client-kubelet   kubelet-bootstrap   Pending</span><br><span class="line">node-csr-Fo25Zn3aZshIrmT2WKAtfHeELEAcdq18HR_QpNlexyY   2m6s   kubernetes.io/kube-apiserver-client-kubelet   kubelet-bootstrap   Pending</span><br><span class="line">node-csr-m-RuMCihhrALjCJWwNQBKIP2JprawKzyZ6VWQPrOzCQ   80m    kubernetes.io/kube-apiserver-client-kubelet   kubelet-bootstrap   Approved,Issued</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">kubectl certificate approve node-csr-0WbEBs72A03Y-WhgrPvbd91b9T8vw8hwmaQ_t4FiIJ4</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">kubectl certificate approve node-csr-Fo25Zn3aZshIrmT2WKAtfHeELEAcdq18HR_QpNlexyY</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">kubectl get node</span> </span><br><span class="line">[root@K8s-Master cni]# kubectl get node</span><br><span class="line">NAME         STATUS     ROLES    AGE   VERSION</span><br><span class="line">k8s-master   Ready      &lt;none&gt;   75m   v1.18.3</span><br><span class="line">k8s-node1    NotReady   &lt;none&gt;   40s   v1.18.3</span><br><span class="line">k8s-node2    NotReady   &lt;none&gt;   46s   v1.18.3</span><br><span class="line">[root@K8s-Master cni]# kubectl get node</span><br><span class="line">NAME         STATUS   ROLES    AGE    VERSION</span><br><span class="line">k8s-master   Ready    &lt;none&gt;   76m    v1.18.3</span><br><span class="line">k8s-node1    Ready    &lt;none&gt;   111s   v1.18.3</span><br><span class="line">k8s-node2    Ready    &lt;none&gt;   117s   v1.18.3</span><br><span class="line"><span class="meta"># </span><span class="language-bash">稍稍等一会，节点的状态就会从NotReady变为Ready</span></span><br></pre></td></tr></table></figure>



<h5 id="测试Kubernetes集群"><a href="#测试Kubernetes集群" class="headerlink" title="测试Kubernetes集群"></a>测试Kubernetes集群</h5><p>在kubernetes集群中创建一个pod，验证是否正常运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">kubectl create deployment nginx --image=nginx</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">kubectl expose deployment nginx --port=80 --<span class="built_in">type</span>=NodePort</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">kubectl get pod,svc</span></span><br><span class="line">[root@K8s-Master cni]# kubectl get pod,svc</span><br><span class="line">NAME                        READY   STATUS              RESTARTS   AGE</span><br><span class="line">pod/nginx-f89759699-rwjd9   0/1     ContainerCreating   0          18s</span><br><span class="line"></span><br><span class="line">NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">service/kubernetes   ClusterIP   10.0.0.1     &lt;none&gt;        443/TCP        15h</span><br><span class="line">service/nginx        NodePort    10.0.0.182   &lt;none&gt;        80:30077/TCP   9s</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试：<a target="_blank" rel="noopener" href="http://192.168.0.110:30077/">http://192.168.0.110:30077</a></p>
<h2 id="第三部分：K8s核心概念"><a href="#第三部分：K8s核心概念" class="headerlink" title="第三部分：K8s核心概念"></a>第三部分：K8s核心概念</h2><ol>
<li>Pod</li>
<li>Controller</li>
<li>Service</li>
<li>Ingress</li>
<li>RABC</li>
<li>Helm（类似于yun）</li>
<li>持久化存储</li>
</ol>
<h3 id="kubernetes集群命令行工具kubectl"><a href="#kubernetes集群命令行工具kubectl" class="headerlink" title="kubernetes集群命令行工具kubectl"></a>kubernetes集群命令行工具kubectl</h3><h4 id="1-kubectl概述"><a href="#1-kubectl概述" class="headerlink" title="1. kubectl概述"></a>1. kubectl概述</h4><p>kubectl是Kubernetes集群的命令行工具，通过kubectl能够对集群本身进行管理，并能够在集群上进行容器化应用的安装部署。</p>
<h4 id="2-kubectl命令的语法"><a href="#2-kubectl命令的语法" class="headerlink" title="2. kubectl命令的语法"></a>2. kubectl命令的语法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">kubectl [<span class="built_in">command</span>] [TYPE] [NAME] [flags]</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>command:指定要对资源执行的操作，例如：create、get、describe和delete</p>
</li>
<li><p>TYPE：指定资源类型，资源类型是大小写敏感的，开发者能够以单数、复数和缩略的形式。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">kubectl get pod pod1</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">kubectl get pods pod1</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">kubectl get po pod1</span></span><br></pre></td></tr></table></figure></li>
<li><p>NAME:指定资源的名称，名称也大小写敏感。如果省略名称，则会显示所有的资源，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">kubectl get pods</span></span><br></pre></td></tr></table></figure></li>
<li><p>flags:指定可选的参数。例如：可用-s或者-server参数指定Kubernetes API server 的地址和端口。</p>
</li>
</ol>
<h4 id="3-kubectl-help获取更多信息"><a href="#3-kubectl-help获取更多信息" class="headerlink" title="3. kubectl help获取更多信息"></a>3. kubectl help获取更多信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">kubectl --<span class="built_in">help</span></span></span><br><span class="line">kubectl controls the Kubernetes cluster manager.</span><br><span class="line"></span><br><span class="line"> Find more information at: https://kubernetes.io/docs/reference/kubectl/overview/</span><br><span class="line"></span><br><span class="line">Basic Commands (Beginner):</span><br><span class="line">  create        Create a resource from a file or from stdin.</span><br><span class="line">  expose        Take a replication controller, service, deployment or pod and expose it as a new Kubernetes Service</span><br><span class="line">  run           Run a particular image on the cluster</span><br><span class="line">  set           Set specific features on objects</span><br><span class="line"></span><br><span class="line">Basic Commands (Intermediate):</span><br><span class="line">  explain       Documentation of resources</span><br><span class="line">  get           Display one or many resources</span><br><span class="line">  edit          Edit a resource on the server</span><br><span class="line">  delete        Delete resources by filenames, stdin, resources and names, or by resources and label selector</span><br><span class="line"></span><br><span class="line">Deploy Commands:</span><br><span class="line">  rollout       Manage the rollout of a resource</span><br><span class="line">  scale         Set a new size for a Deployment, ReplicaSet or Replication Controller</span><br><span class="line">  autoscale     Auto-scale a Deployment, ReplicaSet, or ReplicationController</span><br><span class="line"></span><br><span class="line">Cluster Management Commands:</span><br><span class="line">  certificate   Modify certificate resources.</span><br><span class="line">  cluster-info  Display cluster info</span><br><span class="line">  top           Display Resource (CPU/Memory/Storage) usage.</span><br><span class="line">  cordon        Mark node as unschedulable</span><br><span class="line">  uncordon      Mark node as schedulable</span><br><span class="line">  drain         Drain node in preparation for maintenance</span><br><span class="line">  taint         Update the taints on one or more nodes</span><br><span class="line"></span><br><span class="line">Troubleshooting and Debugging Commands:</span><br><span class="line">  describe      Show details of a specific resource or group of resources</span><br><span class="line">  logs          Print the logs for a container in a pod</span><br><span class="line">  attach        Attach to a running container</span><br><span class="line">  exec          Execute a command in a container</span><br><span class="line">  port-forward  Forward one or more local ports to a pod</span><br><span class="line">  proxy         Run a proxy to the Kubernetes API server</span><br><span class="line">  cp            Copy files and directories to and from containers.</span><br><span class="line">  auth          Inspect authorization</span><br><span class="line"></span><br><span class="line">Advanced Commands:</span><br><span class="line">  diff          Diff live version against would-be applied version</span><br><span class="line">  apply         Apply a configuration to a resource by filename or stdin</span><br><span class="line">  patch         Update field(s) of a resource using strategic merge patch</span><br><span class="line">  replace       Replace a resource by filename or stdin</span><br><span class="line">  wait          Experimental: Wait for a specific condition on one or many resources.</span><br><span class="line">  convert       Convert config files between different API versions</span><br><span class="line">  kustomize     Build a kustomization target from a directory or a remote url.</span><br><span class="line"></span><br><span class="line">Settings Commands:</span><br><span class="line">  label         Update the labels on a resource</span><br><span class="line">  annotate      Update the annotations on a resource</span><br><span class="line">  completion    Output shell completion code for the specified shell (bash or zsh)</span><br><span class="line"></span><br><span class="line">Other Commands:</span><br><span class="line">  alpha         Commands for features in alpha</span><br><span class="line">  api-resources Print the supported API resources on the server</span><br><span class="line">  api-versions  Print the supported API versions on the server, in the form of &quot;group/version&quot;</span><br><span class="line">  config        Modify kubeconfig files</span><br><span class="line">  plugin        Provides utilities for interacting with plugins.</span><br><span class="line">  version       Print the client and server version information</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  kubectl [flags] [options]</span><br><span class="line"></span><br><span class="line">Use &quot;kubectl &lt;command&gt; --help&quot; for more information about a given command.</span><br><span class="line">Use &quot;kubectl options&quot; for a list of global command-line options (applies to all commands).</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="4-kubectl-子命令使用分类"><a href="#4-kubectl-子命令使用分类" class="headerlink" title="4. kubectl 子命令使用分类"></a>4. kubectl 子命令使用分类</h4><table>
<thead>
<tr>
<th>分类</th>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>基础命令</strong></td>
<td>create</td>
<td>通过文件名或标准输入创建资源</td>
</tr>
<tr>
<td></td>
<td>expose</td>
<td>将一个资源公开为一个新的Service</td>
</tr>
<tr>
<td></td>
<td>run</td>
<td>在集群中运行一个特定的功能</td>
</tr>
<tr>
<td></td>
<td>set</td>
<td>在对象上设置特定的功能</td>
</tr>
<tr>
<td></td>
<td>get</td>
<td>显示一个或多个资源</td>
</tr>
<tr>
<td></td>
<td>explain</td>
<td>文档参考资料</td>
</tr>
<tr>
<td></td>
<td>edit</td>
<td>使用默认的编辑器编辑一个资源</td>
</tr>
<tr>
<td></td>
<td>delete</td>
<td>通过文件名、标准输入、资源名称或标签选择器来删除资源</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>部署命令</strong></td>
<td>rollout</td>
<td>管理资源的发布</td>
</tr>
<tr>
<td></td>
<td>rolling-update</td>
<td>对给定的复制控制器滚动更新</td>
</tr>
<tr>
<td></td>
<td>scale</td>
<td>扩容或缩容Pod数量，Deployment、ReplicaSet、RC或Job</td>
</tr>
<tr>
<td></td>
<td>autoscale</td>
<td>创建一个自动选择扩容或缩容并设置Pod数量</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>集群管理命令</strong></td>
<td>certificate</td>
<td>修改证书资源</td>
</tr>
<tr>
<td></td>
<td>cluster-info</td>
<td>显示集群信息</td>
</tr>
<tr>
<td></td>
<td>top</td>
<td>显示资源（CPU/Memory/Storage）使用。需要Heapster运行</td>
</tr>
<tr>
<td></td>
<td>cordon</td>
<td>标记节点不可调度</td>
</tr>
<tr>
<td></td>
<td>uncordon</td>
<td>标记节点可调度</td>
</tr>
<tr>
<td></td>
<td>drain</td>
<td>驱逐节点上的应用，准备下线维护</td>
</tr>
<tr>
<td></td>
<td>taint</td>
<td>修改节点taint标记</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>故障诊断和调试命令</strong></td>
<td><font color=red>describe</font></td>
<td>显示特定资源或资源组的详细信息</td>
</tr>
<tr>
<td></td>
<td><font color=red>logs</font></td>
<td>在一个Pod中打印一个容器日志。如果Pod只有一个容器，容器名称是可选的</td>
</tr>
<tr>
<td></td>
<td>attach</td>
<td>附加到一个运行的容器</td>
</tr>
<tr>
<td></td>
<td><font color=red>exec</font></td>
<td>执行命令到容器</td>
</tr>
<tr>
<td></td>
<td>port-forward</td>
<td>转发一个或多个本地端口到一个pod</td>
</tr>
<tr>
<td></td>
<td>proxy</td>
<td>运行一个proxy到Kubernetes API Server</td>
</tr>
<tr>
<td></td>
<td>cp</td>
<td>拷贝文件或目录到容器中</td>
</tr>
<tr>
<td></td>
<td>auth</td>
<td>检查授权</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>其他命令</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>高级命令</td>
<td>apply</td>
<td>通过文件名或标准输入对资源应用配置</td>
</tr>
<tr>
<td></td>
<td>patch</td>
<td>使用补丁修改、更新资源的字段</td>
</tr>
<tr>
<td></td>
<td>replace</td>
<td>通过文件名或标准输入替换一个资源</td>
</tr>
<tr>
<td></td>
<td>convert</td>
<td>不同的API版本之间转换配置文件</td>
</tr>
<tr>
<td>设置命令</td>
<td>label</td>
<td>更新资源上的标签</td>
</tr>
<tr>
<td></td>
<td>annotate</td>
<td>更新资源上的注释</td>
</tr>
<tr>
<td></td>
<td>completion</td>
<td>用于实现kubectl工具自动补全</td>
</tr>
<tr>
<td>其他命令</td>
<td>api-versions</td>
<td>打印受支持的API版本</td>
</tr>
<tr>
<td></td>
<td>config</td>
<td>修改kubeconfig文件（用于访问API， 比如配置认证信息）</td>
</tr>
<tr>
<td></td>
<td>help</td>
<td>所有命令帮助</td>
</tr>
<tr>
<td></td>
<td>plugin</td>
<td>运行一个命令行插件</td>
</tr>
<tr>
<td></td>
<td>version</td>
<td>打印客户端和服务版本信息</td>
</tr>
</tbody></table>
<h3 id="YAML文件说明"><a href="#YAML文件说明" class="headerlink" title="YAML文件说明"></a>YAML文件说明</h3><h4 id="1-YAML文件概述"><a href="#1-YAML文件概述" class="headerlink" title="1. YAML文件概述"></a>1. YAML文件概述</h4><p>k8s集群中对资源管理和资源对象编排部署都可以通过声明样式（YAML）文件来解决，也就是可以把需要对资源对象操作编辑到YAML格式文件中，我们把这种文件叫做资源清单文件，通过kubectl命令直接使用资源清单文件就可以实现对大量的资源对象进行编排部署了。</p>
<h4 id="2-YAML语法格式"><a href="#2-YAML语法格式" class="headerlink" title="2. YAML语法格式"></a>2. YAML语法格式</h4><ul>
<li>使用空格作为缩进（不使用tap）</li>
<li>缩进的空格数目不重要，只要相同层级的元素左侧对其即可</li>
<li>低版本缩进时不允许使用tap键，只允许使用空格</li>
<li>使用#表示注释，从这个字符一直到行尾，都会被解释器忽略</li>
</ul>
<h4 id="3-yaml文件组成部分"><a href="#3-yaml文件组成部分" class="headerlink" title="3. yaml文件组成部分"></a>3. yaml文件组成部分</h4><ol>
<li>控制器定义</li>
<li>被控制对象</li>
</ol>
<h4 id="4-资源清单描述方法"><a href="#4-资源清单描述方法" class="headerlink" title="4. 资源清单描述方法"></a>4. 资源清单描述方法</h4><ol>
<li>在k8s中，一般使用YAML格式的文件来创建符合我们预期期望的pod，这样的YAML文件成为资源清单</li>
<li>常用字段</li>
</ol>
<table>
<thead>
<tr>
<th>字段名</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>apiVersion</td>
<td>API版本</td>
</tr>
<tr>
<td>kind</td>
<td>资源类型</td>
</tr>
<tr>
<td>metadata</td>
<td>资源元数据</td>
</tr>
<tr>
<td>spec</td>
<td>资源规格</td>
</tr>
<tr>
<td>replicas</td>
<td>副本数量</td>
</tr>
<tr>
<td>selector·</td>
<td>标签选择器</td>
</tr>
<tr>
<td>template</td>
<td>Pod模板</td>
</tr>
<tr>
<td>metadata</td>
<td>Pod元数据</td>
</tr>
<tr>
<td>spec</td>
<td>Pod规格</td>
</tr>
<tr>
<td>containers</td>
<td>容器配置</td>
</tr>
</tbody></table>
<p><font color=red>必须存在的属性</font></p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>字段类型</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>version</td>
<td>String</td>
<td>k8s API的版本，目前基本是v1，可以用kubectl api-version命令查询</td>
<td></td>
</tr>
<tr>
<td>kind</td>
<td>String</td>
<td>这里指的是yaml文件定义的资源类型和角色，比如：Pod</td>
<td></td>
</tr>
<tr>
<td>metadata</td>
<td>Object</td>
<td>元数据对象，固定值写 metadata</td>
<td></td>
</tr>
<tr>
<td>metadata.name</td>
<td>String</td>
<td>元数据对象的名字，这里由我们编写，比如命令Pod的名字</td>
<td></td>
</tr>
<tr>
<td>metadata.namespace</td>
<td>String</td>
<td>元数据对象的命名空间，由我们自身定义</td>
<td></td>
</tr>
<tr>
<td>Spec</td>
<td>Object</td>
<td>资源规格；详细定义对象，固定值写Spec</td>
<td></td>
</tr>
<tr>
<td>spec.containers[]</td>
<td>list</td>
<td>这里是Spec对象的容器列表定义，是个列表</td>
<td></td>
</tr>
<tr>
<td>spec.containers[].name</td>
<td>String</td>
<td>这里定义容器的名字</td>
<td></td>
</tr>
<tr>
<td>spec.containers[].image</td>
<td>String</td>
<td>这里定义要用到的镜像名称</td>
<td></td>
</tr>
</tbody></table>
<p><font color=red>spec主要对象</font></p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>字段类型</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>spec.containers[].name</td>
<td>String</td>
<td>定义容器的名字</td>
<td></td>
</tr>
<tr>
<td>spec.containers[].image</td>
<td>String</td>
<td>定义要用到的镜像的名称</td>
<td></td>
</tr>
<tr>
<td><strong>spec.containers[].imagePullPolicy</strong></td>
<td>String</td>
<td><strong>定义镜像拉取策略</strong>，有Always，Never，IfNotPresent三个值可选<br />（1）Always：意思是每次尝试重新拉取镜像；（2）Never：表示仅使用本地镜像；（3）IfNotPresent：如果本地有镜像就使用本地镜像，没有就拉取在线镜像。上面三个值都没有设置的话，默认为：Always</td>
<td></td>
</tr>
<tr>
<td>spec.containers[].command[]</td>
<td>list</td>
<td>指定容器启动命令，因为是数组可以指定多个，不指定则使用镜像打包时使用的启动命令</td>
<td></td>
</tr>
<tr>
<td>spec.containers[].args[]</td>
<td>list</td>
<td>指定容器启动命令参数，因为是数组可以指定多个</td>
<td></td>
</tr>
<tr>
<td>spec.containers[].workingDir</td>
<td>String</td>
<td>指定容器的工作目录</td>
<td></td>
</tr>
<tr>
<td>spec.containers[].volumeMounts[]</td>
<td>List</td>
<td>指定容器内部的存储卷设置</td>
<td></td>
</tr>
<tr>
<td>spec.containers[].volumeMounts[].name</td>
<td>String</td>
<td>指定可以被容器挂载的存储卷的名称</td>
<td></td>
</tr>
<tr>
<td>spec.containers[].volumeMounts[].mountPath</td>
<td>String</td>
<td>指定可以被容器挂载的容器卷的路径</td>
<td></td>
</tr>
<tr>
<td>spec.containers[].volumeMounts[].readOnly</td>
<td>String</td>
<td>设置指定存储卷路径的读写模式：true或者false；默认为读写模式</td>
<td></td>
</tr>
<tr>
<td>spec.containers[].ports[]</td>
<td>list</td>
<td>指定容器需要用到的端口列表</td>
<td></td>
</tr>
<tr>
<td>spec.containers[].ports[].name</td>
<td>String</td>
<td>指定端口名称</td>
<td></td>
</tr>
<tr>
<td>spec.containers[].ports[].containerPort</td>
<td>String</td>
<td>指定容器需要监听的端口号</td>
<td></td>
</tr>
<tr>
<td>spec.containers[].ports[].hostPort</td>
<td>String</td>
<td>指定容器所在主机需要监听的端口号，默认跟上面containerPort相同，注意设置了hostPort同一台主机无法启动该容器的相同副本（因为主机的端口号不能相同，这样会冲突）</td>
<td></td>
</tr>
<tr>
<td>spec.containers[].ports[].protocol</td>
<td>String</td>
<td>指定端口协议，支持TCP和UDP，默认值为TCP</td>
<td></td>
</tr>
<tr>
<td>spec.containers[].env[]</td>
<td>List</td>
<td>指定容器运行时所需设置的环境变量列表</td>
<td></td>
</tr>
<tr>
<td>spec.containers[].env[].name</td>
<td>string</td>
<td>指定环境变量名称</td>
<td></td>
</tr>
<tr>
<td>spec.containers[].env[].value</td>
<td>string</td>
<td>指定环境变量值</td>
<td></td>
</tr>
<tr>
<td><strong>Pod的资源限制</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>spec.containers[].resources</td>
<td>Object</td>
<td>指定资源限制和资源强求的值（这里开始就是设置容器的资源上限）</td>
<td></td>
</tr>
<tr>
<td>spec.containers[].resources.limits</td>
<td>Object</td>
<td>指定设置容器运行时资源的运行上限</td>
<td></td>
</tr>
<tr>
<td>spec.containers[].resources.limits.cpu</td>
<td>String</td>
<td>指定cpu的限制，单位为core数，将用于docker run –cpu-shares 参数</td>
<td></td>
</tr>
<tr>
<td>spec.containers[].resources.limits.memory</td>
<td>String</td>
<td>指定MEM内存的限制，单位为：MIB，GIB</td>
<td></td>
</tr>
<tr>
<td>spec.containers[].resources.requests</td>
<td>Object</td>
<td>指定容器启动和调度时的限制设置</td>
<td></td>
</tr>
<tr>
<td>spec.containers[].resources.cpu</td>
<td>String</td>
<td>cpu请求，单位为core数，容器启动时初始化可用数量</td>
<td></td>
</tr>
<tr>
<td>spec.containers[].resources.memory</td>
<td>String</td>
<td>内存请求，单位为MIB，GIB；容器启动的初始化可用数量</td>
<td></td>
</tr>
</tbody></table>
<p><font color=red>额外的参数</font></p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>字段类型</th>
<th>索命</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>spec.restartPolicy</td>
<td>String</td>
<td><strong>定义Pod重启策略</strong>，可以选择为：Always，OnFailure，默认值为Always。（1）Always：Pod一旦终止运行，则无论容器是如何终止的，kubelet服务都将重启它；（2）OnFailure：只有Pod以非零退出码终止时，kubelet才会重启该容器。如果容器正常结束（退出码为0），则kubelet将不会重启它。（3）Never：Pod终止后，kubelet将退出码报告给Master，不会重启该Pod</td>
<td></td>
</tr>
<tr>
<td>spec.nodeSelector</td>
<td>Object</td>
<td>定义Node的Label过滤标签，以科研：value格式指定</td>
<td></td>
</tr>
<tr>
<td>spec.imagePullSecrets</td>
<td>Object</td>
<td>定义pull镜像是使用secret名称，以name：secretkey格式指定</td>
<td></td>
</tr>
<tr>
<td>spec.hostNetwork</td>
<td>Boolean</td>
<td>定义是否使用主机网络模式，默认值为false。设置true表示使用宿主机网络，不使用docker网桥，同时设置了true将无法在同一台宿主机上启动第二个副本</td>
<td></td>
</tr>
<tr>
<td><strong>Pod健康检查</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>livenessProbe</td>
<td>Object</td>
<td>存活检查；如果检查失败，将杀死容器，根据Pod的restartPolicy来操作</td>
<td></td>
</tr>
<tr>
<td>readinessProbe</td>
<td>Object</td>
<td>就绪检查：如果检查失败，k8s会把pod从service endpoint中剔除</td>
<td></td>
</tr>
<tr>
<td>Probe支持以下三种检查方法</td>
<td></td>
<td>1. httpGet：发送HTTP请求，返回200-400范围状态码为成功<br />2. exec：执行Shell命令返回状态码是0为成功<br />3. tcpSocket:发起TCP Socket 建立成功。</td>
<td></td>
</tr>
</tbody></table>
<h4 id="5-实际环境下yaml文件的快速生成方式"><a href="#5-实际环境下yaml文件的快速生成方式" class="headerlink" title="5. 实际环境下yaml文件的快速生成方式"></a>5. 实际环境下yaml文件的快速生成方式</h4><h5 id="第一种方式：-使用kubectl-create，命令生成yaml文件"><a href="#第一种方式：-使用kubectl-create，命令生成yaml文件" class="headerlink" title="第一种方式： 使用kubectl create，命令生成yaml文件"></a>第一种方式： 使用kubectl create，命令生成yaml文件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">[root@K8s-Master ~]# kubectl create deployment web --image=nginx -o yaml --dry-run</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: &quot;2021-07-03T08:18:42Z&quot;</span><br><span class="line">  generation: 1</span><br><span class="line">  labels:</span><br><span class="line">    app: web</span><br><span class="line">  managedFields:</span><br><span class="line">  - apiVersion: apps/v1</span><br><span class="line">    fieldsType: FieldsV1</span><br><span class="line">    fieldsV1:</span><br><span class="line">      f:metadata:</span><br><span class="line">        f:labels:</span><br><span class="line">          .: &#123;&#125;</span><br><span class="line">          f:app: &#123;&#125;</span><br><span class="line">      f:spec:</span><br><span class="line">        f:progressDeadlineSeconds: &#123;&#125;</span><br><span class="line">        f:replicas: &#123;&#125;</span><br><span class="line">        f:revisionHistoryLimit: &#123;&#125;</span><br><span class="line">        f:selector:</span><br><span class="line">          f:matchLabels:</span><br><span class="line">            .: &#123;&#125;</span><br><span class="line">            f:app: &#123;&#125;</span><br><span class="line">        f:strategy:</span><br><span class="line">          f:rollingUpdate:</span><br><span class="line">            .: &#123;&#125;</span><br><span class="line">            f:maxSurge: &#123;&#125;</span><br><span class="line">            f:maxUnavailable: &#123;&#125;</span><br><span class="line">          f:type: &#123;&#125;</span><br><span class="line">        f:template:</span><br><span class="line">          f:metadata:</span><br><span class="line">            f:labels:</span><br><span class="line">              .: &#123;&#125;</span><br><span class="line">              f:app: &#123;&#125;</span><br><span class="line">          f:spec:</span><br><span class="line">            f:containers:</span><br><span class="line">              k:&#123;&quot;name&quot;:&quot;nginx&quot;&#125;:</span><br><span class="line">                .: &#123;&#125;</span><br><span class="line">                f:image: &#123;&#125;</span><br><span class="line">                f:imagePullPolicy: &#123;&#125;</span><br><span class="line">                f:name: &#123;&#125;</span><br><span class="line">                f:resources: &#123;&#125;</span><br><span class="line">                f:terminationMessagePath: &#123;&#125;</span><br><span class="line">                f:terminationMessagePolicy: &#123;&#125;</span><br><span class="line">            f:dnsPolicy: &#123;&#125;</span><br><span class="line">            f:restartPolicy: &#123;&#125;</span><br><span class="line">            f:schedulerName: &#123;&#125;</span><br><span class="line">            f:securityContext: &#123;&#125;</span><br><span class="line">            f:terminationGracePeriodSeconds: &#123;&#125;</span><br><span class="line">    manager: kubectl</span><br><span class="line">    operation: Update</span><br><span class="line">    time: &quot;2021-07-03T08:18:42Z&quot;</span><br><span class="line">  name: web</span><br><span class="line">  namespace: default</span><br><span class="line">  resourceVersion: &quot;145011&quot;</span><br><span class="line">  selfLink: /apis/apps/v1/namespaces/default/deployments/web</span><br><span class="line">  uid: 5f8fa363-1640-4900-be13-e5ee32ad2aad</span><br><span class="line">spec:</span><br><span class="line">  progressDeadlineSeconds: 600</span><br><span class="line">  replicas: 1</span><br><span class="line">  revisionHistoryLimit: 10</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: web</span><br><span class="line">  strategy:</span><br><span class="line">    rollingUpdate:</span><br><span class="line">      maxSurge: 25%</span><br><span class="line">      maxUnavailable: 25%</span><br><span class="line">    type: RollingUpdate</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      creationTimestamp: null</span><br><span class="line">      labels:</span><br><span class="line">        app: web</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: nginx</span><br><span class="line">        imagePullPolicy: Always</span><br><span class="line">        name: nginx</span><br><span class="line">        resources: &#123;&#125;</span><br><span class="line">        terminationMessagePath: /dev/termination-log</span><br><span class="line">        terminationMessagePolicy: File</span><br><span class="line">      dnsPolicy: ClusterFirst</span><br><span class="line">      restartPolicy: Always</span><br><span class="line">      schedulerName: default-scheduler</span><br><span class="line">      securityContext: &#123;&#125;</span><br><span class="line">      terminationGracePeriodSeconds: 30</span><br><span class="line">status: &#123;&#125;</span><br><span class="line"><span class="meta"># </span><span class="language-bash">可以写入到指定的文件中</span></span><br><span class="line">[root@K8s-Master ~]# kubectl create deployment web --image=nginx -o yaml --dry-run &gt; myyaml.yaml</span><br><span class="line">W0703 18:04:22.589508   43652 helpers.go:535] --dry-run is deprecated and can be replaced with --dry-run=client.</span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">cat</span> myyaml.yaml</span></span><br></pre></td></tr></table></figure>

<h5 id="第二种方式：-使用kubectl-get-命令导出yaml文件"><a href="#第二种方式：-使用kubectl-get-命令导出yaml文件" class="headerlink" title="第二种方式： 使用kubectl get 命令导出yaml文件"></a>第二种方式： 使用kubectl get 命令导出yaml文件</h5><p>这种方式适用于已经部署好的文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">[root@K8s-Master ~]# kubectl get deploy</span><br><span class="line">NAME   READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">web    0/1     1            0           8s</span><br><span class="line"><span class="meta"># </span><span class="language-bash">通过get命令导出已经部署好的yaml代码</span></span><br><span class="line">[root@K8s-Master ~]# kubectl get deploy web -o=yaml --export &gt; myyaml.yaml</span><br><span class="line">Flag --export has been deprecated, This flag is deprecated and will be removed in future.</span><br><span class="line">[root@K8s-Master ~]# cat myyaml.yaml </span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    deployment.kubernetes.io/revision: &quot;1&quot;</span><br><span class="line">  creationTimestamp: null</span><br><span class="line">  generation: 1</span><br><span class="line">  labels:</span><br><span class="line">    app: web</span><br><span class="line">  managedFields:</span><br><span class="line">  - apiVersion: apps/v1</span><br><span class="line">    fieldsType: FieldsV1</span><br><span class="line">    fieldsV1:</span><br><span class="line">      f:metadata:</span><br><span class="line">        f:annotations:</span><br><span class="line">          .: &#123;&#125;</span><br><span class="line">          f:deployment.kubernetes.io/revision: &#123;&#125;</span><br><span class="line">      f:status:</span><br><span class="line">        f:conditions:</span><br><span class="line">          .: &#123;&#125;</span><br><span class="line">          k:&#123;&quot;type&quot;:&quot;Available&quot;&#125;:</span><br><span class="line">            .: &#123;&#125;</span><br><span class="line">            f:lastTransitionTime: &#123;&#125;</span><br><span class="line">            f:lastUpdateTime: &#123;&#125;</span><br><span class="line">            f:message: &#123;&#125;</span><br><span class="line">            f:reason: &#123;&#125;</span><br><span class="line">            f:status: &#123;&#125;</span><br><span class="line">            f:type: &#123;&#125;</span><br><span class="line">          k:&#123;&quot;type&quot;:&quot;Progressing&quot;&#125;:</span><br><span class="line">            .: &#123;&#125;</span><br><span class="line">            f:lastTransitionTime: &#123;&#125;</span><br><span class="line">            f:lastUpdateTime: &#123;&#125;</span><br><span class="line">            f:message: &#123;&#125;</span><br><span class="line">            f:reason: &#123;&#125;</span><br><span class="line">            f:status: &#123;&#125;</span><br><span class="line">            f:type: &#123;&#125;</span><br><span class="line">        f:observedGeneration: &#123;&#125;</span><br><span class="line">        f:replicas: &#123;&#125;</span><br><span class="line">        f:unavailableReplicas: &#123;&#125;</span><br><span class="line">        f:updatedReplicas: &#123;&#125;</span><br><span class="line">    manager: kube-controller-manager</span><br><span class="line">    operation: Update</span><br><span class="line">    time: &quot;2021-07-03T10:20:44Z&quot;</span><br><span class="line">  - apiVersion: apps/v1</span><br><span class="line">    fieldsType: FieldsV1</span><br><span class="line">    fieldsV1:</span><br><span class="line">      f:metadata:</span><br><span class="line">        f:labels:</span><br><span class="line">          .: &#123;&#125;</span><br><span class="line">          f:app: &#123;&#125;</span><br><span class="line">      f:spec:</span><br><span class="line">        f:progressDeadlineSeconds: &#123;&#125;</span><br><span class="line">        f:replicas: &#123;&#125;</span><br><span class="line">        f:revisionHistoryLimit: &#123;&#125;</span><br><span class="line">        f:selector:</span><br><span class="line">          f:matchLabels:</span><br><span class="line">            .: &#123;&#125;</span><br><span class="line">            f:app: &#123;&#125;</span><br><span class="line">        f:strategy:</span><br><span class="line">          f:rollingUpdate:</span><br><span class="line">            .: &#123;&#125;</span><br><span class="line">            f:maxSurge: &#123;&#125;</span><br><span class="line">            f:maxUnavailable: &#123;&#125;</span><br><span class="line">          f:type: &#123;&#125;</span><br><span class="line">        f:template:</span><br><span class="line">          f:metadata:</span><br><span class="line">            f:labels:</span><br><span class="line">              .: &#123;&#125;</span><br><span class="line">              f:app: &#123;&#125;</span><br><span class="line">          f:spec:</span><br><span class="line">            f:containers:</span><br><span class="line">              k:&#123;&quot;name&quot;:&quot;nginx&quot;&#125;:</span><br><span class="line">                .: &#123;&#125;</span><br><span class="line">                f:image: &#123;&#125;</span><br><span class="line">                f:imagePullPolicy: &#123;&#125;</span><br><span class="line">                f:name: &#123;&#125;</span><br><span class="line">                f:resources: &#123;&#125;</span><br><span class="line">                f:terminationMessagePath: &#123;&#125;</span><br><span class="line">                f:terminationMessagePolicy: &#123;&#125;</span><br><span class="line">            f:dnsPolicy: &#123;&#125;</span><br><span class="line">            f:restartPolicy: &#123;&#125;</span><br><span class="line">            f:schedulerName: &#123;&#125;</span><br><span class="line">            f:securityContext: &#123;&#125;</span><br><span class="line">            f:terminationGracePeriodSeconds: &#123;&#125;</span><br><span class="line">    manager: kubectl</span><br><span class="line">    operation: Update</span><br><span class="line">    time: &quot;2021-07-03T10:20:44Z&quot;</span><br><span class="line">  name: web</span><br><span class="line">  selfLink: /apis/apps/v1/namespaces/default/deployments/web</span><br><span class="line">spec:</span><br><span class="line">  progressDeadlineSeconds: 600</span><br><span class="line">  replicas: 1</span><br><span class="line">  revisionHistoryLimit: 10</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: web</span><br><span class="line">  strategy:</span><br><span class="line">    rollingUpdate:</span><br><span class="line">      maxSurge: 25%</span><br><span class="line">      maxUnavailable: 25%</span><br><span class="line">    type: RollingUpdate</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      creationTimestamp: null</span><br><span class="line">      labels:</span><br><span class="line">        app: web</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: nginx</span><br><span class="line">        imagePullPolicy: Always</span><br><span class="line">        name: nginx</span><br><span class="line">        resources: &#123;&#125;</span><br><span class="line">        terminationMessagePath: /dev/termination-log</span><br><span class="line">        terminationMessagePolicy: File</span><br><span class="line">      dnsPolicy: ClusterFirst</span><br><span class="line">      restartPolicy: Always</span><br><span class="line">      schedulerName: default-scheduler</span><br><span class="line">      securityContext: &#123;&#125;</span><br><span class="line">      terminationGracePeriodSeconds: 30</span><br><span class="line">status: &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Kubernetes核心技术-Pod"><a href="#Kubernetes核心技术-Pod" class="headerlink" title="Kubernetes核心技术-Pod"></a>Kubernetes核心技术-Pod</h3><h4 id="1-Pod概述"><a href="#1-Pod概述" class="headerlink" title="1. Pod概述"></a>1. Pod概述</h4><p>Pod是k8s系统中可以创建和管理的最小单元，是资源对象模型中由用户创建或部署的最小资源对象模型，也是在k8s上运行容器化应用的资源对象，其他的资源对象都是用来支撑或者扩展Pod对象功能的，比如<strong>控制器</strong>对象是用来管控Pod对象的，<strong>Service</strong>或者<strong>Ingress</strong>资源对象是用来暴露Pod引用对象的，PersistentVolume资源对象是用来为Pod提供存储等等，k8s不会直接处理容器，而是Pod，Pod是有一个或多个container组成。</p>
<p>Pod是Kubernetes的最重要概念，每一个Pod都有一个特殊的被称为“<strong>根容器</strong>”的<strong>Pause容器</strong>。<strong>Pause容器</strong>对应的镜像属于Kubernetes平台的一部分，除了Pause容器，每个Pod还包含一个或多个紧密相关的<strong>用户业务容器</strong>。</p>
<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F5333071-57db1cb170adec26.png&refer=http%3A%2F%2Fupload-images.jianshu.io&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1627905475&t=88c8502c297f8f6d1aca68ed85eae33b" alt="img"></p>
<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimage.morecoder.com%2Farticle%2F201812%2F20181230121245190929.png&refer=http%3A%2F%2Fimage.morecoder.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1627905524&t=df98d88c967aa9d462ca707b5784b687" alt="img"></p>
<p>小总结：</p>
<ol>
<li>pod是k8s的最小部署单元</li>
<li>一个pod中包含多个容器（一组容器的集合）</li>
<li>一个pod中容器共享网络命名空间</li>
<li>pod是短暂的</li>
</ol>
<p><strong>Pod存在的意义</strong></p>
<ol>
<li>创建容器使用docker，一个docker对应一个容器，一个容器对应一个进程，一个容器一般运行一个应用程序。（Docker中的容器是单进程的）</li>
<li>Pod是多进程设计，运行多个应用程序。<ul>
<li>一个Pod有多个容器，一个容器里面运行一个应用程序</li>
</ul>
</li>
<li>Pod的存在为了亲密性应用<ul>
<li>两个应用之间进行交互</li>
<li>网络之间调用</li>
<li>两个应用需要频繁调用</li>
</ul>
</li>
</ol>
<blockquote>
<p>Pod VS 应用：</p>
<p>​    每个pod都是应用的一个实例，有专用的ip</p>
<p>Pod VS 容器：</p>
<p>​    一个Pod可以有多个容器，彼此间共享网络和存储资源，每个Pod中有一个（根容器）Pause容器保存所有的容器状态，通过管理Pause容器，达到管理Pod中所有容器的效果</p>
<p>Pod VS 节点：</p>
<p>​    同一个Pod中的容器总会被调度到相同Node节点，不同节点间Pod的通信基于虚拟二层网络技术实现</p>
<p>Pod VS Pod：</p>
<p>​    普通的Pod和静态Pod</p>
</blockquote>
<h4 id="2-Pod特性"><a href="#2-Pod特性" class="headerlink" title="2.Pod特性"></a>2.Pod特性</h4><h5 id="1-资源共享"><a href="#1-资源共享" class="headerlink" title="1. 资源共享"></a>1. 资源共享</h5><p>一个Pod里的多个容器可以共享存储和网络，可以看作一个逻辑的主机。共享的如namespace，cgroup或者其他的隔离资源。</p>
<p><font color=green>多个容器共享同一network namespace，由此在一个Pod里的多个容器共享Pod的IP和端口namespace，所以一个Pod内的多个容器之间可以通过localhost来进行通信，所需要注意的是不同容器要注意不要有端口冲突即可。</font>不同的Pod有不同的IP，不同Pod内的多个容器之间通信，不可以使用IPC（如果没有特殊指定的话）通信，通常情况下使用Pod的IP进行通信。</p>
<p>一个Pod里的多个容器可以共享存储卷，这个存储卷会被定义为Pod的一部分，并且可以挂载到该Pod里的所有容器的文件系统上。</p>
<h5 id="2-声明周期短暂"><a href="#2-声明周期短暂" class="headerlink" title="2. 声明周期短暂"></a>2. 声明周期短暂</h5><p>Pod属于生命周期比较短暂的组件,比如,当Pod所在节点发生故障,那么该节点上的Pod会被调度到其他节点,但需要注意的是,被重新调度的Pod是一个全新的Pod,跟之前的Pod没有半毛钱关系.</p>
<h5 id="3-平坦的网络"><a href="#3-平坦的网络" class="headerlink" title="3. 平坦的网络"></a>3. 平坦的网络</h5><p>k8s集群中的所有Pod都在同一个共享网络地址空间中,也就是说每个Pod都可以通过其他Pod的IP地址来实现访问.</p>
<h4 id="3-Pod的调度机制"><a href="#3-Pod的调度机制" class="headerlink" title="3. Pod的调度机制"></a>3. Pod的调度机制</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">kubectl get pods -o wide</span></span><br></pre></td></tr></table></figure>

<p><strong>Pod创建流程：</strong></p>
<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Foscimg.oschina.net%2Foscnet%2F04062caf14fd406c4cbdc5fbe5229116b61.png&refer=http%3A%2F%2Foscimg.oschina.net&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1628003614&t=36360dd0a7039cb66c3ab4363f2b3b0d" alt="img"></p>
<h5 id="1-影响调度的属性"><a href="#1-影响调度的属性" class="headerlink" title="1. 影响调度的属性"></a>1. 影响调度的属性</h5><ol>
<li><p><strong>Pod资源限制对Pod调度产生影响</strong></p>
<ul>
<li>根据request找到足够node节点进行调度</li>
</ul>
</li>
<li><p><strong>节点选择器标签影响Pod调度</strong></p>
<ul>
<li>```yaml<br>nodeSelector:<br> env_role: dev  # 具体节点的标签名（可以是一组）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```shell</span><br><span class="line">  $ kubectl label node node1 env_role=dev  # 为节点1打一个标签env_role=dev</span><br><span class="line">  # 可以通过如下命名查看节点的标签明细</span><br><span class="line">  $ kubectl get nodes k8snode1 --show-lablels</span><br><span class="line">  </span><br><span class="line">  [root@K8s-Master ~]# kubectl label node k8s-node1 env_role=dev </span><br><span class="line">  node/k8s-node1 labeled</span><br><span class="line">  [root@K8s-Master ~]# kubectl get nodes k8s-node1 --show-labels</span><br><span class="line">  NAME        STATUS   ROLES    AGE   VERSION   LABELS</span><br><span class="line">  k8s-node1   Ready    &lt;none&gt;   24h   v1.18.3   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,env_role=dev,kubernetes.io/arch=amd64,kubernetes.io/hostname=k8s-node1,kubernetes.io/os=linux</span><br><span class="line">  </span><br><span class="line">  [root@K8s-Master ~]# kubectl label node k8s-node1 env-role2=dev2</span><br><span class="line">  node/k8s-node1 labeled</span><br><span class="line">  [root@K8s-Master ~]# kubectl get nodes k8s-node1 --show-labels</span><br><span class="line">  NAME        STATUS   ROLES    AGE   VERSION   LABELS</span><br><span class="line">  k8s-node1   Ready    &lt;none&gt;   24h   v1.18.3   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,env_role=dev,kubernetes.io/arch=amd64,kubernetes.io/hostname=k8s-node1,kubernetes.io/os=linux</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>节点亲和性影响Pod调度</strong></p>
<ul>
<li><p>```yaml<br>nodeAffinity:</p>
<h1 id="nodeAffinity和之前的nodeSelector基本一样的，根据节点上标签约束来决定Pod调度到哪些节点上"><a href="#nodeAffinity和之前的nodeSelector基本一样的，根据节点上标签约束来决定Pod调度到哪些节点上" class="headerlink" title="nodeAffinity和之前的nodeSelector基本一样的，根据节点上标签约束来决定Pod调度到哪些节点上"></a>nodeAffinity和之前的nodeSelector基本一样的，根据节点上标签约束来决定Pod调度到哪些节点上</h1><h1 id="功能比nodeSelector要强大"><a href="#功能比nodeSelector要强大" class="headerlink" title="功能比nodeSelector要强大"></a>功能比nodeSelector要强大</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 硬亲和性</span><br><span class="line"></span><br><span class="line">  - ```yaml</span><br><span class="line">    # 硬亲和性，约束条件必须满足</span><br><span class="line">    spec:</span><br><span class="line">     affinity:</span><br><span class="line">      nodeAffinity:</span><br><span class="line">       requiredDuringSchedulingIgnoreDuringExecution:</span><br><span class="line">        nodeSelectorTerms:</span><br><span class="line">        - matchExpressions:</span><br><span class="line">         - key: env_role</span><br><span class="line">           operator: In  # 操作符， in 代表值在下面两个里面</span><br><span class="line">           values:</span><br><span class="line">           - dev</span><br><span class="line">           - test</span><br></pre></td></tr></table></figure>

<ul>
<li>软亲和性</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 尝试满足，不保证</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="attr">affinity:</span></span><br><span class="line">  <span class="attr">nodeAffinity:</span></span><br><span class="line">   <span class="attr">preferredDuringSchedulingIgnoreDuringExecution:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">1</span> <span class="comment">#权重</span></span><br><span class="line">     <span class="attr">preference:</span></span><br><span class="line">      <span class="attr">matchExpressions:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">group</span></span><br><span class="line">        <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">        <span class="attr">values:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">otherprod</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>```yaml</p>
<h1 id="常用的操作符"><a href="#常用的操作符" class="headerlink" title="常用的操作符"></a>常用的操作符</h1><p>In：在里面<br>NotIn：不在里面<br>Exists：存在<br>Gt：大于<br>Lt：小于<br>DoesNotExists：不存在</p>
<h1 id="使用Not可实现反亲和性"><a href="#使用Not可实现反亲和性" class="headerlink" title="使用Not可实现反亲和性"></a>使用Not可实现反亲和性</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. **Taint** **污点和污点容忍**</span><br><span class="line"></span><br><span class="line">   &gt; nodeSelector和nodeAffinity将Pod调度到某些节点上，是Pod中的属性，调度的时候实现</span><br><span class="line">   &gt;</span><br><span class="line">   &gt; Taint污点：节点不做普通分配调度，它是节点的属性</span><br><span class="line">   &gt;</span><br><span class="line">   &gt; - &lt;font color=green&gt;污点值有三个:&lt;/font&gt;</span><br><span class="line">   &gt;   - &lt;font color=green&gt;NoSchedule：一定不被调度&lt;/font&gt;</span><br><span class="line">   &gt;   - &lt;font color=green&gt;PreferNoSchdule： 尽量不被调用&lt;/font&gt;</span><br><span class="line">   &gt;   - &lt;font color=green&gt;NoExecute：不会调度，并且还会驱逐Node已有的Pod&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">   - 应用场景</span><br><span class="line"></span><br><span class="line">     - 专用节点</span><br><span class="line">     - 配置特点硬件节点</span><br><span class="line">     - 基于Taint驱逐</span><br><span class="line"></span><br><span class="line">   - 具体演示</span><br><span class="line"></span><br><span class="line">     - ```shell</span><br><span class="line">       # 1. 查看节点污点情况</span><br><span class="line">       [root@K8s-Master ~]# kubectl describe nodes k8s-master | grep Taint</span><br><span class="line">       Taints:             &lt;none&gt;</span><br><span class="line">       # 2. 为节点添加污点</span><br><span class="line">       $ kubectl taint node [节点主机名：k8s-master] key=value:污点的三个值</span><br><span class="line">       </span><br><span class="line">       # 测试</span><br><span class="line">       # 创建一个pod，然后设置污点，然后增加pod的副本</span><br><span class="line">       $ kubectl create deployment web --images=nginx</span><br><span class="line">       $ kubectl get pods -o wide</span><br><span class="line">       NAME                   READY   STATUS              RESTARTS   AGE   IP       NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">       web-5dcb957ccc-zmj4x   0/1     ContainerCreating   0          75s   &lt;none&gt;   k8s-node1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">       [root@K8s-Master ~]# kubectl scale deployment web --replicas=5</span><br><span class="line">       deployment.apps/web scaled</span><br><span class="line">       [root@K8s-Master ~]# kubectl get pods -o wide</span><br><span class="line">       NAME                   READY   STATUS              RESTARTS   AGE     IP       NODE         NOMINATED NODE   READINESS GATES</span><br><span class="line">       web-5dcb957ccc-7mw6s   0/1     ContainerCreating   0          4s      &lt;none&gt;   k8s-master   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">       web-5dcb957ccc-dl84z   0/1     ContainerCreating   0          4s      &lt;none&gt;   k8s-node2    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">       web-5dcb957ccc-tqf5k   0/1     ContainerCreating   0          4s      &lt;none&gt;   k8s-node1    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">       web-5dcb957ccc-z747m   0/1     ContainerCreating   0          4s      &lt;none&gt;   k8s-node2    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">       web-5dcb957ccc-zmj4x   0/1     ContainerCreating   0          4m49s   &lt;none&gt;   k8s-node1    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">       # 删除pod 重新建立</span><br><span class="line">       $ kubectl delete deployment web</span><br><span class="line">       $ kubectl taint node k8s-node2 key=value:NoSchedule</span><br><span class="line">       node/k8s-node2 tainted</span><br><span class="line">       $ kubectl scale deployment web --replicas=5</span><br><span class="line">       $ kubectl get pods -o wide</span><br><span class="line">       [root@K8s-Master ~]# kubectl scale deployment web --replicas=5</span><br><span class="line">       deployment.apps/web scaled</span><br><span class="line">       [root@K8s-Master ~]# kubectl get pods -o wide</span><br><span class="line">       NAME                   READY   STATUS              RESTARTS   AGE    IP       NODE         NOMINATED NODE   READINESS GATES</span><br><span class="line">       web-5dcb957ccc-55k2m   0/1     ContainerCreating   0          16s    &lt;none&gt;   k8s-master   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">       web-5dcb957ccc-9jhqm   0/1     ContainerCreating   0          16s    &lt;none&gt;   k8s-node1    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">       web-5dcb957ccc-hmsrj   0/1     ContainerCreating   0          16s    &lt;none&gt;   k8s-master   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">       web-5dcb957ccc-mc2qz   0/1     ContainerCreating   0          2m8s   &lt;none&gt;   k8s-node1    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">       web-5dcb957ccc-nt956   0/1     ContainerCreating   0          16s    &lt;none&gt;   k8s-node1    &lt;none&gt;           &lt;none&gt;</span><br><span class="line">       </span><br><span class="line">       # 查看node2上的污点的情况</span><br><span class="line">       $ kubectl describe node k8s-node2 | grep Taint</span><br><span class="line">       [root@K8s-Master ~]# kubectl describe node k8s-node2 | grep Taint</span><br><span class="line">       Taints:             env_role=dev:NoSchedule</span><br><span class="line">       # 删除污点</span><br><span class="line">       $ kubectl taint node k8s-node2 env_role:NoSchedule-</span><br><span class="line">       [root@K8s-Master ~]# kubectl taint node k8s-node2 env_role:NoSchedule-</span><br><span class="line">       node/k8s-node2 untainted</span><br><span class="line">       [root@K8s-Master ~]# kubectl describe node k8s-node2 | grep Taint</span><br><span class="line">       Taints:             &lt;none&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>污点容忍</p>
<ul>
<li><pre><code class="yaml">spec:
 tolerations:   # 虽然设置了污点，但是也可能被调度到
 - key: &quot;key&quot;
   operator: &quot;Equal&quot;
   value: &quot;value&quot;
   effect: &quot;NoSchedule&quot;
 containers:
 - name: webdemo
   image:nginx
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="Kubernetes核心技术-controller"><a href="#Kubernetes核心技术-controller" class="headerlink" title="Kubernetes核心技术-controller"></a>Kubernetes核心技术-controller</h3><h4 id="1-什么是controller？"><a href="#1-什么是controller？" class="headerlink" title="1.  什么是controller？"></a>1.  什么是controller？</h4><h4 id="2-Pod是Controller关系"><a href="#2-Pod是Controller关系" class="headerlink" title="2. Pod是Controller关系"></a>2. Pod是Controller关系</h4><h4 id="3-Deployment控制器应用场景"><a href="#3-Deployment控制器应用场景" class="headerlink" title="3. Deployment控制器应用场景"></a>3. Deployment控制器应用场景</h4><h4 id="4-yaml文件字段说明"><a href="#4-yaml文件字段说明" class="headerlink" title="4. yaml文件字段说明"></a>4. yaml文件字段说明</h4><h4 id="5-Deployment控制器部署应用"><a href="#5-Deployment控制器部署应用" class="headerlink" title="5.Deployment控制器部署应用"></a>5.Deployment控制器部署应用</h4><h4 id="6-升级回滚"><a href="#6-升级回滚" class="headerlink" title="6. 升级回滚"></a>6. 升级回滚</h4><h4 id="7-弹性伸缩"><a href="#7-弹性伸缩" class="headerlink" title="7. 弹性伸缩"></a>7. 弹性伸缩</h4><h2 id="第四部分：-搭建集群监控平台系统"><a href="#第四部分：-搭建集群监控平台系统" class="headerlink" title="第四部分： 搭建集群监控平台系统"></a>第四部分： 搭建集群监控平台系统</h2><h2 id="第五部分：从零搭建高可用K8s集群"><a href="#第五部分：从零搭建高可用K8s集群" class="headerlink" title="第五部分：从零搭建高可用K8s集群"></a>第五部分：从零搭建高可用K8s集群</h2><h2 id="第六部分：在集群环境部署项目"><a href="#第六部分：在集群环境部署项目" class="headerlink" title="第六部分：在集群环境部署项目"></a>第六部分：在集群环境部署项目</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://xiaowodi.github.io/2022/06/24/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/24/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Flink学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-24 08:12:10" itemprop="dateCreated datePublished" datetime="2022-06-24T08:12:10+00:00">2022-06-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h1 id="Flink学习笔记"><a href="#Flink学习笔记" class="headerlink" title="Flink学习笔记"></a>Flink学习笔记</h1><h2 id="运行时架构"><a href="#运行时架构" class="headerlink" title="运行时架构"></a>运行时架构</h2><h3 id="1-flink运行时的组件"><a href="#1-flink运行时的组件" class="headerlink" title="1. flink运行时的组件"></a>1. flink运行时的组件</h3><p><img src="https://img1.baidu.com/it/u=1363017092,178586132&fm=15&fmt=auto&gp=0.jpg" alt="img"></p>
<h4 id="作业管理器（JobManager）"><a href="#作业管理器（JobManager）" class="headerlink" title="作业管理器（JobManager）"></a>作业管理器（JobManager）</h4><ul>
<li>控制一个应用程序执行的主进程，也就是说，每个应用程序都会被一个不同的JobManager所控制执行</li>
<li>JobManager会现接收到要执行的应用程序，这个应用程序会包括：作业图（JobGraph）、逻辑数据流图（logical dataflow graph）和打包了所有的类、库和其他资源的jar包</li>
<li>JobManager会把JobGraph转换成一个物理层面的数据流图，这个图被叫做“执行图”（ExecutionGraph），包含了所有可以并发执行的任务。</li>
<li>JobManager会向资源管理器（ResourceManager）请求执行任务必要的资源，也就是任务管理器（TaskManager）上面的插槽（slot）。一旦它获取了足够的资源，就会将执行图分发到真正运行它们的TaskManager上。而在运行过程中，JobManager会负责所有需要中央协调的操作，比如说检查点（checkpoint）的协调。</li>
</ul>
<h4 id="任务管理器（TaskManager）"><a href="#任务管理器（TaskManager）" class="headerlink" title="任务管理器（TaskManager）"></a>任务管理器（TaskManager）</h4><ul>
<li>flink中的工作进程。通常在flink中会有多个TaskManager运行，每一个TaskManager都包含了一定数量的插槽（slot）。插槽的数量限制了TaskManager能够并发执行的任务数量。</li>
<li>启动子后，TaskManager会向资源管理器注册它的插槽；收到资源管理器的指令后，TaskManager就会将一个或多个插槽提供给JobManager调用。JobManager就可以向slot分配任务（tasks）来执行了。</li>
<li>在执行过程中，一个TaskManager可以跟其他运行同一应用程序的TaskManager交换数据。</li>
</ul>
<h4 id="资源管理器（ResourceManager）"><a href="#资源管理器（ResourceManager）" class="headerlink" title="资源管理器（ResourceManager）"></a>资源管理器（ResourceManager）</h4><ul>
<li>主要负责管理任务管理器（TaskManager）的插槽（slot），TaskManager插槽是Flink中定义的处理资源单元。</li>
<li>Flink为不同的环境和资源管理工具提供了不同资源管理器，比如yarn、Mesos、k8s以及standalone部署。</li>
<li>当JobManager申请插槽资源时，ResourceManager会将有空闲插槽的TaskManager分配给JobManager。如果ResourceManager没有足够的插槽来满足JobManager的请求，它还可以向资源提供平台发起会话，以提供启动TaskManager进程的容器。</li>
</ul>
<h4 id="分发器（Dispatcher）"><a href="#分发器（Dispatcher）" class="headerlink" title="分发器（Dispatcher）"></a>分发器（Dispatcher）</h4><ul>
<li>可以跨作业运行，它为应用提交提供了REST接口</li>
<li>当一个应用被提交执行时，分发器就会启动并将应用移交给一个JobManager。</li>
<li>Dispatcher也会启动一个web UI，用来方便地展示和监控作业执行的信息。</li>
<li>Dispatcher在架构中可能并不是必需的，这取决于应用提交执行的方式。</li>
</ul>
<h3 id="2-任务提交流程"><a href="#2-任务提交流程" class="headerlink" title="2. 任务提交流程"></a>2. 任务提交流程</h3><h4 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h4><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2F20200524212126844.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTgwMjI5%2Csize_16%2Ccolor_FFFFFF%2Ct_70&refer=http%3A%2F%2Fimg-blog.csdnimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1629178209&t=dba3c336b51674fdb35f9f86eccfadd7" alt="img"></p>
<h4 id="任务提交流程（Yarn）"><a href="#任务提交流程（Yarn）" class="headerlink" title="任务提交流程（Yarn）"></a>任务提交流程（Yarn）</h4><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.pianshen.com%2Fimages%2F597%2F9112d7f39d3f178daa84fda2f75a9815.png&refer=http%3A%2F%2Fwww.pianshen.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1629178307&t=b26d75e5a47e8ae65ce87280ce6d4bf0" alt="img"></p>
<h3 id="3-任务调度原理"><a href="#3-任务调度原理" class="headerlink" title="3. 任务调度原理"></a>3. 任务调度原理</h3><p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.13/fig/processes.svg" alt="The processes involved in executing a Flink dataflow"></p>
<p>Flink 运行时由两种类型的进程组成：一个 <em>JobManager</em> 和一个或者多个 <em>TaskManager</em>。</p>
<p><em>Client</em> 不是运行时和程序执行的一部分，而是用于准备数据流并将其发送给 JobManager。之后，客户端可以断开连接（<em>分离模式</em>），或保持连接来接收进程报告（<em>附加模式</em>）。客户端可以作为触发执行 Java/Scala 程序的一部分运行，也可以在命令行进程<code>./bin/flink run ...</code>中运行。</p>
<p>可以通过多种方式启动 JobManager 和 TaskManager：直接在机器上作为<a target="_blank" rel="noopener" href="https://ci.apache.org/projects/flink/flink-docs-release-1.13/zh/docs/deployment/resource-providers/standalone/overview/">standalone 集群</a>启动、在容器中启动、或者通过<a target="_blank" rel="noopener" href="https://ci.apache.org/projects/flink/flink-docs-release-1.13/zh/docs/deployment/resource-providers/yarn/">YARN</a>或<a target="_blank" rel="noopener" href="https://ci.apache.org/projects/flink/flink-docs-release-1.13/zh/docs/deployment/resource-providers/mesos/">Mesos</a>等资源框架管理并启动。TaskManager 连接到 JobManagers，宣布自己可用，并被分配工作。</p>
<h3 id="4-并行度（Parallelism）"><a href="#4-并行度（Parallelism）" class="headerlink" title="4. 并行度（Parallelism）"></a>4. 并行度（Parallelism）</h3><p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.13/fig/tasks_chains.svg" alt="Operator chaining into Tasks"></p>
<p>一个特定算子的子任务（subtask）的个数被称之为其其并行度（parallelism）</p>
<p>一般情况下，一个stream的并行度，可以认为就是其所有算子中最大的并行度</p>
<h3 id="5-TaskManager和Slots"><a href="#5-TaskManager和Slots" class="headerlink" title="5. TaskManager和Slots"></a>5. TaskManager和Slots</h3><p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.13/fig/tasks_slots.svg" alt="A TaskManager with Task Slots and Tasks"></p>
<p>每个 worker（TaskManager）都是一个 <em>JVM 进程</em>，可以在单独的线程中执行一个或多个 subtask。为了控制一个 TaskManager 中接受多少个 task，就有了所谓的 <strong>task slots</strong>（至少一个）。</p>
<p>每个 <em>task slot</em> 代表 TaskManager 中资源的固定子集。例如，具有 3 个 slot 的 TaskManager，会将其托管内存 1/3 用于每个 slot。分配资源意味着 subtask 不会与其他作业的 subtask 竞争托管内存，而是具有一定数量的保留托管内存。注意此处没有 CPU 隔离；当前 slot 仅分离 task 的托管内存。</p>
<p>通过调整 task slot 的数量，用户可以定义 subtask 如何互相隔离。每个 TaskManager 有一个 slot，这意味着每个 task 组都在单独的 JVM 中运行（例如，可以在单独的容器中启动）。具有多个 slot 意味着更多 subtask 共享同一 JVM。同一 JVM 中的 task 共享 TCP 连接（通过多路复用）和心跳信息。它们还可以共享数据集和数据结构，从而减少了每个 task 的开销。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.13/fig/slot_sharing.svg" alt="TaskManagers with shared Task Slots"></p>
<p>默认情况下，Flink 允许 subtask 共享 slot，即便它们是不同的 task 的 subtask，只要是来自于同一作业即可。结果就是一个 slot 可以持有整个作业管道。允许 <em>slot 共享</em>有两个主要优点：</p>
<ul>
<li>Flink 集群所需的 task slot 和作业中使用的最大并行度恰好一样。无需计算程序总共包含多少个 task（具有不同并行度）。</li>
<li>容易获得更好的资源利用。如果没有 slot 共享，非密集 subtask（<em>source/map()<em>）将阻塞和密集型 subtask（</em>window</em>） 一样多的资源。通过 slot 共享，我们示例中的基本并行度从 2 增加到 6，可以充分利用分配的资源，同时确保繁重的 subtask 在 TaskManager 之间公平分配。</li>
<li>Task Slot是静态的概念，是指TaskManager具有的并发执行能力</li>
</ul>
<h3 id="6-并行子任务的分配"><a href="#6-并行子任务的分配" class="headerlink" title="6. 并行子任务的分配"></a>6. 并行子任务的分配</h3><p><img src="https://img2.baidu.com/it/u=2280219054,4248526086&fm=26&fmt=auto&gp=0.jpg" alt="img"></p>
<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fss.csdn.net%2Fp%3Fhttps%3A%2F%2Fmmbiz.qpic.cn%2Fmmbiz_png%2FadI0ApTVBFVEicLjjV1Ye9EdgGBJGzzibf5t5iaXUCFx52A4x88Cok5tUgkXk4pqhTdTMAB4EVWkZDW0iaVWn1Ka6g%2F640%3Fwx_fmt%3Dpng&refer=http%3A%2F%2Fss.csdn.net&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1629180212&t=1e62d7035afbbc12e4e1215dd95ec0b4" alt="img"></p>
<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F16177192-b180d5636433f157.png&refer=http%3A%2F%2Fupload-images.jianshu.io&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1629180234&t=69834520f36f495104904898bc387e8e" alt="img"></p>
<h3 id="7-程序与数据流（DataFlow）"><a href="#7-程序与数据流（DataFlow）" class="headerlink" title="7.程序与数据流（DataFlow）"></a>7.程序与数据流（DataFlow）</h3><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.it610.com%2Fimage%2Finfo8%2Fb6208b0c1f91485c950269d469c2cf07.jpg&refer=http%3A%2F%2Fimg.it610.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1629180804&t=2bdb07510edffe42079397a2c959d836" alt="img"></p>
<p>所有的Flink程序都是由三部分组成的：Source、Transformation和Sink。</p>
<ul>
<li>Source负责读取数据源，Transformation利用各种算子进行处理加工，Sink负责输出</li>
<li>在运行时，Flink上运行 的程序会被映射成“逻辑数据流”（dataflows），它包含了这三部分</li>
<li>每一个dataflow以一个或多个sources开始以一个或多个sinks结束。dataflow类似于任意的邮箱无环图（DAG）</li>
<li>再大部分情况下，程序中的转换运算（transformation）跟dataflow中的算子（operator）是一一对应的关系</li>
</ul>
<h3 id="8-执行图（ExecutionGraph）"><a href="#8-执行图（ExecutionGraph）" class="headerlink" title="8. 执行图（ExecutionGraph）"></a>8. 执行图（ExecutionGraph）</h3><ul>
<li>Flink中的执行图可以分成四层：StreamGraph -&gt; JobGraph -&gt; ExecutionGraph -&gt; 物理执行图</li>
<li>StreamGraph：是根据用户通过StreamAPI编写的代码生成的最初的图。用来表示程序的拓扑结构。</li>
<li>JobGraph：StreamGraph经过优化后生成了JobGraph，提交给JobManager的数据结构。主要的优化为：将多个符合条件的节点chain在一起作为一个节点。</li>
<li>ExecutionGraph：JobManager根据JobGraph生成ExecutionGraph。ExecutionGraph是JobGraph的并行化版本，是调度层最核心的数据结构。</li>
<li>物理执行图：JobManager根据ExecutionGraph对Job进行调度后，在各个TaskManager上部署Task后形成的“图”，并不是一个具体的数据结构。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210408231604597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5nbG9uZ180NDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210408231751844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5nbG9uZ180NDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210408231836577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5nbG9uZ180NDQ0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="9-数据传输形式"><a href="#9-数据传输形式" class="headerlink" title="9. 数据传输形式"></a>9. 数据传输形式</h3><ul>
<li>一个程序中，不同的算子可能具有不同的并行度</li>
<li>算子之间传输数据的形式可以是one-to-one（forwarding）的模式也可以是redistributing的模式，具体是哪一种形式，取决于算子的种类。</li>
<li>One-to-One：stream维护着分区以及元素的顺序（比如source和map之间）。这意味着map算子的子任务看到的个数以及顺序跟source算则的子任务生产的元素的个数、顺序相同。map、fliter、flatMap等算子都是one-to-one的对应关系。</li>
<li>Redistribution：stream的分区会发生改变。每一个算子的子任务依据选择的transformation发送数据到不同的目标任务。例如，keyBy基于hashCode充分去。而broadcast和rebalance会重新分区（rebalance会轮询的方式进行分区，shuffle算子随机分区），这些算子都会引起redistribute过程，而redistribute的过程类似于spark中的shuffle过程。</li>
</ul>
<h3 id="10-任务链（Operator-Chains）"><a href="#10-任务链（Operator-Chains）" class="headerlink" title="10. 任务链（Operator Chains）"></a>10. 任务链（Operator Chains）</h3><p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.13/fig/tasks_chains.svg" alt="Operator chaining into Tasks"></p>
<ul>
<li>Flink采用了一种称为任务链（chains）的优化技术，可以在特定条件下减少本地通信的开销。为了满足任务链的要求，必须将两个或多个算子设为相同的并行度，并通过本地转发（local forward）的方式进行连接</li>
<li><strong>相同并行度的one-to-one</strong>操作，Flink这样相连的算子链成在一起形成一个task，原来的算子成为里面subtask</li>
<li>并行度相同，并且one-to-one操作，两个条件缺一不可</li>
</ul>
<h2 id="Flink流处理API"><a href="#Flink流处理API" class="headerlink" title="Flink流处理API"></a>Flink流处理API</h2><p><img src="https://img-blog.csdnimg.cn/20200509164232473.png#pic_center" alt="在这里插入图片描述"></p>
<h3 id="1-Environment"><a href="#1-Environment" class="headerlink" title="1. Environment"></a>1. Environment</h3><h4 id="1-getExecutionEnvironment"><a href="#1-getExecutionEnvironment" class="headerlink" title="1. getExecutionEnvironment"></a>1. getExecutionEnvironment</h4><p>创建一个执行环境，表示当前执行程序的上下文。如果程序时独立调度用的，则此方法返回本地执行环境：如果从命令行客户端调用程序以提交到集群，则此方法返回此集群的执行环境，也就是说，getExecutionEnvironmen会根据查询运行的方式决定返回什么样的运行环境，是最常用的一种创建方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 批</span></span><br><span class="line"><span class="type">ExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> ExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"><span class="comment">// 流</span></span><br><span class="line"><span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br></pre></td></tr></table></figure>

<p>如果没有设置并行度，会议flink-conf.yaml中的配置为准，默认是1.</p>
<h4 id="2-createLocalEnvironment"><a href="#2-createLocalEnvironment" class="headerlink" title="2 createLocalEnvironment"></a>2 createLocalEnvironment</h4><p>返回本地执行环境，需要在调用时指定默认的并行度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalStreamEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.createLocalEnvironment(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h4 id="3-createRemoteEnvironment"><a href="#3-createRemoteEnvironment" class="headerlink" title="3 createRemoteEnvironment"></a>3 createRemoteEnvironment</h4><p>返回集群执行环境，将 Jar 提交到远程服务器。需要在调用时指定 JobManager<br>的 IP 和端口号，并指定要在集群中运行的 Jar 包。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span></span><br><span class="line">StreamExecutionEnvironment.createRemoteEnvironment(<span class="string">&quot;jobmanage-hostname&quot;</span>, <span class="number">6123</span>,<span class="string">&quot;YOURPATH//WordCount.jar&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-Source"><a href="#2-Source" class="headerlink" title="2. Source"></a>2. Source</h3><h4 id="1-从集合读取数据"><a href="#1-从集合读取数据" class="headerlink" title="1. 从集合读取数据"></a>1. 从集合读取数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yulu.apitest.source;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yulu.apitest.beans.SensorReading;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SorceTest1_Collection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        <span class="comment">//从集合中读取数据</span></span><br><span class="line">        DataStream&lt;SensorReading&gt; data = env.fromCollection(Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SensorReading</span>(<span class="string">&quot;sensor1&quot;</span>, <span class="number">1547718199L</span>, <span class="number">35.8</span>)</span><br><span class="line">                , <span class="keyword">new</span> <span class="title class_">SensorReading</span>(<span class="string">&quot;sensor2&quot;</span>, <span class="number">1547718200L</span>, <span class="number">36.8</span>)</span><br><span class="line">                , <span class="keyword">new</span> <span class="title class_">SensorReading</span>(<span class="string">&quot;sensor3&quot;</span>, <span class="number">1547718211L</span>, <span class="number">34.6</span>)</span><br><span class="line">        ));</span><br><span class="line">        DataStream&lt;Integer&gt; source = env.fromElements(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        data.print(<span class="string">&quot;SensorReading&quot;</span>);</span><br><span class="line">        source.print(<span class="string">&quot;int&quot;</span>);</span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-从文件读取数据"><a href="#2-从文件读取数据" class="headerlink" title="2. 从文件读取数据"></a>2. 从文件读取数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;String&gt; dataStream = env.readTextFile(<span class="string">&quot;YOUR_FILE_PATH&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="3-以kafka消息队列的数据作为来源"><a href="#3-以kafka消息队列的数据作为来源" class="headerlink" title="3. 以kafka消息队列的数据作为来源"></a>3. 以kafka消息队列的数据作为来源</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;--!需要添加kafaka的flink的插件--&gt;</span><br><span class="line">pom.xml文件中需要添加依赖</span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">https://mvnrepository.com/artifact/org.apache.flink/flink-connector-kafka-0.11</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-kafka-0.11_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kafka配置项</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.setProperty(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">properties.setProperty(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;consumer-group&quot;</span>);</span><br><span class="line">properties.setProperty(<span class="string">&quot;key.deserializer&quot;</span>,</span><br><span class="line"><span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">properties.setProperty(<span class="string">&quot;value.deserializer&quot;</span>,</span><br><span class="line"><span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">properties.setProperty(<span class="string">&quot;auto.offset.reset&quot;</span>, <span class="string">&quot;latest&quot;</span>);</span><br><span class="line"><span class="comment">// 从 kafka 读取数据</span></span><br><span class="line">DataStream&lt;String&gt; dataStream = env.addSource( <span class="keyword">new</span></span><br><span class="line"><span class="title class_">FlinkKafkaConsumer011</span>&lt;String&gt;(<span class="string">&quot;sensor&quot;</span>, <span class="keyword">new</span> <span class="title class_">SimpleStringSchema</span>(), properties));</span><br></pre></td></tr></table></figure>



<h4 id="4-自定义Source"><a href="#4-自定义Source" class="headerlink" title="4. 自定义Source"></a>4. 自定义Source</h4><p>除了以上的source数据来源，我们还可以自定义source。需要做的，只是传入一个SourceFunction就可以了。具体调用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;SensorReading&gt; dataStream = env.addSource( <span class="keyword">new</span> <span class="title class_">MySensor</span>());</span><br></pre></td></tr></table></figure>

<p>测试例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yulu.apitest.source;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yulu.apitest.beans.SensorReading;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.MapFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStreamSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.SourceFunction;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span>  <span class="title class_">SourceTest2_UDF</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        DataStreamSource&lt;SensorReading&gt; data = env.addSource(<span class="keyword">new</span> <span class="title class_">MySourceFunction</span>());</span><br><span class="line">        SingleOutputStreamOperator&lt;String&gt; map = data.map(<span class="keyword">new</span> <span class="title class_">MapFunction</span>&lt;SensorReading, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">map</span><span class="params">(SensorReading sensorReading)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">tempStr</span> <span class="operator">=</span> sensorReading.getId() + <span class="string">&quot;: &quot;</span> + sensorReading.getTimestamp() + <span class="string">&quot;: &quot;</span> + sensorReading.getTemperature();</span><br><span class="line">                <span class="keyword">return</span> tempStr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        map.print(<span class="string">&quot;自定义数据源&quot;</span>);</span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySourceFunction</span> <span class="keyword">implements</span> <span class="title class_">SourceFunction</span>&lt;SensorReading&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Double&gt; sensorMap;</span><br><span class="line">    <span class="keyword">private</span> Random random;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MySourceFunction</span><span class="params">()</span>&#123;</span><br><span class="line">        sensorMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Double&gt;();</span><br><span class="line">        random = <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;sensor_&quot;</span>+(i+<span class="number">1</span>);</span><br><span class="line">            sensorMap.put(key, <span class="number">60</span> + random.nextGaussian() * <span class="number">20</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(SourceContext&lt;SensorReading&gt; sourceContext)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">for</span>(String key : sensorMap.keySet())&#123;</span><br><span class="line">                <span class="type">Double</span> <span class="variable">temp_value</span> <span class="operator">=</span> sensorMap.getOrDefault(key, <span class="number">0.0</span>) + random.nextGaussian();</span><br><span class="line">                sensorMap.put(key, temp_value);</span><br><span class="line">                <span class="type">Long</span> <span class="variable">timestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                sourceContext.collect(<span class="keyword">new</span> <span class="title class_">SensorReading</span>(key, timestamp, temp_value));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span> &#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h3><p>转换算子</p>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h4><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><h4 id="keyBy"><a href="#keyBy" class="headerlink" title="keyBy"></a>keyBy</h4><p>DataStream—》KeyedStream：逻辑地将一个流拆分成不相交的分区，每个分区包含具有相同key的元素，在内部以hash的形式实现的。</p>
<p>只有使用了分组转换算子之后，才可以使用聚合类算子</p>
<h4 id="滚动聚合算子"><a href="#滚动聚合算子" class="headerlink" title="滚动聚合算子"></a>滚动聚合算子</h4><h5 id="1-sum"><a href="#1-sum" class="headerlink" title="1. sum()"></a>1. sum()</h5><h5 id="2-min"><a href="#2-min" class="headerlink" title="2. min()"></a>2. min()</h5><h5 id="3-max"><a href="#3-max" class="headerlink" title="3. max()"></a>3. max()</h5><h5 id="4-minBy"><a href="#4-minBy" class="headerlink" title="4. minBy()"></a>4. minBy()</h5><h5 id="5-maxBy"><a href="#5-maxBy" class="headerlink" title="5. maxBy()"></a>5. maxBy()</h5><h5 id="6-Reduce"><a href="#6-Reduce" class="headerlink" title="6. Reduce"></a>6. Reduce</h5><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="多流转换算子"><a href="#多流转换算子" class="headerlink" title="多流转换算子"></a>多流转换算子</h4><h5 id="split-amp-select"><a href="#split-amp-select" class="headerlink" title="split&amp;select"></a>split&amp;select</h5><p><strong>DataStream</strong> —–》 <strong>SplitStream</strong>：根据某些特征把一个DataStream拆分成两个或者多个DataStream</p>
<p><img src="source/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Flink%20%E5%88%86%E6%B5%81.png" alt="Flink 分流"></p>
<p>SplitStream —-》 DataStream：从一个SplitStream中获取一个或者多个DataStream。</p>
<p><img src="source/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Flink%20%E5%90%88%E6%B5%81.png" alt="Flink 合流"></p>
<h5 id="connect-amp-coMap"><a href="#connect-amp-coMap" class="headerlink" title="connect&amp;coMap"></a>connect&amp;coMap</h5><p><img src="source/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Connect%E7%AE%97%E5%AD%90.jpg" alt="Connect算子"></p>
<p>DataStream —-》ConnectedStreams：连接两个保持他们类型的数据流（两条数据流类型可以不一致），两个数据流被Connect之后，只是被放在了同一个流中，内部依然各自保持各自的数据和形式不发生任何变化，两个流相互独立。</p>
<p><img src="source/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ConMap&ConflatMap.jpg" alt="ConMap&amp;ConflatMap"></p>
<p>ConnectedStreams  —–》 DataStream：作用于ConnectedStreams上，功能与map和flatMap一致，对ConnectedStreams中的每一个Stream分别进行map和flatMap处理。</p>
<p>其中传入的map方法会有两个，分别对应上述两个不同的流分别做各自的map处理。</p>
<h5 id="union"><a href="#union" class="headerlink" title="union"></a>union</h5><p><img src="source/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/union%E5%90%88%E6%B5%81.jpg" alt="union合流"></p>
<p>DataStream  —》 DataStream ： 对两个或者两个以上的DataStream进行union操作，产生一个包含所有DataStream元素的新DataStream</p>
<h5 id="Connect与Union的区别"><a href="#Connect与Union的区别" class="headerlink" title="Connect与Union的区别"></a>Connect与Union的区别</h5><ol>
<li>Union之前两个流的类型必须是一样的，Connect可以不一样，在之后的coMap中再去调整成一样的。</li>
<li>Connect只能操作两个流，Union可以操作多个。</li>
</ol>
<h4 id="支持的数据类型"><a href="#支持的数据类型" class="headerlink" title="支持的数据类型"></a>支持的数据类型</h4><p>Flink 流应用程序处理的是以数据对象表示的事件流。所以在 Flink 内部，我们 需要能够处理这些对象。它们需要被序列化和反序列化，以便通过网络传送它们； 或者从状态后端、检查点和保存点读取它们。为了有效地做到这一点，Flink 需要明 确知道应用程序所处理的数据类型。Flink 使用类型信息的概念来表示数据类型，并 为每个数据类型生成特定的序列化器、反序列化器和比较器。</p>
<p> Flink 还具有一个类型提取系统，该系统分析函数的输入和返回类型，以自动获 取类型信息，从而获得序列化器和反序列化器。但是，在某些情况下，例如 lambda 函数或泛型类型，需要显式地提供类型信息，才能使应用程序正常工作或提高其性 能。</p>
<p> Flink 支持 Java 和 Scala 中所有常见数据类型。使用最广泛的类型有以下几种。</p>
<h5 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h5><p>Flink支持所有的Java和Scala基础数据类型：Integer， Double， Long， String……..</p>
<h6 id="元组：Java和Scala中的元组（Tuples）"><a href="#元组：Java和Scala中的元组（Tuples）" class="headerlink" title="元组：Java和Scala中的元组（Tuples）"></a>元组：Java和Scala中的元组（Tuples）</h6><p>java中的元组类型是Flink中自己实现的，最多支持25个元素的Tuple</p>
<h6 id="Scala中的样例类（case-class）"><a href="#Scala中的样例类（case-class）" class="headerlink" title="Scala中的样例类（case class）"></a>Scala中的样例类（case class）</h6><h6 id="Java简单对象（POJOs）"><a href="#Java简单对象（POJOs）" class="headerlink" title="Java简单对象（POJOs）"></a>Java简单对象（POJOs）</h6><p><strong>JAVA  的 POJOs对象要求：</strong></p>
<ol>
<li>必须有空参构造方法</li>
<li>如果字段类型不是public，必须有getter和setter方法。</li>
</ol>
<h6 id="其他（Arrays，Lists，-Maps，-Enums等等）"><a href="#其他（Arrays，Lists，-Maps，-Enums等等）" class="headerlink" title="其他（Arrays，Lists， Maps， Enums等等）"></a>其他（Arrays，Lists， Maps， Enums等等）</h6><h4 id="实现UDF函数—-更细粒度的控制流"><a href="#实现UDF函数—-更细粒度的控制流" class="headerlink" title="实现UDF函数—-更细粒度的控制流"></a>实现UDF函数—-更细粒度的控制流</h4><h5 id="函数类（Function-Classes）"><a href="#函数类（Function-Classes）" class="headerlink" title="函数类（Function Classes）"></a>函数类（Function Classes）</h5><p>Flink暴露了所有的UDF函数的接口（实现方式为接口或者抽象类）。例如MapFunction，FillterFunction、ProcessFunction等等。</p>
<h5 id="匿名函数类（Lambda-Functions）"><a href="#匿名函数类（Lambda-Functions）" class="headerlink" title="匿名函数类（Lambda Functions）"></a>匿名函数类（Lambda Functions）</h5><p>（Lambda表达式）</p>
<h5 id="富函数（Rich-Functions）"><a href="#富函数（Rich-Functions）" class="headerlink" title="富函数（Rich Functions）"></a>富函数（Rich Functions）</h5><p>“富函数”是DataStream API提供的一个函数类的接口，所有Flink函数类都有其Rich版本。它与常规函数的不同在于，可以获取运行环境的上下文，并拥有一些生命周期方法，所以可以实现更复杂的功能。</p>
<ul>
<li>RichMapFunction</li>
<li>RichFlatMapFunction</li>
<li>RichFilterFunction</li>
<li>。。。。</li>
</ul>
<p>Rich Funntion有一个生命周期的概念。典型的声明周期方法有：</p>
<ul>
<li>open()方法是rich function的初始化方法，当一个算子例如map或者filter被调用之前open()会被调用。</li>
<li>close()方法是生命周期中的最后一个调用的方法，做一些清理工作</li>
<li>getRuntimeContext()方法提供了函数的RuntimeContext的一些信息，例如函数执行的并行度，任务的名字，以及state状态。</li>
</ul>
<h3 id="Sink"><a href="#Sink" class="headerlink" title="Sink"></a>Sink</h3><p>Flink没有类似于java中的foreach方法，让用户进行迭代的操作。虽然有对外的输出操作，但是都要利用Sink完成。最后通过类似如下方式完成任务的最终输出操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.addSink(<span class="keyword">new</span> <span class="title class_">MySink</span>(XXXX));</span><br></pre></td></tr></table></figure>













<h3 id="Window-API"><a href="#Window-API" class="headerlink" title="Window API"></a>Window API</h3><h4 id="window概述"><a href="#window概述" class="headerlink" title="window概述"></a>window概述</h4><p>streaming流式计算是一种被设计用于处理无限数据集的数据处理引擎，而无限数据集是指一种不断增长的本质上无限的数据集，而<strong>window</strong>是一种<strong>切割无限数据为有限块进行处理</strong>的手段。</p>
<p>window是无限数据流处理的核心，Window将一个无限的stream拆分成有限大小的“buckets”桶，我们可以在这些桶上做计算操作。</p>
<h4 id="窗口的声明周期"><a href="#窗口的声明周期" class="headerlink" title="窗口的声明周期"></a>窗口的声明周期</h4><p>简而言之，一旦应该属于这个窗口的第一个元素到达，就会创建一个窗口，并且当时间(这里的时间可分为两种：<strong>事件时间</strong>：EventTime或<strong>处理时间：ProcessTime</strong>)超过其结束时间戳和用户指定的允许迟到时间(参见允许迟到)时，该窗口将被完全删除。</p>
<p><strong>Flink 保证只对基于时间的窗口进行删除</strong>，而不对其他类型的窗口进行删除，例如全局窗口(参见窗口分配器)。</p>
<p>例如，使用基于<strong>事件时间</strong>的窗口策略，每5分钟创建一个不重叠(或滚动)窗口，并允许迟到1分钟，Flink 将为12:00到12:05之间的间隔创建一个新窗口，当时间戳为此间隔的第一个元素到达时，它将在水印通过12:06时间戳时删除它。</p>
<p>此外，每个窗口将有一个触发器(<strong>触发器</strong>)和一个函数(ProcessWindowFunction、 ReduceFunction 或 AggregateFunction)(<strong>窗口函数</strong>)附加到它。</p>
<p>该函数将包含应用于窗口内容的计算，而触发器指定窗口在何种条件下被认为已准备好应用该函数。触发策略可能类似于“<strong>当窗口中的元素数量超过4时</strong>”，或者“<strong>当水印通过窗口的末端时</strong>”。触发器也可以决定在窗口创建和移除之间的任何时间清除窗口的内容。在这种情况下，清除仅仅指向窗口中的元素，而不是窗口元数据。这意味着仍然可以向该窗口添加新数据。</p>
<p>除此之外，还可以指定一个 Evictor (类似于过滤器) ，它将能够在触发器触发之后以及应用函数之前和/或之后从窗口中移除元素。</p>
<h4 id="Keyed-vs-Non-Keyed-Windows-键控窗口与非键控窗口"><a href="#Keyed-vs-Non-Keyed-Windows-键控窗口与非键控窗口" class="headerlink" title="Keyed vs Non-Keyed Windows 键控窗口与非键控窗口"></a>Keyed vs Non-Keyed Windows 键控窗口与非键控窗口</h4><blockquote>
<p> The first thing to specify is whether your stream should be keyed or not. This has to be done before defining the window. Using the <code>keyBy(...)</code> will split your infinite stream into logical keyed streams. If <code>keyBy(...)</code> is not called, your stream is not keyed.</p>
<p>In the case of keyed streams, any attribute of your incoming events can be used as a key (more details <a target="_blank" rel="noopener" href="https://ci.apache.org/projects/flink/flink-docs-release-1.13/zh/docs/dev/datastream/fault-tolerance/state/#keyed-datastream">here</a>). Having a keyed stream will allow your windowed computation to be performed in parallel by multiple tasks, as each logical keyed stream can be processed independently from the rest. All elements referring to the same key will be sent to the same parallel task.</p>
<p>In case of non-keyed streams, your original stream will not be split into multiple logical streams and all the windowing logic will be performed by a single task, <em>i.e.</em> with parallelism of 1.</p>
</blockquote>
<h4 id="window类型"><a href="#window类型" class="headerlink" title="window类型"></a>window类型</h4><p>Window可以分成两种类型：</p>
<ul>
<li><strong>TimeWindow</strong>：按照时间生成Window（处理时间 、 时间时间）<ul>
<li>滚动时间窗口（Tumbling window）</li>
<li>滑动时间窗口（Sliding Window）</li>
<li>会话窗口（Session Window）</li>
</ul>
</li>
<li><strong>CountWindow</strong>：按照指定的数据条数生成一个Window，与时间无关。<ul>
<li>滚动计数窗口</li>
<li>滑动计数窗口</li>
</ul>
</li>
</ul>
<p>每种窗口类型下面都有一定相应的窗口分配器</p>
<h4 id="Window-Assigners-窗口分配器"><a href="#Window-Assigners-窗口分配器" class="headerlink" title="Window Assigners 窗口分配器"></a>Window Assigners 窗口分配器</h4><p>在指定流是否为键控之后，下一步就是定义窗口分配器。窗口分配器定义如何将元素分配给指定的窗口。这是通过在<code>.window(WindowAssigner)</code>调用中指定选择的<strong>WindowAssigner</strong>来实现的。</p>
<p><strong>Windowwassigner</strong> 负责将每个传入元素分配给一个或多个窗口。Flink 提供了预先定义的窗口分配，用于最常见的用例，即滚动窗口、滑动窗口、会话窗口和全局窗口。您还可以通过扩展 windowwassigner 类来实现自定义窗口分配器。所有内置的窗口分配器(全局窗口除外)根据时间将元素分配给窗口，可以是处理时间，也可以是事件时间。</p>
<p>基于时间的窗口有一个起始时间戳(包括起始时间戳)和一个结束时间戳(排他时间戳) ，它们共同描述了窗口的大小。在代码中，Flink 在处理基于时间的窗口时使用 <strong>TimeWindow</strong>，该窗口有查询开始和结束时间戳的方法，还有一个额外的方法 maxTimestamp () ，它返回给定窗口允许的最大时间戳。</p>
<h5 id="1-滚动窗口（Tumbling-Windows）"><a href="#1-滚动窗口（Tumbling-Windows）" class="headerlink" title="1. 滚动窗口（Tumbling Windows）"></a>1. 滚动窗口（Tumbling Windows）</h5><p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.13/fig/tumbling-windows.svg" alt="Tumbling Windows"></p>
<p>将数据依据固定的窗口长度对数据进行切片。（<strong>不指定步长，或者步长为窗口的宽度</strong>）</p>
<p><font color=green>其实本质上来讲，滚动窗口就是步长为窗口宽度的滑动窗口</font></p>
<p><strong>特点：</strong></p>
<blockquote>
<p>时间对其，窗口长度固定， 没有重叠。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;T&gt; input = ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于事件时间的滚动窗口分配器</span></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">5</span>)))</span><br><span class="line">    .&lt;windowed transformation&gt;(&lt;window funciton&gt;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于处理时间的滚动窗口分配器</span></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(TumblingProcessingTimeWindows.of(Time.seconds(<span class="number">5</span>)))</span><br><span class="line">    .&lt;windowed transformation&gt;(&lt;window funciton&gt;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// daily tumbling event-time windows offset by -8 hours.</span></span><br><span class="line"><span class="comment">// 指定窗口事件时间的偏移量</span></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(TumblingEventTimeWindows.of(Time.days(<span class="number">1</span>), Time.hours(-<span class="number">8</span>)))</span><br><span class="line">    .&lt;windowed transformation&gt;(&lt;window function&gt;);</span><br></pre></td></tr></table></figure>

<p>滚动窗口的of方法还提供了另外一个可选的参数：offset；这个参数可用于改变窗口的对其方式。</p>
<p>For example, without offsets hourly tumbling windows are aligned with epoch, that is you will get windows such as <code>1:00:00.000 - 1:59:59.999</code>, <code>2:00:00.000 - 2:59:59.999</code> and so on. If you want to change that you can give an offset. With an offset of 15 minutes you would, for example, get <code>1:15:00.000 - 2:14:59.999</code>, <code>2:15:00.000 - 3:14:59.999</code> etc. An important use case for offsets is to adjust windows to timezones other than UTC-0. For example, in China you would have to specify an offset of <code>Time.hours(-8)</code>.</p>
<p>可用此参数更改其他时区。</p>
<h5 id="2-滑动窗口（Sliding-Windows）"><a href="#2-滑动窗口（Sliding-Windows）" class="headerlink" title="2. 滑动窗口（Sliding Windows）"></a>2. 滑动窗口（Sliding Windows）</h5><p>The <em>sliding windows</em> assigner assigns elements to windows of fixed length. Similar to a tumbling windows assigner, the size of the windows is configured by the <em>window size</em> parameter. An additional <em>window slide</em> parameter controls how frequently a sliding window is started. Hence, sliding windows can be overlapping if the slide is smaller than the window size. In this case elements are assigned to multiple windows.</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.13/fig/sliding-windows.svg" alt="sliding windows"></p>
<p>这样，你可以有10分钟大小的窗口，可以滑动5分钟。有了这个，您每5分钟就会得到一个窗口，其中包含在过去10分钟内到达的事件，</p>
<p><font color=green>滑动窗口可以说是一种更为广义的一种窗口分配器，上述我们了解的滚动窗口其实质上就是滑动步长定滑动窗口宽度的一种滑动窗口。</font></p>
<p><strong>特点：</strong></p>
<blockquote>
<p>窗口长度固定， 可以有重叠</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;T&gt; input = ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sliding event-time windows</span></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(SlidingEventTimeWindows.of(Time.seconds(<span class="number">10</span>), Time.seconds(<span class="number">5</span>)))</span><br><span class="line">    .&lt;windowed transformation&gt;(&lt;window function&gt;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sliding processing-time windows</span></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(SlidingProcessingTimeWindows.of(Time.seconds(<span class="number">10</span>), Time.seconds(<span class="number">5</span>)))</span><br><span class="line">    .&lt;windowed transformation&gt;(&lt;window function&gt;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sliding processing-time windows offset by -8 hours</span></span><br><span class="line"><span class="comment">// 同理，依然可以传入一个偏移量，控制窗口的对齐时间</span></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(SlidingProcessingTimeWindows.of(Time.hours(<span class="number">12</span>), Time.hours(<span class="number">1</span>), Time.hours(-<span class="number">8</span>)))</span><br><span class="line">    .&lt;windowed transformation&gt;(&lt;window function&gt;);</span><br></pre></td></tr></table></figure>



<h5 id="3-会话窗口（Session-Windows）"><a href="#3-会话窗口（Session-Windows）" class="headerlink" title="3. 会话窗口（Session Windows）"></a>3. 会话窗口（Session Windows）</h5><p>会话窗口分配器按照会话对元素进行分窗。相比于滚动窗口与滑动窗口，会话窗口没有一个固定的开始时间和结束时间。</p>
<p>相反，当会话窗口在一段时间内没有接收到元素时，即出现非活动间隔时，它将关闭。会话窗口分配器可以配置为静态会话间隙或者会话间隙提取器函数，该函数定义了不活动的周期有多长。当此期限过期时，当前会话关闭，并将后续元素分配给新的会话窗口。</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.13/fig/session-windows.svg" alt="session windows"></p>
<p>由一系列事件组合一个指定时间长度的timeout间隙组成，也就是一段时间没有接收到新数据就会生成新的窗口</p>
<p><strong>特点：</strong></p>
<blockquote>
<p>时间无对齐</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;T&gt; input = ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// event-time session windows with static gap</span></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(EventTimeSessionWindows.withGap(Time.minutes(<span class="number">10</span>)))</span><br><span class="line">    .&lt;windowed transformation&gt;(&lt;window function&gt;);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// event-time session windows with dynamic gap</span></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(EventTimeSessionWindows.withDynamicGap((element) -&gt; &#123;</span><br><span class="line">        <span class="comment">// determine and return session gap</span></span><br><span class="line">    &#125;))</span><br><span class="line">    .&lt;windowed transformation&gt;(&lt;window function&gt;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// processing-time session windows with static gap</span></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(ProcessingTimeSessionWindows.withGap(Time.minutes(<span class="number">10</span>)))</span><br><span class="line">    .&lt;windowed transformation&gt;(&lt;window function&gt;);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// processing-time session windows with dynamic gap</span></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(ProcessingTimeSessionWindows.withDynamicGap((element) -&gt; &#123;</span><br><span class="line">        <span class="comment">// determine and return session gap</span></span><br><span class="line">    &#125;))</span><br><span class="line">    .&lt;windowed transformation&gt;(&lt;window function&gt;);</span><br></pre></td></tr></table></figure>

<p><font color=blue>特别说明:</font></p>
<p>由于会话窗口没有固定的开始和结束，它们的评估不同于滚动窗口和滑动窗口。在内部，会话窗口操作符会为每个到达的纪录<strong>创建一个新窗口</strong>，然后进行窗口之间的距离比对，如果距离比我们指定的间隔更近，就将两个窗口进行合并。</p>
<p>指定的最小间隔，可以通过实现<code>SessionWindowTimeGapExtractor </code>接口来动态指定间隔。</p>
<h5 id="4-全局窗口（Global-Windows）"><a href="#4-全局窗口（Global-Windows）" class="headerlink" title="4. 全局窗口（Global Windows）"></a>4. 全局窗口（Global Windows）</h5><p>A <em>global windows</em> assigner assigns all elements with the same key to the same single <em>global window</em>. This windowing scheme is only useful if you also specify a custom <a target="_blank" rel="noopener" href="https://ci.apache.org/projects/flink/flink-docs-release-1.13/zh/docs/dev/datastream/operators/windows/#triggers">trigger</a>. Otherwise, no computation will be performed, as the global window does not have a natural end at which we could process the aggregated elements.</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.13/fig/non-windowed.svg" alt="global windows"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;T&gt; input = ...;</span><br><span class="line"></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(GlobalWindows.create())</span><br><span class="line">    .&lt;windowed transformation&gt;(&lt;window function&gt;);</span><br></pre></td></tr></table></figure>



<h4 id="window-API节"><a href="#window-API节" class="headerlink" title="window API节"></a>window API节</h4><p>窗口函数：window()方法</p>
<blockquote>
<p>我们可以用window()来定义一个窗口，然后基于这个window去做一些聚合或者其他处理操作。</p>
<p><font color=red>但是需要注意：window()方法必须在keyBy()方法之后才能调用</font></p>
<p>Flink提供了更加简单的.timeWindow() 和 .countWindow()方法，用于定义时间窗口和计数窗口。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Tuple2&lt;String, Double&gt;&gt; minTempPerWindowStream = dataStream.map(<span class="keyword">new</span> <span class="title class_">MapFunction</span>&lt;&gt;&#123;.....&#125;).keyBy(data-&gt;data.f0)</span><br><span class="line">    .timeWindow(Time.seconds(<span class="number">15</span>))</span><br><span class="line">    .minBy(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h4 id="创建不同类型的窗口-简化版"><a href="#创建不同类型的窗口-简化版" class="headerlink" title="创建不同类型的窗口(简化版)"></a>创建不同类型的窗口(简化版)</h4><ul>
<li><p>滚动时间窗口（tumbling time window）</p>
<ul>
<li>```java<br>.timeWindow(Time.seconds(15))<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 滑动时间窗口（sliding time window）</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    .timeWindow(Time.second(15), Time.second(5))</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>会话窗口（Session window）</p>
<ul>
<li>```java<br>.window(EventTimeSessionWindows.withGap(Time.minutes(10)))<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 滚动计数窗口（tumbling count window）</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    .countWindow(5)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>滑动计数窗口（sliding count window）</p>
<ul>
<li>```java<br>.countWindow(10, 2)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 当窗口中的数据不足窗口长度的时候，每次满足步长就会产生一个窗口，相当于自动的往前补齐了10个元素；</span><br><span class="line"></span><br><span class="line">  - 当窗口中的数据满足了窗口长度的时候，就不会触发往前的自动补齐了。</span><br><span class="line"></span><br><span class="line">#### 窗口函数（window function）</span><br><span class="line"></span><br><span class="line">开窗之后就需要调用窗口函数来对窗口中收集的数据做计算操作</span><br><span class="line"></span><br><span class="line">窗口函数一般可分为两类：</span><br><span class="line"></span><br><span class="line">- 增量聚合函数（incremental aggregation function）</span><br><span class="line">  - 每条数据到来就进行计算，保持一个简单的状态</span><br><span class="line">  - **ReduceFunction**：聚合前后的类型需要保持一致</span><br><span class="line">  - **AggregateFunciton**：聚合前后的类型可以不一致，中间还多一个累加器acc</span><br><span class="line">- 全窗口函数（full window functions）</span><br><span class="line">  - 先把窗口所有数据收集起来，等到计算的时候会遍历所有数据</span><br><span class="line">  - **ProcessWindowFunction**</span><br><span class="line">  - **WindowFunction**</span><br><span class="line"></span><br><span class="line">##### ReduceFunction 增量窗口函数</span><br><span class="line"></span><br><span class="line">ReduceFunction 指定如何将输入中的两个元素组合起来，以生成同类型的输出元素。使用 ReduceFunction 增量聚合窗口的元素。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;</span><br><span class="line"></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(&lt;window assigner&gt;)</span><br><span class="line">    .reduce(new ReduceFunction&lt;Tuple2&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">      public Tuple2&lt;String, Long&gt; reduce(Tuple2&lt;String, Long&gt; v1, Tuple2&lt;String, Long&gt; v2) &#123;</span><br><span class="line">        return new Tuple2&lt;&gt;(v1.f0, v1.f1 + v2.f1);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">// 上面的示例总结了一个窗口中所有元素的元组的第二个字段的和。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h5 id="AggregateFunciton-增量窗口函数"><a href="#AggregateFunciton-增量窗口函数" class="headerlink" title="AggregateFunciton 增量窗口函数"></a>AggregateFunciton 增量窗口函数</h5><p>AggregateFunction 是 ReduceFunction 的通用版本，它有三种类型: 输入类型(IN)、累加器类型(ACC)和输出类型(OUT)。输入类型是输入流中元素的类型，而 AggregateFunction 有一个将一个输入元素添加到累加器的方法。该接口还具有用于创建初始累加器、将两个累加器合并为一个累加器以及从累加器中提取输出(OUT 类型)的方法。</p>
<p>和 ReduceFunction 一样，AggregateFunction  会在窗口的输入元素到达时增量地聚合它们。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The accumulator is used to keep a running sum and a count. The &#123;<span class="doctag">@code</span> getResult&#125; method</span></span><br><span class="line"><span class="comment"> * computes the average.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AverageAggregate</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">AggregateFunction</span>&lt;Tuple2&lt;String, Long&gt;, Tuple2&lt;Long, Long&gt;, Double&gt; &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Tuple2&lt;Long, Long&gt; <span class="title function_">createAccumulator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(<span class="number">0L</span>, <span class="number">0L</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Tuple2&lt;Long, Long&gt; <span class="title function_">add</span><span class="params">(Tuple2&lt;String, Long&gt; value, Tuple2&lt;Long, Long&gt; accumulator)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(accumulator.f0 + value.f1, accumulator.f1 + <span class="number">1L</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Double <span class="title function_">getResult</span><span class="params">(Tuple2&lt;Long, Long&gt; accumulator)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">double</span>) accumulator.f0) / accumulator.f1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Tuple2&lt;Long, Long&gt; <span class="title function_">merge</span><span class="params">(Tuple2&lt;Long, Long&gt; a, Tuple2&lt;Long, Long&gt; b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(a.f0 + b.f0, a.f1 + b.f1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;</span><br><span class="line"></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(&lt;window assigner&gt;)</span><br><span class="line">    .aggregate(<span class="keyword">new</span> <span class="title class_">AverageAggregate</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的示例计算窗口中元素的第二个字段的平均值。</span></span><br></pre></td></tr></table></figure>



<h5 id="ProcessWindowFunction-全量窗口函数"><a href="#ProcessWindowFunction-全量窗口函数" class="headerlink" title="ProcessWindowFunction 全量窗口函数"></a>ProcessWindowFunction 全量窗口函数</h5><p>一个 ProcessWindowFunction 获得一个包含窗口所有元素的 Iterable，以及一个访问时间和状态信息的 Context 对象，这使得它比其他窗口函数提供更多的灵活性。这是以性能和资源消耗为代价的，因为不能对元素进行递增聚合，而是需要在内部缓冲，直到认为可以处理窗口为止。</p>
<p>内部定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ProcessWindowFunction</span>&lt;IN, OUT, KEY, W <span class="keyword">extends</span> <span class="title class_">Window</span>&gt; <span class="keyword">implements</span> <span class="title class_">Function</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Evaluates the window and outputs none or several elements.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key The key for which this window is evaluated.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context The context in which the window is being evaluated.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> elements The elements in the window being evaluated.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out A collector for emitting elements.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception The function may throw exceptions to fail the program and trigger recovery.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(</span></span><br><span class="line"><span class="params">            KEY key,</span></span><br><span class="line"><span class="params">            Context context,</span></span><br><span class="line"><span class="params">            Iterable&lt;IN&gt; elements,</span></span><br><span class="line"><span class="params">            Collector&lt;OUT&gt; out)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">/**</span></span><br><span class="line"><span class="comment">   	 * The context holding window metadata.</span></span><br><span class="line"><span class="comment">   	 */</span></span><br><span class="line">   	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Context</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">   	    <span class="comment">/**</span></span><br><span class="line"><span class="comment">   	     * Returns the window that is being evaluated.</span></span><br><span class="line"><span class="comment">   	     */</span></span><br><span class="line">   	    <span class="keyword">public</span> <span class="keyword">abstract</span> W <span class="title function_">window</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   	    <span class="comment">/** Returns the current processing time. */</span></span><br><span class="line">   	    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">long</span> <span class="title function_">currentProcessingTime</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   	    <span class="comment">/** Returns the current event-time watermark. */</span></span><br><span class="line">   	    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">long</span> <span class="title function_">currentWatermark</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   	    <span class="comment">/**</span></span><br><span class="line"><span class="comment">   	     * State accessor for per-key and per-window state.</span></span><br><span class="line"><span class="comment">   	     *</span></span><br><span class="line"><span class="comment">   	     * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt;If you use per-window state you have to ensure that you clean it up</span></span><br><span class="line"><span class="comment">   	     * by implementing &#123;<span class="doctag">@link</span> ProcessWindowFunction#clear(Context)&#125;.</span></span><br><span class="line"><span class="comment">   	     */</span></span><br><span class="line">   	    <span class="keyword">public</span> <span class="keyword">abstract</span> KeyedStateStore <span class="title function_">windowState</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   	    <span class="comment">/**</span></span><br><span class="line"><span class="comment">   	     * State accessor for per-key global state.</span></span><br><span class="line"><span class="comment">   	     */</span></span><br><span class="line">   	    <span class="keyword">public</span> <span class="keyword">abstract</span> KeyedStateStore <span class="title function_">globalState</span><span class="params">()</span>;</span><br><span class="line">   	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>key参数是通过为 keyBy ()调用指定的 KeySelector 提取的key。在元组索引键或字符串字段引用的情况下，该键类型始终是 Tuple，您必须手动将其转换为大小正确的元组以提取key字段。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;</span><br><span class="line"></span><br><span class="line">input</span><br><span class="line">  .keyBy(t -&gt; t.f0)</span><br><span class="line">  .window(TumblingEventTimeWindows.of(Time.minutes(<span class="number">5</span>)))</span><br><span class="line">  .process(<span class="keyword">new</span> <span class="title class_">MyProcessWindowFunction</span>());  <span class="comment">// 通过调用process方法调用ProcessWindowFunction全量窗口函数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyProcessWindowFunction</span> </span><br><span class="line">    <span class="comment">// 泛型的类型： 输入类型， 输出类型， key的类型， window类型</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">ProcessWindowFunction</span>&lt;Tuple2&lt;String, Long&gt;, String, String, TimeWindow&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(String key, Context context, Iterable&lt;Tuple2&lt;String, Long&gt;&gt; input, Collector&lt;String&gt; out)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Tuple2&lt;String, Long&gt; in: input) &#123;</span><br><span class="line">      count++;</span><br><span class="line">    &#125;</span><br><span class="line">    out.collect(<span class="string">&quot;Window: &quot;</span> + context.window() + <span class="string">&quot;count: &quot;</span> + count);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该示例显示了计算窗口中元素数量的 ProcessWindowFunction。此外，window 函数将有关窗口的信息添加到输出中。</p>
<p><font color=green>这种全量的窗口函数非常耗费资源，计算的过程中需要保持这个窗口的所有元素。</font></p>
<h6 id="具有增量功能的ProcessWindowFunction函数"><a href="#具有增量功能的ProcessWindowFunction函数" class="headerlink" title="具有增量功能的ProcessWindowFunction函数"></a>具有增量功能的ProcessWindowFunction函数</h6><p>ProcessWindowFunction可以与ReduceFunction或者AggregateFunction组合，以便在元素到达窗口时对其进行增量聚合。当窗口关闭时，ProcessWindowFunction将提供聚合结果。这允许在访问ProcessWindowFunction的附加窗口元信息时增量计算窗口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;SensorReading&gt; input = ...;</span><br><span class="line"></span><br><span class="line">input</span><br><span class="line">  .keyBy(&lt;key selector&gt;)</span><br><span class="line">  .window(&lt;window assigner&gt;)</span><br><span class="line">  .reduce(<span class="keyword">new</span> <span class="title class_">MyReduceFunction</span>(), <span class="keyword">new</span> <span class="title class_">MyProcessWindowFunction</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function definitions</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyReduceFunction</span> <span class="keyword">implements</span> <span class="title class_">ReduceFunction</span>&lt;SensorReading&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> SensorReading <span class="title function_">reduce</span><span class="params">(SensorReading r1, SensorReading r2)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> r1.value() &gt; r2.value() ? r2 : r1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyProcessWindowFunction</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">ProcessWindowFunction</span>&lt;SensorReading, Tuple2&lt;Long, SensorReading&gt;, String, TimeWindow&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(String key,</span></span><br><span class="line"><span class="params">                    Context context,</span></span><br><span class="line"><span class="params">                    Iterable&lt;SensorReading&gt; minReadings,</span></span><br><span class="line"><span class="params">                    Collector&lt;Tuple2&lt;Long, SensorReading&gt;&gt; out)</span> &#123;</span><br><span class="line">      <span class="type">SensorReading</span> <span class="variable">min</span> <span class="operator">=</span> minReadings.iterator().next();</span><br><span class="line">      out.collect(<span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;Long, SensorReading&gt;(context.window().getStart(), min));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;</span><br><span class="line"></span><br><span class="line">input</span><br><span class="line">  .keyBy(&lt;key selector&gt;)</span><br><span class="line">  .window(&lt;window assigner&gt;)</span><br><span class="line">  .aggregate(<span class="keyword">new</span> <span class="title class_">AverageAggregate</span>(), <span class="keyword">new</span> <span class="title class_">MyProcessWindowFunction</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function definitions</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The accumulator is used to keep a running sum and a count. The &#123;<span class="doctag">@code</span> getResult&#125; method</span></span><br><span class="line"><span class="comment"> * computes the average.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AverageAggregate</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">AggregateFunction</span>&lt;Tuple2&lt;String, Long&gt;, Tuple2&lt;Long, Long&gt;, Double&gt; &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Tuple2&lt;Long, Long&gt; <span class="title function_">createAccumulator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(<span class="number">0L</span>, <span class="number">0L</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Tuple2&lt;Long, Long&gt; <span class="title function_">add</span><span class="params">(Tuple2&lt;String, Long&gt; value, Tuple2&lt;Long, Long&gt; accumulator)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(accumulator.f0 + value.f1, accumulator.f1 + <span class="number">1L</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Double <span class="title function_">getResult</span><span class="params">(Tuple2&lt;Long, Long&gt; accumulator)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">double</span>) accumulator.f0) / accumulator.f1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Tuple2&lt;Long, Long&gt; <span class="title function_">merge</span><span class="params">(Tuple2&lt;Long, Long&gt; a, Tuple2&lt;Long, Long&gt; b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(a.f0 + b.f0, a.f1 + b.f1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyProcessWindowFunction</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">ProcessWindowFunction</span>&lt;Double, Tuple2&lt;String, Double&gt;, String, TimeWindow&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(String key,</span></span><br><span class="line"><span class="params">                    Context context,</span></span><br><span class="line"><span class="params">                    Iterable&lt;Double&gt; averages,</span></span><br><span class="line"><span class="params">                    Collector&lt;Tuple2&lt;String, Double&gt;&gt; out)</span> &#123;</span><br><span class="line">      <span class="type">Double</span> <span class="variable">average</span> <span class="operator">=</span> averages.iterator().next();</span><br><span class="line">      out.collect(<span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(key, average));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="Window-Function（旧版本）"><a href="#Window-Function（旧版本）" class="headerlink" title="Window Function（旧版本）"></a>Window Function（旧版本）</h5><p>在一些可以使用 ProcessWindowFunction 的地方，您也可以使用 WindowFunction。这是 ProcessWindowFunction 的较老版本，它提供的上下文信息较少，并且没有一些先进的特性，比如按窗口键控状态。此接口将在某个时候被弃用。</p>
<p>定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WindowFunction</span>&lt;IN, OUT, KEY, W <span class="keyword">extends</span> <span class="title class_">Window</span>&gt; <span class="keyword">extends</span> <span class="title class_">Function</span>, Serializable &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Evaluates the window and outputs none or several elements.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key The key for which this window is evaluated.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> window The window that is being evaluated.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> input The elements in the window being evaluated.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> out A collector for emitting elements.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception The function may throw exceptions to fail the program and trigger recovery.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(KEY key, W window, Iterable&lt;IN&gt; input, Collector&lt;OUT&gt; out)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Tuple2&lt;String, Long&gt;&gt; input = ...;</span><br><span class="line"></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(&lt;window assigner&gt;)</span><br><span class="line">    .apply(<span class="keyword">new</span> <span class="title class_">MyWindowFunction</span>());</span><br></pre></td></tr></table></figure>







<h4 id="其他可选API"><a href="#其他可选API" class="headerlink" title="其他可选API"></a>其他可选API</h4><h5 id="触发器Trigger"><a href="#触发器Trigger" class="headerlink" title="触发器Trigger"></a>触发器Trigger</h5><p>A <code>Trigger</code> determines when a window (as formed by the <em>window assigner</em>) is ready to be processed by the <em>window function</em>. Each <code>WindowAssigner</code> comes with a default <code>Trigger</code>. If the default trigger does not fit your needs, you can specify a custom trigger using <code>trigger(...)</code>.</p>
<p>触发器确定窗口(由窗口分配者形成)什么时候可以被窗口函数处理。每个 windowwassigner 都有一个默认触发器。如果默认触发器不符合您的需要，可以使用<code>trigger(...)</code>方法指定自定义触发器。</p>
<p>触发器接口有5个方法，允许触发器对不同的事件做出反应：</p>
<ul>
<li>The  <code>onElement()</code> method is called for each element that is added to a window.  对于添加到窗口中的每个元素，都会调用</li>
<li>The <code>onEventTime()</code> method is called when a registered event-time timer fires. 当注册的事件时间计时器 触发时，调用</li>
<li>The <code>onProcessingTime()</code> method is called when a registered processing-time timer fires. 当注册的处理时间计时器触发时，调用</li>
<li>The <code>onMerge()</code> method is relevant for stateful triggers and merges the states of two triggers when their corresponding windows merge, 方法与有状态触发器相关，并在两个触发器对应的窗口合并时合并它们的状态,<em>e.g. 例如:</em> when using session windows. 当使用会话窗口时</li>
<li>The <code>clear()</code> method performs any action needed upon removal of the corresponding window. 方法在移除相应的窗口时执行所需的任何操作</li>
</ul>
<h5 id="-1"><a href="#-1" class="headerlink" title=""></a></h5><h5 id="evictor-——移除器"><a href="#evictor-——移除器" class="headerlink" title="evictor()——移除器"></a>evictor()——移除器</h5><p>定义移除某些数据的逻辑</p>
<h5 id="allowedLateness-——允许处理迟到的数据"><a href="#allowedLateness-——允许处理迟到的数据" class="headerlink" title=".allowedLateness()——允许处理迟到的数据"></a>.allowedLateness()——允许处理迟到的数据</h5><p>在使用事件时间窗口时，可能会发生元素延迟到达的情况，例如，Flink 用于跟踪事件时间进度的水印已经超过了元素所属窗口的结束时间戳。查看事件时间，特别是后期元素，可以更彻底地讨论 Flink 如何处理事件时间。</p>
<p>默认情况下，当水印超过窗口的末尾时，后期元素将被删除。但是，flink 允许指定窗口操作符允许的最大迟到时间。允许迟到指定元素在被删除之前可以迟到多少时间，其默认值为0。在水印通过窗口末端之后、但在通过窗口末端之前以及允许的迟到之后到达的元素仍然添加到窗口中。根据所使用的触发器，延迟但未删除的元素可能会导致窗口再次启动。这是 EventTimeTrigger 的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;T&gt; input = ...;</span><br><span class="line"></span><br><span class="line">input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(&lt;window assigner&gt;)</span><br><span class="line">    .allowedLateness(&lt;time&gt;)</span><br><span class="line">    .&lt;windowed transformation&gt;(&lt;window function&gt;);</span><br></pre></td></tr></table></figure>



<h5 id="sideOutputLateData-——将迟到的数据放入侧输出流"><a href="#sideOutputLateData-——将迟到的数据放入侧输出流" class="headerlink" title=".sideOutputLateData()——将迟到的数据放入侧输出流"></a>.sideOutputLateData()——将迟到的数据放入侧输出流</h5><p>因为仅仅是设置了延迟时间也不能保证所有的数据都会如期的达到，例如实习生产环境消息会积压，造成消息延迟一天都是有可能的。但是我们不能直接把允许的延迟时间调的很大，这样很耗性能。</p>
<p><font color=green>侧输出流就是一个很好的兜底方案</font></p>
<p>侧输出流可以获得一个数据流，这些数据已经被丢弃了（或者可以说是水印超过了窗口的最大时间限制，被丢弃的数据）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> OutputTag&lt;T&gt; lateOutputTag = <span class="keyword">new</span> <span class="title class_">OutputTag</span>&lt;T&gt;(<span class="string">&quot;late-data&quot;</span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">DataStream&lt;T&gt; input = ...;</span><br><span class="line"></span><br><span class="line">SingleOutputStreamOperator&lt;T&gt; result = input</span><br><span class="line">    .keyBy(&lt;key selector&gt;)</span><br><span class="line">    .window(&lt;window assigner&gt;)</span><br><span class="line">    .allowedLateness(&lt;time&gt;)</span><br><span class="line">    .sideOutputLateData(lateOutputTag)</span><br><span class="line">    .&lt;windowed transformation&gt;(&lt;window function&gt;);</span><br><span class="line"></span><br><span class="line">DataStream&lt;T&gt; lateStream = result.getSideOutput(lateOutputTag); <span class="comment">// 从已经处理完的结果中获取侧输出流</span></span><br></pre></td></tr></table></figure>

<h4 id="处理窗口结果"><a href="#处理窗口结果" class="headerlink" title="处理窗口结果"></a>处理窗口结果</h4><h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><p><strong>Keyed Windows</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stream</span><br><span class="line">       .keyBy(...)               &lt;-  keyed versus non-keyed windows</span><br><span class="line">       .window(...)              &lt;-  required: <span class="string">&quot;assigner&quot;</span></span><br><span class="line">      [.trigger(...)]            &lt;-  optional: <span class="string">&quot;trigger&quot;</span> (<span class="keyword">else</span> <span class="keyword">default</span> trigger)</span><br><span class="line">      [.evictor(...)]            &lt;-  optional: <span class="string">&quot;evictor&quot;</span> (<span class="keyword">else</span> no evictor)</span><br><span class="line">      [.allowedLateness(...)]    &lt;-  optional: <span class="string">&quot;lateness&quot;</span> (<span class="keyword">else</span> zero)</span><br><span class="line">      [.sideOutputLateData(...)] &lt;-  optional: <span class="string">&quot;output tag&quot;</span> (<span class="keyword">else</span> no side output <span class="keyword">for</span> late data)</span><br><span class="line">       .reduce/aggregate/apply()      &lt;-  required: <span class="string">&quot;function&quot;</span></span><br><span class="line">      [.getSideOutput(...)]      &lt;-  optional: <span class="string">&quot;output tag&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>Non-Keyed Windows</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">stream</span><br><span class="line">       .windowAll(...)           &lt;-  required: <span class="string">&quot;assigner&quot;</span></span><br><span class="line">      [.trigger(...)]            &lt;-  optional: <span class="string">&quot;trigger&quot;</span> (<span class="keyword">else</span> <span class="keyword">default</span> trigger)</span><br><span class="line">      [.evictor(...)]            &lt;-  optional: <span class="string">&quot;evictor&quot;</span> (<span class="keyword">else</span> no evictor)</span><br><span class="line">      [.allowedLateness(...)]    &lt;-  optional: <span class="string">&quot;lateness&quot;</span> (<span class="keyword">else</span> zero)</span><br><span class="line">      [.sideOutputLateData(...)] &lt;-  optional: <span class="string">&quot;output tag&quot;</span> (<span class="keyword">else</span> no side output <span class="keyword">for</span> late data)</span><br><span class="line">       .reduce/aggregate/apply()      &lt;-  required: <span class="string">&quot;function&quot;</span></span><br><span class="line">      [.getSideOutput(...)]      &lt;-  optional: <span class="string">&quot;output tag&quot;</span></span><br></pre></td></tr></table></figure>





<h2 id="Flink中的时间语义与WaterMark"><a href="#Flink中的时间语义与WaterMark" class="headerlink" title="Flink中的时间语义与WaterMark"></a>Flink中的时间语义与WaterMark</h2><p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.13/fig/event_processing_time.svg" alt="Event Time and Processing Time"></p>
<p>在Flink的流式处理中，会涉及到时间的不同概念，如上图：</p>
<ul>
<li><strong>Event Time</strong>：是事件创建的时间。它通常有事件中的时间戳描述，例如采集的日志数据中，每条日志都会记录自己的生成时间，Flink通过时间戳分配访问事件时间戳。</li>
<li><strong>Ingestion(摄食，吸收，吞入) Time</strong>：是数据进入Flink的时间。</li>
<li><strong>Processing Time</strong>：是每一个执行基于时间操作的算子的本地系统时间，与机器相关，flink1.2之前默认的时间属性就是Process Time。</li>
</ul>
<p>举个例子来区分Event time  和 Processing Time：星球大战</p>
<p><img src="source/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BA%8B%E4%BB%B6%E6%97%B6%E9%97%B4%20&%20%E5%A4%84%E7%90%86%E6%97%B6%E9%97%B4.png" alt="事件时间 &amp; 处理时间"></p>
<p>在例如：一条日志进入Flink的时间为10:00:000.123， 到达Window的系统时间为10:00:01:123</p>
<p>对于业务来说，要统计1min内的故障日志个数，哪个时间最有意义？——当然是eventTime，因为我们要根据日志的生成时间进行统计。</p>
<p>在Flink的流式处理中，绝大部分的业务都会使用eventTime，一般只在eventTime无法使用时，才会被迫使用ProcessingTime或者IngestionTime。</p>
<p>如果要使用EventTime，那么需要引入EventTime的时间属性，引入方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)</span><br></pre></td></tr></table></figure>

<p><font color=green>但是上述设置EventTime的操作在1.12版本之后就变成了默认</font></p>
<p><strong>乱序数据的影响</strong></p>
<p><img src="source/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B9%B1%E5%BA%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%BD%B1%E5%93%8D%EF%BC%88%E9%A1%BA%E5%BA%8F%E6%95%B0%E6%8D%AE%EF%BC%89.png" alt="乱序数据的影响（顺序数据）"></p>
<p><img src="source/Flink%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%B9%B1%E5%BA%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%BD%B1%E5%93%8D%EF%BC%88%E4%B9%B1%E5%BA%8F%E6%95%B0%E6%8D%AE%EF%BC%89.png" alt="乱序数据的影响（乱序数据）"></p>
<ul>
<li>当Flink以Event Time模式处理数据流时，它会根据数据里的时间戳来处理基于时间的算子</li>
<li>由于网络、分布式等原因，会导致乱序数据的产生</li>
<li>乱序数据会让窗口计算不准确</li>
</ul>
<p>因此Flink为解决乱序数据的情况，引入了重要的<strong>WaterMark</strong></p>
<h3 id="WaterMark"><a href="#WaterMark" class="headerlink" title="WaterMark"></a>WaterMark</h3><p>支持事件时间的流处理器需要一种方法来度量事件时间的进度， 以便窗口能够根据事件时间的进度决定是否关闭窗口。</p>
<p>在Flink中测量事件时间进度的机制就是<strong>watermark</strong>（水印/水位线）。watermark会作为输入流的一部分数据进行流动，并带有时间戳t；这个时间戳t表示事件时间在流中到达的时间（或者称之为事件时间的进度）；这就意味着，<strong>watermark</strong>所带的这个时间戳t之前的事件时间到达时间都要<strong>小于等于</strong>这个时间戳t(即时间所带的时间戳早于或等于水印watermark的时间戳)</p>
<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.13/fig/stream_watermark_out_of_order.svg" alt="A data stream with events (out of order) and watermarks"></p>
<p>水印对于无序流至关重要，如上述图所示：w(11)watermark 代表时间戳小于11的事件时间都已经达到了。</p>
<p><font color=green>自我理解：watermark就是事件时间戳的时间戳。</font></p>
<p>每个事件或者流入flink中的每个元素都可能带有这个事件时间，而watermark就是事件时间戳的时间戳，不过对于无序来说，这个时间戳是递增的。</p>
<img src=".\图片\watermark处理乱序数据.png" alt="watermark处理乱序数据" style="zoom:80%;" />

<p>举个例子：如上述图</p>
<p>窗口大小为4s， watermark延迟时间为2s；</p>
<p>其窗口关闭的时机是在watermark为4的时候，第一个窗口才会关闭。</p>
<h3 id="WaterMark-Strategy（水印策略）"><a href="#WaterMark-Strategy（水印策略）" class="headerlink" title="WaterMark Strategy（水印策略）"></a>WaterMark Strategy（水印策略）</h3><p>为了处理事件时间，Flink需要知道事件时间戳，这就意味着流中的每个元素都需要分配其事件时间戳。1.12版本之后，通常通过使用<strong>TimestampAssigner</strong>从元素中的某个字段提取时间戳来完成。</p>
<p>时间戳分配与生成水印watermark密切相关，matermark告诉系统事件时间的进度。可以通过指定一个<strong>WatermarkGenerator</strong>来配置watermark。</p>
<p>Flik API 期望一个同时包含 TimestampAssigner 和 WatermarkGenerator 的 <strong>WatermarkStrategy</strong>。一些常见的策略可以作为 WatermarkStrategy 的静态方法开箱即用，但用户也可以在需要时构建自己的策略。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.flink.api.common.eventtime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.annotation.Public;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.eventtime.WatermarkGeneratorSupplier.Context;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Preconditions;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Public</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WatermarkStrategy</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">TimestampAssignerSupplier</span>&lt;T&gt;, WatermarkGeneratorSupplier&lt;T&gt; &#123;</span><br><span class="line">    WatermarkGenerator&lt;T&gt; <span class="title function_">createWatermarkGenerator</span><span class="params">(Context var1)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> TimestampAssigner&lt;T&gt; <span class="title function_">createTimestampAssigner</span><span class="params">(org.apache.flink.api.common.eventtime.TimestampAssignerSupplier.Context context)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RecordTimestampAssigner</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> WatermarkStrategy&lt;T&gt; <span class="title function_">withTimestampAssigner</span><span class="params">(TimestampAssignerSupplier&lt;T&gt; timestampAssigner)</span> &#123;</span><br><span class="line">        Preconditions.checkNotNull(timestampAssigner, <span class="string">&quot;timestampAssigner&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WatermarkStrategyWithTimestampAssigner</span>(<span class="built_in">this</span>, timestampAssigner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> WatermarkStrategy&lt;T&gt; <span class="title function_">withTimestampAssigner</span><span class="params">(SerializableTimestampAssigner&lt;T&gt; timestampAssigner)</span> &#123;</span><br><span class="line">        Preconditions.checkNotNull(timestampAssigner, <span class="string">&quot;timestampAssigner&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WatermarkStrategyWithTimestampAssigner</span>(<span class="built_in">this</span>, TimestampAssignerSupplier.of(timestampAssigner));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> WatermarkStrategy&lt;T&gt; <span class="title function_">withIdleness</span><span class="params">(Duration idleTimeout)</span> &#123;</span><br><span class="line">        Preconditions.checkNotNull(idleTimeout, <span class="string">&quot;idleTimeout&quot;</span>);</span><br><span class="line">        Preconditions.checkArgument(!idleTimeout.isZero() &amp;&amp; !idleTimeout.isNegative(), <span class="string">&quot;idleTimeout must be greater than zero&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WatermarkStrategyWithIdleness</span>(<span class="built_in">this</span>, idleTimeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; WatermarkStrategy&lt;T&gt; <span class="title function_">forMonotonousTimestamps</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (ctx) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AscendingTimestampsWatermarks</span>();</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; WatermarkStrategy&lt;T&gt; <span class="title function_">forBoundedOutOfOrderness</span><span class="params">(Duration maxOutOfOrderness)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (ctx) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BoundedOutOfOrdernessWatermarks</span>(maxOutOfOrderness);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; WatermarkStrategy&lt;T&gt; <span class="title function_">forGenerator</span><span class="params">(WatermarkGeneratorSupplier&lt;T&gt; generatorSupplier)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> generatorSupplier::createWatermarkGenerator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; WatermarkStrategy&lt;T&gt; <span class="title function_">noWatermarks</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (ctx) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NoWatermarksGenerator</span>();</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>正如前面提到的，通常不会自己实现这个接口，而是使用WaterMarkStrategy上的静态辅助方法来实现常见的水印策略，或者将定制的TimestampAssigner和WaterMarkGenerator绑定在一起。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WaterMarkStrategy</span><br><span class="line">    .&lt;Tuple2&lt;Long, String&gt;&gt;forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">20</span>))</span><br><span class="line">    .withTiemstampAssigner((event, timestamp)-&gt;event.f0);</span><br></pre></td></tr></table></figure>

<p>使用WatermarkStrategy这种方法获取一个流，并生成一个带有时间戳元素和水印的新流。如果原始流已经具有时间戳/水印，时间戳分配器将覆盖他们。</p>
<h3 id="Dealing-With-Idle-Sources（处理闲置资源）"><a href="#Dealing-With-Idle-Sources（处理闲置资源）" class="headerlink" title="Dealing With Idle Sources（处理闲置资源）"></a>Dealing With Idle Sources（处理闲置资源）</h3><p>如果其中一个输入（分区）有一段时间不携带任何事件，这意味着waterMark Generator也不能获得任何新的信息来源为水印做基础。这种情况我们称之为空闲输入（空闲源）。这是一个问题，因为一些分区可能仍然带有事件，但是最小的水印可能会保持不变，下游任务的水印就不会改变。</p>
<p>为了解决这个问题，可以使用一个WaterMaterStrategy来检测闲置状态并将输入标记为空闲。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WatermarkStrategy</span><br><span class="line">        .&lt;Tuple2&lt;Long, String&gt;&gt;forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">20</span>))</span><br><span class="line">        .withIdleness(Duration.ofMinutes(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>



<h3 id="水印生成器WaterMark-Generator"><a href="#水印生成器WaterMark-Generator" class="headerlink" title="水印生成器WaterMark Generator"></a>水印生成器WaterMark Generator</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@code</span> WatermarkGenerator&#125; generates watermarks either based on events or</span></span><br><span class="line"><span class="comment"> * periodically (in a fixed interval).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; This WatermarkGenerator subsumes the previous distinction between the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> AssignerWithPunctuatedWatermarks&#125; and the &#123;<span class="doctag">@code</span> AssignerWithPeriodicWatermarks&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Public</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WatermarkGenerator</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called for every event, allows the watermark generator to examine </span></span><br><span class="line"><span class="comment">     * and remember the event timestamps, or to emit a watermark based on</span></span><br><span class="line"><span class="comment">     * the event itself.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(T event, <span class="type">long</span> eventTimestamp, WatermarkOutput output)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called periodically, and might emit a new watermark, or not.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The interval in which this method is called and Watermarks </span></span><br><span class="line"><span class="comment">     * are generated depends on &#123;<span class="doctag">@link</span> ExecutionConfig#getAutoWatermarkInterval()&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onPeriodicEmit</span><span class="params">(WatermarkOutput output)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>waterMark的生成有两种不同的方式：<strong>周期性水印（periodic）</strong>  和 <strong>间断性水印（punctuated）</strong></p>
<p>周期性生成器通常通过onEvent()观察传入的事件， 然后框架调用onPeriodicEmit()时发出水印。</p>
<p>Puncutated 生成器将查看 onEvent ()中的事件，并等待在流中携带水印信息的特殊标记事件或标点。当它看到这些事件中的一个时，它会立即发出水印。通常，间断性生成器不会从 onPeriodicEmit ()发出水印。</p>
<h4 id="自定义周期性watermark生成器"><a href="#自定义周期性watermark生成器" class="headerlink" title="自定义周期性watermark生成器"></a>自定义周期性watermark生成器</h4><p>周期生成器定期地观察流事件并生成水印(可能取决于流元素，也可能纯粹取决于处理时间)。</p>
<p>生成水印的时间间隔(每 n 毫秒)是通过 ExecutionConfig.setAutoWatermarkInterval (…)定义的。每次都会调用生成器的 onPeriodicEmit ()方法<strong>，如果返回的水印非空且大于以前的水印，则会发出新的水印</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This generator generates watermarks assuming that elements arrive out of order,</span></span><br><span class="line"><span class="comment"> * but only to a certain degree. The latest elements for a certain timestamp t will arrive</span></span><br><span class="line"><span class="comment"> * at most n milliseconds after the earliest elements for timestamp t.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoundedOutOfOrdernessGenerator</span> <span class="keyword">implements</span> <span class="title class_">WatermarkGenerator</span>&lt;MyEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">maxOutOfOrderness</span> <span class="operator">=</span> <span class="number">3500</span>; <span class="comment">// 3.5 seconds</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> currentMaxTimestamp;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(MyEvent event, <span class="type">long</span> eventTimestamp, WatermarkOutput output)</span> &#123;</span><br><span class="line">        <span class="comment">// onEvent每来一个事件，就会调用一次， 选取元素流中的当前最大时间戳</span></span><br><span class="line">        currentMaxTimestamp = Math.max(currentMaxTimestamp, eventTimestamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPeriodicEmit</span><span class="params">(WatermarkOutput output)</span> &#123;</span><br><span class="line">        <span class="comment">// emit the watermark as current highest timestamp minus the out-of-orderness bound</span></span><br><span class="line">        <span class="comment">// 当周期一到，就会调用一次此方法</span></span><br><span class="line">        output.emitWatermark(<span class="keyword">new</span> <span class="title class_">Watermark</span>(currentMaxTimestamp - maxOutOfOrderness - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This generator generates watermarks that are lagging behind processing time </span></span><br><span class="line"><span class="comment"> * by a fixed amount. It assumes that elements arrive in Flink after a bounded delay.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeLagWatermarkGenerator</span> <span class="keyword">implements</span> <span class="title class_">WatermarkGenerator</span>&lt;MyEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">maxTimeLag</span> <span class="operator">=</span> <span class="number">5000</span>; <span class="comment">// 5 seconds</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(MyEvent event, <span class="type">long</span> eventTimestamp, WatermarkOutput output)</span> &#123;</span><br><span class="line">        <span class="comment">// don&#x27;t need to do anything because we work on processing time</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPeriodicEmit</span><span class="params">(WatermarkOutput output)</span> &#123;</span><br><span class="line">        output.emitWatermark(<span class="keyword">new</span> <span class="title class_">Watermark</span>(System.currentTimeMillis() - maxTimeLag));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义一个间断性watermark-Generator"><a href="#自定义一个间断性watermark-Generator" class="headerlink" title="自定义一个间断性watermark Generator"></a>自定义一个间断性watermark Generator</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PunctuatedAssigner</span> <span class="keyword">implements</span> <span class="title class_">WatermarkGenerator</span>&lt;MyEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(MyEvent event, <span class="type">long</span> eventTimestamp, WatermarkOutput output)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (event.hasWatermarkMarker()) &#123;</span><br><span class="line">            output.emitWatermark(<span class="keyword">new</span> <span class="title class_">Watermark</span>(event.getWatermarkTimestamp()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPeriodicEmit</span><span class="params">(WatermarkOutput output)</span> &#123;</span><br><span class="line">        <span class="comment">// don&#x27;t need to do anything because we emit in reaction to events above</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=red>可以在每个事件上生成水印。然而，由于每个水印都会导致一些下行计算，过多的水印会降低性能</font></p>
<h3 id="WaterMark的传递"><a href="#WaterMark的传递" class="headerlink" title="WaterMark的传递"></a>WaterMark的传递</h3><p>一个任务可能有多个并行的分区子任务，那么waterMark如何在任务之间传递的呢？</p>
<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2F20200205213258357.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxODY2Nzkz%2Csize_16%2Ccolor_FFFFFF%2Ct_70&refer=http%3A%2F%2Fimg-blog.csdnimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1629787474&t=adc8126790231c8f42f5fa85869c4663" alt="img"></p>
<p>每个分区都会维护一个partition WM， 每次都会选取这些分区中waterMark<strong>最小值</strong>往下游传递，通过<strong>广播的方式</strong>，会传递给下游所有任务</p>
<h3 id="EventTime在window中的使用"><a href="#EventTime在window中的使用" class="headerlink" title="EventTime在window中的使用"></a>EventTime在window中的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.yulu.apitest.beans.SensorReading;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.eventtime.WatermarkStrategy;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.MapFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.TimeCharacteristic;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStreamSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.Time;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        <span class="comment">// 1.12版本之后，默认为EventTime</span></span><br><span class="line">        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</span><br><span class="line"></span><br><span class="line">        DataStreamSource&lt;String&gt; source = env.socketTextStream(<span class="string">&quot;192.168.0.110&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;SensorReading&gt; sensorReadingSingleOutputStreamOperator = source.map(<span class="keyword">new</span> <span class="title class_">MapFunction</span>&lt;String, SensorReading&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> SensorReading <span class="title function_">map</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                String[] fields = s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SensorReading</span>(fields[<span class="number">0</span>], Long.parseLong(fields[<span class="number">1</span>]), Double.parseDouble(fields[<span class="number">2</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">            	<span class="comment">// 这里分配时间时间戳字段和 waterMark策略</span></span><br><span class="line">                .assignTimestampsAndWatermarks(WatermarkStrategy</span><br><span class="line">                        .&lt;SensorReading&gt;forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">2</span>)) <span class="comment">// 指定watermark的延迟时间为2s</span></span><br><span class="line">                        .withTimestampAssigner((sensorReading, l) -&gt; sensorReading.getTimestamp() * <span class="number">1000L</span></span><br><span class="line">                        ) <span class="comment">// 指定eventTime字段</span></span><br><span class="line">                        .withIdleness(Duration.ofSeconds(<span class="number">1</span>))</span><br><span class="line">                );</span><br><span class="line">        <span class="comment">//.withTimestampAssigner((sensorReading, l) -&gt; sensorReading.getTimestamp() * 1000)</span></span><br><span class="line"></span><br><span class="line">        sensorReadingSingleOutputStreamOperator.keyBy(sensorReading -&gt; sensorReading.getId())</span><br><span class="line">                .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">5</span>)))   <span class="comment">// 滚动窗口大小：5s</span></span><br><span class="line">                .min(<span class="string">&quot;temperature&quot;</span>)</span><br><span class="line">                .print(<span class="string">&quot;max Temperature&quot;</span>);</span><br><span class="line">        env.execute();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据测试：</span></span><br><span class="line">sensor1,<span class="number">1547718192</span>,<span class="number">35.8</span>   </span><br><span class="line">sensor1,<span class="number">1547718193</span>,<span class="number">35.8</span>   </span><br><span class="line">sensor1,<span class="number">1547718194</span>,<span class="number">34.8</span>   </span><br><span class="line">sensor1,<span class="number">1547718195</span>,<span class="number">35.8</span>   </span><br><span class="line">sensor1,<span class="number">1547718196</span>,<span class="number">35.8</span>   </span><br><span class="line">sensor1,<span class="number">1547718197</span>,<span class="number">35.8</span>   </span><br><span class="line">sensor1,<span class="number">1547718198</span>,<span class="number">35.8</span></span><br><span class="line">sensor1,<span class="number">1547718199</span>,<span class="number">35.8</span></span><br><span class="line">sensor1,<span class="number">1547718200</span>,<span class="number">35.8</span></span><br><span class="line">sensor1,<span class="number">1547718201</span>,<span class="number">35.8</span></span><br><span class="line">sensor1,<span class="number">1547718202</span>,<span class="number">35.8</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">输出：</span><br><span class="line">max Temperature:<span class="number">1</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor1&#x27;</span>, timestamp=<span class="number">1547718192</span>, temperature=<span class="number">34.8</span>&#125;</span><br><span class="line">max Temperature:<span class="number">1</span>&gt; SensorReading&#123;id=<span class="string">&#x27;sensor1&#x27;</span>, timestamp=<span class="number">1547718195</span>, temperature=<span class="number">35.8</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="窗口的起点和偏移量"><a href="#窗口的起点和偏移量" class="headerlink" title="窗口的起点和偏移量"></a>窗口的起点和偏移量</h3><p>默认窗口的起点是窗口的大小的整数倍</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sensor1,<span class="number">1547718192</span>,<span class="number">35.8</span>   </span><br><span class="line">sensor1,<span class="number">1547718193</span>,<span class="number">35.8</span>   </span><br><span class="line">sensor1,<span class="number">1547718194</span>,<span class="number">34.8</span>   </span><br><span class="line">sensor1,<span class="number">1547718195</span>,<span class="number">35.8</span>   </span><br><span class="line">sensor1,<span class="number">1547718196</span>,<span class="number">35.8</span> </span><br><span class="line">    </span><br><span class="line">针对于上述数据，当窗口大小为<span class="number">5</span>时，那么其实watermark时间</span><br><span class="line">第一个滚动窗口  [<span class="number">190</span>~<span class="number">196</span>)  最开右闭</span><br><span class="line">第二个滚动窗口	[<span class="number">196</span>~<span class="number">201</span>)  一次类推</span><br><span class="line"></span><br><span class="line">watermark的延迟时间设置了2s，那么watermark的时间达到<span class="number">197</span>才会关闭第一窗口， 但是窗口中只有[<span class="number">190</span>~<span class="number">196</span>)的数据。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">5</span>)))</span><br><span class="line">    默认的offset=<span class="number">0</span>，我们可以指定offset，可以使得窗口的起点为我们自定义的时间点</span><br><span class="line">    也可以通过这个偏移量控制时区UTC</span><br></pre></td></tr></table></figure>

<h3 id="允许延迟时间-allowedLateness"><a href="#允许延迟时间-allowedLateness" class="headerlink" title="允许延迟时间(allowedLateness)"></a>允许延迟时间(allowedLateness)</h3><p>虽然watermark在一定程度上可以解决数据乱序的问题，但是如果数据乱序特别严重，即使使用了watermark也是会有出现丢失数据的可能给。</p>
<p>针对上述问题，flink允许我们设置延迟时间，延迟窗口关闭的时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sensorReadingSingleOutputStreamOperator.keyBy(sensorReading -&gt; sensorReading.getId())</span><br><span class="line">                .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">5</span>)))</span><br><span class="line">                .allowedLateness(Time.seconds(<span class="number">1</span>))  <span class="comment">//设置允许延迟时间</span></span><br><span class="line">                .min(<span class="string">&quot;temperature&quot;</span>)</span><br><span class="line">                .print(<span class="string">&quot;max Temperature&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><font color=blue>但是即使设置了允许延迟时间，依然还有可能会出现延迟的数据没有及时的流入到窗口中</font></p>
<p>flink还提供了一个兜底方案：侧输出流（SideOutputLateData）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义侧输出流标签</span></span><br><span class="line">OutputTag&lt;SensorReading&gt; outputTag = <span class="keyword">new</span> <span class="title class_">OutputTag</span>&lt;SensorReading&gt;(<span class="string">&quot;late SensorReading Data&quot;</span>) &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SingleOutputStreamOperator&lt;SensorReading&gt; min = sensorReadingSingleOutputStreamOperator.keyBy(sensorReading -&gt; sensorReading.getId())</span><br><span class="line">        .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">5</span>)))</span><br><span class="line">        .allowedLateness(Time.seconds(<span class="number">1</span>))</span><br><span class="line">        .sideOutputLateData(outputTag)  <span class="comment">// 兜底方案：将无法捕捉到的数据存放到侧输出流中</span></span><br><span class="line">        .min(<span class="string">&quot;temperature&quot;</span>);</span><br><span class="line">min.getSideOutput(outputTag).print(<span class="string">&quot;late data&quot;</span>);  <span class="comment">// 获取侧输出流</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190321213307414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RkeHlncQ==,size_16,color_FFFFFF,t_70" alt="flink数据流上的类型和操作"></p>
<h2 id="Flink状态管理"><a href="#Flink状态管理" class="headerlink" title="Flink状态管理"></a>Flink状态管理</h2><p>流式计算分为无状态和有状态两种情况。无状态的计算观察每个独立事件，并根据最后一个事件输出结果。</p>
<p>例如：流处理应用程序从传感器接收温度读数，并在温度超过90度的时候发出报警。</p>
<p>有状态的计算则会基于多个事件输出结果。一下有一些例子：</p>
<ul>
<li>所有类型的窗口。例如：计算过去一小时的平均温度，就是有状态计算（需要用到历史数据）</li>
<li>所有用于复杂时间处理的状态机。例如：若在一分钟内收到两个相差20度以上的温度读数，则发出告警信息，就也是有状态计算（需要用到前一个数据）。</li>
<li>流与流之间的所有关联操作，以及流与静态或动态之间的关联操作，都是有状态的计算。</li>
</ul>
<p>无状态流处理分别接受数据记录，然后根据最新输入的数据生成输出数据。</p>
<p>有状态流处理会维护状态（根据每条输入记录进行更新），并基于最新输入的纪录和当前的状态值生成输出记录。</p>
<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2F20200424090646923.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h6MzcwMDU3NDQ4%2Csize_16%2Ccolor_FFFFFF%2Ct_70&refer=http%3A%2F%2Fimg-blog.csdnimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1629907502&t=b5d7d2cb16d77ed59fe518b0ef958c77" alt="img"></p>
<p>无状态流处理每次只转换一条输入记录，并且仅根据最新的输入记录输出结果。</p>
<p>有状态流处理维护所有已经处理的纪录状态，并根据每条新输入的纪录更新状态，因此输出记录反映的是综合考虑多个事件之后的结果。</p>
<p>尽管无状态的计算很重要，但是流处理对有状态的计算更感兴趣。事实上，正确地实现有状态的计算比实现无状态的计算难得多。</p>
<p>flink中的状态包括两种：</p>
<ol>
<li>算子状态（Operator State）</li>
<li>键控状态（Keyed State）</li>
</ol>
<h3 id="算子状态（Operator-State）"><a href="#算子状态（Operator-State）" class="headerlink" title="算子状态（Operator State）"></a>算子状态（Operator State）</h3><p>算子状态的作用范围限定为算子任务。这意味着同一并行任务所处理的所有数据都可以访问到相同的状态，状态对于同一任务而言是共享 的。算子状态不能由相同或不同算子的另一个任务访问。</p>
<p><img src="https://img1.baidu.com/it/u=402931042,4216055398&fm=15&fmt=auto&gp=0.jpg" alt="img"></p>
<p>Flink为算子状态提供三种基本数据结构：</p>
<ul>
<li>列表状态（List State）<ul>
<li>将状态表示为一组数据的列表（可用于持续的状态存储）</li>
</ul>
</li>
<li>联合列表状态（Union list state）<ul>
<li>也将状态表示为数据的列表。它与常规列表状态的区别在于，在发生故障时，或者从保存点（savepoint）启动应用程序时如何恢复。</li>
</ul>
</li>
<li>广播状态（BroadCast State）<ul>
<li>如果一个算子有多项任务，而它的每项任务状态又都相同，那么这种特殊情况最适合应用广播状态。</li>
</ul>
</li>
</ul>
<h3 id="键控状态（Keyed-State）"><a href="#键控状态（Keyed-State）" class="headerlink" title="键控状态（Keyed State）"></a>键控状态（Keyed State）</h3><p>键控状态是根据输入数据流中定义的键（key）来维护和访问的。</p>
<p>Flink为每个键值维护一个状态实例，并将具有相同键的所有数据，都分区到同一个算子任务中，这个任务会维护和处理这个key对应的状态。</p>
<p>当任务处理一条数据时，它会自动将状态的访问范围限定为当前数据的key。</p>
<p>因此，具有相同key的所有数据都会访问相同的状态。Keyed State很类似于一个分布式的key-value map数据结构，只能用于KeyedStream（keyBy算子处理之后）。</p>
<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2F20210104153154601.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_Q2FwZV9zaXI%3D%2Csize_36%2Ccolor_FFFFFF%2Ct_30&refer=http%3A%2F%2Fimg-blog.csdnimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1629908308&t=07382c840a0c0fe45d5c354392e04e09" alt="img"></p>
<p>Flink的Keyed State支持以下数据类型：</p>
<ul>
<li><p>ValueState<T> 保存单个值，值的类型为T</p>
<ul>
<li>```java<br>get操作：ValueState.value()<br>set操作：ValueState.update(T value);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ListState&lt;T&gt;保存一个列表，列表里的元素的数据类型为T</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    ListState.add(T value);</span><br><span class="line">    ListState.addAll(List&lt;T&gt; values);</span><br><span class="line">    ListState.get() 返回 Iterable&lt;T&gt;;</span><br><span class="line">    ListState.update(List&lt;T&gt; values);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>MapState&lt;K,V&gt; 保存Key-Value对儿</p>
<ul>
<li>```java<br>MapState.get(UK key);<br>MapState.put(UK key, UV value);<br>MapState.contains(UK key);<br>MapState.remove(UK key);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ReducingState&lt;T&gt;</span><br><span class="line"></span><br><span class="line">- AggregatingState&lt;I,O&gt;</span><br><span class="line"></span><br><span class="line">`State.clear()可以清空状态`</span><br><span class="line"></span><br><span class="line">上述这些状态可以在抽象类的富函数`Rich`中通过`getRuntimeContext().getState(new ValueStateDescriptor&lt;Double&gt;(&quot;状态名&quot;, Double.class));`来获取当前的监控状态。</span><br><span class="line"></span><br><span class="line">**测试例子：**</span><br><span class="line"></span><br><span class="line">利用KeyState，实现一个需求：检测传感器的温度值，如果连续的两个温度差值超过10度，就输出报警信息。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">import com.yulu.apitest.beans.SensorReading;</span><br><span class="line">import org.apache.flink.api.common.functions.MapFunction;</span><br><span class="line">import org.apache.flink.api.common.state.ValueState;</span><br><span class="line">import org.apache.flink.api.common.state.ValueStateDescriptor;</span><br><span class="line">import org.apache.flink.configuration.Configuration;</span><br><span class="line">import org.apache.flink.streaming.api.datastream.DataStreamSource;</span><br><span class="line">import org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;</span><br><span class="line">import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line">import org.apache.flink.streaming.api.functions.KeyedProcessFunction;</span><br><span class="line">import org.apache.flink.util.Collector;</span><br><span class="line">import org.apache.flink.util.OutputTag;</span><br><span class="line"></span><br><span class="line">public class processDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        DataStreamSource&lt;String&gt; source = env.socketTextStream(&quot;192.168.0.103&quot;, 7777);</span><br><span class="line">        SingleOutputStreamOperator&lt;SensorReading&gt; sensorReadingDS = source.map(new MapFunction&lt;String, SensorReading&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public SensorReading map(String s) throws Exception &#123;</span><br><span class="line">                String[] split = s.split(&quot;,&quot;);</span><br><span class="line">                return new SensorReading(split[0], Long.parseLong(split[1]), Double.parseDouble(split[2]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 小需求： 实现监控每个传感器连续10s中钟温度上升，输出报警信息</span><br><span class="line">         */</span><br><span class="line">        // 定义一个侧输出流标签</span><br><span class="line">        OutputTag&lt;SensorReading&gt; outputTag = new OutputTag&lt;SensorReading&gt;(&quot;温度值非连续输出&quot;)&#123;&#125;;</span><br><span class="line">        SingleOutputStreamOperator&lt;String&gt; result = sensorReadingDS</span><br><span class="line">                .keyBy(sensorReading -&gt; sensorReading.getId())</span><br><span class="line">                .process(new MyKeyedProcessFunction(5000L, outputTag));</span><br><span class="line">        result.print();</span><br><span class="line">        result.getSideOutput(outputTag).print(&quot;其他数据&quot;);</span><br><span class="line"></span><br><span class="line">        env.execute();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class MyKeyedProcessFunction extends KeyedProcessFunction&lt;String, SensorReading, String&gt; &#123;</span><br><span class="line"></span><br><span class="line">        private Long Interval;</span><br><span class="line">        private ValueState&lt;Long&gt; timerTS; // 定时器时间</span><br><span class="line">        private ValueState&lt;Double&gt; lastTempurate;</span><br><span class="line">        private OutputTag&lt;SensorReading&gt; outputTag;</span><br><span class="line"></span><br><span class="line">        public MyKeyedProcessFunction(Long interval, OutputTag&lt;SensorReading&gt; outputTag)&#123;</span><br><span class="line">            this.Interval=interval;</span><br><span class="line">            this.outputTag=outputTag;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void open(Configuration parameters) throws Exception &#123;</span><br><span class="line">            timerTS = getRuntimeContext().getState(new ValueStateDescriptor&lt;Long&gt;(&quot;timer-TS&quot;, Long.class));</span><br><span class="line">            lastTempurate = getRuntimeContext().getState(new ValueStateDescriptor&lt;Double&gt;(&quot;lastTempurate&quot;, Double.class));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void close() throws Exception &#123;</span><br><span class="line">            timerTS.clear();</span><br><span class="line">            lastTempurate.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void processElement(SensorReading sensorReading, Context context, Collector&lt;String&gt; collector) throws Exception &#123;</span><br><span class="line">            Long timerts = timerTS.value();</span><br><span class="line">            Double lasttemp = lastTempurate.value();</span><br><span class="line">            // 当温度值上升，且定时器没有创建，则创建定时器</span><br><span class="line">            if (lasttemp!=null  &amp;&amp; sensorReading.getTemperature()&gt;lasttemp &amp;&amp; timerts==null)&#123;</span><br><span class="line">                // 创建一个定时器， 时间到达某个时刻就触发一次操作</span><br><span class="line">                Long ts = context.timerService().currentProcessingTime()+Interval;</span><br><span class="line">                context.timerService().registerProcessingTimeTimer(ts);</span><br><span class="line">                timerTS.update(ts);</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果温度值下降， 就删除定时器，状态归</span><br><span class="line">            if (lasttemp!=null  &amp;&amp; sensorReading.getTemperature()&lt;=lasttemp &amp;&amp; timerts !=null)&#123;</span><br><span class="line">                // 根据传入的时间，删除指定的定时器</span><br><span class="line">                context.timerService().deleteProcessingTimeTimer(timerts);</span><br><span class="line">                timerTS.clear();</span><br><span class="line">                context.output(this.outputTag, sensorReading);</span><br><span class="line">            &#125;</span><br><span class="line">            // 更新状态</span><br><span class="line"></span><br><span class="line">            lastTempurate.update(sensorReading.getTemperature());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onTimer(long timestamp, OnTimerContext ctx, Collector&lt;String&gt; out) throws Exception &#123;</span><br><span class="line">            out.collect(&quot;传感器：&quot;+ctx.getCurrentKey()+&quot;\t 温度值在：&quot;+this.Interval+&quot;ms 温度值连续上升&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="Flink的容错机制"><a href="#Flink的容错机制" class="headerlink" title="Flink的容错机制"></a>Flink的容错机制</h2><h3 id="一致性检查点"><a href="#一致性检查点" class="headerlink" title="一致性检查点"></a>一致性检查点</h3><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Foscimg.oschina.net%2Foscnet%2Fc15e5cf0-5f5a-48ac-ba14-b3d370a196cb.png&refer=http%3A%2F%2Foscimg.oschina.net&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1630159034&t=49399bac16c4c42293f8fa7cffe1f0d2" alt="img"></p>
<ul>
<li>Flink故障恢复机制的核心，就是应用状态的一致性检查点</li>
<li>有状态流应用的一直检查点，其实就是所有任务的状态，在某个时间点的一份拷贝（一份快照）；这个时间点，<font color=red>应该是所有任务都恰好处理完一个相同的出入数据的时候。</font></li>
</ul>
<p>以上述图为例：如果当前source读取到5，下游任务也必须是都处理完5这个数据之后才做checkpoint。</p>
<h3 id="从检查点恢复状态"><a href="#从检查点恢复状态" class="headerlink" title="从检查点恢复状态"></a>从检查点恢复状态</h3><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2020.cnblogs.com%2Fblog%2F1824311%2F202009%2F1824311-20200908213604870-202910531.png&refer=http%3A%2F%2Fimg2020.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1630159603&t=9156f9309a498e83d6fe0a15fa6dc8e9" alt="img"></p>
<ul>
<li>在执行流应用程序期间，、flink会定期保存状态的一致检查点</li>
<li>如果发生故障，Flink将会使用最近的检查点来恢复应用程序的状态，并重新启动处理流程。</li>
</ul>
<p>这就要数据源能够有<strong>数据重放的功能</strong></p>
<p><img src="https://nimg.ws.126.net/?url=http://dingyue.ws.126.net/2021/0727/1e1f12b7j00qwwn0g002ac000hs00umg.jpg&thumbnail=650x2147483647&quality=80&type=jpg" alt="img"></p>
<ul>
<li>遇到故障之后，第一步就是重启应用</li>
<li>第二步是从checkpoint中读取状态，将状态重置</li>
<li>从检查点重新启动应用程序后，其内部状态与检查点完成时的状态完全相同</li>
<li>第三步：开始消费并处理检查点到发生故障之间的所有数据</li>
<li>这种检查点的保存和恢复机制可以为应用程序状态提供“精确一次”（exactly-once）的一致性，因为所有算子都会保存检查点并回复其所有状态，这样一来所有的输入流就都会被重置到检查点完成时的位置。</li>
</ul>
<h3 id="Flink检查点算法"><a href="#Flink检查点算法" class="headerlink" title="Flink检查点算法"></a>Flink检查点算法</h3><ul>
<li>一种简单的想法<ul>
<li>暂停应用，保存状态到检查点，再重新恢复应用</li>
</ul>
</li>
<li>Flink的改进实现<ul>
<li>基于Chandy-Lamport算法的分布式快照</li>
<li>将检查点的保存和数据处理分离开，不暂停整个应用</li>
</ul>
</li>
</ul>
<h4 id="检查点分界线（Checkpoint-Barrier）"><a href="#检查点分界线（Checkpoint-Barrier）" class="headerlink" title="检查点分界线（Checkpoint Barrier）"></a>检查点分界线（Checkpoint Barrier）</h4><ul>
<li>Flink的检查点算法用到了一种称为分界线（barrier）的特殊数据形式，用来把一条流上数据按照不同的检查点分开</li>
<li>分界线之前到来的数据导致的状态更改，都会被包含在当前分界线所属的检查点中；而基于分界线之后的数据导致的所有更改，就会被包含在之后的检查点中。</li>
</ul>
<h4 id="Flink检查点算法介绍"><a href="#Flink检查点算法介绍" class="headerlink" title="Flink检查点算法介绍"></a>Flink检查点算法介绍</h4><p><img src="https://www.icode9.com/i/ll/?i=20210111152147546.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_Q2FwZV9zaXI=,size_36,color_FFFFFF,t_30" alt="在这里插入图片描述"></p>
<ul>
<li>现在是一个两个输入流的应用程序，用并行的两个source任务来读取</li>
</ul>
<p><img src="https://www.icode9.com/i/ll/?i=2021011115251435.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_Q2FwZV9zaXI=,size_36,color_FFFFFF,t_30" alt="在这里插入图片描述"></p>
<ul>
<li>JobManager 会向每个Source任务发送一条带有新检查点ID的消息，通过这种方法来启动检查点</li>
<li>这个消息会传递给下游所有任务</li>
</ul>
<p><img src="https://www.icode9.com/i/ll/?i=20210111153027619.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_Q2FwZV9zaXI=,size_36,color_FFFFFF,t_30" alt="在这里插入图片描述"></p>
<ul>
<li>数据源将它们的状态写入检查点，并发出一个检查点barrier，广播发送到下游任务。状态后端在状态存入检查点之后，会返回通知给source任务，source任务就会向JobManager确认检查点完成。</li>
</ul>
<p><img src="https://www.icode9.com/i/ll/?i=20210111153426447.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_Q2FwZV9zaXI=,size_36,color_FFFFFF,t_30" alt="在这里插入图片描述"></p>
<p>分界线对齐（barrier对齐）：barrier向下游传递，sum任务会等待所有输入分区的barrier到达。</p>
<p>对于barrier已经到达的分区，继续接收到的数据会被缓存起来；而barrier尚未到达的分区，数据会被正常处理。</p>
<p><img src="https://www.icode9.com/i/ll/?i=20210111153926877.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_Q2FwZV9zaXI=,size_36,color_FFFFFF,t_30" alt="在这里插入图片描述"></p>
<p>当接收到所有分区的barrier时，任务就将其状态保存到状态后端的检查点中，然后将barrier继续向下游转发。</p>
<p><img src="https://www.icode9.com/i/ll/?i=2021011115420988.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_Q2FwZV9zaXI=,size_36,color_FFFFFF,t_30" alt="在这里插入图片描述"></p>
<p>向下游转发barrier后，任务继续正常的数据处理。</p>
<p><img src="https://www.icode9.com/i/ll/?i=20210111154304922.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY1MjU5Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>sink任务向JobManager确认状态保存到checkpoint完毕</li>
<li>当所有任务都确认已成功将状态保存到检查点时，检查点就真正完成了。</li>
</ul>
<p>每个任务都相应的状态的检查点，所有任务的状态checkpoint被状态后端state backend保存，当出现故障的时候，从此checkpoint就可以恢复任务。</p>
<p>上述蓝8，黄8就是source处理完蓝3和黄4的结果。</p>
<h3 id="保存点（savepoints）"><a href="#保存点（savepoints）" class="headerlink" title="保存点（savepoints）"></a>保存点（savepoints）</h3><ul>
<li>Flink还提供了可以自定义的镜像保存功能，就是保存点（savepoints）</li>
<li>原则上，创建保存点使用的算法与检查点完全相同，因为保存点可以认为就是具有一些额外元数据的检查点</li>
<li>Flink不会自动创建保存点，因此用户（或者外部调度程序）必须明确地触发创建操作</li>
<li>保存点是一个强大的功能。除了故障恢复外，保存点可以用于：有计划的手动备份，更新应用程序，版本迁移，暂停和重启应用，等等。</li>
</ul>
<h2 id="状态一致性"><a href="#状态一致性" class="headerlink" title="状态一致性"></a>状态一致性</h2><p>当在分布式系统中引入状态时，自然也引入了一致性问题。一致性实际上是“正确性级别”的另一种说法，也就是说在成功处理故障之后得到的结果，与没有发生然和故障时得到的结果相比，前者到底有多正确？举例来说：假设要对最近一小时登录的用户计数。在系统经理故障之后，计数结果是多少？如果有偏差，是有漏掉的计数还是重复计数？</p>
<h3 id="一致性级别"><a href="#一致性级别" class="headerlink" title="一致性级别"></a>一致性级别</h3><p>在流处理中，一致性可以分3个级别：</p>
<ul>
<li>at-most-once：至多一次<ul>
<li>这其实是没有正确性保障的委婉说法——故障发生之后，计数结果可能丢失。</li>
</ul>
</li>
<li>at-least-once：至少一次<ul>
<li>这表示计数结果可能大于正确值，但绝对不会小于正确值。也就是说，计数程序在发生故障后可能多算，但是绝不会少算</li>
</ul>
</li>
<li>exactly-once<ul>
<li>这指的是系统保证在发生故障后得到的计数结果与正确值一致。</li>
</ul>
</li>
</ul>
<p>Flink的一个重大价值在于，它既保证了<strong>exactly-once</strong>，<strong>也具有低延迟和高吞吐的处理能力</strong>。</p>
<p>从根本上说，Flink通过使自身满足所有需求来避免权衡，它是业界的一次意义重大的技术飞跃。</p>
<h3 id="一致性检查点（checkpoints）"><a href="#一致性检查点（checkpoints）" class="headerlink" title="一致性检查点（checkpoints）"></a>一致性检查点（checkpoints）</h3><ul>
<li>Flink使用了一种轻量级快照机制——检查点来保证exactly-once语义</li>
<li>有状态流应用的一致检查点，其实就是：所有任务的状态，在某个时间点的一份拷贝（一份快照）。而这个时间点，应该是所有任务都恰好处理完一个相同的输入数据的时候。</li>
<li>应用状态的一致检查点，是Flink故障恢复机制的核心</li>
</ul>
<h3 id="端到端（end-to-end）状态一致性"><a href="#端到端（end-to-end）状态一致性" class="headerlink" title="端到端（end-to-end）状态一致性"></a>端到端（end-to-end）状态一致性</h3><p>目前我们看到的一致性保证都是有流处理器实现的，也就是说都是在Flink流处理器内部保证的；而在真实应用中，流处理应用除了流处理器以外还包含了数据源（例如Kafka）和输出到持久化系统。</p>
<p>端到端的一致性保证，意味着结果的正确性贯穿了整个流处理应用的始终；每一个组件都保证了它自己的一致性，整个端到端的一致性级别取决于所有组件中一致性最弱的组件。具体可以划分如下：</p>
<ul>
<li>内部保证——依赖checkpoints</li>
<li>source端——<strong>需要外部源可重设数据的读取位置</strong></li>
<li>sink端——需要保证从故障恢复时，数据不会重复写入外部系统</li>
</ul>
<p>而对于sink端，又有两种具体的实现方式：幂等性写入和事务性写入</p>
<ul>
<li>幂等写入<ul>
<li>所谓幂等操作，是说一个操作，可以重复执行很多次，但只导致一次结果更改，也就是说，后面再重复执行就不起作用了。</li>
</ul>
</li>
<li>事务写入<ul>
<li>需要构建事务来写入外部系统，构建的事务对应着checkpoint，等到checkpoint真正完成的时候，才把所有对应的结果写入sink系统中。</li>
<li>具有原子性：一个事务中的一系列的操作要么全部成功，要么一个都不做。</li>
<li>实现思想：构建的事务对应着checkpoint，等到checkpoint真正完成的时候，才把所有对应的结果写入sink系统中。</li>
<li>实现方式<ul>
<li>预写日志</li>
<li>两阶段提交</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="预写日志"><a href="#预写日志" class="headerlink" title="预写日志"></a>预写日志</h4><ul>
<li>把结果数据先当成状态保存，然后在收到checkpoint完成的通知时，一次性写入sink系统</li>
<li>简单易于实现，由于数据提前在状态后端中做了缓存，所以无论什么sink系统，都能用这种方式一批搞定。</li>
<li>DataStreamAPI提供了一个模板类：GenericWriteAheadSink，来实现这种事务性sink</li>
</ul>
<p>缺点：一个checkpoint内的数据变成的批处理</p>
<h4 id="两阶段提交（2PC）"><a href="#两阶段提交（2PC）" class="headerlink" title="两阶段提交（2PC）"></a>两阶段提交（2PC）</h4><ul>
<li>对于每个checkpoint，sink任务启动一个事务，并将接下来所有接收的数据添加到事务里</li>
<li>然后将这些数据写入外部sink系统，但不提交它们——这是只是“预提交“</li>
<li>当它收到checkpoint完成的通知时，它才正式提交事务，实现结果的真正写入</li>
<li>这种方式真正实现了exactly-once，它需要一个提供事务支持的外部sink系统。Flink提供了TwoPhaseCommitSinkFunction接口。</li>
</ul>
<p><strong>2PC对外部sink系统的要求</strong></p>
<ul>
<li><p>外部sink系统必须提供事务支持，或者sink任务必须能够模拟外部系统上的事务</p>
</li>
<li><p>在checkpoint的间隔期间里，必须能够开启一个事务并接受数据写入</p>
</li>
<li><p>在收到checkpoint完成的通知之前，事务必须是“等待提交”的状态。</p>
<p>在故障恢复的情况下，这可能需要一些时间。如果这个时候sink系统关闭事务（例如超时），那么未提交的数据就会丢失</p>
</li>
<li><p>sink任务必须能够在进程失败后恢复事务</p>
</li>
<li><p>提交事务必须是幂等操作</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>sink\source</th>
<th>不可重置</th>
<th>可重置</th>
</tr>
</thead>
<tbody><tr>
<td>任意(Any)</td>
<td>At-most-once</td>
<td>At-least-once</td>
</tr>
<tr>
<td>幂等</td>
<td>At-most-once</td>
<td>Exactly-once<br />（故障恢复时会出现暂时不一致）</td>
</tr>
<tr>
<td>预写日志（WAL）</td>
<td>At-most-once</td>
<td>At-least-once</td>
</tr>
<tr>
<td>两阶段提交（2PC）</td>
<td>At-most-once</td>
<td>Exactly-once</td>
</tr>
</tbody></table>
<h2 id="Flink-SQL-和-Table-SQL"><a href="#Flink-SQL-和-Table-SQL" class="headerlink" title="Flink SQL 和 Table SQL"></a>Flink SQL 和 Table SQL</h2><h3 id="1-整体介绍"><a href="#1-整体介绍" class="headerlink" title="1. 整体介绍"></a>1. 整体介绍</h3><h4 id="1-1-什么是Table-API-和-Flink-SQL"><a href="#1-1-什么是Table-API-和-Flink-SQL" class="headerlink" title="1.1 什么是Table API 和 Flink SQL"></a>1.1 什么是Table API 和 Flink SQL</h4><p>Flink本身是批流统一的处理框架，所以Table API和SQL，就是批流统一的上层处理API。</p>
<p>目前功能尚未完善，处于活跃的开发阶段。</p>
<p>Table API是一套内嵌在Java和Scala语言中的查询API，它允许我们以非常直观的方式，组合来自一些关系运算符的查询（比如select、filter和join）。而对于Flink SQL，就是直接可以在代码中写SQL，来实现一些查询（Query）操作。Flink的SQL支持，基于实现了SQL标准的Apache Calcite（Apache开源SQL解析工具）。</p>
<p>无论输入是批输入还是流式输入，在这两套API中，指定的查询都具有相同的语义，得到相同的结果。</p>
<h4 id="1-2-需要引入的依赖"><a href="#1-2-需要引入的依赖" class="headerlink" title="1.2 需要引入的依赖"></a>1.2 需要引入的依赖</h4><p>Table API 和 SQL 需要引入的依赖有两个：planner和bridge。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.flink&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;flink-table-planner_2<span class="number">.11</span>&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.10</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.flink&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;flink-table-api-scala（java）-bridge_2<span class="number">.11</span>&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.10</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>flink-table-planner</strong>：planner计划器，是table API最主要的部分，提供了运行时环境和生成程序执行计划的planner；</p>
<p><strong>flink-table-api-scala-bridge</strong>：bridge桥接器，主要负责table API和 DataStream/DataSet API的连接支持，按照语言分java和scala。</p>
<p>这里的两个依赖，是IDE环境下运行需要添加的；如果是生产环境，lib目录下默认已经有了planner，就只需要有bridge就可以了。</p>
<p>当然，如果想使用用户自定义函数，或是跟kafka做连接，需要有一个SQL client，这个包含在flink-table-common里。</p>
<h4 id="1-3-两种planner（old-amp-blink）的区别"><a href="#1-3-两种planner（old-amp-blink）的区别" class="headerlink" title="1.3 两种planner（old&amp;blink）的区别"></a>1.3 两种planner（old&amp;blink）的区别</h4><ol>
<li><p>批流统一：Blink将批处理作业，视为流式处理的特殊情况。所以，blink不支持表和DataSet之间的转换，批处理作业将不转换为DataSet应用程序，而是跟流处理一样，转换为DataStream程序来处理。</p>
</li>
<li><p>因为批流统一，Blink planner也不支持BatchTableSource，而使用有界的StreamTableSource代替。</p>
</li>
<li><p>Blink planner只支持全新的目录，不支持已弃用的ExternalCatalog。</p>
</li>
<li><p>旧planner和Blink planner的FilterableTableSource实现不兼容。旧的planner会把PlannerExpressions下推到filterableTableSource中，而blink planner则会把Expressions下推。</p>
</li>
<li><p>基于字符串的键值配置选项仅适用于Blink planner。</p>
</li>
<li><p>PlannerConfig在两个planner中的实现不同。</p>
</li>
<li><p>Blink planner会将多个sink优化在一个DAG中（仅在TableEnvironment上受支持，而在StreamTableEnvironment上不受支持）。而旧planner的优化总是将每一个sink放在一个新的DAG中，其中所有DAG彼此独立。</p>
</li>
<li><p>旧的planner不支持目录统计，而Blink planner支持。</p>
</li>
</ol>
<h3 id="2-API调用"><a href="#2-API调用" class="headerlink" title="2. API调用"></a>2. API调用</h3><h4 id="2-1-基本程序结构"><a href="#2-1-基本程序结构" class="headerlink" title="2.1 基本程序结构"></a>2.1 基本程序结构</h4><p>Table API 和 SQL 的程序结构，与流式处理的程序结构类似；也可以近似地认为有这么几步：首先创建执行环境，然后定义source、transform和sink。</p>
<p>具体操作流程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">tableEnv</span> <span class="operator">=</span> ...     <span class="comment">// 创建表的执行环境</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一张表，用于读取数据</span></span><br><span class="line">tableEnv.connect(...).createTemporaryTable(<span class="string">&quot;inputTable&quot;</span>)</span><br><span class="line"><span class="comment">// 注册一张表，用于把计算结果输出</span></span><br><span class="line">tableEnv.connect(...).createTemporaryTable(<span class="string">&quot;outputTable&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 Table API 查询算子，得到一张结果表</span></span><br><span class="line"><span class="type">val</span> <span class="variable">result</span> <span class="operator">=</span> tableEnv.from(<span class="string">&quot;inputTable&quot;</span>).select(...)</span><br><span class="line"><span class="comment">// 通过 SQL查询语句，得到一张结果表</span></span><br><span class="line"><span class="type">val</span> <span class="variable">sqlResult</span>  <span class="operator">=</span> tableEnv.sqlQuery(<span class="string">&quot;SELECT ... FROM inputTable ...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将结果表写入输出表中</span></span><br><span class="line">result.insertInto(<span class="string">&quot;outputTable&quot;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="2-2-创建表环境"><a href="#2-2-创建表环境" class="headerlink" title="2.2 创建表环境"></a>2.2 创建表环境</h4><p>创建表环境最简单的方式，就是基于流处理执行环境，调用create方法直接创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"><span class="type">StreamTableEnvironment</span> <span class="variable">tableEnv</span> <span class="operator">=</span> StreamTableEnvironment.create(env);</span><br></pre></td></tr></table></figure>

<p>表环境（<strong>TableEnvironment</strong>）是flink中集成Table API &amp; SQL的核心概念。它负责:</p>
<ul>
<li><p>注册catalog</p>
</li>
<li><p>在内部 catalog 中注册表</p>
</li>
<li><p>执行 SQL 查询</p>
</li>
<li><p> 注册用户自定义函数</p>
</li>
<li><p>将 DataStream 或 DataSet 转换为表</p>
</li>
<li><p> 保存对 ExecutionEnvironment或者StreamExecutionEnvironment 的引用</p>
</li>
</ul>
<p>在创建TableEnv的时候，可以多传入一个EnvironmentSettings或者TableConfig参数，可以用来配置TableEnvironment的一些特性。</p>
<h4 id="2-3-在Catalog中注册表"><a href="#2-3-在Catalog中注册表" class="headerlink" title="2.3 在Catalog中注册表"></a>2.3 在Catalog中注册表</h4><h5 id="2-3-1-表（Table）的概念"><a href="#2-3-1-表（Table）的概念" class="headerlink" title="2.3.1 表（Table）的概念"></a>2.3.1 表（Table）的概念</h5><p>TableEnvironment可以注册目录Catalog，并可以基于Catalog注册表。它会维护一个Catalog-Table表之间的map。</p>
<p>表（Table）是由一个“标识符”来指定的，由3部分组成：Catalog名、数据库（database）名和对象名（表名）。如果没有指定目录或数据库，就使用当前的默认值。</p>
<p>表可以是常规的（Table，表），或者虚拟的（View，视图）。常规表（Table）一般可以用来描述外部数据，比如文件、数据库表或消息队列的数据，也可以直接从 DataStream转换而来。视图可以从现有的表中创建，通常是table API或者SQL查询的一个结果。</p>
<h5 id="2-3-2-连接到文件系统（CSV格式）"><a href="#2-3-2-连接到文件系统（CSV格式）" class="headerlink" title="2.3.2 连接到文件系统（CSV格式）"></a>2.3.2 连接到文件系统（CSV格式）</h5><p>连接外部系统在Catalog中注册表，直接调用tableEnv.connect就可以，里面参数要传入一个ConnectorDescriptor，也就是connector描述器。对于文件系统的connector而言，flink内部已经提供了，FileSystem().</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"><span class="type">StreamTableEnvironment</span> <span class="variable">tableEnv</span> <span class="operator">=</span> StreamTableEnvironment.create(env);</span><br><span class="line">tableEnv.connect(<span class="keyword">new</span> <span class="title class_">FileSystem</span>().path(<span class="string">&quot;E:\\DATA\\IdeaProject\\FlinkProject\\src\\main\\resources\\Files\\sensor&quot;</span>))</span><br><span class="line">        .withFormat(<span class="keyword">new</span> <span class="title class_">Csv</span>())</span><br><span class="line">        .withSchema(<span class="keyword">new</span> <span class="title class_">Schema</span>() <span class="comment">// 指定schema</span></span><br><span class="line">        .field(<span class="string">&quot;sensor_id&quot;</span>, DataTypes.STRING())</span><br><span class="line">        .field(<span class="string">&quot;timestamp&quot;</span>, DataTypes.BIGINT())</span><br><span class="line">        .field(<span class="string">&quot;tempara&quot;</span>, DataTypes.DOUBLE())</span><br><span class="line">        )</span><br><span class="line">        .createTemporaryTable(<span class="string">&quot;sensor_table&quot;</span>); <span class="comment">// 创建临时表</span></span><br><span class="line"><span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> tableEnv.sqlQuery(<span class="string">&quot;select * from sensor_table&quot;</span>);</span><br><span class="line">table.getSchema();</span><br><span class="line">tableEnv.toAppendStream(table, Row.class).print()</span><br></pre></td></tr></table></figure>



<h5 id="2-3-3-连接到kafka"><a href="#2-3-3-连接到kafka" class="headerlink" title="2.3.3 连接到kafka"></a>2.3.3 连接到kafka</h5><p>kafka的连接器flink-kafka-connector中，1.10版本的已经提供了Table API的支持。我们可以在 connect方法中直接传入一个叫做Kafka的类，这就是kafka连接器的描述器ConnectorDescriptor。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">tableEnv.connect(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Kafka</span>()</span><br><span class="line">                .version(<span class="string">&quot;0.11&quot;</span>) <span class="comment">// 定义kafka的版本</span></span><br><span class="line">                .topic(<span class="string">&quot;sensor&quot;</span>) <span class="comment">// 定义主题</span></span><br><span class="line">                .property(<span class="string">&quot;zookeeper.connect&quot;</span>, <span class="string">&quot;localhost:2181&quot;</span>)</span><br><span class="line">                .property(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>)</span><br><span class="line">)</span><br><span class="line">        .withFormat(<span class="keyword">new</span> <span class="title class_">Csv</span>())</span><br><span class="line">        .withSchema(<span class="keyword">new</span> <span class="title class_">Schema</span>()</span><br><span class="line">                .field(<span class="string">&quot;id&quot;</span>, DataTypes.STRING())</span><br><span class="line">                .field(<span class="string">&quot;timestamp&quot;</span>, DataTypes.BIGINT())</span><br><span class="line">                .field(<span class="string">&quot;temperature&quot;</span>, DataTypes.DOUBLE())</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        .createTemporaryTable(<span class="string">&quot;kafka_table&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>当然也可以连接到ElasticSearch、MySql、HBase、Hive等外部系统，实现方式基本上是类似的。</p>
<h4 id="2-4-表的查询"><a href="#2-4-表的查询" class="headerlink" title="2.4 表的查询"></a>2.4 表的查询</h4><p>利用外部系统的连接器connector，我们可以读写数据，并在环境的Catalog中注册表。接下来就可以对表做查询转换了。</p>
<p>Flink给我们提供了两种查询方式：Table API和 SQL。</p>
<h5 id="2-4-1-Table-API的调用"><a href="#2-4-1-Table-API的调用" class="headerlink" title="2.4.1 Table API的调用"></a>2.4.1 Table API的调用</h5><p>Table API是集成在Scala和Java语言内的查询API。与SQL不同，Table API的查询不会用字符串表示，而是在宿主语言中一步一步调用完成的。</p>
<p>Table API基于代表一张“表”的Table类，并提供一整套操作处理的方法API。这些方法会返回一个新的Table对象，这个对象就表示对输入表应用转换操作的结果。有些关系型转换操作，可以由多个方法调用组成，构成链式调用结构。例如table.select(…).filter(…)，其中select（…）表示选择表中指定的字段，filter(…)表示筛选条件。</p>
<p>代码中的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> tableEnv.from(<span class="string">&quot;inputTable&quot;</span>)</span><br><span class="line">table.select(<span class="string">&quot;id, temperator&quot;</span>)</span><br><span class="line">    .filter(<span class="string">&quot;id=&#x27;sensor_1&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="2-4-2-SQL-查询"><a href="#2-4-2-SQL-查询" class="headerlink" title="2.4.2 SQL 查询"></a>2.4.2 SQL 查询</h5><p>Flink的SQL集成，基于的是ApacheCalcite，它实现了SQL标准。在Flink中，用常规字符串来定义SQL查询语句。SQL 查询的结果，是一个新的 Table。</p>
<p>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tableEnv.sqlQuery(<span class="string">&quot;select id, temperature from inputTable where id=&#x27;sensor_1&#x27;&quot;</span>);</span><br></pre></td></tr></table></figure>



<h4 id="2-5-DataStream-转换成表"><a href="#2-5-DataStream-转换成表" class="headerlink" title="2.5 DataStream 转换成表"></a>2.5 DataStream 转换成表</h4><p>Flink允许我们把Table和DataStream做转换：我们可以基于一个DataStream，先流式地读取数据源，然后map成样例类，再把它转成Table。Table的列字段（column fields），就是样例类里的字段，这样就不用再麻烦地定义schema了。</p>
<p><strong>tableEnv.fromDataStream(“table_name”, PoJos)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">       SingleOutputStreamOperator&lt;SensorReading&gt; sensorReadingDS = env.socketTextStream(<span class="string">&quot;192.168.0.103&quot;</span>, <span class="number">7777</span>)</span><br><span class="line">               .map(s -&gt; &#123;</span><br><span class="line">                   String[] fields = s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SensorReading</span>(fields[<span class="number">0</span>], Long.parseLong(fields[<span class="number">1</span>]), Double.parseDouble(fields[<span class="number">2</span>]));</span><br><span class="line">               &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="type">StreamTableEnvironment</span> <span class="variable">tableEnv</span> <span class="operator">=</span> StreamTableEnvironment.create(env);</span><br><span class="line">       <span class="type">Table</span> <span class="variable">dataTable</span> <span class="operator">=</span> tableEnv.fromDataStream(sensorReadingDS);</span><br><span class="line">       tableEnv.createTemporaryView(<span class="string">&quot;sensor&quot;</span>, dataTable);</span><br><span class="line">       <span class="type">Table</span> <span class="variable">resultTable</span> <span class="operator">=</span> tableEnv.sqlQuery(<span class="string">&quot;select * from sensor&quot;</span>);</span><br><span class="line">       DataStream&lt;Row&gt; rowDataStream = tableEnv.toAppendStream(resultTable, Row.class);</span><br><span class="line">       rowDataStream.print();</span><br><span class="line">       env.execute();</span><br></pre></td></tr></table></figure>

<h4 id="2-6-创建临时视图"><a href="#2-6-创建临时视图" class="headerlink" title="2.6 创建临时视图"></a>2.6 创建临时视图</h4><p>创建临时视图的第一种方式，就是直接从DataStream转换而来。同样，可以直接对应字段转换；也可以在转换的时候，指定相应的字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tableEnv.createTemporaryView(<span class="string">&quot;sensorView&quot;</span>,dataStream);</span><br><span class="line"></span><br><span class="line">tableEnv.createTemporaryView(<span class="string">&quot;sensorView&quot;</span>,dataStream, <span class="string">&quot;id&quot;</span>,<span class="string">&quot;temperature&quot;</span>,<span class="string">&quot;timestamp as ts&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="2-7-输出表"><a href="#2-7-输出表" class="headerlink" title="2.7 输出表"></a>2.7 输出表</h4><h5 id="2-7-1-输出到文件"><a href="#2-7-1-输出到文件" class="headerlink" title="2.7.1 输出到文件"></a>2.7.1 输出到文件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table.insertInto(<span class="string">&quot;outputTable&quot;</span>);</span><br></pre></td></tr></table></figure>



<h5 id="2-7-2-更新模式（update-Mode）"><a href="#2-7-2-更新模式（update-Mode）" class="headerlink" title="2.7.2 更新模式（update Mode）"></a>2.7.2 更新模式（update Mode）</h5><p>在流处理过程中，表的处理并不像传统定义的那样简单。</p>
<p>对于流式查询（Streaming Queries），需要声明如何在（动态）表和外部连接器之间执行转换。与外部系统交换的消息类型，由<strong>更新模式</strong>（update mode）指定。</p>
<p>Flink Table API中的更新模式有以下三种：</p>
<h6 id="1-追加模式（Append-Mode）"><a href="#1-追加模式（Append-Mode）" class="headerlink" title="1. 追加模式（Append Mode）"></a>1. 追加模式（Append Mode）</h6><p>在追加模式下，表（动态表）和外部连接器只交换插入（Insert）消息。 </p>
<h6 id="2-撤回模式（RetractMode）"><a href="#2-撤回模式（RetractMode）" class="headerlink" title="2. 撤回模式（RetractMode）"></a>2. 撤回模式（RetractMode）</h6><p>在撤回模式下，表和外部连接器交换的是：添加（Add）和撤回（Retract）消息。</p>
<ul>
<li>插入（insert）会被编码为添加消息</li>
<li>删除（Delete）则编码为撤回消息</li>
<li>更新（Update）则会编码为，已更新行（上一行）的撤回想消息，和更新行（新行）的添加消息。</li>
</ul>
<p>在此模式下，不能定义key，这一点跟upsert模式完全不同。</p>
<h6 id="3-Upsert（更新插入）模式"><a href="#3-Upsert（更新插入）模式" class="headerlink" title="3. Upsert（更新插入）模式"></a>3. Upsert（更新插入）模式</h6><p>在Upsert模式下，动态表和外部连接器交换Upsert和Delete消息</p>
<p>这个模式需要一个唯一的key，通过这个key可以传递更新消息。为了正确应用消息，外部连接器需要知道这个唯一key的属性。</p>
<ul>
<li><p>插入（Insert）和更新（Update）都被编码为Upsert消息；</p>
</li>
<li><p> 删除（Delete）编码为Delete信息。</p>
</li>
</ul>
<p>这种模式和Retract模式的主要区别在于，Update操作是用单个消息编码的，所以效率会更高。</p>
<h4 id="2-8-将表转换成DataStream"><a href="#2-8-将表转换成DataStream" class="headerlink" title="2.8 将表转换成DataStream"></a>2.8 将表转换成DataStream</h4><p>将表转换为DataStream或DataSet时，需要指定生成的数据类型，即要将表的每一行转换成的数据类型。通常，最方便的转换类型就是Row。当然，因为结果的所有字段类型都是明确的，我们也经常会用元组类型来表示。</p>
<p>表作为流式查询的结果，是动态更新的。所以，将这种动态查询转换成的数据流，同样需要对表的更新操作进行编码，进而有不同的转换模式。</p>
<p>Table API中表到DataStream有两种模式：</p>
<ul>
<li> 追加模式（Append Mode）</li>
</ul>
<p>  用于表只会被插入（Insert）操作更改的场景。</p>
<ul>
<li> 撤回模式（Retract Mode）</li>
</ul>
<p>  用于任何场景。有些类似于更新模式中Retract模式，它只有Insert和Delete两类操作。</p>
<p>得到的数据会增加一个Boolean类型的标识位（返回的第一个字段），用它来表示到底是新增的数据（Insert），还是被删除的数据（老数据， Delete）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Row&gt; rowDataStream = tableEnv.toAppendStream(resultTable, Row.class);</span><br></pre></td></tr></table></figure>

<p>所以，没有经过groupby之类聚合操作，可以直接用 toAppendStream 来转换；而如果经过了聚合，有更新操作，一般就必须用 toRetractDstream。</p>
<h4 id="2-9-Query-的解释和执行"><a href="#2-9-Query-的解释和执行" class="headerlink" title="2.9 Query 的解释和执行"></a>2.9 Query 的解释和执行</h4><p>Table API提供了一种机制来解释（Explain）计算表的逻辑和优化查询计划。这是通过TableEnvironment.explain（table）方法或TableEnvironment.explain（）方法完成的。</p>
<p>explain方法会返回一个字符串，描述三个计划：</p>
<ul>
<li><p> 未优化的逻辑查询计划</p>
</li>
<li><p> 优化后的逻辑查询计划</p>
</li>
<li><p> 实际执行计划</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tableEnv.explain(resultTable)</span><br></pre></td></tr></table></figure>

<p>Query的解释和执行过程，老planner和blink planner大体是一致的，又有所不同。整体来讲，Query都会表示成一个逻辑查询计划，然后分两步解释：</p>
<ol>
<li><p>优化查询计划</p>
</li>
<li><p>解释成 DataStream 或者 DataSet程序</p>
</li>
</ol>
<p>而Blink版本是批流统一的，所以所有的Query，只会被解释成DataStream程序；另外在批处理环境TableEnvironment下，Blink版本要到tableEnv.execute()执行调用才开始解释。</p>
<h3 id="3-流处理中的特殊概念"><a href="#3-流处理中的特殊概念" class="headerlink" title="3. 流处理中的特殊概念"></a>3. 流处理中的特殊概念</h3><p>Table API和SQL，本质上还是基于关系型表的操作方式；而关系型表、关系代数，以及SQL本身，一般是有界的，更适合批处理的场景。这就导致在进行流处理的过程中，理解会稍微复杂一些，需要引入一些特殊概念。</p>
<h4 id="3-1-流处理和关系代数（表，及SQL）的区别"><a href="#3-1-流处理和关系代数（表，及SQL）的区别" class="headerlink" title="3.1 流处理和关系代数（表，及SQL）的区别"></a>3.1 流处理和关系代数（表，及SQL）的区别</h4><p><img src="C:\Users\LuYu\AppData\Roaming\Typora\typora-user-images\image-20210801231913955.png" alt="image-20210801231913955"></p>
<p>可以看到，其实关系代数（主要就是指关系型数据库中的表）和SQL，主要就是针对批处理的，这和流处理有天生的隔阂。</p>
<h4 id="3-2-动态表（Dynamic-Tables）"><a href="#3-2-动态表（Dynamic-Tables）" class="headerlink" title="3.2 动态表（Dynamic Tables）"></a>3.2 动态表（Dynamic Tables）</h4><p>因为流处理面对的数据，是连续不断的，这和我们熟悉的关系型数据库中保存的“表”完全不同。所以，如果我们把流数据转换成Table，然后执行类似于table的select操作，结果就不是一成不变的，而是随着新数据的到来，会不停更新。</p>
<p>我们可以随着新数据的到来，不停地在之前的基础上更新结果。这样得到的表，在Flink Table API概念里，就叫做“<strong>动态表</strong>”（Dynamic Tables）。</p>
<p>动态表是Flink对流数据的Table API和SQL支持的核心概念。与表示批处理数据的静态表不同，动态表是随时间变化的。动态表可以像静态的批处理表一样进行查询，查询一个动态表会产生持续查询（Continuous Query）。连续查询永远不会终止，并会生成另一个动态表。查询（Query）会不断更新其动态结果表，以反映其动态输入表上的更改。</p>
<h4 id="3-3-流式持续查询的过程"><a href="#3-3-流式持续查询的过程" class="headerlink" title="3.3 流式持续查询的过程"></a>3.3 流式持续查询的过程</h4><p><img src="C:\Users\LuYu\AppData\Roaming\Typora\typora-user-images\image-20210801232116759.png" alt="image-20210801232116759"></p>
<p>流式持续查询的过程为：</p>
<ol>
<li>流被转换为动态表</li>
<li>对动态表计算连续查询，生成的新的动态表</li>
<li>生成的动态表被转换回流</li>
</ol>
<h4 id="3-4-时间特性"><a href="#3-4-时间特性" class="headerlink" title="3.4 时间特性"></a>3.4 时间特性</h4><p>基于时间的操作（比如Table API和SQL中窗口操作），需要定义相关的时间语义和时间数据来源的信息。所以，Table可以提供一个逻辑上的时间字段，用于在表处理程序中，指示时间和访问相应的时间戳。</p>
<p>时间属性，可以是每个表schema的一部分。一旦定义了时间属性，它就可以作为一个字段引用，并且可以在基于时间的操作中使用。</p>
<p>时间属性的行为类似于常规时间戳，可以访问，并且进行计算。</p>
<h5 id="3-4-1-处理时间（Processing-Time）"><a href="#3-4-1-处理时间（Processing-Time）" class="headerlink" title="3.4.1 处理时间（Processing Time）"></a>3.4.1 处理时间（Processing Time）</h5><h5 id="3-4-2-事件时间"><a href="#3-4-2-事件时间" class="headerlink" title="3.4.2 事件时间"></a>3.4.2 事件时间</h5><p>事件时间语义，允许表处理程序根据每个记录中包含的时间生成结果。这样即使在有乱序事件或者延迟事件时，也可以获得正确的结果。</p>
<p>为了处理无序事件，并区分流中的准时和迟到事件；Flink需要从事件数据中，提取时间戳，并用来推进事件时间的进展（watermark）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://xiaowodi.github.io/2022/06/24/Java-IO%E4%B8%8ENIO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/24/Java-IO%E4%B8%8ENIO/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-24 08:12:10" itemprop="dateCreated datePublished" datetime="2022-06-24T08:12:10+00:00">2022-06-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-IO流"><a href="#1-IO流" class="headerlink" title="1. IO流"></a>1. IO流</h1><h2 id="1-1-File类的使用"><a href="#1-1-File类的使用" class="headerlink" title="1.1 File类的使用"></a>1.1 File类的使用</h2><h3 id="File类的理解"><a href="#File类的理解" class="headerlink" title="File类的理解"></a>File类的理解</h3><ol>
<li><p>File类的一个对象，代表一个文件或一个目录（俗称：文件夹）</p>
</li>
<li><p>File类声明在<code>java.io</code>包下</p>
</li>
<li><p>File类中涉及到关于文件或文件目录的创建，删除、重命名、修改时间、文件大小等方法</p>
<p>并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流来完成</p>
</li>
<li><p>后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的“终点”。</p>
</li>
</ol>
<h3 id="File的实例化"><a href="#File的实例化" class="headerlink" title="File的实例化"></a>File的实例化</h3><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p><img src="source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211012095630962.png" alt="image-20211012095630962"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(String filePath);</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(String parentPath, String childPath);</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(File parentFile, String childPath);</span><br></pre></td></tr></table></figure>



<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDirectory</span><span class="params">()</span>：判断是否是文件目录</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFile</span><span class="params">()</span> ：判断是否是文件</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exists</span><span class="params">()</span> ：判断是否存在</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canRead</span><span class="params">()</span> ：判断是否可读</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canWrite</span><span class="params">()</span> ：判断是否可写</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHidden</span><span class="params">()</span> ：判断是否隐藏</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">createNewFile</span><span class="params">()</span> ：创建文件。若文件存在，则不创建，返回<span class="literal">false</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">mkdirs</span><span class="params">()</span> ：创建文件目录。如果此文件目录存在，就不创建了。如果词文件目录的上层目录不存在， 也不创建。</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">mkdir</span><span class="params">()</span> ：创建文件目录，如果上层文件目录不存在，一并创建</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">()</span> ：删除文件或者文件夹（直接删除，不走回收站）</span><br><span class="line"><span class="comment">//  分隔符常量</span></span><br><span class="line">File.separator  用于路径的分隔符  <span class="comment">/* unix：/   windows： \\ */</span></span><br></pre></td></tr></table></figure>





<h2 id="1-2-IO流概述"><a href="#1-2-IO流概述" class="headerlink" title="1.2 IO流概述"></a>1.2 IO流概述</h2><ul>
<li><p>I/O是Input/Output的缩写，I/O技术是非常实用的技术，用于处理设备之间的数据传输。如读/写文件、网络通讯等。</p>
</li>
<li><p>Java程序中，对于数据的输入/输出操作以“流Stream”的方式进行。</p>
</li>
<li><p>java.io包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过标准的方法输入或输出数据。</p>
</li>
<li><p>输入Input：读取外部数据（磁盘，光盘等存储设备的数据）到程序（内存）中</p>
</li>
<li><p>输出output：将程序（内存）数据输出到磁盘、光盘等存储设备中</p>
</li>
</ul>
<p><strong>流的分类</strong></p>
<ul>
<li>按操作数据单位不同分为：<strong>字节流（8bit）</strong>、<strong>字符流（16bit）</strong></li>
<li>按数据流的流向不同分为：输入流、输出流</li>
<li>按数据流的角色不同分为：节点流、处理流</li>
</ul>
<table>
<thead>
<tr>
<th>抽象基类</th>
<th>字节流</th>
<th>字符流</th>
</tr>
</thead>
<tbody><tr>
<td>输入流</td>
<td>InputStream</td>
<td>Reader（往内存中读取数据）</td>
</tr>
<tr>
<td>输出流</td>
<td>OutputStream</td>
<td>Writer（将内存中数据写出）</td>
</tr>
</tbody></table>
<p>Java的IO流涉及40多个类，实际上非常规则，都是从上述4个抽象基类派生的；由这四个类派生出来的子类名称都是其父类名作为子类名后缀。</p>
<p><strong>IO流的体系</strong></p>
<table>
<thead>
<tr>
<th>分类</th>
<th>字节输入流</th>
<th>字节输出流</th>
<th>字符输入流</th>
<th>字符输出流</th>
</tr>
</thead>
<tbody><tr>
<td>抽象基类</td>
<td>InputStream</td>
<td>OutputStream</td>
<td>Reader</td>
<td>Writer</td>
</tr>
<tr>
<td>访问文件（节点流）</td>
<td>FileInputStream</td>
<td>FileOutputStream</td>
<td>FileReader</td>
<td>FileWriter</td>
</tr>
<tr>
<td>访问数组</td>
<td>ByteArrayInputStream</td>
<td>ByteArrayOutputStream</td>
<td>CharArrayReader</td>
<td>CharArrayWriter</td>
</tr>
<tr>
<td>访问管道</td>
<td>PipedInputStream</td>
<td>PipedOutputStream</td>
<td>PipedReader</td>
<td>PipedWriter</td>
</tr>
<tr>
<td>访问字符串</td>
<td></td>
<td></td>
<td>StringReader</td>
<td>StringWriter</td>
</tr>
<tr>
<td>缓冲流(处理流的一种)</td>
<td>BufferedInputStream</td>
<td>BufferedOutputStream</td>
<td>BufferedReader</td>
<td>BufferedWriter</td>
</tr>
<tr>
<td>转换流</td>
<td></td>
<td></td>
<td>InputStreamReader</td>
<td>OutputStreamWriter</td>
</tr>
<tr>
<td>对象流</td>
<td>ObjectInputStream</td>
<td>ObjectOutputStream</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>FilterInputStream</td>
<td>FilterOutputStream</td>
<td>FilterReader</td>
<td>FilterWriter</td>
</tr>
<tr>
<td>打印流</td>
<td></td>
<td>PrintStream</td>
<td></td>
<td>PrintWriter</td>
</tr>
<tr>
<td>推回输入流</td>
<td>PushbackinputStream</td>
<td></td>
<td>PushbackReader</td>
<td></td>
</tr>
<tr>
<td>特殊流</td>
<td>DataInputStream</td>
<td>DataOutputStream</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="1-3-文件流"><a href="#1-3-文件流" class="headerlink" title="1.3 文件流"></a>1.3 文件流</h2><h3 id="1-3-1-FileReader读入数据的基本操作"><a href="#1-3-1-FileReader读入数据的基本操作" class="headerlink" title="1.3.1 FileReader读入数据的基本操作"></a>1.3.1 FileReader读入数据的基本操作</h3><p><strong>四步骤：</strong></p>
<ol>
<li><p>建立一个流对象，将已存在的一个文件加载进流</p>
<ul>
<li>```java<br>FileReader fr = new FileReader(new File(“Test.txt”));<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 创建一个临时存放数据的数组</span><br><span class="line"></span><br><span class="line">   - ```java</span><br><span class="line">     char[] ch = new char[1024];</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>调用流对象对象的读取方法将流中的数据读入到数组中</p>
<ul>
<li>```java<br>fr.read(ch);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 关闭资源</span><br><span class="line"></span><br><span class="line">   - ```java</span><br><span class="line">     fr.close();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><strong>使用read()方法一个字符一个字符的读取</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IoDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Files\\file1.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fileReader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line">            <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> fileReader.read();</span><br><span class="line">            <span class="keyword">while</span> (read!=-<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.print((<span class="type">char</span>)read);</span><br><span class="line">                read = fileReader.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            fileReader.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果 </span></span><br><span class="line">asdfsdfasdfsdf</span><br><span class="line">dsfsd</span><br><span class="line">cvc</span><br><span class="line">qwref</span><br></pre></td></tr></table></figure>

<p><strong>使用read(char[] chars) 方法读入数据</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readDemo2</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Files\\file1.txt&quot;</span>);</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line">        <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len=fr.read(chars))!=-<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(len);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(chars,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-2-FileWriter写出数据的操作"><a href="#1-3-2-FileWriter写出数据的操作" class="headerlink" title="1.3.2 FileWriter写出数据的操作"></a>1.3.2 FileWriter写出数据的操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writterDemo</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Files\\fileOutput.txt&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Files\\fileOutput2.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 默认 每次 write 覆盖原有文件中的内容</span></span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file,<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 指定为true时， 每次write 表示追加内容到文件中</span></span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fw2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file2,<span class="literal">true</span>);</span><br><span class="line">    fw.write(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    fw2.write(<span class="string">&quot;hello2&quot;</span>);</span><br><span class="line">    fw.close();</span><br><span class="line">    fw2.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认 每次 write 覆盖原有文件中的内容</span></span><br><span class="line">    fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file,<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 指定为true时， 每次write 表示追加内容到文件中</span></span><br><span class="line">    fw2 = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file2,<span class="literal">true</span>);</span><br><span class="line">    fw.write(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    fw2.write(<span class="string">&quot;hello2&quot;</span>);</span><br><span class="line">    fw.close();</span><br><span class="line">    fw2.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211018141242195-16345375636911.png" alt="image-20211018141242195"></p>
<h3 id="1-3-3-FileReader-和-FileWriter实现文本复制"><a href="#1-3-3-FileReader-和-FileWriter实现文本复制" class="headerlink" title="1.3.3 FileReader 和 FileWriter实现文本复制"></a>1.3.3 FileReader 和 FileWriter实现文本复制</h3><p>小需求：要求将文件<code>file1.txt</code>中的内容复制到另一个文件<code>file2.txt</code>中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyContextToOther</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">filePath1</span> <span class="operator">=</span> <span class="string">&quot;Files\\file1.txt&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">filePath2</span> <span class="operator">=</span> <span class="string">&quot;Files\\file2.txt&quot;</span>;</span><br><span class="line">    <span class="type">File</span> <span class="variable">src</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath1);</span><br><span class="line">    <span class="type">File</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath2);</span><br><span class="line">    <span class="comment">// 将 file1.txt 中的内容读到内存中</span></span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(src);</span><br><span class="line">    <span class="comment">// 将读取的数据临时存放到buffer中</span></span><br><span class="line">    <span class="type">char</span>[] buffer = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="comment">// 将file1.txt 中的内容写到file2.txt中</span></span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(target);</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((len = fr.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        fw.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    fw.close();</span><br><span class="line">    fr.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211018143034994-16345386387512.png" alt="image-20211018143034994"></p>
<h3 id="1-3-4-FileInputStream和FileOutputStream不能读取文本文件"><a href="#1-3-4-FileInputStream和FileOutputStream不能读取文本文件" class="headerlink" title="1.3.4 FileInputStream和FileOutputStream不能读取文本文件"></a>1.3.4 FileInputStream和FileOutputStream不能读取文本文件</h3><p><strong>tip:</strong></p>
<p><strong>FileInputStream</strong>和<strong>FileOutputStream</strong>不能操作像<code>.java</code>,<code>.cpp</code>,<code>.txt</code>,<code>.c</code>等文本文件，操作文本文件使用<strong>FileReader</strong>和<strong>FileWriter</strong>字符流；</p>
<p>如果是<code>.jpg</code>,<code>.mp4</code>,<code>.mp3</code>等文件使用<strong>FileInputStream</strong>和<strong>FileOutputStream</strong>字节流操作</p>
<p><font color=green>使用字节流<strong>FileInputStream</strong>和<strong>FileOutputStream</strong>操作文本文件，有可能出现乱码的问题</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用字节流操作文本文件</span></span><br><span class="line">    <span class="comment">//使用字节流FileInputStream处理文本文件，可能出现乱码。</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileInputStream</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.造文件</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Files\\file1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.造流</span></span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.读数据</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="type">int</span> len;<span class="comment">//记录每次读取的字节的个数</span></span><br><span class="line">            <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer,<span class="number">0</span>,len);</span><br><span class="line">                System.out.print(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fis != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//4.关闭资源</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>使用<strong>FileInputStream</strong>和<strong>FileOutputStream</strong>实现文件的复制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyByte</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Files\\卡通 - 4.jpg&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Files\\卡通 - 5.jpg&quot;</span>);</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file1);</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file2);</span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((len=fis.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    fos.close();</span><br><span class="line">    fis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211018145332931-16345400144173.png" alt="image-20211018145332931"></p>
<h2 id="1-4-缓冲流的使用"><a href="#1-4-缓冲流的使用" class="headerlink" title="1.4 缓冲流的使用"></a>1.4 缓冲流的使用</h2><p><img src="source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/7ce79819b9685ffc2bae685bec83b0f1.png" alt="img"></p>
<ul>
<li>缓冲流要<code>套接</code>在相应的节点流之上，根据数据操作单位可以把缓冲流分为：<ul>
<li><strong>BufferedInputStream</strong>和<strong>BufferedOutputStream</strong></li>
<li><strong>BufferedReader</strong>和<strong>BufferedWriter</strong></li>
</ul>
</li>
<li>当读取数据时，数据按块读入缓冲区，其后的读操作则直接访问缓冲区</li>
<li>当使用BufferedInputStream读取字节文件时，BufferedInputStream会一次性从文件中读取8192（8kb）,存在缓冲区中，直到缓冲区装满了，才重新从文件中读取下一个8kb的字节数组。</li>
<li>向流中写入字节时，不会直接写到文件，先写到缓冲区中直到缓冲区写满，BufferedOutputStream才会把缓冲区中的数据一次性写到文件中。使用<code>flush()</code>可以强制将缓冲区的内容全部写入到输出流中。</li>
<li>关闭流的顺序和打开流的顺序相反。只要关闭最外层流即可，关闭最外层流也会相应关闭内层节点流</li>
<li>flush()方法的使用：手动将buffer中内容写入到文件</li>
<li>如果是带缓冲区的流对象的close()方法，不但会关闭流，还会在关闭流之间刷线缓冲区，关闭后不能再写出。</li>
</ul>
<h2 id="1-5-转换流的使用"><a href="#1-5-转换流的使用" class="headerlink" title="1.5 转换流的使用"></a>1.5 转换流的使用</h2><h3 id="1-5-1-转换流概述与InputStreamReader的使用"><a href="#1-5-1-转换流概述与InputStreamReader的使用" class="headerlink" title="1.5.1 转换流概述与InputStreamReader的使用"></a>1.5.1 转换流概述与InputStreamReader的使用</h3><ul>
<li>转换流提供了在字节流和字符流之间的转换</li>
<li>Java API提供了两个转换流：<ul>
<li><code>InputStreamReader</code>：将InputStream转换成Reader<ul>
<li>实现将字节的输入流按指定字符集转换成字符的输入流</li>
<li>需要和<code>InputStream</code>套接</li>
<li>构造器<ul>
<li><code>public InputStreamReader(InpurStream in)</code></li>
<li><code>public InputStreamReader(InpurStream in, String charsetName)</code></li>
<li>例如：<code>Reader isr=new InpurStreamReader(System.in, &quot;gbk&quot;)</code></li>
</ul>
</li>
</ul>
</li>
<li><code>OutputStreamWriter</code>：将Writer转换为OutputStream<ul>
<li>实现将字符的输出流按指定字符集转换为字节的输出流</li>
<li>需要和<code>OutputStream</code>套接</li>
<li>构造器<ul>
<li><code>public OutputStreamWriter(OutputStream out)</code></li>
<li><code>public OutputStreamWriter(OutputStream out, String charsetName)</code></li>
</ul>
</li>
</ul>
</li>
<li>字节流中的数据都是字符时，转换成字符流操作更高效</li>
<li>很多时候我们使用转换流来处理文本乱码问题。实现编码和解码的功能。</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4dfa85f71b54ed2d8e3a43371933b7fb.png" alt="img"></p>
<h3 id="1-5-2-转换流实现文件的读入和写出"><a href="#1-5-2-转换流实现文件的读入和写出" class="headerlink" title="1.5.2 转换流实现文件的读入和写出"></a>1.5.2 转换流实现文件的读入和写出</h3><p><strong>InputStreamReader</strong>：将一个字节的输入流转换为字符的输入流</p>
<p><strong>OutputStreamWriter</strong>：将一个字符的输出流转换为字节的输出流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transformation</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Files\\file1.txt&quot;</span>));</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Files\\file3.txt&quot;</span>));</span><br><span class="line">    <span class="comment">// 将字节流转换成字符流</span></span><br><span class="line">    <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream);</span><br><span class="line">    <span class="comment">// 将字符流转换成字节输出流</span></span><br><span class="line">    <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream);</span><br><span class="line">    <span class="comment">// 用字符数组承接字节流转换成字符流的数据</span></span><br><span class="line">    <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((len=isr.read(chars))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 将字符流通过转换流写出到字节流FileOutputStream中</span></span><br><span class="line">        osw.write(chars,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    osw.close();</span><br><span class="line">    isr.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="1-6-其他的流的使用"><a href="#1-6-其他的流的使用" class="headerlink" title="1.6 其他的流的使用"></a>1.6 其他的流的使用</h2><h3 id="1-6-1-标准输入、输出流"><a href="#1-6-1-标准输入、输出流" class="headerlink" title="1.6.1 标准输入、输出流"></a>1.6.1 标准输入、输出流</h3><ul>
<li>System.in 和 System.out 分别代表了系统标准的输入和输出设备</li>
<li>默认输入设备是键盘；输出设备是：显示器</li>
<li>System.in 的类型方式InputStream</li>
<li>System.out的类型是PrintStream，其是OutputStream的子类FilterOutputStream的子类</li>
<li>重定向：通过System类的setln，setOut方法对默认设备进行改变。<ul>
<li><code>public static void setln(InputStream in)</code></li>
<li><code>public static void setOut(PrintStream out)</code></li>
</ul>
</li>
</ul>
<h3 id="1-6-2-打印流"><a href="#1-6-2-打印流" class="headerlink" title="1.6.2 打印流"></a>1.6.2 打印流</h3><ul>
<li>实现将基本数据类型的数据格式转化为字符串输出</li>
<li>打印流：PrintStream和PrintWriter<ul>
<li>提供了一系列重载的print()和println()方法，用于多种数据类型的输出</li>
<li>PrintStream和PrintWriter的输出不会抛出IOException异常</li>
<li>PrintStream和PrintWriter有自动flush功能</li>
<li>PrintStream打印的所有字符都使用平台的默认字符编码转换为字节。在需要写入字符而不是写入字节的情况下，应该使用PrintWriter类。</li>
<li>System.out返回的是PrintStream的实例</li>
</ul>
</li>
</ul>
<h3 id="1-6-3-数据流"><a href="#1-6-3-数据流" class="headerlink" title="1.6.3 数据流"></a>1.6.3 数据流</h3><ul>
<li>为了方便地操作Java语言的基本数据类型和String的string数据，可以使用数据流</li>
<li>数据流有两个类：（用于读取和写出基本数据类型、String类的数据）<ul>
<li>DataInputStream和DataOutputStream</li>
<li>分别“套接”在InputStream和OutputStream</li>
</ul>
</li>
</ul>
<p><strong>数据流</strong>：</p>
<ul>
<li>DataInputStream：数据输入流</li>
<li>DataOutputStream：数据输出流</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dataStreamDemoWrite</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="comment">// 数据流 可以读取特定类型的数据，可以写特定的数据类型的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Files\\data.txt&quot;</span>)));</span><br><span class="line">    dos.writeChar(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">    dos.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">    dos.writeDouble(<span class="number">2.0798654</span>);</span><br><span class="line">    dos.writeLong(<span class="number">123456789L</span>);</span><br><span class="line">    dos.flush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dataStreamDemoReade</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Files\\data.txt&quot;</span>)));</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> dis.readChar();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> dis.readBoolean();</span><br><span class="line">    <span class="type">double</span> <span class="variable">v</span> <span class="operator">=</span> dis.readDouble();</span><br><span class="line">    <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> dis.readLong();</span><br><span class="line">    System.out.println(c+<span class="string">&quot;\t&quot;</span>+b+<span class="string">&quot;\t&quot;</span>+v+<span class="string">&quot;\t&quot;</span>+l+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="1-7-对象流"><a href="#1-7-对象流" class="headerlink" title="1.7 对象流"></a>1.7 对象流</h2><h3 id="1-7-1-对象序列化机制的理解"><a href="#1-7-1-对象序列化机制的理解" class="headerlink" title="1.7.1 对象序列化机制的理解"></a>1.7.1 对象序列化机制的理解</h3><ul>
<li><code>ObjectInputStream</code>和<code>ObjectOutputStream</code></li>
<li>用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。</li>
<li>序列化：用<code>ObjectInputStream</code>类读取基本类型数据或对象的机制</li>
<li>反序列化：用<code>ObjectInputStream</code>类读取基本类型数据或对象的机制</li>
<li><code>ObjectOutputStream</code>和<code>ObjectInputStream</code>不能序列化<code>static</code>和<code>transient</code>修饰的成员变量</li>
<li>对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其他程序获取这种二进制流，就可以恢复原来的Java对象。</li>
<li>序列化的好处在于可将任何实现了<code>Serializable</code>接口的对象转化为字节数据，使其在保存和传输时刻被还原</li>
<li>序列化是RMI（Remote Method Invoke-远程方法调用）过程的参数和返回值都必须实现的机制，而RMI是JavaEE的基础。因此序列化机制是JavaEE平台的基础</li>
<li>如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一。否则，会抛出<code>NotSerializableException</code>异常<ul>
<li><code>Serializable</code></li>
<li><code>Externalizable</code></li>
</ul>
</li>
</ul>
<h3 id="1-7-2-对象流序列化与反序列化字符串操作"><a href="#1-7-2-对象流序列化与反序列化字符串操作" class="headerlink" title="1.7.2 对象流序列化与反序列化字符串操作"></a>1.7.2 对象流序列化与反序列化字符串操作</h3><p>定义一个Person类，并实现<code>Serializable</code>接口，实现系列化功能，</p>
<p>通过<code>ObjectOutputStream</code>将Person对象写入到<code>person.dat</code>文件中，然后通过<code>ObjectInputStream</code>将person读回内存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化与反序列化</span></span><br><span class="line"><span class="comment">     *  实现Serializable接口，即可将对象通过ObjectOutputStream存储到磁盘中</span></span><br><span class="line"><span class="comment">     *                              通过ObjectInputStream读取到内存中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serializableDemo</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Files\\person.dat&quot;</span>)));</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;yu&quot;</span>, <span class="number">25</span>);</span><br><span class="line">    oos.writeObject(person);</span><br><span class="line"></span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Files\\person.data&quot;</span>)));</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> (Person)ois.readObject();</span><br><span class="line">    System.out.println(person1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-7-3-serialVersionUID的理解"><a href="#1-7-3-serialVersionUID的理解" class="headerlink" title="1.7.3 serialVersionUID的理解"></a>1.7.3 serialVersionUID的理解</h3><ul>
<li>凡是实现<code>Serializable</code>接口的类都有一个表示序列化版本标识符的静态变量<ul>
<li><code>private static final long serialVersionUID</code></li>
<li><code>serialVersionUID</code>用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容</li>
<li>如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实力变量做了修改，<code>serialVersionUID</code>可能发生变化，故建议显示声明</li>
</ul>
</li>
<li>简单来说，Java的序列化机制是通过在运行时判断类的<code>serialVersionUID</code>来验证版本一致的。在进行反序列化时，JVM会把传来的字节流中的<code>serialVersionUID</code>与本地相应实体类的<code>serialVersionUID</code>进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常（InvalidCastException）</li>
</ul>
<p>如果想要一个类的对象可序列化，除了实现<code>Serializable</code>接口之外，还必须保证其内部所有的属性也必须是可序列化的。（默认情况下，基本数据类型都可序列化）</p>
<p>一般情况下需要自定义<code>serialVersionUID</code></p>
<blockquote>
<p><strong>序列化机制</strong></p>
<p>对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其他程序获取了这种二进制流，就可以恢复成原来的Java对象。</p>
</blockquote>
<h2 id="1-8-RandomAccessFile-随机存取文件流-的使用"><a href="#1-8-RandomAccessFile-随机存取文件流-的使用" class="headerlink" title="1.8 RandomAccessFile(随机存取文件流)的使用"></a>1.8 RandomAccessFile(随机存取文件流)的使用</h2><ul>
<li><code>RandomAccessFile</code>声明在<code>java.io</code>包下，但直接继承于<code>java.lang.Object</code>类。并且它实现了<code>DataInput、DataOutput</code>这两个接口，也就意味着这个类<strong>既可以读也可以写</strong></li>
<li><code>RandomAccessFile</code>类支持“随机访问”的方式，程序可以直接跳到文件的任意地方来读、写文件<ul>
<li>支持只访问文件的部分内容</li>
<li>可以向已存在的文件后追加内容</li>
</ul>
</li>
<li><code>RandomAccessFile</code>对象包含一个记录指针，用以表示单签读写处的位置。<code>RandomAccessFile</code>类对象可以自己移动记录指针：<ul>
<li><code>long getFilePointer()</code></li>
<li><code>void seek(long pos)</code></li>
</ul>
</li>
<li>构造器<ul>
<li><code>public RandomAccessFile(File file, String mode)</code></li>
<li><code>public RandomAccessFile(String name, String mode)</code></li>
</ul>
</li>
<li>创建RandomAccessFile类实例需要指定一个mode参数，该参数指定RandomAccessFile的访问模式：<ul>
<li><code>r</code>：以只读方式打开</li>
<li><code>rw</code>：打开以便读取和写入</li>
<li><code>rwd</code>：打开以便读取和写入；同步文件内容的更新</li>
<li><code>rws</code>：打开以便读取和写入；同步文件内容和元数据的更新</li>
</ul>
</li>
<li>如果模式为只读<code>r</code>，则不会创建文件，而是会去读取一个已经存在的文件，如果读取的文件不存在则会出现异常。如果模式为<code>rw</code>读写，如果文件不存在则去创建文件，如果存在则不会创建。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RandomAccessFile的使用</span></span><br><span class="line"><span class="comment"> * 1.RandomAccessFile直接继承于java.lang.Object类，实现了DataInput和DataOutput接口</span></span><br><span class="line"><span class="comment"> * 2.RandomAccessFile既可以作为一个输入流，又可以作为一个输出流</span></span><br><span class="line"><span class="comment"> * 3.如果RandomAccessFile作为输出流时，写出到的文件如果不存在，则在执行过程中自动创建。</span></span><br><span class="line"><span class="comment"> *   如果写出到的文件存在，则会对原有文件内容进行覆盖。（默认情况下，从头覆盖）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomAccessFileTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">raf1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">raf2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            raf1 = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;爱情与友情.jpg&quot;</span>),<span class="string">&quot;r&quot;</span>);</span><br><span class="line">            raf2 = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;爱情与友情1.jpg&quot;</span>),<span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = raf1.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                raf2.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(raf1 != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    raf1.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(raf2 != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    raf2.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">raf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;hello.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">        raf1.write(<span class="string">&quot;xyz&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        raf1.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RandomAccessFile实现数据的插入（seek()方法会重置偏移量）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RandomAccessFile的使用</span></span><br><span class="line"><span class="comment"> * 1.RandomAccessFile直接继承于java.lang.Object类，实现了DataInput和DataOutput接口</span></span><br><span class="line"><span class="comment"> * 2.RandomAccessFile既可以作为一个输入流，又可以作为一个输出流</span></span><br><span class="line"><span class="comment"> * 3.如果RandomAccessFile作为输出流时，写出到的文件如果不存在，则在执行过程中自动创建。</span></span><br><span class="line"><span class="comment"> *   如果写出到的文件存在，则会对原有文件内容进行覆盖。（默认情况下，从头覆盖）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 4.可以通过相关的操作，实现RandomAccessFile“插入”数据的效果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomAccessFileTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用RandomAccessFile实现数据的插入效果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">raf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;hello.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">        raf1.seek(<span class="number">3</span>);<span class="comment">//将指针调到角标为3的位置</span></span><br><span class="line">        <span class="comment">//保存指针3后面的所有数据到StringBuilder中</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>((<span class="type">int</span>) <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>).length());</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = raf1.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            builder.append(<span class="keyword">new</span> <span class="title class_">String</span>(buffer,<span class="number">0</span>,len)) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调回指针，写入“xyz”</span></span><br><span class="line">        raf1.seek(<span class="number">3</span>);</span><br><span class="line">        raf1.write(<span class="string">&quot;xyz&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将StringBuilder中的数据写入到文件中</span></span><br><span class="line">        raf1.write(builder.toString().getBytes());</span><br><span class="line"></span><br><span class="line">        raf1.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//思考：将StringBuilder替换为ByteArrayOutputStream</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-9-Path、Paths、Files的使用"><a href="#1-9-Path、Paths、Files的使用" class="headerlink" title="1.9 Path、Paths、Files的使用"></a>1.9 Path、Paths、Files的使用</h2><h1 id="2-网络编程"><a href="#2-网络编程" class="headerlink" title="2. 网络编程"></a>2. 网络编程</h1><h3 id="2-1-网络编程概述"><a href="#2-1-网络编程概述" class="headerlink" title="2.1 网络编程概述"></a>2.1 网络编程概述</h3><ul>
<li>Java是Internet上的语言，它从语言级上提供了对网络应用程序的支持，程序员能够很容易开发常见的网络应用程序。</li>
<li>Java提供的网络类库，可以实现无痛的网络连接，联网的底层细节被隐藏在Java的本机安装系统中，有JVM进行控制。并且Java实现了一个跨平台的网络库，<strong>程序面对的是一个统一的网络编程环境</strong>。</li>
<li>网络编程的目的：直接或间接地通过网络协议与其它计算机实现数据交换，进行通讯</li>
<li>网络编程中有两个主要的问题：<ul>
<li>如果准确地定位网络上一台或多台主机；定位主机上的特定的应用</li>
<li>找到主机后如何可靠高效地进行数据传输</li>
</ul>
</li>
</ul>
<h3 id="2-2-网络通信要素概述"><a href="#2-2-网络通信要素概述" class="headerlink" title="2.2 网络通信要素概述"></a>2.2 网络通信要素概述</h3><ul>
<li>通信双方地址<ul>
<li>IP</li>
<li>端口号</li>
</ul>
</li>
<li>一定的规则（即：网络通信协议。有两套参考模型）<ul>
<li>OSI参考模型：模型过于理想化，未能在因特网上进行广泛推广</li>
<li>TCP/IP参考模型（或TCP/IP协议）：实事上的国际标准</li>
</ul>
</li>
<li>网络通信协议</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/09bdce6b569fe3cf80206cc704dbf7cb.png" alt="img"></p>
<p><img src="source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/e769997523201f9fa4f83e501931e6e1.png" alt="img"></p>
<blockquote>
<p>网络编程中有两个主要的问题：</p>
<ol>
<li>如何准确地定位网络上一台或多台主机；定位主机上的特定的应用</li>
<li>找到主机后如何可靠高效地进行数据传输</li>
</ol>
<p>网络编程中的两个要素：</p>
<ol>
<li>对应问题1：IP和端口号</li>
<li>对应问题2：提供网络通信协议：TCP/IP参考模型（应用层、传输层、网络层、物理+数据链路层）</li>
</ol>
</blockquote>
<h3 id="2-3-通信要素1：IP和端口号"><a href="#2-3-通信要素1：IP和端口号" class="headerlink" title="2.3 通信要素1：IP和端口号"></a>2.3 通信要素1：IP和端口号</h3><h4 id="2-3-1-IP的理解与InetAddress类的实例化"><a href="#2-3-1-IP的理解与InetAddress类的实例化" class="headerlink" title="2.3.1 IP的理解与InetAddress类的实例化"></a>2.3.1 IP的理解与InetAddress类的实例化</h4><ul>
<li>IP地址：<code>InetAddress</code><ul>
<li>唯一的表示Internet上的计算机（通信实体）</li>
<li>本地回环地址（hostAddress）：127.0.01 主机名（hostName）：localhost</li>
<li>IP地址分类方式1：IPV4和IPV6<ul>
<li>IPV4：由4个字节组成</li>
<li>IPV6：由16个字节组成</li>
</ul>
</li>
<li>IP地址分类方式2：公网地址（万维网使用）和私有地址（局域网使用）。<code>192.168. . </code>开头的就是私有地址，范围即为<code>192.168.0.0 ~ 192.168.255.255</code>，专门为组织内部使用。</li>
</ul>
</li>
<li>Internet上的主机有两种方式表示：<ul>
<li>域名（hostName）：<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a></li>
<li>IP地址（hostAddress）：220.181.38.149</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">    <span class="type">InetAddress</span> <span class="variable">inetAddress</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">    System.out.println(inetAddress);</span><br><span class="line">    <span class="comment">// 获取本地ip</span></span><br><span class="line">    System.out.println(InetAddress.getLocalHost());</span><br><span class="line">    <span class="comment">// 获取主机名</span></span><br><span class="line">    System.out.println(inetAddress.getHostName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">www.baidu.com/<span class="number">220.181</span><span class="number">.38</span><span class="number">.149</span></span><br><span class="line">DESKTOP-AQE9VH2/<span class="number">192.168</span><span class="number">.70</span><span class="number">.1</span></span><br><span class="line">www.baidu.com</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-端口号的理解"><a href="#2-3-2-端口号的理解" class="headerlink" title="2.3.2 端口号的理解"></a>2.3.2 端口号的理解</h4><ul>
<li>端口号表示正在计算机上运行的进程（程序）<ul>
<li>不同的进程有不同的端口号</li>
<li>被规定为一个16位的整数<code>0~65535</code></li>
<li>端口分类：<ul>
<li>公认端口：<code>0~1023</code>.被预先定义的服务通信占用（如：HTTP占用端口80，FTP占用端口21，Telnet占用端口23）</li>
<li>注册端口：<code>1024~49151</code>.分配给用户进程或应用程序。（如：Tomcat占用端口8080，MySQL占用端口3306，Oracle占用端口1521等）。</li>
<li>动态/私有端口：49152~65535.</li>
</ul>
</li>
</ul>
</li>
<li>端口号与IP地址的组合得出一个网络套接字：<code>Socket</code></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/cdbda7a9127a6319dcd57cc16be48849.png" alt="img"></p>
<h3 id="2-4-通信要素2：网络协议"><a href="#2-4-通信要素2：网络协议" class="headerlink" title="2.4 通信要素2：网络协议"></a>2.4 通信要素2：网络协议</h3><ul>
<li><p><strong>网络通信协议</strong></p>
<p>计算机网络中实现通信必须有一些约定，即通信协议，对速率，传输代码，代码结构，传输控制步骤，出错控制等制定标准。</p>
</li>
<li><p><strong>问题：网络协议太复杂</strong></p>
<p>计算机网络通信设计内容很多，比如指定源地址和目标地址，加密解密，压缩解压缩，差错控制，流量控制，路由控制等</p>
</li>
<li><p><strong>通信协议分层的思想</strong></p>
<p>在制定协议时，把复杂问题分解成一些简单的成分，再将他们复合起来。最常用的复合方式使层次方式，即同层间可以通信，上一层可以调用下一层，而与再下一层不发生关系。各层互不影响，利于系统的开发和扩展。</p>
</li>
</ul>
<h4 id="2-4-1-TCP和UDP网络通信协议的对比"><a href="#2-4-1-TCP和UDP网络通信协议的对比" class="headerlink" title="2.4.1 TCP和UDP网络通信协议的对比"></a>2.4.1 TCP和UDP网络通信协议的对比</h4><ul>
<li>传输层协议中有两个非常重要的协议：<ul>
<li>传输控制协议TCP</li>
<li>用户数据报协议UDP</li>
</ul>
</li>
<li>TCP/IP以其两个主要协议：传输控制协议（TCP）和网络互联协议（IP）而得名，实际上是一组协议，包括多个具有不同功能互为关联的协议。</li>
<li>IP协议是网络层的主要协议，支持网络间互连的数据通信</li>
<li>TCP/IP协议模型从更实用的角度出发，形成了高效的四层体系结构，即物理层、数据链路层、IP层、传输层T、应用层。</li>
<li>TCP协议：<ul>
<li>使用TCP协议前，需先建立TCP连接，形传输数据通道</li>
<li>传输前，采用“三次握手”方式，点对点通信，是可靠的</li>
<li>TCP协议进行通信的两个应用进程：客户端、服务端</li>
<li>在连接中进行大数据量的传输，传输完毕，需释放已建立的连接，效率低</li>
</ul>
</li>
<li>UDP协议：<ul>
<li>将数据、源、目的封装成数据包，不需要建立连接</li>
<li>每个数据报的大小限制在64K内</li>
<li>发送不管对方是否准备好，接收方收到也不确认，故是不可靠的</li>
<li>可以广播发送</li>
<li>发送数据结束时无需释放资源，开销小，速度快。</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e028a11c223c41376e42a0cecd7dc505.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/3125b3b4a4431912fa787bbeaea342b6.png" alt="img"></p>
<h3 id="2-5-TCP网络编程"><a href="#2-5-TCP网络编程" class="headerlink" title="2.5 TCP网络编程"></a>2.5 TCP网络编程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Client端 向 服务器端 发送数据</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// client 端 发送消息</span></span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建Socket对象，指明服务器端的ip和端口</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;192.168.137.237&quot;</span>);</span><br><span class="line">        socket = <span class="keyword">new</span> <span class="title class_">Socket</span>(inet, <span class="number">8899</span>);</span><br><span class="line">        <span class="comment">// 2. 获取一个输出流，用于输出数据</span></span><br><span class="line">        os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 3. 写出数据</span></span><br><span class="line">        os.write(<span class="string">&quot;hello world !&quot;</span>.getBytes());</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(os!=<span class="literal">null</span>)&#123;</span><br><span class="line">            os.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(socket!=<span class="literal">null</span>)&#123;</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Server端接收Client端发送来的数据</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// server 端 接收消息</span></span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 1. 创建服务器端的ServerSocket，指明自己的端口号</span></span><br><span class="line">    ss = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8899</span>);</span><br><span class="line">    <span class="comment">//2. 调用accept()表示接收来自客户端的socket</span></span><br><span class="line">    socket = ss.accept();</span><br><span class="line">    <span class="comment">// 3. 获取输入流    获取输出流的时候，会阻塞，等待Client端 给服务器端发送数据</span></span><br><span class="line">    is = socket.getInputStream();</span><br><span class="line">    <span class="comment">// 4. 读取输入流中的数据</span></span><br><span class="line">    baos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((len=is.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        baos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;收到来自：&quot;</span>+socket.getInetAddress().getHostAddress()+<span class="string">&quot;的数据&quot;</span>);</span><br><span class="line">    System.out.println(baos.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>TCP网络编程：从客户端发送文件给服务端，服务端保存到本地，并返回“发送成功”给客户端。并关闭相应的连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client2</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1. 客户端向服务端发送一张图片， 等待服务端接收完毕后返回 接收成功！ 信息</span></span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9090</span>);</span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Files\\卡通 - 4.jpg&quot;</span>));</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((len=fis.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 从文件中读取的数据写入到到socket输出流中</span></span><br><span class="line">        os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭socket数据的输出</span></span><br><span class="line">    socket.shutdownOutput();</span><br><span class="line">    <span class="comment">// 接收服务器端的数据，并显示到控制台上</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">    <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">    buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((len=is.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        baos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(baos.toString());</span><br><span class="line">    fis.close();</span><br><span class="line">    os.close();</span><br><span class="line">    socket.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server2</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9090</span>);</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Files\\图片1.jpg&quot;</span>));</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((len=is.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;服务器端接收数据完毕&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给客户端进行反馈</span></span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">    os.write(<span class="string">&quot;照片服务器端已经接收完毕&quot;</span>.getBytes());</span><br><span class="line">    os.close();</span><br><span class="line">    fos.close();</span><br><span class="line">    is.close();</span><br><span class="line">    socket.close();</span><br><span class="line">    ss.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-6-UDP网络编程"><a href="#2-6-UDP网络编程" class="headerlink" title="2.6 UDP网络编程"></a>2.6 UDP网络编程</h3><ul>
<li>类<strong>DatagramSocket</strong>和<strong>DatagramPacket</strong>实现了基于UDP协议网络程序。</li>
<li>UDP数据报通过数据报套接字DatagramSocket发送和接收，系统不保证UDP数据包一定能够安全送到目的地，也不能确定什么时候可以抵达</li>
<li>DatagramPacket对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号。</li>
<li>UDP协议中每个数据报都给出了完整的地址信息，因此无需建立发送方和接收方的连接。如同发快递包裹一样。</li>
<li>流程<ol>
<li>DatagramSocket与DatagramPacket</li>
<li>建立发送端，接收端</li>
<li>建立数据包</li>
<li>调用Socket的发送、接收方法</li>
<li>关闭Socket</li>
</ol>
</li>
</ul>
<blockquote>
<p>发送端与接收端是两个独立的运行程序</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">udpSend</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;我是UDP发送端&quot;</span>;</span><br><span class="line">    <span class="type">byte</span>[] data = str.getBytes();</span><br><span class="line">    <span class="type">InetAddress</span> <span class="variable">inetAddress</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">    <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data,<span class="number">0</span>,data.length,inetAddress,<span class="number">9090</span>);</span><br><span class="line">    socket.send(packet);</span><br><span class="line">    socket.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">udpReceive</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9090</span>);</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer,<span class="number">0</span>,buffer.length);</span><br><span class="line">    socket.receive(packet);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(),<span class="number">0</span>,packet.getLength()));</span><br><span class="line">    socket.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-7-URL编程"><a href="#2-7-URL编程" class="headerlink" title="2.7 URL编程"></a>2.7 URL编程</h3><p>URL网络编程实现数据下载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">urlDemo</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">HttpURLConnection</span> <span class="variable">urlConnection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;https://pic2.zhimg.com/80/v2-576df7c2088825cc388a4a8f74f8b2ed_720w.jpg&quot;</span>);</span><br><span class="line">    urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line">    urlConnection.connect();</span><br><span class="line">    is = urlConnection.getInputStream(); <span class="comment">// 得到输入流</span></span><br><span class="line">    fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Files\\spark.jpg&quot;</span>));</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        fos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;图片下载完成&quot;</span>);</span><br><span class="line">    fos.close();</span><br><span class="line">    is.close();</span><br><span class="line">    urlConnection.disconnect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="3-NIO"><a href="#3-NIO" class="headerlink" title="3. NIO"></a>3. NIO</h1><h2 id="3-1-Java-NIO-概述"><a href="#3-1-Java-NIO-概述" class="headerlink" title="3.1 Java NIO 概述"></a>3.1 Java NIO 概述</h2><h3 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h3><p>通常在进行同步I/O操作时，如果读取数据，代码会阻塞直至有可提供读取的数据。同样，写入调用将会阻塞直至数据能够写入。传统的Server/Client模式会基于（TPR：Thread per Request），服务器会为每个客户端请求建立一个线程，由该线程单独负责处理一个客户请求。这种模式带来的一个问题就是线程数量的剧增，大量的线程会增大服务器的开销。大多数的实现为了避免这个问题，都采用了线程池模型，并设置线程池线程的最大数量，这又带来了新的问题，如果线程池中有100个线程，而有100个用户都在进行大文件下载，会导致第101个用户的请求无法及时处理，即便第101个用户只想请求一个几kb大小的页面。传统的Server/Client模式如图所示：</p>
<p><img src="source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211020210801147-16347352859511.png" alt="image-20211020210801147"></p>
<h3 id="非阻塞IO（NIO）"><a href="#非阻塞IO（NIO）" class="headerlink" title="非阻塞IO（NIO）"></a>非阻塞IO（NIO）</h3><p>NIO中非阻塞I/O采用了基于Reactor模式的工作方式，I/O调用不会被阻塞，相反是注册感兴趣的特定I/O事件，如可读数据到达，新的套接字连接等等，在发生特定事件时，系统再通知我们。NIO中实现非阻塞I/O的核心对象就是Selector，Selector就是注册各种I/O事件地方，而且当我们感兴趣的事件发生时，就是这个对象告诉我们所发生的时间。</p>
<p><img src="source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211020211145095-16347355066182.png" alt="image-20211020211145095"></p>
<p>当有读或写等任何注册的时间发生时，可以从Selector中获得相应的SelectionKey，同时SelectionKey中可以找到发生的事件和该事件所发生的具体的SelectableChannel，以获得客户端发送过来的数据。</p>
<p>非阻塞指的是IO时间本身不阻塞，但是获取IO事件的select()方法是需要阻塞等待的。区别是阻塞的IO会阻塞IO操作上，NIO阻塞在事件获取上，没有事件就没有IO，从高层次看IO就不阻塞了。也就是说只有IO已经发生那么我们才评估IO是否阻塞，但是select()阻塞的时候IO还没有发生，何谈IO的阻塞呢？NIO的本质是延迟IO操作到真正发生IO的时候，而不是以前的只要IO流打开了就一直等到IO操作。</p>
<table>
<thead>
<tr>
<th>IO</th>
<th>NIO</th>
</tr>
</thead>
<tbody><tr>
<td>面向流(Stream Oriented)</td>
<td>面向缓冲区（Buffer Oriented）</td>
</tr>
<tr>
<td>阻塞IO（Blocking IO）</td>
<td>非阻塞IO（Non Blocking IO）</td>
</tr>
<tr>
<td>无</td>
<td>选择器（Selectors）</td>
</tr>
</tbody></table>
<p>Java的NIO由以下几个核心部分组成：</p>
<ul>
<li><p>Channels</p>
<ul>
<li><blockquote>
<p>NIO中的Channel和 IO中的Stream(流)是差不多一个等级的。只不过Stream是单向的，譬如：<strong>InputStream</strong>，<strong>OutputStream</strong>。而<strong>Channel</strong>是双向的，<strong>即可以用来进行读操作，又可以用来进行写操作</strong>。</p>
<p>NIO中的Channel的主要实现有：FileChannel，DatagramChannel，SocketChannel和ServerSocketChannel，分别对应文件IO，UDP和TCP（Server和Client）</p>
</blockquote>
</li>
</ul>
</li>
<li><p>Buffers</p>
<ul>
<li><blockquote>
<p>NIO中的关键实现有：ByteBuffer，CharBuffer，DoubleBuffer，FloatBuffer，IntBuffer，LongBuffer，ShortBuffer，分别对应基本数据类型：byte，char，double，float，int，long，short。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>Selectors</p>
<ul>
<li><blockquote>
<p>Selector运行单线程处理多个Channel，如果你的应用打开了多个通道，但每个连接的流量都很低，使用Selector就会很方便。例如在一个聊天服务器中。要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法就会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子就如新的连接进行，数据接收等。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>虽然Java NIO中除此之外还有很多类和组件，但Channel，Buffer和Selector构成了核心的API。其他组件，如Pipe和FileLock，只不过是与三个核心组件共同使用的工具类。</p>
<h2 id="3-2-Channel"><a href="#3-2-Channel" class="headerlink" title="3.2 Channel"></a>3.2 Channel</h2><p>Channel是一个通道，可以通过它读取和写入数据，它就像水管一样，网络数据通过Channel读取和写入。通道与流的不同之处在于通道是双向的，流只是在一个方向移动（一个流必须是InputStream或者OutputStream的子类），而且通道可以用于读，写或者同时用于读写。因为Channel是全双工的，所以它可以比流更好地映射底层操作系统的API。</p>
<p>NIO中通过Channel封装了数据源的操作，通过channel我们可以操作数据源，但又不必关系数据源的具体物理结构。这个数据源可能是多种的。比如：可以是文件，也可以是socket。在大多数应用中，Channel与文件描述或者socket是一一对应的。<strong>Channel用于在字节缓冲区和位于通道另一侧的实体</strong>（通常是一个文件或套接字）之间有效地传输数据。</p>
<p>与缓冲区不同，通道API主要由接口指定。不同的操作系统上通道实现（Channel Implementation）会有根本性的差异，所以通道API仅仅描述了可以做什么。因此很自然地，通道实现经常使用操作系统的本地代码。通道接口允许您以一种受控且可移植的方式来访问底层的I/O服务。</p>
<p>Channel是一个对象，可以通过它读取和写入数据。拿NIO与原来的I/O做个比对，通道就像是流。所有数据都通过<strong>Buffer</strong>对象来处理。您永远不会将字节直接写入同道中人，相反，您是将数据写入包含一个或者多个字节的缓冲区。同样，您不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。</p>
<p><strong>Java NIO的通道类似流，但又有些不同：</strong></p>
<ul>
<li>既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。</li>
<li>通道可以异步地读写</li>
<li>通道中的数据总是要先读到一个<strong>Buffer</strong>，或者总是要从一个<strong>Buffer</strong>中写入。</li>
</ul>
<p>如图所示：从通道读数据到缓冲区；从缓冲区写入数据到通道</p>
<p><img src="source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/png2.png"></p>
<h3 id="Channel-的实现"><a href="#Channel-的实现" class="headerlink" title="Channel 的实现"></a>Channel 的实现</h3><p>下面是Java IO 中最重要的Channel的实现：</p>
<ul>
<li><strong>FileChannel</strong><ul>
<li>FileChannel从文件中读写数据</li>
</ul>
</li>
<li><strong>DatagramChannel</strong><ul>
<li>DatagramChannel能通过UDP读写网络中的数据</li>
</ul>
</li>
<li><strong>SocketChannel</strong><ul>
<li>SocketChannel能通过TCP读写网络中的数据</li>
</ul>
</li>
<li><strong>ServerSocketChannel</strong><ul>
<li>ServerSocketChannel可以监听新进来的TCP连接，像Web服务器那样，对每一个新进来的连接都会创建一个SocketChannel。</li>
</ul>
</li>
</ul>
<h4 id="FileChannel-操作详解"><a href="#FileChannel-操作详解" class="headerlink" title="FileChannel 操作详解"></a>FileChannel 操作详解</h4><h5 id="FileChannel介绍和示例"><a href="#FileChannel介绍和示例" class="headerlink" title="FileChannel介绍和示例"></a>FileChannel介绍和示例</h5><p>FileChannel类可以实现常用的read，write以及scatter/gather操作，同时它也提供了很多专用于文件的新方法。这些方法中的许多都是我们所熟悉的文件操作。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>int read(ByteBuffer dst)</strong></td>
<td><strong>从Channel中读取数据到ByteBuffer</strong></td>
</tr>
<tr>
<td><strong>long read(ByteBuffer[] dsts)</strong></td>
<td><strong>将Channel中的数据“分散”到ByteBuffer[]</strong></td>
</tr>
<tr>
<td><strong>int write(ByteBuffer src)</strong></td>
<td><strong>将ByteBuffer中的数据写入到Channel</strong></td>
</tr>
<tr>
<td><strong>long write(ByteBuffer[] srcs)</strong></td>
<td><strong>将ByteBuffer[]中的数据“聚集”到Channel</strong></td>
</tr>
<tr>
<td>long position()</td>
<td>返回此通道的文件位置</td>
</tr>
<tr>
<td>FileChannel position(long p)</td>
<td>设置此通道的文件位置</td>
</tr>
<tr>
<td>long size()</td>
<td>返回此通道的文件的当前大小</td>
</tr>
<tr>
<td>FileChannel truncate(long s)</td>
<td>将此通道的文件截取为给定大小</td>
</tr>
<tr>
<td>void force(boolean metaData)</td>
<td>强制将所有对此通道的文件更新写入到存储设备中</td>
</tr>
</tbody></table>
<p><strong>FileChannel Demo</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileChannelDemo1</span> &#123;</span><br><span class="line">    <span class="comment">// FileChannel 读取数据到buffer中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建FileChannel</span></span><br><span class="line">        <span class="type">RandomAccessFile</span> <span class="variable">aFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;Files\\data.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> aFile.getChannel();</span><br><span class="line">        <span class="comment">// 2. 创建Buffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 读取数据到buffer中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">byteReads</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((byteReads=fileChannel.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;读取了：&quot;</span>+byteReads);</span><br><span class="line">            <span class="comment">// 读写反转，重置缓冲区的position</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="keyword">while</span> (buffer.hasRemaining())&#123;</span><br><span class="line">                System.out.print((<span class="type">char</span>)buffer.get());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// buffer 中的数据读取完成后 清空</span></span><br><span class="line">            System.out.println();</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭channel</span></span><br><span class="line">        aFile.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;结束了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Buffer通常的操作</strong></p>
<ul>
<li>将数据写入缓冲区</li>
<li>调用<code>buffer.flip()</code>反转读写模式</li>
<li>从缓冲区读取数据</li>
<li>调用<code>buffer.clear()</code>或<code>buffer.compact()</code>清除缓冲区内容</li>
</ul>
<h5 id="1-打开FileChannel"><a href="#1-打开FileChannel" class="headerlink" title="1.  打开FileChannel"></a>1.  打开FileChannel</h5><p>在使用<strong>FileChannel</strong>之前，必须先打开它。但是，无法直接打开一个FileChannel，需要通过使用一个InputStream、OutputStream或RandomAccessFile来获取一个FileChannel实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">aFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;Files\\data.txt&quot;</span>);</span><br><span class="line"><span class="type">FileChannle</span> <span class="variable">fileChannel</span> <span class="operator">=</span> aFile.getChannel();</span><br></pre></td></tr></table></figure>

<h5 id="2-从FileChannel读取数据"><a href="#2-从FileChannel读取数据" class="headerlink" title="2. 从FileChannel读取数据"></a>2. 从FileChannel读取数据</h5><p>使用FileChannel.read()方法从FileChannel中读取数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">byteRead</span> <span class="operator">=</span> fileChannel.read(buffer);</span><br></pre></td></tr></table></figure>

<p>首先分配一个Buffer。从FileChannel中读取的数据将被读取到Buffer中。然后，调用FileChannel.read()方法。该方法将数据从FileChannel读取到Buffer中。read()方法返回的int值表示有多少字节被读取到了Buffer中。如果返回-1，表示到了文件末尾。</p>
<h5 id="3-向FileChannel写数据"><a href="#3-向FileChannel写数据" class="headerlink" title="3. 向FileChannel写数据"></a>3. 向FileChannel写数据</h5><p>使用FileChannel.write()方法向FileChannel中写数据，该方法的参数是一个Buffer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeDemo</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">aFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;Files\\data2.txt&quot;</span>),<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> aFile.getChannel();</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;new String to write file ........ !&quot;</span>+System.currentTimeMillis();</span><br><span class="line">    byteBuffer.clear();</span><br><span class="line">    byteBuffer.put(data.getBytes());</span><br><span class="line">    <span class="comment">// 将Buffer中的数据写入到Channel中，需要从buffer中读取数据，put的时候，buffer为写的模式，需要反转buffer的读写模式</span></span><br><span class="line">    <span class="comment">// todo 换言之，读 或者 写 之后的 写 或者 读 操作之前需要转换一下 buffer 的读写模式</span></span><br><span class="line">    byteBuffer.flip();</span><br><span class="line">    <span class="keyword">while</span>(byteBuffer.hasRemaining())&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;写入中。。。&quot;</span>);</span><br><span class="line">        fileChannel.write(byteBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭通道</span></span><br><span class="line">    fileChannel.close();</span><br><span class="line">    aFile.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：FileChannel.write()是在while循环中调用的。因为无法保证write()方法一次能向FileChannel写入多少字节，因此需要重复调用write()方法，直到Buffer中已经没有尚未写入通道的字节。</p>
<h5 id="4-关闭FileChannel"><a href="#4-关闭FileChannel" class="headerlink" title="4. 关闭FileChannel"></a>4. 关闭FileChannel</h5><p>用完FileChannel后必须将其关闭</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fileChannel.close();</span><br></pre></td></tr></table></figure>

<h5 id="5-FileChannel的position方法"><a href="#5-FileChannel的position方法" class="headerlink" title="5. FileChannel的position方法"></a>5. FileChannel的position方法</h5><p>有时可能需要在<strong>FileChannel</strong>的某个特定位置进行数据的读/写操作。可以通过调用<strong>position()<strong>方法获取</strong>FileChannel</strong>的当前位置。也可以通过调用<strong>position(long pos)</strong> 方法设置<strong>FileChannel</strong>的当前位置。</p>
<p>例子：</p>
<ul>
<li><code>long pos = channel.position();</code></li>
<li><code>channel.position(pos+123);</code></li>
</ul>
<p>如果将位置设置在文件结束符之后，然后试图从文件通道中读取数据，读方法将返回<code>-1</code>（文件结束标志）。</p>
<p>如果将位置设置在文件结束符之后，然后向通道中写数据，文件将撑大到当前位置并写入数据。这可能导致“<font color=red>文件空洞</font>”，磁盘上物理文件中写入的数据间有空隙。</p>
<h5 id="6-FileChannel的size方法"><a href="#6-FileChannel的size方法" class="headerlink" title="6. FileChannel的size方法"></a>6. FileChannel的size方法</h5><p>FileChannel实例的size()方法将返回该示例所关联文件的大小。如：</p>
<p><code>long fileSize = channel.size();</code></p>
<h5 id="7-FileChannel-的-truncate方法"><a href="#7-FileChannel-的-truncate方法" class="headerlink" title="7. FileChannel 的 truncate方法"></a>7. FileChannel 的 truncate方法</h5><p>可以使用<code>FileChannel.truncate()</code>方法截取一个文件。截取文件时，文件将指定长度后面的部分将被删除。如：</p>
<p><code>channel.truncate(1024);</code></p>
<p>这个例子截取文件的前<code>1024</code>个字节。</p>
<h5 id="8-FileChannel的force方法"><a href="#8-FileChannel的force方法" class="headerlink" title="8. FileChannel的force方法"></a>8. FileChannel的force方法</h5><p>FileChannel.force()方法将通道里面尚未写入磁盘的数据强制写到磁盘上 。处于性能方面的考虑，操作系统会将数据缓存在内存中，所以无法保证写入到FileChannel里面的数据一定会及时写到磁盘上。要保证这一点，需要调用<code>force()</code>方法。</p>
<p><code>force()</code>方法有一个<code>boolean</code>类型的参数，指明是否同时将文件元数据（权限信息等）写入到磁盘上。</p>
<h5 id="9-FileChannel的transferTo和transferFrom方法"><a href="#9-FileChannel的transferTo和transferFrom方法" class="headerlink" title="9. FileChannel的transferTo和transferFrom方法"></a>9. FileChannel的transferTo和transferFrom方法</h5><p><strong>通道之间的数据传输</strong></p>
<p>如果两个通道中有一个是FileChannel，那么可以直接将数据从一个C hannel传输到另外一个Channel。</p>
<ol>
<li><p><strong>transferFrom()</strong></p>
<ul>
<li><p>FileChannel的transferFrom()方法可以将数据从源通道传输到FileChannel中</p>
<ul>
<li>```java<br>@Test<br>public void transferFromDemo() throws IOException {<pre><code>// 定义 源 Channel
RandomAccessFile file = new RandomAccessFile(&quot;Files\\data.txt&quot;, &quot;rw&quot;);
FileChannel fromChannel = file.getChannel();
// 定义 目标 Channel
RandomAccessFile file1 = new RandomAccessFile(&quot;Files\\dataTo.txt&quot;, &quot;rw&quot;);
FileChannel toChannel = file1.getChannel();
long position = 0;
long count = fromChannel.size();
// transferFrom 从一个通道中复制数据到另一个通道中
toChannel.transferFrom(fromChannel,0,count);

toChannel.close();
fromChannel.close();
file1.close();
file.close();
System.out.println(&quot;over!&quot;);
</code></pre>
}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. **transferTo**</span><br><span class="line"></span><br><span class="line">   - transferTo()方法将数据从FileChannel传输到其他的channel中。</span><br><span class="line"></span><br><span class="line">     - ```java</span><br><span class="line">       @Test</span><br><span class="line">       public void transferToDemo() throws IOException&#123;</span><br><span class="line">           // 定义 源 Channel</span><br><span class="line">           RandomAccessFile file = new RandomAccessFile(&quot;Files\\data.txt&quot;, &quot;rw&quot;);</span><br><span class="line">           FileChannel fromChannel = file.getChannel();</span><br><span class="line">           // 定义 目标 Channel</span><br><span class="line">           RandomAccessFile file1 = new RandomAccessFile(&quot;Files\\dataTo2.txt&quot;, &quot;rw&quot;);</span><br><span class="line">           FileChannel toChannel = file1.getChannel();</span><br><span class="line">           long size = fromChannel.size();</span><br><span class="line">           int position = 0;</span><br><span class="line">       </span><br><span class="line">           fromChannel.transferTo(position, size, toChannel);</span><br><span class="line">       </span><br><span class="line">           fromChannel.close();</span><br><span class="line">           toChannel.close();</span><br><span class="line">           file.close();</span><br><span class="line">           file1.close();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ol>
<p><font color=red>注意</font></p>
<p>通道之间的传输方法每次最多只能传输<code>2GB</code>的数据，如果超过了<code>2GB</code>，就需要额外的处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransferToDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">                <span class="type">FileChannel</span> <span class="variable">fromChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src\\Files\\data.txt&quot;</span>)).getChannel();</span><br><span class="line">                <span class="keyword">final</span> <span class="type">FileChannel</span> <span class="variable">targetChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src\\Files\\data2.txt&quot;</span>)).getChannel()</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">/*核心代码*/</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> fromChannel.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">long</span> <span class="variable">remain</span> <span class="operator">=</span> size; remain&gt;<span class="number">0</span>;)&#123;</span><br><span class="line">                remain -= fromChannel.transferTo(remain - size, size, targetChannel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="SocketChannel通道"><a href="#SocketChannel通道" class="headerlink" title="SocketChannel通道"></a>SocketChannel通道</h3><ol>
<li><blockquote>
<p><font size=4px color=green>新的 socket 通道类可以运行非阻塞模式并且是可选择的，可以激活大程序（如网络服务器和中间件组件）巨大的可伸缩性和灵活性。再也不需要为每个 socket 连接使用一个线程的必要了，也避免了管理大量线程所需的上下文交换开销。借助新的 NIO 类，一个或几个线程就可以管理成百上千的活动 socket 连接了并且只有很少甚至可能没有性能损失。所有的 socket 通道类(DatagramChannel、SocketChannel 和 ServerSocketChannel)都继承了位于 java.nio.channels.spi 包中的 AbstractSelectableChannel。这意味着我们可以用一个 Selector 对象来执行socket 通道的就绪选择（readiness selection）。</font></p>
</blockquote>
</li>
<li><blockquote>
<p><font size=4px color=green>请注意 DatagramChannel 和 SocketChannel 实现定义读和写的功能，而接口<br>ServerSocketChannel 没有实现。ServerSocketChannel 负责监听传入的连接和创建新<br>的 SocketChannel 对象，它本身从不传输数据。</font></p>
</blockquote>
</li>
<li><blockquote>
<p><strong>socket 和 socket 通道之间 的关系</strong>。通道是一个连接 I/O 服务导管并提供与该服务交互的方法。就某个 socket 而 言，它不会再次实现与之对应的 socket 通道类中的 socket 协议 API，而 java.net 中 已经存在的 socket 通道都可以被大多数协议操作重复使用。</p>
<p><font size=4px color=green>全部 socket 通道类（DatagramChannel、SocketChannel 和<br>ServerSocketChannel）在被实例化时都会创建一个对等 socket 对象。这些是我们所<br>熟悉的来自 java.net 的类（Socket、ServerSocket 和 DatagramSocket），它们已<br>经被更新以识别通道。对等 socket 可以通过调用 socket( )方法从一个通道上获取。<br>此外，这三个 java.net 类现在都有 getChannel( )方法。</font></p>
</blockquote>
</li>
<li><blockquote>
<p><font size=4px color=green>要把一个 socket 通道置于非阻塞模式，我们要依靠所有 socket 通道类的公有 超级类：SelectableChannel。就绪选择（readiness selection）是一种可以用来查 询通道的机制，该查询可以判断通道是否准备好执行一个目标操作，如读或写。非阻 塞 I/O 和可选择性是紧密相连的，那也正是管理阻塞模式的 API 代码要在 SelectableChannel 超级类中定义的原因。设置或重新设置一个通道的阻塞模式是很简单的，<strong>只要调用 configureBlocking( )方 法即可</strong>，传递参数值为 true 则设为阻塞模式，参数值为 false 值设为非阻塞模式。可 以通过调用 isBlocking( )方法来判断某个 socket 通道当前处于哪种模式。</font></p>
</blockquote>
</li>
</ol>
<p>非阻塞 socket 通常被认为是服务端使用的，因为它们使同时管理很多 socket 通道变 得更容易。但是，在客户端使用一个或几个非阻塞模式的 socket 通道也是有益处的， 例如，借助非阻塞 socket 通道，GUI 程序可以专注于用户请求并且同时维护与一个或 多个服务器的会话。在很多程序上，非阻塞模式都是有用的。 偶尔地，我们也会需要防止 socket 通道的阻塞模式被更改。API 中有一个 blockingLock( )方法，该方法会返回一个非透明的对象引用。返回的对象是通道实现 修改阻塞模式时内部使用的。只有拥有此对象的锁的线程才能更改通道的阻塞模式。</p>
<h4 id="1-ServerSocketChannel"><a href="#1-ServerSocketChannel" class="headerlink" title="1. ServerSocketChannel"></a>1. ServerSocketChannel</h4><p><code>ServerSocketChannel</code>是一个基于通道的socket监听器。它同我们所熟悉的<code>java.net.ServerSocket</code>执行相同的任务，不过它增加了通道语义，因此能够在非阻塞模式下运行。</p>
<p>由于<code>ServerSocketChannel</code>没有<code>bind()</code>方法，因此有必要取出对等的socket并使用它来绑定一个端口以开始监听连接。我们也是使用对等<code>ServerSocket</code>的API来根据需要设置其他的socket选项。</p>
<p>同<code>java.net.ServerSocket</code>一样，<code>ServerSocketChannel</code>也有<code>accept()</code>方法。一旦创建了一个<code>ServerSocketChannel</code>并用对等socket绑定了，然后就可以在其中一个上调用<code>accpet()</code>。如果您选择在<code>ServerSocket</code>上调用<code>accept()</code>方法，那么他会同任何其他的<code>ServerSocket</code>表现一样的行为：总是阻塞并返回一个<code>java.net.Socket</code>对象；如果您选择在<code>ServerSocketChannel</code>上调用<code>accept()</code>方法则会返回<code>SocketChannel</code>类型的对象，返回的对象能够在非阻塞模式下运行。</p>
<blockquote>
<p>换句话说：</p>
<p>ServerSocketChannel的accept()方法会返回ServerChannel类型对象，SocketChannel可以在非阻塞模式下运行。</p>
<p>其他Socket的accept()方法会阻塞返回一个Socket对象。如果ServerSocketChannel以非阻塞模式被调用，当没有传入在等待时，ServerSocketChannel.accept()会立即返回null。正是这种检查连接而不阻塞的能力实现了可伸缩性并降低了复杂性。可选择性也因此得到实现。我们可以使用一个选择器实例来注册<code>ServerSocketChannel</code>对象以实现新连接到达时自动通知的功能。</p>
</blockquote>
<p><strong>Server端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serverSocketChannelTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 定义一个端口号 8888</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8888</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开一个SocketServerChannel</span></span><br><span class="line">    <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">    <span class="comment">// 定义一个缓冲区</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="string">&quot;Hello java.nio&quot;</span>.getBytes());  <span class="comment">// 直接将一个字节数组包装成一个ByteBuffer</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">accept_buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">8</span>);  <span class="comment">// 申请一个8字节的字节缓冲区</span></span><br><span class="line">    <span class="comment">// 绑定端口号  用于接收数据</span></span><br><span class="line">    ssc.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>,port));</span><br><span class="line">    <span class="comment">// 设置非阻塞模式</span></span><br><span class="line">    ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//循环监听</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Waiting for connections&quot;</span>);</span><br><span class="line">        <span class="comment">// 此处得到的是一个非阻塞式的socketChannel</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept();</span><br><span class="line">        <span class="comment">//TODO 如果是阻塞式的socket，那么接下来的代码会被一直阻塞着，一直等到socket收到请求为止</span></span><br><span class="line">        <span class="keyword">if</span>(sc==<span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;connection is null&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Incoming connection from&quot;</span>+sc.socket().getRemoteSocketAddress());</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="comment">// 重置缓冲区位置</span></span><br><span class="line">            buffer.rewind();</span><br><span class="line">            sc.write(buffer);  <span class="comment">// 将buffer中的数据写入接收到的socket中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Client端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">socketClientDemo</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">8888</span>);</span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">    os.write(<span class="string">&quot;客户端发送消息！&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];</span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((len=is.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>)buffer[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    os.close();</span><br><span class="line">    is.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="打开ServerSocketChannel"><a href="#打开ServerSocketChannel" class="headerlink" title="打开ServerSocketChannel"></a>打开ServerSocketChannel</h5><p>通过调用ServerSocketChannel.open()方法来打开ServerSocketChannel。</p>
<p><code>ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</code></p>
<h5 id="关闭ServerSocketChannel"><a href="#关闭ServerSocketChannel" class="headerlink" title="关闭ServerSocketChannel"></a>关闭ServerSocketChannel</h5><p>通过调用ServerSocketChannel.close()方法来关闭ServerSocketChannel。</p>
<p><code>serverSocketChannel.close();</code></p>
<h5 id="监听新的连接"><a href="#监听新的连接" class="headerlink" title="监听新的连接"></a>监听新的连接</h5><p>通过<code>ServerSocketChannel.accept()</code>方法监听新进的连接。当<code>accept()</code>方法返回的时候，它会返回一个包含新进来的<code>SocketChannel</code>。因此，<code>accept()</code>方法会一直阻塞到有新连接到达。</p>
<p>通常不会仅仅只监听一个连接，在while循环中调用<code>accept()</code>方法。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Waiting for connections&quot;</span>);</span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> scc.accept();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="阻塞模式"><a href="#阻塞模式" class="headerlink" title="阻塞模式"></a>阻塞模式</h5><p>如果是阻塞模式下，那么调用<code>accept()</code>方法后，会被阻塞，知道有新的连接进来才会继续执行接下来的代码。</p>
<h5 id="非阻塞模式"><a href="#非阻塞模式" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h5><p><code>ServerSocketChannel</code>可以设置成非阻塞模式。在非阻塞模式下，<code>accept()</code>方法会立即返回，如果还没有进来的连接，返回的就是null。因此，需要检查返回的<code>SocketChannel</code>是否是null。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">ssc.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(port));</span><br><span class="line">ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">while</span>(ture)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Waiting for connections&quot;</span>);</span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept();</span><br><span class="line">    <span class="keyword">if</span>(sc==<span class="literal">null</span>)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-SocketChannel"><a href="#2-SocketChannel" class="headerlink" title="2.  SocketChannel"></a>2.  SocketChannel</h4><h5 id="SocketChannel介绍"><a href="#SocketChannel介绍" class="headerlink" title="SocketChannel介绍"></a>SocketChannel介绍</h5><p>JAVA NIO 中的SocketChannel是一个连接到TCP网络套接字的通道。它是一种面向流连接sockets套接字的可选择通道</p>
<ul>
<li>SocketChannel是用来连接Socket套接字</li>
<li>SocketChannel主要用途用来处理网络IO的通道</li>
<li>SocketChannel是基于TCP连接传输</li>
<li>SocketChannel实现了可选择通道，可以被多路复用的</li>
</ul>
<h5 id="SocketChannel特征"><a href="#SocketChannel特征" class="headerlink" title="SocketChannel特征"></a>SocketChannel特征</h5><ol>
<li><p>对于已经存在的socket不能创建SocketChannel</p>
</li>
<li><p>SocketChannel中提供的open接口创建的Channel并没有进行网络级联，需要使用connect接口连接到指定地址</p>
</li>
<li><p>未进行连接的SocketChannel执行IO操作时，会抛出<code>NotYetConnectedException</code></p>
</li>
<li><p>SocketChannel支持两种IO模式：阻塞式和非阻塞式</p>
</li>
<li><p>SocketChannel支持异步关闭。如果SocketChannel在一个线程上read阻塞，另一个线程对该SocketChannel调用<code>shutdowninput</code>，则读阻塞的线程将返回-1表示没有读取任何数据；如果SocketChannel在一个线程上write，另一个线程对该SocketChannel调用<code>shutdownWrite</code>，则写阻塞的线程将抛出<code>AsynchronousCloseException</code></p>
</li>
<li><p>SocketChannel支持设定参数</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>SO_SNDBUF</strong></td>
<td>套接字发送缓冲区大小</td>
</tr>
<tr>
<td><strong>SO_RCVBUF</strong></td>
<td>套接字接收缓冲区大小</td>
</tr>
<tr>
<td><strong>SO_KEEPALIVE</strong></td>
<td>保活连接</td>
</tr>
<tr>
<td><strong>O_REUSEADDR</strong></td>
<td>复用地址</td>
</tr>
<tr>
<td><strong>SO_LINGER</strong></td>
<td>有数据传输时延缓关闭Channel（只有在非阻塞模式下有用）</td>
</tr>
<tr>
<td><strong>TCP_NODELAY</strong></td>
<td>禁用Nagle</td>
</tr>
</tbody></table>
</li>
</ol>
<h5 id="SocketChannel使用"><a href="#SocketChannel使用" class="headerlink" title="SocketChannel使用"></a>SocketChannel使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">socketChannelTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">/* TODO 创建SocketChannel   */</span></span><br><span class="line">    <span class="comment">// 方式一</span></span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;www.baidu.com&quot;</span>, <span class="number">80</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式二</span></span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">socketChannel1</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">    socketChannel1.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;www.baidu.com&quot;</span>, <span class="number">80</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* TODO 连接校验 */</span></span><br><span class="line">    System.out.println(socketChannel.isOpen());                 <span class="comment">// 测试SocketChannel是否为open状态</span></span><br><span class="line">    System.out.println(socketChannel.isConnected());            <span class="comment">// 测试SocketChannel是否已经被连接</span></span><br><span class="line">    System.out.println(socketChannel.isConnectionPending());    <span class="comment">// 测试SocketChannel是否正在进行连接</span></span><br><span class="line">    System.out.println(socketChannel.finishConnect());          <span class="comment">// 校验正在进行套接字连接的SocketChannel是否已经完成连接</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* TODO 读写模式 */</span></span><br><span class="line">    socketChannel.configureBlocking(<span class="literal">false</span>);                     <span class="comment">// 非阻塞式模式</span></span><br><span class="line">    socketChannel1.configureBlocking(<span class="literal">true</span>);                     <span class="comment">// 阻塞式模式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer1</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">    <span class="comment">// TODO 非阻塞式模式下，会打印出 socketChannel read over !</span></span><br><span class="line">    socketChannel.read(buffer1);</span><br><span class="line">    socketChannel.close();</span><br><span class="line">    System.out.println(<span class="string">&quot; socketChannel read over ! &quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">    <span class="comment">// TODO 阻塞模式下，read方法会阻塞，控制台无法打印出 socketChannel1 read over !</span></span><br><span class="line">    socketChannel1.read(buffer2);</span><br><span class="line">    socketChannel1.close();</span><br><span class="line">    System.out.println(<span class="string">&quot; socketChannel1 read over !&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* TODO 设置和获取参数 */</span></span><br><span class="line">    socketChannel.setOption(StandardSocketOptions.SO_KEEPALIVE, Boolean.TRUE)</span><br><span class="line">        .setOption(StandardSocketOptions.TCP_NODELAY, Boolean.TRUE);                    <span class="comment">// 通过setOptions方法可以设置socket套接字的相关参数</span></span><br><span class="line">    <span class="comment">// 获取相关参数的值</span></span><br><span class="line">    System.out.println(socketChannel.getOption(StandardSocketOptions.SO_KEEPALIVE));</span><br><span class="line">    System.out.println(socketChannel.getOption(StandardSocketOptions.SO_RCVBUF));           <span class="comment">// 通过getOption获取相关参数的值。如默认的接收缓冲区大小是8192byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-DatagramChannel"><a href="#3-DatagramChannel" class="headerlink" title="3. DatagramChannel"></a>3. DatagramChannel</h4><p>正如 SocketChannel 对应 Socket，ServerSocketChannel 对应 ServerSocket，每 一个DatagramChannel 对象也有一个关联的 DatagramSocket 对象。正如 SocketChannel 模拟连接导向的流协议（如TCP/IP），DatagramChannel 则模拟包 导向的无连接协议（如 UDP/IP）。DatagramChannel 是无连接的，每个数据报 （datagram）都是一个自包含的实体，拥有它自己的目的地址及不依赖其他数据报的 数据负载。与面向流的的 socket 不同，DatagramChannel 可以发送单独的数据报给不同的目的地址。同样，DatagramChannel对象也可以接收来自任意地址的数据包。每个到达的数据报都含有关于它来自何处的信息（源地址）</p>
<h5 id="打开DatagramChannel"><a href="#打开DatagramChannel" class="headerlink" title="打开DatagramChannel"></a>打开DatagramChannel</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DatagramChannel</span> <span class="variable">server</span> <span class="operator">=</span> DatagramChannel.open();</span><br><span class="line">server.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">10010</span>));</span><br></pre></td></tr></table></figure>

<p>此例子是打开10010端口接收UDP数据包</p>
<h5 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h5><p>通过<code>receive()</code>接收UDP包</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer receiveBuffer=ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line">receiveBuffer.clear();</span><br><span class="line"><span class="type">SocketAddress</span> <span class="variable">receiveAddr</span> <span class="operator">=</span> server.receive(receiveBuffer);</span><br></pre></td></tr></table></figure>

<p>SocketAddress可以获得发包的IP，端口等信息，用toString查看，格式如下：</p>
<blockquote>
<p>/127.0.0.1:57126</p>
</blockquote>
<h5 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h5><p>通过<code>send()</code>发送UDP包</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DatagramChannel</span> <span class="variable">server</span> <span class="operator">=</span> DatagramChannel.open();</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">sendBuffer</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="string">&quot;client send&quot;</span>.getBytes());</span><br><span class="line">server.send(sendBuffer, <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">10010</span>))</span><br></pre></td></tr></table></figure>



<h5 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h5><p>UDP不存在真正意义上的连接，这里的连接是向特定服务地址用<code>read</code>和<code>write</code>接收发送数据包。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">client.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">10010</span>));</span><br><span class="line"><span class="type">int</span> <span class="variable">readSize</span> <span class="operator">=</span> client.read(sendBuffer);</span><br><span class="line">server.write(sendBuffer);</span><br></pre></td></tr></table></figure>

<p><code>read()</code>和<code>write()</code>只有在<code>connect()</code>后才能使用，不然会抛出<code>NotYetConnectedException</code>异常。用<code>read()</code>接收时，如果没有接收到包，会抛出<code>PortUnreachableException</code>异常。</p>
<h5 id="DatagramChannel示例"><a href="#DatagramChannel示例" class="headerlink" title="DatagramChannel示例"></a>DatagramChannel示例</h5><p>模拟 客户端发送，服务端接收的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.DatagramChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatagramChannelDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendDatagram</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="type">DatagramChannel</span> <span class="variable">sendChannel</span> <span class="operator">=</span> DatagramChannel.open();</span><br><span class="line">        <span class="type">InetSocketAddress</span> <span class="variable">inetSocketAddress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9999</span>);</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="string">&quot;发送 UDP包&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            sendChannel.send(buffer,inetSocketAddress);</span><br><span class="line">            System.out.println(<span class="string">&quot;已经完成了发送！！！&quot;</span>+random.nextInt(<span class="number">1000</span>));</span><br><span class="line">            Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveDatagram</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">DatagramChannel</span> <span class="variable">receiveChannel</span> <span class="operator">=</span> DatagramChannel.open();</span><br><span class="line">        receiveChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9999</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">receiveBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            receiveBuffer.clear();</span><br><span class="line">            <span class="type">SocketAddress</span> <span class="variable">socketAddress</span> <span class="operator">=</span> receiveChannel.receive(receiveBuffer);</span><br><span class="line">            <span class="keyword">if</span>(socketAddress==<span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            receiveBuffer.flip();</span><br><span class="line">            System.out.println(socketAddress.toString());</span><br><span class="line">            System.out.println(Charset.forName(<span class="string">&quot;UTF-8&quot;</span>).decode(receiveBuffer));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>connect测试</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接 read 和 write</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connectDemo</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">DatagramChannel</span> <span class="variable">client</span> <span class="operator">=</span> DatagramChannel.open();</span><br><span class="line">    client.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9999</span>));  <span class="comment">// 绑定 用于 接收</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接</span></span><br><span class="line">    client.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">9999</span>));  <span class="comment">// 连接 用于 发送</span></span><br><span class="line">    client.write(ByteBuffer.wrap(<span class="string">&quot;发送 UDP包&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">readBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        readBuffer.clear();</span><br><span class="line">        client.read(readBuffer);</span><br><span class="line">        readBuffer.flip();</span><br><span class="line">        System.out.println(Charset.forName(<span class="string">&quot;UTF-8&quot;</span>).decode(readBuffer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Scatter-Gather"><a href="#Scatter-Gather" class="headerlink" title="Scatter/Gather"></a>Scatter/Gather</h3><p>Java NIO开始支持scatter/gather，scatter/gather用于描述从Channel中读取或者写入到Channel的操作。</p>
<ul>
<li><p><strong>分散（Scatter）读</strong></p>
<ul>
<li><blockquote>
<p><font color=green size=4px>分散（Scatter）从Channel中读取  是指在读操作时将读取的数据写入多个buffer中，因此，Channel将从Channel中读取的数据  分散Scatter 到多个Buffer中。</font></p>
</blockquote>
</li>
<li><p><img src="source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E5%88%86%E6%95%A3.png"></p>
</li>
<li><p><strong>分散读（Scatter Reads）</strong> 是指数据从一个Channel读取到多个buffer中。</p>
</li>
</ul>
</li>
<li><p><strong>聚集（Gather）写</strong></p>
<ul>
<li><blockquote>
<p><font color=green size=4px>聚集（Gather）写入Channel是指在写操作时将多个buffer的数据写入同一个Channel，因此，Channel将多个Buffer中的数据聚集（Gather）后发送到Channel。</font></p>
</blockquote>
</li>
<li><p><img src="source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E8%81%9A%E9%9B%86%E5%86%99.png"></p>
</li>
<li><p><strong>聚集写（Gathering Writes）</strong>是指数据从多个buffer写入到同一个channel。</p>
</li>
</ul>
</li>
</ul>
<p>scatter/gather经常用于需要将传输的数据分开处理的场合，例如传输一个由消息头和消息体组成的消息，你可能会将消息体和消息头分散到不同的buffer中，这样你可以方便的处理消息头和消息体。</p>
<h4 id="1-Scattering-Reads"><a href="#1-Scattering-Reads" class="headerlink" title="1. Scattering Reads"></a>1. Scattering Reads</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">header</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">body</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">ByteBuffer[] bufferArray = &#123;header, body&#125;;</span><br><span class="line">channel.read(bufferArray);</span><br></pre></td></tr></table></figure>

<p><font color=red>注意</font></p>
<p>buffer首先被插入到数组，然后再将数组作为<code>channel.read()</code>的输入参数。<code>read()</code>方法按照buffer在数组中的顺序将从channel中读取的数据写入到buffer，当一个buffer被写满后，channel紧接着向另一个buffer中写。</p>
<p>Scattering Reads在移动下一个buffer前，必须填满当前的buffer，这也意味着它不适用动态消息（消息大小不固定）。换句话说，如果存在消息头和消息体，消息头必须完成填充（例如 128byte），Scattering Reads 才能正常工作。</p>
<h4 id="2-Gathering-Writes"><a href="#2-Gathering-Writes" class="headerlink" title="2. Gathering Writes"></a>2. Gathering Writes</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">header</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">body</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">ByteBuffer[] bufferArray = &#123;header, body&#125;;</span><br><span class="line"></span><br><span class="line">channel.write(bufferArray);</span><br></pre></td></tr></table></figure>

<p>buffers数组是<code>write()</code>方法的入参，<code>write()</code>方法会按照buffer在数组中的顺序，将数据写入到channel，注意只有position和limit之间的数据才会被写入。因此，如果一个buffer的容量为128byte，但是仅仅包含58byte的数据，那么这58byte的数据将被写入到channel中。<font color=blue>因此与Scattering Reads相反, Gathering Writes能较好的处理动态消息。</font></p>
<h2 id="3-3-Buffer"><a href="#3-3-Buffer" class="headerlink" title="3.3  Buffer"></a>3.3  Buffer</h2><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="ByteBuffer-结构"><a href="#ByteBuffer-结构" class="headerlink" title="ByteBuffer 结构"></a>ByteBuffer 结构</h4><p>ByteBuffer 有以下重要属性</p>
<ul>
<li>capacity</li>
<li>position</li>
<li>limit</li>
</ul>
<p>一开始</p>
<p><img src="source/Java-IO%E4%B8%8ENIO/0021.png"></p>
<p>写模式下，position 是写入位置，limit 等于容量，下图表示写入了 4 个字节后的状态</p>
<p><img src="source/Java-IO%E4%B8%8ENIO/0018.png"></p>
<p>flip 动作发生后，position 切换为读取位置，limit 切换为读取限制</p>
<p><img src="source/Java-IO%E4%B8%8ENIO/0019.png"></p>
<p>读取 4 个字节后，状态</p>
<p><img src="source/Java-IO%E4%B8%8ENIO/0020.png"></p>
<p>clear 动作发生后，状态</p>
<p><img src="source/Java-IO%E4%B8%8ENIO/0021.png"></p>
<p>compact 方法，是把未读完的部分向前压缩，然后切换至写模式</p>
<p><img src="source/Java-IO%E4%B8%8ENIO/0022.png"></p>
<h4 id="💡-调试工具类"><a href="#💡-调试工具类" class="headerlink" title="💡 调试工具类"></a>💡 调试工具类</h4><p>需要引入netty依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io-netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.51.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>







<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteBufferUtil</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span>[] BYTE2CHAR = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span>[] HEXDUMP_TABLE = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">256</span> * <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] HEXPADDING = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] HEXDUMP_ROWPREFIXES = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">65536</span> &gt;&gt;&gt; <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] BYTE2HEX = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] BYTEPADDING = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">char</span>[] DIGITS = <span class="string">&quot;0123456789abcdef&quot;</span>.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">            HEXDUMP_TABLE[i &lt;&lt; <span class="number">1</span>] = DIGITS[i &gt;&gt;&gt; <span class="number">4</span> &amp; <span class="number">0x0F</span>];</span><br><span class="line">            HEXDUMP_TABLE[(i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>] = DIGITS[i &amp; <span class="number">0x0F</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for hex dump paddings</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HEXPADDING.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">padding</span> <span class="operator">=</span> HEXPADDING.length - i;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(padding * <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; padding; j++) &#123;</span><br><span class="line">                buf.append(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            HEXPADDING[i] = buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for the start-offset header in each row (up to 64KiB).</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HEXDUMP_ROWPREFIXES.length; i++) &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">12</span>);</span><br><span class="line">            buf.append(NEWLINE);</span><br><span class="line">            buf.append(Long.toHexString(i &lt;&lt; <span class="number">4</span> &amp; <span class="number">0xFFFFFFFFL</span> | <span class="number">0x100000000L</span>));</span><br><span class="line">            buf.setCharAt(buf.length() - <span class="number">9</span>, <span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">            buf.append(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">            HEXDUMP_ROWPREFIXES[i] = buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for byte-to-hex-dump conversion</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BYTE2HEX.length; i++) &#123;</span><br><span class="line">            BYTE2HEX[i] = <span class="string">&#x27; &#x27;</span> + StringUtil.byteToHexStringPadded(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for byte dump paddings</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BYTEPADDING.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">padding</span> <span class="operator">=</span> BYTEPADDING.length - i;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(padding);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; padding; j++) &#123;</span><br><span class="line">                buf.append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            BYTEPADDING[i] = buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for byte-to-char conversion</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BYTE2CHAR.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= <span class="number">0x1f</span> || i &gt;= <span class="number">0x7f</span>) &#123;</span><br><span class="line">                BYTE2CHAR[i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                BYTE2CHAR[i] = (<span class="type">char</span>) i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印所有内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">debugAll</span><span class="params">(ByteBuffer buffer)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldlimit</span> <span class="operator">=</span> buffer.limit();</span><br><span class="line">        buffer.limit(buffer.capacity());</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">origin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">256</span>);</span><br><span class="line">        appendPrettyHexDump(origin, buffer, <span class="number">0</span>, buffer.capacity());</span><br><span class="line">        System.out.println(<span class="string">&quot;+--------+-------------------- all ------------------------+----------------+&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;position: [%d], limit: [%d]\n&quot;</span>, buffer.position(), oldlimit);</span><br><span class="line">        System.out.println(origin);</span><br><span class="line">        buffer.limit(oldlimit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印可读取内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">debugRead</span><span class="params">(ByteBuffer buffer)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">256</span>);</span><br><span class="line">        appendPrettyHexDump(builder, buffer, buffer.position(), buffer.limit() - buffer.position());</span><br><span class="line">        System.out.println(<span class="string">&quot;+--------+-------------------- read -----------------------+----------------+&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;position: [%d], limit: [%d]\n&quot;</span>, buffer.position(), buffer.limit());</span><br><span class="line">        System.out.println(builder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">appendPrettyHexDump</span><span class="params">(StringBuilder dump, ByteBuffer buf, <span class="type">int</span> offset, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isOutOfBounds(offset, length, buf.capacity())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(</span><br><span class="line">                    <span class="string">&quot;expected: &quot;</span> + <span class="string">&quot;0 &lt;= offset(&quot;</span> + offset + <span class="string">&quot;) &lt;= offset + length(&quot;</span> + length</span><br><span class="line">                            + <span class="string">&quot;) &lt;= &quot;</span> + <span class="string">&quot;buf.capacity(&quot;</span> + buf.capacity() + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dump.append(</span><br><span class="line">                <span class="string">&quot;         +-------------------------------------------------+&quot;</span> +</span><br><span class="line">                        NEWLINE + <span class="string">&quot;         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |&quot;</span> +</span><br><span class="line">                        NEWLINE + <span class="string">&quot;+--------+-------------------------------------------------+----------------+&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> offset;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">fullRows</span> <span class="operator">=</span> length &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">remainder</span> <span class="operator">=</span> length &amp; <span class="number">0xF</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dump the rows which have 16 bytes.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; row &lt; fullRows; row++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rowStartIndex</span> <span class="operator">=</span> (row &lt;&lt; <span class="number">4</span>) + startIndex;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Per-row prefix.</span></span><br><span class="line">            appendHexDumpRowPrefix(dump, row, rowStartIndex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Hex dump</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rowEndIndex</span> <span class="operator">=</span> rowStartIndex + <span class="number">16</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(<span class="string">&quot; |&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ASCII dump</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dump the last row which has less than 16 bytes.</span></span><br><span class="line">        <span class="keyword">if</span> (remainder != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rowStartIndex</span> <span class="operator">=</span> (fullRows &lt;&lt; <span class="number">4</span>) + startIndex;</span><br><span class="line">            appendHexDumpRowPrefix(dump, fullRows, rowStartIndex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Hex dump</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rowEndIndex</span> <span class="operator">=</span> rowStartIndex + remainder;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(HEXPADDING[remainder]);</span><br><span class="line">            dump.append(<span class="string">&quot; |&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Ascii dump</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(BYTEPADDING[remainder]);</span><br><span class="line">            dump.append(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dump.append(NEWLINE +</span><br><span class="line">                <span class="string">&quot;+--------+-------------------------------------------------+----------------+&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">appendHexDumpRowPrefix</span><span class="params">(StringBuilder dump, <span class="type">int</span> row, <span class="type">int</span> rowStartIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; HEXDUMP_ROWPREFIXES.length) &#123;</span><br><span class="line">            dump.append(HEXDUMP_ROWPREFIXES[row]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dump.append(NEWLINE);</span><br><span class="line">            dump.append(Long.toHexString(rowStartIndex &amp; <span class="number">0xFFFFFFFFL</span> | <span class="number">0x100000000L</span>));</span><br><span class="line">            dump.setCharAt(dump.length() - <span class="number">9</span>, <span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">            dump.append(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">getUnsignedByte</span><span class="params">(ByteBuffer buffer, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">short</span>) (buffer.get(index) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Java NIO中的Buffer用于和NIO通道Channel进行交互。数据是从通道读入缓冲区，从缓冲区写入通道中的。</p>
<p><img src="source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/src=http%253A%252F%252Fimg.mp.itc.cn%252Fupload%252F20160527%252F94502ff22866475a8ddaa3b832de64d2.jpg&refer=http%253A%252F%252Fimg.mp.itc-16354874682132.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg" alt="img"></p>
<p>缓冲区<font color=red>本质上是一块可以写入数据，然后可以从中读取数据的内存</font>.这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便访问该块内存。缓冲区实际上是一个容器对象，更直接的说，其实就是一个<strong>数组</strong>，<font color=red>在NIO库中，所有数据都是缓冲区处理的。</font>在读取数据时，它是直接读到缓冲区中的；在写入数据时，它也是写入到缓冲区中的；任何时候访问NIO中的数据，都是将它放到缓冲区中。而在面向流IO系统中，所有数据都是直接写入或者直接将数据读取到Stream对象中。</p>
<p>在NIO中，所有的缓冲区类型都继承于抽象类<code>Buffer</code>，最常用的就是<code>ByteBuffer</code>，对于Java中的基本类型，基本都有一个具体Buffer类型与之相对应，他们之间的继承关系如下图所示：</p>
<p><img src="source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211029141706293-16354882280304.png" alt="image-20211029141706293"></p>
<h3 id="1-Buffer-的基本用法"><a href="#1-Buffer-的基本用法" class="headerlink" title="1. Buffer 的基本用法"></a>1. Buffer 的基本用法</h3><p><strong>使用Buffer读写数据，一般遵循以下四个步骤：</strong></p>
<ol>
<li>写入数据到Buffer</li>
<li>调用<code>flip()</code>方法</li>
<li>从Buffer中读取数据</li>
<li>调用<code>clear()</code>方法或者<code>compact()</code>方法</li>
</ol>
<blockquote>
<p>当向buffer写入数据是，buffer会记录下写了多少数据。一旦要读取数据，需要通过<code>flip()</code>方法将Buffer从写模式切换到读模式。在读模式下，可以读取之前写入到Buffer的所有数据。一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用<code>clear()</code>或<code>compact()</code>方法。<code>clear()</code>方法会清空整个缓冲区。<code>compact()</code>方法只会清除已经读过的数据。任何未读的数据都<br>被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。</p>
</blockquote>
<p>ByteBuffer Demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bufferTest1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;Files\\data.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">fileChannel</span> <span class="operator">=</span> raf.getChannel();</span><br><span class="line">    <span class="comment">// 创建Buffer</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line">    <span class="comment">// 承接读取的字节数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">readBytes</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((readBytes=fileChannel.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 写读转换</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="keyword">while</span> (buffer.hasRemaining())&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>)buffer.get());</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.compact();</span><br><span class="line">    &#125;</span><br><span class="line">    raf.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>IntBuffer Demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">intBuferTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 分配新的int缓冲区，参数为缓冲区容量</span></span><br><span class="line">    <span class="comment">// 新缓冲区的当前位置为零， 其界限（限制位置）将为其容量</span></span><br><span class="line">    <span class="comment">// 它将具有一个底层实现数组，其数组偏移量将为零</span></span><br><span class="line">    <span class="type">IntBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> IntBuffer.allocate(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;buffer.capacity();++i)&#123;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">2</span>*(i+<span class="number">1</span>);</span><br><span class="line">        buffer.put(j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置缓冲区，将限制设置为当前位置，然后将当前位置设置为0</span></span><br><span class="line">    buffer.flip();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (buffer.hasRemaining())&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> buffer.get();</span><br><span class="line">        System.out.print(j+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Buffer的capacity、position和limit</strong></p>
<p>为了理解Buffer的工作原理，需要熟悉它的三个属性：</p>
<ul>
<li>Capacity</li>
<li>Position</li>
<li>limit</li>
</ul>
<p>position和limit的含义取决于Buffer处于<strong>读模式</strong>还是<strong>写模式</strong>。不管Buffer处在什么模式，capacity的含义总是一样的。</p>
<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fdl2.iteye.com%2Fupload%2Fattachment%2F0096%2F4782%2Fb8a7bad8-ec65-36dc-bb11-4f352e00cd67.png&refer=http%3A%2F%2Fdl2.iteye.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1638086744&t=8d1f749ef4dcf004a67f97d4223aaa68" alt="img"></p>
<ol>
<li><strong>capacity</strong><ul>
<li>作为一个内存块，Buffer有一个固定的大小值，也叫“capacity”。你只能往里面写capacity个byte、long、char等类型。一旦buffer满了，需要将其清空（通过读数据或者清除数据）才能继续往里写数据。</li>
</ul>
</li>
<li><strong>position</strong><ul>
<li><strong>写数据到Buffer中时</strong>，position表示写入数据的当前位置，position的初始值为0,。当一个byte、long等数据写到buffer后，position会向下移动到下一个可插入数据的buffer单元。position最大可为capacity-1（因为position的初始值为0）</li>
<li><strong>读数据到Buffer中时</strong>，position表示读入数据的当前位置，如position=2时表示已开始读入了3个byte，或从第3个byte开始读取。通过<code>ByteBuffer.flip()</code>切换到读模式时，position会被重置为0，当Buffer从position读入数据后，position会下移到下一个可读入的数据Buffer单元。</li>
</ul>
</li>
<li><strong>limit</strong><ul>
<li>写数据时，limit表示可对Buffer最多写入多少个数据。写模式下，limit等于Buffer的capacity</li>
<li>读数据时，limit表示Buffer里有多少可读数据（not null 的数据），因此能读到之前写入的所有数据（limit被设置成已写数据的数量，这个值在写模式下就是position）</li>
</ul>
</li>
</ol>
<h3 id="2-Buffer的类型"><a href="#2-Buffer的类型" class="headerlink" title="2. Buffer的类型"></a>2. Buffer的类型</h3><p>JAVA NIO 有一下Buffer类型</p>
<ul>
<li>ByteBuffer</li>
<li>MappedByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>这些Buffer类型代表了不同的数据类型。换句话说，就是可以通过char，short，int，long，float或double类型来操作缓冲区中的字节。</p>
<h3 id="3-Buffer分配和写数据"><a href="#3-Buffer分配和写数据" class="headerlink" title="3. Buffer分配和写数据"></a>3. Buffer分配和写数据</h3><h4 id="Buffer的分配"><a href="#Buffer的分配" class="headerlink" title="Buffer的分配"></a>Buffer的分配</h4><p>想要获得一个Buffer对象首先要进行过分配。每一个Buffer类都有一个allocate方法。比如分配一个48字节capacity的ByteBuffer：</p>
<p><code>ByteBuffer buffer = ByteBuffer.allocate(48);</code></p>
<p>分配一个可存储1024个字符的CharBuffer：</p>
<p><code>CharBuffer buffer = CharBuffer.allocate(1024);</code></p>
<h4 id="向Buffer中写数据"><a href="#向Buffer中写数据" class="headerlink" title="向Buffer中写数据"></a>向Buffer中写数据</h4><p>写数据到Buffer中有两种方式：</p>
<ol>
<li>从Channel写到Buffer<ul>
<li><code>int bytesRead = inChannel.read(buffer)</code></li>
</ul>
</li>
<li>通过Buffer的<code>put()</code>方法写到Buffer中<ul>
<li><code>buffer.put(127);</code></li>
<li>put方法有很多版本，允许以不同的方式把数据写入到Buffer中。例如，写到一个指定的位置，或者把一个字节数组写入到Buffer中。</li>
</ul>
</li>
</ol>
<h3 id="4-flip-方法"><a href="#4-flip-方法" class="headerlink" title="4. flip() 方法"></a>4. flip() 方法</h3><p><code>flip()</code>方法将Buffer从写模式切换到读模式。调用<code>flip()</code>方法会将position设置为0，并将limit设置成之前position的值。换句话说，position现在用于标记读的位置，limit表示之前写进了多少个byte，char等（现在能读取多少个byte，char等）。</p>
<h3 id="5-从Buffer中读取数据"><a href="#5-从Buffer中读取数据" class="headerlink" title="5. 从Buffer中读取数据"></a>5. 从Buffer中读取数据</h3><p><strong>从Buffer中读取数据有两种方式：</strong></p>
<ol>
<li>从Buffer读取数据到Channel<ul>
<li><code>int byteWrites = inchannel.write(buffer)</code></li>
<li>读取buffer中的数据，写入到channel中</li>
</ul>
</li>
<li>使用<code>get()</code>方法从Buffer中读取数据<ul>
<li><code>byte aByte = buffer.get();</code></li>
<li>get方法有很多版本，允许你以不同的方式从Buffer中读取数据。例如，从指定position读取，或者从Buffer中读取数据到字节数组。</li>
</ul>
</li>
</ol>
<h3 id="6-Buffer的几个方法"><a href="#6-Buffer的几个方法" class="headerlink" title="6. Buffer的几个方法"></a>6. Buffer的几个方法</h3><h4 id="rewind-方法"><a href="#rewind-方法" class="headerlink" title="rewind()方法"></a>rewind()方法</h4><p><code>Buffer.rewind()</code>将position设回0，所以可以重读Buffer中的所有数据。limit保持不变，任然表示能从Buffer中读取多少个元素（byte，char等）。</p>
<h4 id="clear-与-compact-方法"><a href="#clear-与-compact-方法" class="headerlink" title="clear() 与 compact()方法"></a>clear() 与 compact()方法</h4><p>一旦读完Buffer中的数据，需要让Buffer准备好再次被写入。可以通过<code>clear()</code>或者<code>compact()</code>方法来完成。</p>
<p>如果调用的是<code>clear()</code>方法，position将被设置回0，limit被设置为capacity的值。换句话说，Buffer被清空了。Buffer中的数据并未清除，只是这些标记告诉我们可以从哪里开始往Buffer里写数据。</p>
<p>如果Buffer中有一些未读的数据，调用<code>clear()</code>方法，数据将被“<strong>遗忘</strong>”，意味着不再有任何标记会告诉你哪些数据呗读过，哪些还没有。</p>
<p>如果Buffer中仍有未读的数据，且后续还需要这些数据，但是此时想要先写些数据，那么使用<code>compact()</code>方法。</p>
<p><code>compact()</code>方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个维度元素正后面。limit属性依然像<code>clear()</code>方法一样，设置成capacity。现在Buffer准备好写数据了，但是不会覆盖未读的数据。</p>
<h4 id="mark-与reset-方法"><a href="#mark-与reset-方法" class="headerlink" title="mark()与reset()方法"></a>mark()与reset()方法</h4><p>通过调用<code>Buffer.mark()</code>方法，可以标记Buffer中的一个特定的position。之后可以通过调用<code>Buffer.reset()</code>方法恢复到这个position。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buffer.mark();</span><br><span class="line"><span class="comment">// set position back to mark</span></span><br><span class="line">buffer.reset();</span><br></pre></td></tr></table></figure>



<h3 id="7-Buffer-操作"><a href="#7-Buffer-操作" class="headerlink" title="7. Buffer 操作"></a>7. Buffer 操作</h3><h4 id="1-Buffer分片"><a href="#1-Buffer分片" class="headerlink" title="1. Buffer分片"></a>1. Buffer分片</h4><p>在NIO中，除了可以分配或者包装一个缓冲区对象外，还可以根据现有的缓冲区对象来创建一个子缓冲区，即在现有缓冲区上切出一片来作为一个新的缓冲区，但现有的缓冲区与创建的子缓冲区在底层数组层面上是<strong>数据共享</strong>的，也就是说，子缓冲区相当于是现有缓冲区的一个视图窗口。调用<code>slice()</code>方法可以创建一个子缓冲区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sliceTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buffer.capacity(); i++) &#123;</span><br><span class="line">        buffer.put((<span class="type">byte</span>)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buffer.position(<span class="number">3</span>);</span><br><span class="line">    buffer.limit(<span class="number">7</span>);</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">slice</span> <span class="operator">=</span> buffer.slice();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变子缓冲区的内容</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; slice.capacity(); i++) &#123;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> slice.get(i);</span><br><span class="line">        b*=<span class="number">10</span>;</span><br><span class="line">        slice.put(i,b);</span><br><span class="line">    &#125;</span><br><span class="line">    buffer.position(<span class="number">0</span>);</span><br><span class="line">    buffer.limit(buffer.capacity());</span><br><span class="line">    <span class="keyword">while</span> (buffer.hasRemaining())&#123;</span><br><span class="line">        System.out.print(buffer.get()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-只读缓冲区"><a href="#2-只读缓冲区" class="headerlink" title="2. 只读缓冲区"></a>2. 只读缓冲区</h4><p>只读缓冲区非常简单，可以读取他们，但是不能写入数据。可以通过调用缓冲区的<code>asReadOnlyBuffer()</code>方法，将任何常规缓冲区转换为只读缓冲区，这个方法返回一个与原缓冲区完全相同的缓冲区，并与原缓冲区共享数据，只不过它是只读的。如果原缓冲区的内容发生了变化，只读缓冲区的内容也随之发生变化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readOnlyBufferTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buffer.capacity(); i++) &#123;</span><br><span class="line">        buffer.put((<span class="type">byte</span>)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建只读缓冲区</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">readOnlyBuffer</span> <span class="operator">=</span> buffer.asReadOnlyBuffer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变原缓冲区的内容</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buffer.capacity(); i++) &#123;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> buffer.get();</span><br><span class="line">        b*=<span class="number">10</span>;</span><br><span class="line">        buffer.put(i, b);</span><br><span class="line">    &#125;</span><br><span class="line">    readOnlyBuffer.position(<span class="number">0</span>);</span><br><span class="line">    readOnlyBuffer.limit(buffer.capacity());</span><br><span class="line">    <span class="comment">//只读缓冲区的内容也随之改变</span></span><br><span class="line">    <span class="keyword">while</span>(readOnlyBuffer.remaining()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(readOnlyBuffer.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果尝试修改只读缓冲区的内容，则会报<code>ReadOnlyBufferException</code>异常。只读缓冲区对于保护数据很有用，在将缓冲区传递给某个对象的时候，无法知道这个方法是否会修改缓冲区中的数据。创建一个只读的缓冲区可以保证该缓冲区不会被修改。只可以把常规缓冲区转换为只读缓冲区，而不能将只读缓冲区转换成可写的缓冲区。</p>
<h4 id="3-直接缓冲区"><a href="#3-直接缓冲区" class="headerlink" title="3. 直接缓冲区"></a>3. 直接缓冲区</h4><p>直接缓冲区是为了加快<code>I/O</code>速度，使用一种特殊方式为其分配内存的缓冲区，JDK文档中的描述为：<font color=blue>给定一个直接缓冲区，Java虚拟机将尽最大努力直接对它执行本机I/O操作。</font></p>
<p>也就是说，它会在每次调用底层操作系统的本机I/O操作之前（或之后），尝试避免将缓冲区的内容拷贝到另一个中间缓冲区中，或者从一个中间缓冲区拷贝数据。要分配直接缓冲区，需要调用<code>allocateDirect()</code>方法，而不是<code>allocate()</code>方法，是用方式与普通缓冲区并无区别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">directBufferTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;Files\\data.txt&quot;</span>);</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;Files\\data4.txt&quot;</span>);</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">inChannel</span> <span class="operator">=</span> fileInputStream.getChannel();</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">oChannel</span> <span class="operator">=</span> fileOutputStream.getChannel();</span><br><span class="line">    <span class="comment">// 创建直接缓冲区</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line">    <span class="comment">// 复制文件内容</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        buffer.clear();</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> inChannel.read(buffer);</span><br><span class="line">        <span class="keyword">if</span> (r==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.flip();</span><br><span class="line">        oChannel.write(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    inChannel.close();</span><br><span class="line">    oChannel.close();</span><br><span class="line">    fileInputStream.close();</span><br><span class="line">    fileOutputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="直接缓冲区与非直接缓冲区的区别"><a href="#直接缓冲区与非直接缓冲区的区别" class="headerlink" title="直接缓冲区与非直接缓冲区的区别"></a>直接缓冲区与非直接缓冲区的区别</h5><p><img src="source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzQwMzg5Nzc1,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<p>在非直接缓冲区中读或者写数据都要在<code>操作系统</code>和<code>JVM</code>直接进行<code>copy</code>，所以它的效率不高</p>
<p><img src="https://img-blog.csdnimg.cn/20190410105333435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzQwMzg5Nzc1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>直接缓冲区建立在操作系统的物理内存中。应用程序直接面对的是物理内存。所里效率比较高，但是在应用程序中开辟一个直接缓冲区是比较耗费资源的。还有一点：应用程序将文件写入直接缓冲区后，这个文件的数据就不归应用程序所管了。至于直接缓冲区中的数据在何时写入到磁盘中，那就由操作系统决定了。在销毁的时候 需要断开应用程序和 物理内存之间的引用，然后让垃圾回收机制进行回收，这个也是比较耗资源的。</p>
<h4 id="4-内存映射文件I-O"><a href="#4-内存映射文件I-O" class="headerlink" title="4. 内存映射文件I/O"></a>4. 内存映射文件I/O</h4><p>内存映射文件I/O是一种读取和写文件数据的方法，它可以比常规的基于流或者基于通道的I/O快的多。一般来说，只有文件中实际读取或者写入的部分才会映射到内存中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mappedByteBufferTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;Files\\data.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">fc</span> <span class="operator">=</span> raf.getChannel();</span><br><span class="line">    <span class="type">MappedByteBuffer</span> <span class="variable">mbb</span> <span class="operator">=</span> fc.map(FileChannel.MapMode.READ_WRITE, start, size);</span><br><span class="line">    <span class="comment">// 在指定索引处put元素</span></span><br><span class="line">    mbb.put(<span class="number">0</span>,(<span class="type">byte</span>)<span class="number">97</span>);</span><br><span class="line">    mbb.put(<span class="number">1023</span>,(<span class="type">byte</span>)<span class="number">122</span>);</span><br><span class="line">    raf.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="8-黏包-与-半包"><a href="#8-黏包-与-半包" class="headerlink" title="8. 黏包  与  半包"></a>8. 黏包  与  半包</h3><p>通常在网络传输中，可能会出现一个长文本会被拆分成多次进行发送，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">input1</span> <span class="operator">=</span> <span class="string">&quot;Hello,World.\nI&#x27;m zhangsan\nHo&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">input2</span> <span class="operator">=</span> <span class="string">&quot;w are you?\n&quot;</span>;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        byteBuffer.put(input1.getBytes());</span><br><span class="line">        split(byteBuffer);</span><br><span class="line">        byteBuffer.put(input2.getBytes());</span><br><span class="line">        split(byteBuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(ByteBuffer source)</span>&#123;</span><br><span class="line">        source.flip();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; source.limit(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (source.get(i)==<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> i+<span class="number">1</span>-source.position();</span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">target</span> <span class="operator">=</span> ByteBuffer.allocate(length);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                    target.put(source.get());</span><br><span class="line">                &#125;</span><br><span class="line">                print(target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当buffer中的还有元素没有读取完成的时候，采用整理的方式，保留剩余元素，清除读取过的元素</span></span><br><span class="line">        <span class="comment">// 这里没有读到\n 这个buffer就会有剩余元素</span></span><br><span class="line">        source.compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(ByteBuffer target)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; target.limit(); i++) &#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>)target.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是上述<code>split</code>方法存在一个跟大的漏洞，当客户端传递过来的消息长度超过了buffer的容量就会和预期不一致。</p>
<p>解决办法详见 <strong>消息边界一节</strong></p>
<h2 id="3-4-Selector"><a href="#3-4-Selector" class="headerlink" title="3.4 Selector"></a>3.4 Selector</h2><h3 id="1-Selector简介"><a href="#1-Selector简介" class="headerlink" title="1. Selector简介"></a>1. Selector简介</h3><h4 id="Selector和Channel的关系"><a href="#Selector和Channel的关系" class="headerlink" title="Selector和Channel的关系"></a>Selector和Channel的关系</h4><p>Selector一般称为选择器，也可以翻译为 多路复用器。它是Java NIO核心组件中的一个，用于检查一个或多个NIO Channel（通道）的状态是否处于可读、可写。如此可以实现单线程管理多个channels，也就是可以管理多个网络连接。</p>
<p><img src="source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211109100448562-16364234905571.png" alt="image-20211109100448562"></p>
<p>使用Selector的好处在于：使用更少的线程就可以来处理通道了，相比使用多个线程，避免了线程上下文切换所带来的开销。</p>
<h4 id="2-可选择通道（SelectableChannel）"><a href="#2-可选择通道（SelectableChannel）" class="headerlink" title="2. 可选择通道（SelectableChannel）"></a>2. 可选择通道（SelectableChannel）</h4><ol>
<li>不是所有的 Channel 都可以被 Selector 复用的。比方说，FileChannel 就不能 被选择器复用。判断一个 Channel 能被 Selector 复用，有一个前提：判断他是否继 承了一个抽象类 <code>SelectableChannel</code>。如果继承了 <code>SelectableChannel</code>，则可以被复用，否则不能。 </li>
<li><code>SelectableChannel</code> 类提供了实现通道的可选择性所需要的公共方法。它是所有支持就绪检查的通道类的父类。所有 socket 通道，都继承了 <code>SelectableChannel</code> 类 都是可选择的，包括从管道(Pipe)对象的中获得的通道。而 FileChannel 类，没有继 承 <code>SelectableChannel</code>，因此是不是可选通道。 </li>
<li>一个通道可以被注册到多个选择器上，但对每个选择器而言只能被注册一次。通道和选择器之间的关系，使用注册的方式完成。``SelectableChannel<code>可以被注册到</code>Selector` 对象上，在注册的时候，需要指定通道的哪些操作，是 Selector 感兴趣的。</li>
</ol>
<p><img src="source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/src=http%253A%252F%252Fpic1.zhimg.com%252Fv2-805bb1b58bcc01045a6142e6e6fa1304_b.jpg&refer=http%253A%252F%252Fpic1.zhimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg" alt="img"></p>
<h4 id="3-Channel注册到Selector"><a href="#3-Channel注册到Selector" class="headerlink" title="3. Channel注册到Selector"></a>3. Channel注册到Selector</h4><ol>
<li><p>使用<code>Channel.register(Selector sel, int ops)</code>方法，将一个通道注册到一个选择器时。第一个参数，指定通道要注册的选择器。第二个参数指定选择器需要查询的通道操作。</p>
</li>
<li><p>可以供选择器查询的通道操作，从类型来分，包括以下四种：</p>
<ol>
<li>可读<code>SelectorKey.OP_READ</code></li>
<li>可写<code>SelectorKey.OP_WRITE</code></li>
<li>连接<code>SelectorKey.OP_CONNECT</code></li>
<li>接收<code>SelectorKey.OP_ACCEPT</code></li>
</ol>
<p>如果Selector对通道的多操作类型感兴趣，可以使用<code>位或</code>操作符来实现。比如：<code>int key = SelectorKey.OP_READ | SelectorKey.OP_WRITE</code>;、</p>
</li>
<li><p>选择器查询的不是通道的操作，而是通道的某个操作的一种就绪状态。什么是操作的就绪状态？</p>
<blockquote>
<p>一旦通道具备完成某个操作的条件，表示该通道的某个操作已经就绪，就可以被Selector查询到，程序可以对通道进行对应的操作。</p>
<p>比方说，某个SocketChannel通道可以连接到一个服务器，则处于“连接就绪”（OP_CONNECT）。</p>
<p>再比方说，一个ServerSocketChannel服务器通道准备好接收进入的连接，则处于“接收就绪”（OP_ACCEPT）状态，</p>
<p>还不妨说，一个有数据可读的通道，可以说是“读就绪”（OP_READ）。</p>
<p>一个等待写数据的通道可以说是“写就绪”（OP_WRITE）。</p>
</blockquote>
</li>
</ol>
<h4 id="4-选择键（SelectionKey）"><a href="#4-选择键（SelectionKey）" class="headerlink" title="4. 选择键（SelectionKey）"></a>4. 选择键（SelectionKey）</h4><ol>
<li>Channel注册后，并且一旦通道处于某种就绪的状态，就可以被选择器查询到。这个工作，使用选择器Selector的<code>select()</code>方法完成。<code>select()</code>方法的作用，对感兴趣的通道操作，进行就绪状态的查询。</li>
<li>Selector可以不断的查询Channel中发生的操作的就绪状态。并且挑选感兴趣的操作就绪状态。一旦通道有操作的就绪状态达成，并且是Selector感兴趣的操作，就会被Selector选中，放入选择键集合中。</li>
<li>一个选择键，首先是包含了注册在Selector的通道操作类型，比方说<code>SelectorKey.OP_READ</code>。也包含了特定的通道与特定的选择器之间的注册关系。</li>
</ol>
<p>​        开发应用程序时，选择键是编程的关键。NIO的编程，就是根据对应的选择键，进行不同的业务逻辑处理。</p>
<ol start="4">
<li>选择键的概念，和事件的概念比较相似，一个选择键类似监听器模式里边的一个事件。由于Selector不是事件触发的模式，而是主动去查询的模式，所以不叫事件Event，而是叫SelectorKey选择键。</li>
</ol>
<h3 id="2-Selector的使用方法"><a href="#2-Selector的使用方法" class="headerlink" title="2. Selector的使用方法"></a>2. Selector的使用方法</h3><h4 id="1-Selector的创建"><a href="#1-Selector的创建" class="headerlink" title="1. Selector的创建"></a>1. Selector的创建</h4><p>通过调用Selector.open()方法创建一个Selector对象，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 获取Selector选择器</span></span><br><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br></pre></td></tr></table></figure>

<h4 id="2-注册Channel到Selector"><a href="#2-注册Channel到Selector" class="headerlink" title="2. 注册Channel到Selector"></a>2. 注册Channel到Selector</h4><p>要实现Selector管理Channel，需要将Channel注册到相应的Selector上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 获取Selector选择器</span></span><br><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 获取通道</span></span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 设置为非阻塞</span></span><br><span class="line">serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 绑定连接</span></span><br><span class="line">serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9999</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 将通道注册到选择器上，并制定监听事件为：“接收”事件</span></span><br><span class="line">serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>

<p>上面通过调用通道的<code>register()</code>方法会将它注册到一个选择器上。</p>
<p><font color=red>首先需要注意的是：</font></p>
<ol>
<li>与Selector一起使用时，Channel必须处于<strong>非阻塞模式下</strong>，否则将抛出异常<code>IllegalBlockingModeException</code>。这意味着，FileChannel不能与Selector一起使用，因为FileChannel不能切换到非阻塞模式，而套接字相关的所有的通道都可以。</li>
<li>一个通道，并没有一定要支持所有的四种操作。比如服务器通道<code>ServerSocketChannel</code>支持<code>accept()</code>接收操作，而<code>SocketChannel</code>客户端通道则不支持。可以通过通道的<code>validOps()</code>方法，来获取特定通道下所有支持的操作集合。</li>
</ol>
<h4 id="3-轮询查询就绪操作"><a href="#3-轮询查询就绪操作" class="headerlink" title="3. 轮询查询就绪操作"></a>3. 轮询查询就绪操作</h4><ol>
<li><p>通过Selector的select()方法，可以查询出已经就绪的通道操作，这些就绪的状态集合，存到一个SelectionKey对象的Set集合中。</p>
</li>
<li><p>下面是Selector几个重载的查询select()方法：</p>
<ul>
<li><p><code>select()</code>：阻塞到至少有一个通道在你注册的事件上就绪了。</p>
<ul>
<li><blockquote>
<p>这就表明，Selector不会空转cpu，没有key发生时，是会阻塞的，不会一直占用cpu</p>
</blockquote>
<blockquote>
<p>如果select在事件未处理时，它不会阻塞，会一直重复进行未出的那一个key<strong>直至处理为止</strong> 或 <strong>取消</strong>。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>select(long timeout)</code>：和<code>select()</code>一样，但最长阻塞事件时间为timeout毫秒</p>
</li>
<li><p><code>selectNow()</code>：非阻塞，只要有通道就绪就立刻返回</p>
</li>
</ul>
</li>
</ol>
<p><code>select()</code>方法返回的int值，表示有多少通道已经就绪，更准确的说，是之前一次select方法以来到这一次select方法之间的时间段上，有多少通道变成就绪状态。</p>
<p>例如：首次调用<code>select()</code>方法，如果有一个通道变成就绪状态，返回了1，若再次调用<code>select()</code>方法，如果另一个通道就绪了，它会再次返回1.如果对第一个就绪的Channel没有任何操作，现在就有两个就绪的通道，但是每次<code>select()</code>方法调用之间，只有一个通道就绪了。</p>
<p>一旦调用select()方法，并且返回值不为0时，在Selector中有一个<code>selectedKeys()</code>方法，用来访问已选择键集合，迭代集合的每一个选择键元素，根据就绪操作的类型，完成对应的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">selectedKey</span> <span class="operator">=</span> selector.selectedKeys();</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">keyIterator</span> <span class="operator">=</span> selectedKeys.iterator();</span><br><span class="line"><span class="keyword">while</span>(keyIterator.hasNext())&#123;</span><br><span class="line">    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isConnectable())&#123;</span><br><span class="line">        <span class="comment">// a connection was eatablished with a remote server</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isWritable())&#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-停止选择的方法"><a href="#4-停止选择的方法" class="headerlink" title="4.  停止选择的方法"></a>4.  停止选择的方法</h4><p>选择器执行选择的过程，系统底层会依次询问每个通道是否已经就绪，这个过程可能会造成调用线程进行阻塞状态，那么我们有以下三种方式可以唤醒在select()方法中阻塞的线程。</p>
<p><code>wakeup()</code>方法：通过调用Selector对象的<code>wakeup()</code>方法让处于阻塞状态的<code>select()</code>方法立刻返回；该方法使得选择器上的第一个还没有返回的选择操作立即返回。如果当前没有进行中的选择操作，那么下一次对<code>select()</code>方法的一次调用将立即返回。</p>
<p><code>close()</code>方法：通过close()方法关闭Selector，该方法使得任何一个在选择操作中阻塞的线程都被唤醒（类似<code>wakeup()</code>），同时使得注册到该Selector的所有Channel被注销，所有的键将被取消，但是Channel本身并不会关闭。</p>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><p>服务端（接收 客户端的消息，返回消息给客户端）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectorDemo</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serverSelectorTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssc.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;172.16.75.240&quot;</span>,<span class="number">8000</span>));</span><br><span class="line">        ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="comment">// 注册Channel，并且指定感兴趣的事件是Accept</span></span><br><span class="line">        ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">readBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">writeBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        writeBuffer.put(<span class="string">&quot;received&quot;</span>.getBytes());</span><br><span class="line">        writeBuffer.flip();</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nReady</span> <span class="operator">=</span> selector.select();</span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; it = keys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> it.next();</span><br><span class="line">                it.remove();</span><br><span class="line">                <span class="comment">// 接收状态就绪</span></span><br><span class="line">                <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                    <span class="comment">// 创建新的连接，并且把连接注册到selector上，而且，声明这个channel只对读操作感兴趣。</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> ssc.accept();</span><br><span class="line">                    socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    socketChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                    <span class="comment">// 如果读状态就绪</span></span><br><span class="line">                    <span class="comment">// 获取读状态key下的channel</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel)key.channel();</span><br><span class="line">                    readBuffer.clear();</span><br><span class="line">                    socketChannel.read(readBuffer);</span><br><span class="line">                    readBuffer.flip();</span><br><span class="line">                    System.out.println(<span class="string">&quot;received:&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(readBuffer.array()));</span><br><span class="line">                    <span class="comment">// 设置key的感兴趣的状态为写</span></span><br><span class="line">                    key.interestOps(SelectionKey.OP_WRITE);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isWritable())&#123;</span><br><span class="line">                    writeBuffer.rewind();  <span class="comment">// 重置 writeBuffer的position</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                    socketChannel.write(writeBuffer);</span><br><span class="line">                    key.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>客户端向服务端发送消息，并接收服务端返回的消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clientSelector</span><span class="params">()</span> <span class="keyword">throws</span> IOException,InterruptedException&#123;</span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">    socketChannel.connect(<span class="keyword">new</span> <span class="title class_">InetAddress</span>(<span class="string">&quot;172.16.75.240&quot;</span>,<span class="number">8000</span>));</span><br><span class="line">    socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">readBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">32</span>);</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">writeBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">32</span>);</span><br><span class="line">    writeBuffer.put(<span class="string">&quot;hello&quot;</span>.getBytes());</span><br><span class="line">    writeBuffer.flip();</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        writeBuffer.rewind();</span><br><span class="line">        socketChannel.write(writeBuffer);</span><br><span class="line">        readBuffer.clear();</span><br><span class="line">        socketChannel.read(readBuffer);</span><br><span class="line">        System.out.println(<span class="string">&quot;server:&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(readBuffer.array()));</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="NIO编程步骤总结"><a href="#NIO编程步骤总结" class="headerlink" title="NIO编程步骤总结"></a>NIO编程步骤总结</h4><ol>
<li>创建Selector选择器</li>
<li>创建ServerSocketChannel通道，并绑定监听端口</li>
<li>设置Channel通道是非阻塞模式</li>
<li>把Channel注册到Selector选择器上，监听连接事件</li>
<li>调用Selector的select方法（循环调用），监听通道的就绪状态</li>
<li>调用selectKeys方法获取就绪channel集合</li>
<li>遍历就绪channel集合，判断就绪事件类型，实现具体的业务操作</li>
<li>根据业务，决定是否需要再次注册监听事件，重复执行第三步操作</li>
</ol>
<h4 id="为什么每次处理完一个key后，需要将这个key进行移除remove？"><a href="#为什么每次处理完一个key后，需要将这个key进行移除remove？" class="headerlink" title="为什么每次处理完一个key后，需要将这个key进行移除remove？"></a>为什么每次处理完一个key后，需要将这个key进行移除remove？</h4><p>selector内部其实会涉及到两个重要的集合<code>SelectionKey[] ks =  new SelectionKey[n];</code> 和 <code>protected Set&lt;SelectionKey&gt; selectedKeys = new HashSet();</code></p>
<p>在通道Channel往Selector上进行注册时，会对应创建一个<code>SelectionKey</code>, 这个<code>SelectionKey</code>是一个抽象类，附带了所注册的<code>Channel</code>的信息。</p>
<p>当又对应的<code>key</code>就绪时，会往<code>SelectedKeys</code>集合中添加上述注册时创建好的<code>SelectionKey</code>。<font color=red>此处需要注意的是，只要有key的状态变为就绪状态，就会被添加到SelectedKeys中，而且这个过程是单向的，即只往集合中添加相应的key，再相应的key被处理完成之后，这个key的状态会发生改变，但是并没有从集合中移除相应key的操作</font>。因此，在处理完一个就绪的key时，我们就需要及时的进行移除<code>remove</code>操作，避免重复执行。</p>
<blockquote>
<p>如果集合中的key处理完没有及时的移除掉，这就会导致这个key会再次被处理，而在处理这个key 的过程中（假设key所对应的Channel是非阻塞模式的），由于非阻塞模式没有事件发生时，就会返回null，这时就会发生空指针异常。</p>
</blockquote>
<p>使用迭代器的<code>remove()</code>方法就可以将当前的元素从集合中移除。<font color=green>这也是为什么要使用迭代器来进行key的遍历，而不是直接遍历这个集合.</font></p>
<h3 id="💡-select-何时不阻塞"><a href="#💡-select-何时不阻塞" class="headerlink" title="💡 select 何时不阻塞"></a>💡 select 何时不阻塞</h3><ul>
<li>事件发生时<ul>
<li>客户端发起连接请求，会触发accept事件</li>
<li>客户端发送数据过来，客户端正常、异常关闭时，都会触发read事件，另外如果发送的数据大于buffer缓冲区，会触发多次读取事件</li>
<li>channel可写，会触发write时间</li>
<li>在linux下nio bug发生时</li>
</ul>
</li>
<li>调用<code>selector.wakeup()</code></li>
<li>调用<code>selector.close()</code></li>
<li><code>selector</code>所在线程<code>interrupt</code></li>
</ul>
<h2 id="3-5-Pipe和FileLock"><a href="#3-5-Pipe和FileLock" class="headerlink" title="3.5 Pipe和FileLock"></a>3.5 Pipe和FileLock</h2><h3 id="1-Pipe"><a href="#1-Pipe" class="headerlink" title="1. Pipe"></a>1. Pipe</h3><p>Java NIO管道是两个线程之间的单向数据连接。Pipe有一个source通道和一个sink通道。数据会被写入sink通道，从source通道读取。</p>
<p><img src="source/Java-IO%E6%B5%81%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20211112100419343-16366826605741.png" alt="image-20211112100419343"></p>
<h4 id="创建管道"><a href="#创建管道" class="headerlink" title="创建管道"></a>创建管道</h4><p><code>Pipe pipe = Pipe.open();</code></p>
<h4 id="向管道写入管道"><a href="#向管道写入管道" class="headerlink" title="向管道写入管道"></a>向管道写入管道</h4><p>要向管道写数据，需要访问sink通道。</p>
<p><code>Pipe.SinkChannel sinkChannel = pipe.sink();</code></p>
<p>通过调用SinkChannel的<code>write()</code>方法，将数据写入SinkChannel；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">newData</span> <span class="operator">=</span> <span class="string">&quot;New String to write to file&quot;</span>+System.currentTimeMillis();</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buffer.clear();</span><br><span class="line">buffer.put(newData.getBytes());</span><br><span class="line">buffer.flip();</span><br><span class="line"><span class="keyword">while</span>(buffer.hasRemaining())&#123;</span><br><span class="line">    sinkChannel.write(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="从管道读取数据"><a href="#从管道读取数据" class="headerlink" title="从管道读取数据"></a>从管道读取数据</h4><p>从管道中读取数据，需要访问source通道。</p>
<p><code>Pipe.SourceChannel sourceChannel = pipe.source();</code></p>
<p>调用source通道的<code>read()</code>方法来读取数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">byteRead</span> <span class="operator">=</span> sourceChannel.read(buf);</span><br></pre></td></tr></table></figure>

<p><code>read()</code>方法返回的int值会告诉我们多少字节被读进了缓冲区。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Pipe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PipeDemo</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pipeDemo</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Pipe</span> <span class="variable">pipe</span> <span class="operator">=</span> Pipe.open();</span><br><span class="line">        <span class="comment">// 向通道中写入数据</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">        buffer.put(<span class="string">&quot;new String Data&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">// 转换读写模式</span></span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        Pipe.<span class="type">SinkChannel</span> <span class="variable">sinkChannel</span> <span class="operator">=</span> pipe.sink();</span><br><span class="line">        sinkChannel.write(buffer);</span><br><span class="line">        <span class="comment">// 从通道中读取数据</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">readBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">        Pipe.<span class="type">SourceChannel</span> <span class="variable">sourceChannel</span> <span class="operator">=</span> pipe.source();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> sourceChannel.read(readBuffer);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(readBuffer.array(),<span class="number">0</span>,len));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-FileLock"><a href="#2-FileLock" class="headerlink" title="2. FileLock"></a>2. FileLock</h3><h4 id="FileLock简介"><a href="#FileLock简介" class="headerlink" title="FileLock简介"></a>FileLock简介</h4><p>文件锁在OS中很常见，如果多个程序同时访问，修改同一个文件，很容易因为文件数据不同步而出现问题。给文件加一个锁，同一时间，只能有一个程序修改此文件，或者程序都只能读此文件，这就解决了同步问题。</p>
<p>文件锁是进程级别的，不是线程级别的。文件锁可以解决多个<strong>进程</strong>并发访问、修改同一个文件的问题，但不能解决多<strong>线程</strong>并发访问、修改同一文件的问题。使用文件锁时，同一进程内的多个线程，可以同时访问、修改此文件。</p>
<p>文件锁时当前程序所属的JVM实例持有的，一旦获取到文件锁（对文件加锁），需要调用<code>release()</code>，或者关闭对应的<code>FileChannel</code>对象，或者当前JVM退出，才会释放这个锁。</p>
<p>一旦某个进程（比如说JVM实例）对某个文件加锁，则在释放这个锁之前，此进程不能再对此文件加锁，就是说JVM实例在同一个文件上的文件锁是不重叠的（进程级别不能重复在同一文件上获取锁）。</p>
<h4 id="文件锁分类："><a href="#文件锁分类：" class="headerlink" title="文件锁分类："></a>文件锁分类：</h4><p><strong>排它锁</strong>：又叫<strong>独占锁</strong>。对文件加排它锁后，该进程可以对此文件进行读写，该进程独占此文件，其他进程不能读写此文件，直到该进程释放文件锁。</p>
<p><strong>共享锁</strong>：某个进程对文件加共享锁，其他进程也可以访问此文件，但这些进程都只能读此文件，不能写。线程是安全的。只要还有一个进程持有共享锁，词文件就只能读，不能写。</p>
<h4 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建FileChannel对象，文件锁只能通过FileChannel对象来使用</span></span><br><span class="line"><span class="type">FileChannel</span> <span class="variable">fileChannle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;./1.txt&quot;</span>).getChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对文件加锁</span></span><br><span class="line"><span class="type">FileLock</span> <span class="variable">lock</span> <span class="operator">=</span> fileChannel.lock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对此文件进行一些读写操作</span></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">lock.release();</span><br></pre></td></tr></table></figure>

<p>文件锁要通过<code>FileChannel</code>对象使用</p>
<h4 id="获取文件锁方法"><a href="#获取文件锁方法" class="headerlink" title="获取文件锁方法"></a>获取文件锁方法</h4><p><strong>有3中获取文件锁的方法：</strong></p>
<ol>
<li><code>lock()</code> 对整个文件加锁，默认为排它锁</li>
<li><code>lock(long position, long size, boolean shared)</code> 自定义加锁方式。前两个参数指定要加锁的部分（可以只对此文件的部分内容加锁），第三个参数指定是否是共享锁。</li>
<li><code>tryLock()</code> 对整个文件加锁，默认为排他锁</li>
<li><code>tryLock(long position, long size, boolean shared)</code> 自定义加锁方式。</li>
</ol>
<p>如果指定为共享锁，则其他进程可读此文件，所有进程均不能写此文件，如果某进程试图对此文件进行写操作，会抛出异常。</p>
<h4 id="lock和tryLock的区别"><a href="#lock和tryLock的区别" class="headerlink" title="lock和tryLock的区别"></a>lock和tryLock的区别</h4><p>lock是阻塞式的，如果为获取到文件锁，会一直阻塞当前线程，直到获取文件锁。</p>
<p>tryLock和lock的作用相同，只不过tryLock是非阻塞式的，tryLock是尝试获取文件锁，获取成功就返回锁对象，否则返回null，不会阻塞当前线程。</p>
<h4 id="FileLock两个方法"><a href="#FileLock两个方法" class="headerlink" title="FileLock两个方法"></a>FileLock两个方法</h4><p><code>boolean isShared()</code> 此文件锁是否是共享锁</p>
<p><code>boolean isValid()</code> 此文件锁是否还有效</p>
<p>在某些OS上，对某个文件加锁后，不能对此文件使用通道映射。</p>
<h4 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileLock;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.StandardOpenOption;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;input:&quot;</span>+input);</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(input.getBytes());</span><br><span class="line">        <span class="type">String</span> <span class="variable">fp</span> <span class="operator">=</span> <span class="string">&quot;Files\\data.txt&quot;</span>;</span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(fp);</span><br><span class="line">        <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> FileChannel.open(path, StandardOpenOption.WRITE, StandardOpenOption.APPEND);</span><br><span class="line">        channel.position(channel.size()-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">FileLock</span> <span class="variable">lock</span> <span class="operator">=</span> channel.tryLock(<span class="number">0</span>,Long.MAX_VALUE, <span class="literal">false</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;共享锁 shared：&quot;</span>+lock.isShared());</span><br><span class="line"></span><br><span class="line">        channel.write(buffer);</span><br><span class="line">        channel.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;写操作完成&quot;</span>);</span><br><span class="line">        <span class="comment">// 读数据</span></span><br><span class="line">        readPrint(fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readPrint</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(path);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fileReader);</span><br><span class="line">        <span class="type">String</span> <span class="variable">tr</span> <span class="operator">=</span> bufferedReader.readLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;读取内容：&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (tr!=<span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;      &quot;</span>+tr);</span><br><span class="line">            tr = bufferedReader.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">        fileReader.close();</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="3-6-其他"><a href="#3-6-其他" class="headerlink" title="3.6 其他"></a>3.6 其他</h2><h3 id="1-Path"><a href="#1-Path" class="headerlink" title="1. Path"></a>1. Path</h3><h4 id="Path-简介"><a href="#Path-简介" class="headerlink" title="Path 简介"></a>Path 简介</h4><p>Java Path 接口是 Java NIO 更新的一部分，同 Java NIO 一起已经包括在Java6 和 Java7 中。Java Path 接口是在 Java7 中添加到 Java NIO 的。Path 接口位于 java.nio.file 包中，所以 Path 接口的完全限定名称为<code>java.nio.file.Path</code>。</p>
<p>Java Path示例表示文件系统中的路径。一个路径可以指向一个文件或一个目录。路径可以是绝对路径，也可以是相对路径。绝对路径包含从文件系统的根目录到它指向文件或目录的完整路径。相对路径包含相对于其他路径的文件或目录的路径。</p>
<p>在许多方面，<code>java.nio.file.Path</code>接口类似于<code>java.io.File</code>类，但是有一些差别。不过，在许多情况下，可以使用Path接口来替换File类的使用。</p>
<h4 id="创建Path示例"><a href="#创建Path示例" class="headerlink" title="创建Path示例"></a>创建Path示例</h4><p>使用<code>java.nio.file.Path</code>示例必须创建一个Path示例。可以使用Paths类（<code>java.nio.file.Pahts</code>）中的静态方法<code>Paths.get()</code>来创建路径示例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PathDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;D:\\Files\\data.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码，可以理解为，<code>Paths.get()</code>方法是Path示例的工厂方法。</p>
<h4 id="创建绝对路径"><a href="#创建绝对路径" class="headerlink" title="创建绝对路径"></a>创建绝对路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;D:\\Files\\data.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在Linux，MacOs机器上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;/home/Files/data.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果在Windows机器上使用了从<code>/</code>开始的路径，那么路径将被解释为相对于当前驱动器。</p>
<h4 id="创建相对路径"><a href="#创建相对路径" class="headerlink" title="创建相对路径"></a>创建相对路径</h4><p>Java NIO Path类也可以用于处理相对路径。您可以使用<code>Paths.get(basePaht, relativePath)</code>方法创建一个相对路径。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">projects</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;D:\\Files&quot;</span>, <span class="string">&quot;projects&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Path</span> <span class="variable">file</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;D:\\Files&quot;</span>, <span class="string">&quot;projects\\002.txt&quot;</span>);</span><br></pre></td></tr></table></figure>







<h4 id="Path-normalize"><a href="#Path-normalize" class="headerlink" title="Path.normalize()"></a>Path.normalize()</h4><p>Path接口的<code>normalize()</code>方法可以是路径标准化。标准化意味着它将移除所有在路径字符串的中间的.和..代码，并解析路径字符串所引用的路径。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">originalPath</span> <span class="operator">=</span> <span class="string">&quot;d:\\a\\b\\..\\demo.txt&quot;</span>;</span><br><span class="line"><span class="type">Path</span> <span class="variable">path1</span> <span class="operator">=</span> Paths.get(originalPath);</span><br><span class="line">System.out.println(<span class="string">&quot;path1:&quot;</span>path1);</span><br><span class="line"><span class="type">Path</span> <span class="variable">path2</span> <span class="operator">=</span> path1.normalize();</span><br><span class="line">System.out.println(<span class="string">&quot;path2:&quot;</span>+path2);</span><br></pre></td></tr></table></figure>

<p>上述代码会输出：</p>
<blockquote>
<p>path1:d:\a\b\..\demo.txt</p>
<p>path2:d:\a\demo.txt</p>
</blockquote>
<h3 id="2-File"><a href="#2-File" class="headerlink" title="2. File"></a>2. File</h3><h4 id="Files-createDirectory"><a href="#Files-createDirectory" class="headerlink" title="Files.createDirectory()"></a>Files.createDirectory()</h4><h4 id="Files-copy"><a href="#Files-copy" class="headerlink" title="Files.copy()"></a>Files.copy()</h4><h4 id="Files-move"><a href="#Files-move" class="headerlink" title="Files.move()"></a>Files.move()</h4><h4 id="Files-delete"><a href="#Files-delete" class="headerlink" title="Files.delete()"></a>Files.delete()</h4><h4 id="Files-walkFileTree"><a href="#Files-walkFileTree" class="headerlink" title="Files.walkFileTree()"></a>Files.walkFileTree()</h4><h3 id="3-AsynchronousFileChannel"><a href="#3-AsynchronousFileChannel" class="headerlink" title="3. AsynchronousFileChannel"></a>3. AsynchronousFileChannel</h3><h4 id="创建AsynchronousFileChannel"><a href="#创建AsynchronousFileChannel" class="headerlink" title="创建AsynchronousFileChannel"></a>创建AsynchronousFileChannel</h4><h4 id="通过Future读取数据"><a href="#通过Future读取数据" class="headerlink" title="通过Future读取数据"></a>通过Future读取数据</h4><h4 id="通过CompletionHandler读取数据"><a href="#通过CompletionHandler读取数据" class="headerlink" title="通过CompletionHandler读取数据"></a>通过CompletionHandler读取数据</h4><h4 id="通过Future写数据"><a href="#通过Future写数据" class="headerlink" title="通过Future写数据"></a>通过Future写数据</h4><h4 id="通过CompletionHandler写数据"><a href="#通过CompletionHandler写数据" class="headerlink" title="通过CompletionHandler写数据"></a>通过CompletionHandler写数据</h4><h3 id="4-字符集"><a href="#4-字符集" class="headerlink" title="4. 字符集"></a>4. 字符集</h3><p><strong>Charset 常用的静态方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过编码类型获得Charset对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Charset <span class="title function_">forName</span><span class="params">(String charsetName)</span>;</span><br><span class="line"><span class="comment">// 获得系统支持的所有编码方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SortedMap&lt;String, Charset&gt; <span class="title function_">availableCharsets</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 获得虚拟机默认的编码方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Charset <span class="title function_">defaultCharset</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 判断是否支持该编码类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSupported</span><span class="params">(String charsetName)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>Charset 常用普通方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">name</span><span class="params">()</span> <span class="comment">// 获得Charset对象的编码类型String </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> CharsetEncoder <span class="title function_">newEncoder</span><span class="params">()</span>  <span class="comment">// 获得编码器对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> CharsetDecoder <span class="title function_">newDecoder</span><span class="params">()</span>  <span class="comment">// 获得编码器对象</span></span><br></pre></td></tr></table></figure>

<h2 id="3-7-Java-NIO-综合案例"><a href="#3-7-Java-NIO-综合案例" class="headerlink" title="3.7 Java NIO 综合案例"></a>3.7 Java NIO 综合案例</h2><p>使用Java NIO 完成一个多人聊天室功能</p>
<h3 id="1-服务端"><a href="#1-服务端" class="headerlink" title="1. 服务端"></a>1. 服务端</h3><p>code大致思路</p>
<ol>
<li><p>创建Selector选择器</p>
</li>
<li><p>创建ServerSocketChannel通道</p>
</li>
<li><p>为channel通道绑定监听端口</p>
</li>
<li><p>循环，等待有新连接接入</p>
</li>
<li><p>根据就绪状态，调用对应方法实现具体业务操作</p>
<ol>
<li><p>如果是<code>accept</code>状态</p>
<p>…..</p>
</li>
<li><p>如果是可读状态</p>
<p>……</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startServer</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个选择器</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="comment">// 2. 创建一个ServerSocketChannel</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">// 3. 绑定端口号</span></span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9999</span>));</span><br><span class="line">        <span class="comment">// 4. 设置通道模式为非阻塞式模式</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 5. 将serverSocketChannel注册到Selector上,设置监听key为 accept</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器已经成功启动！&quot;</span>);</span><br><span class="line">        <span class="comment">// 循环等待有新连接接入</span></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="comment">// 获取channel的数量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">readChannels</span> <span class="operator">=</span> selector.select();</span><br><span class="line">            <span class="keyword">if</span> (readChannels == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取可用的channel</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            <span class="comment">// 遍历集合</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                <span class="comment">// 移除set集合当前selectionKey</span></span><br><span class="line">                iterator.remove();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 6. 根据就绪状态，调用对应方法实现具体业务操作</span></span><br><span class="line">                <span class="comment">//   6.1 如果监听到的key的状态是accept</span></span><br><span class="line">                <span class="keyword">if</span>(selectionKey.isAcceptable())&#123;</span><br><span class="line">                    <span class="comment">// do something for accept</span></span><br><span class="line">                    acceptOperator(serverSocketChannel, selector);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//   6.2 如果监听到的状态是可读状态</span></span><br><span class="line">                <span class="keyword">if</span>(selectionKey.isReadable())&#123;</span><br><span class="line">                    <span class="comment">// do something for read</span></span><br><span class="line">                    readOperator(selector,selectionKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理接入状态操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">acceptOperator</span><span class="params">(ServerSocketChannel serverSocketChannel, Selector selector)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1. 接入状态，创建socketChannel</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 将socketChannel 设置非阻塞模式</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 把channel注册到selector选择器上，监听可读状态</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 客户端回复消息</span></span><br><span class="line">        socketChannel.write(Charset.forName(<span class="string">&quot;UTF-8&quot;</span>).encode(<span class="string">&quot;欢迎进入聊天室，请注意隐私安全&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理可读状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readOperator</span><span class="params">(Selector selector, SelectionKey selectionKey)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="comment">// 1. 从SelectionKey获取已经就绪的通道</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel) selectionKey.channel();</span><br><span class="line">        <span class="comment">// 2. 创建buffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// 3. 循环读取客户端消息</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">readLength</span> <span class="operator">=</span> socketChannel.read(byteBuffer);</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (readLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 切换缓冲区的读写模式</span></span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            <span class="comment">// 读取内容</span></span><br><span class="line">            message += Charset.forName(<span class="string">&quot;UTF-8&quot;</span>).decode(byteBuffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4. 将channel再次注册到选择器上，监听可读状态</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 把客户端发送的消息，广播到其他客户端</span></span><br><span class="line">        <span class="keyword">if</span> (message.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 广播给其他客户端</span></span><br><span class="line">            System.out.println(message);</span><br><span class="line">            castOtherClient(message, selector, socketChannel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">castOtherClient</span><span class="params">(String message, Selector selector, SocketChannel socketChannel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 获取所有已经连入的channel</span></span><br><span class="line">        Set&lt;SelectionKey&gt; selectionKeySet = selector.keys();</span><br><span class="line">        <span class="comment">// 2. 循环向所有channel广播消息</span></span><br><span class="line">        <span class="keyword">for</span> (SelectionKey selectionKey : selectionKeySet) &#123;</span><br><span class="line">            <span class="comment">// 获取每个channel</span></span><br><span class="line">            <span class="type">SelectableChannel</span> <span class="variable">tarChannel</span> <span class="operator">=</span> selectionKey.channel();</span><br><span class="line">            <span class="comment">// 不给自己发</span></span><br><span class="line">            <span class="keyword">if</span> (tarChannel <span class="keyword">instanceof</span> SocketChannel &amp;&amp; tarChannel != socketChannel) &#123;</span><br><span class="line">                ((SocketChannel)tarChannel).write(Charset.forName(<span class="string">&quot;UTF-8&quot;</span>).encode(message));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ChatServer</span>().startServer();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h3 id="2-客户端"><a href="#2-客户端" class="headerlink" title="2. 客户端"></a>2. 客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatClient</span> &#123;</span><br><span class="line">    <span class="comment">// 启动客户端方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startClient</span><span class="params">(String name)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="comment">// 连接服务器, open方法里面直接传入服务端的ip地址和端口号</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.01&quot;</span>, <span class="number">9999</span>));</span><br><span class="line">        <span class="comment">// 接收服务端响应数据</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程, 用于接收服务端传来的消息</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ClientThread</span>(selector)).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向服务器端发送消息</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            <span class="keyword">if</span>(msg.length()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                socketChannel.write(Charset.forName(<span class="string">&quot;UTF-8&quot;</span>).encode(name+<span class="string">&quot;: &quot;</span>+msg));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-客户端接收服务端线程"><a href="#3-客户端接收服务端线程" class="headerlink" title="3. 客户端接收服务端线程"></a>3. 客户端接收服务端线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClientThread</span><span class="params">(Selector selector)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.selector = selector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">                <span class="comment">// 获取channel数量</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">readChannels</span> <span class="operator">=</span> selector.select();</span><br><span class="line">                <span class="keyword">if</span>(readChannels==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取可用的channel</span></span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                    <span class="comment">// 移除set集合当前selectionKey</span></span><br><span class="line">                    iterator.remove();</span><br><span class="line">                    <span class="comment">// 如果状态为可读状态</span></span><br><span class="line">                    <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">                        readOperator(selector,selectionKey);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readOperator</span><span class="params">(Selector selector, SelectionKey selectionKey)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="comment">// 1. 从Selectionkey获取到已经就绪的通道</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel) selectionKey.channel();</span><br><span class="line">        <span class="comment">// 2. 创建buffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// 3. 循环读取客户端消息</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">readLength</span> <span class="operator">=</span> socketChannel.read(byteBuffer);</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(readLength&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            message += Charset.forName(<span class="string">&quot;UTF-8&quot;</span>).decode(byteBuffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4. 将channel再次注册到选择器上，监听可读状态</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        <span class="keyword">if</span> (message.length()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 广播给其他客户端</span></span><br><span class="line">            System.out.println(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="模拟三个客户端A、B、C三个可客户端在聊天室进行聊天"><a href="#模拟三个客户端A、B、C三个可客户端在聊天室进行聊天" class="headerlink" title="模拟三个客户端A、B、C三个可客户端在聊天室进行聊天"></a>模拟三个客户端A、B、C三个可客户端在聊天室进行聊天</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ChatClient</span>().startClient(<span class="string">&quot;A Client&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ChatClient</span>().startClient(<span class="string">&quot;B Client&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ChatClient</span>().startClient(<span class="string">&quot;C Client&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-8-补充"><a href="#3-8-补充" class="headerlink" title="3.8 补充"></a>3.8 补充</h2><h3 id="处理accept事件"><a href="#处理accept事件" class="headerlink" title="处理accept事件"></a>处理accept事件</h3><p>客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">9090</span>))&#123;</span><br><span class="line">            System.out.println(socket);</span><br><span class="line">            socket.getOutputStream().write(<span class="string">&quot;world&quot;</span>.getBytes());</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>服务端代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelDemo6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> ServerSocketChannel.open()) &#123;</span><br><span class="line">            channel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">            System.out.println(channel);</span><br><span class="line">            <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">            channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            channel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();</span><br><span class="line"><span class="comment">//                int count = selector.selectNow();</span></span><br><span class="line">                log.debug(<span class="string">&quot;select count: &#123;&#125;&quot;</span>, count);</span><br><span class="line"><span class="comment">//                if(count &lt;= 0) &#123;</span></span><br><span class="line"><span class="comment">//                    continue;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取所有事件</span></span><br><span class="line">                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 遍历所有事件，逐一处理</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = keys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                    <span class="comment">// 判断事件类型</span></span><br><span class="line">                    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                        <span class="type">ServerSocketChannel</span> <span class="variable">c</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                        <span class="comment">// 必须处理</span></span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> c.accept();</span><br><span class="line">                        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, sc);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 处理完毕，必须将事件移除</span></span><br><span class="line">                    iter.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="💡-事件发生后能否不处理"><a href="#💡-事件发生后能否不处理" class="headerlink" title="💡 事件发生后能否不处理"></a>💡 事件发生后能否不处理</h4><p>事件发生后，要么处理，要么取消（cancel），不能什么都不做，否则下次该时间仍会触发，这是因为nio底层使用的水平触发。</p>
<h3 id="处理read事件"><a href="#处理read事件" class="headerlink" title="处理read事件"></a>处理read事件</h3><h4 id="消息边界问题-与-channel附件attachment"><a href="#消息边界问题-与-channel附件attachment" class="headerlink" title="消息边界问题  与 channel附件attachment"></a>消息边界问题  与 channel附件attachment</h4><p><img src="source/Java-IO%E4%B8%8ENIO/0023.png" alt="0023"></p>
<ul>
<li>一种思路是固定消息长度，数据包大小一样，服务器按预定长度读取，缺点是浪费贷款</li>
<li>另一种思路是按分隔符拆分，缺点是效率低</li>
<li>TLV格式，即Type类型、Length长度、Value数据，类型和长度已知的情况下，就可以方便获取消息大小，分配合适的buffer，缺点是buffer需要提前分配，如果内容过大，则会影响server的吞吐量<ul>
<li>Http1.1 是TLV格式</li>
<li>Http2.0 是LTV格式</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram </span><br><span class="line">participant c1 as 客户端1</span><br><span class="line">participant s as 服务器</span><br><span class="line">participant b1 as ByteBuffer1</span><br><span class="line">participant b2 as ByteBuffer2</span><br><span class="line">c1 -&gt;&gt; s: 发送 01234567890abcdef3333\r</span><br><span class="line">s -&gt;&gt; b1: 第一次 read 存入 01234567890abcdef</span><br><span class="line">s -&gt;&gt; b2: 扩容</span><br><span class="line">b1 -&gt;&gt; b2: 拷贝 01234567890abcdef</span><br><span class="line">s -&gt;&gt; b2: 第二次 read 存入 3333\r</span><br><span class="line">b2 -&gt;&gt; b2: 01234567890abcdef3333\r</span><br></pre></td></tr></table></figure>



<p>Server端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(ByteBuffer source)</span> &#123;</span><br><span class="line">        source.flip();</span><br><span class="line">        <span class="comment">// 如果没有读到分隔符，source就不会进行get操作，</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; source.limit(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (source.get(i) == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> i + <span class="number">1</span> - source.position();</span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">target</span> <span class="operator">=</span> ByteBuffer.allocate(length);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                    target.put(source.get());</span><br><span class="line">                &#125;</span><br><span class="line">                print(target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当buffer中的还有元素没有读取完成的时候，采用整理的方式，保留剩余元素，清除读取过的元素</span></span><br><span class="line">        <span class="comment">// 这里没有读到\n 这个buffer就会有剩余元素</span></span><br><span class="line">        source.compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(ByteBuffer target)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; target.limit(); i++) &#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>) target.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startServer</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">9999</span>));</span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> serverSocketChannel.register(selector, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        selectionKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="comment">// 循环监听</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            selector.select();  <span class="comment">// 选择阻塞</span></span><br><span class="line">            <span class="comment">// 获取就绪key的集合</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                <span class="comment">// key取出来之后及时的从集合中移除</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="comment">// 根据key的类型，处理不同的业务场景</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> ssc.accept();</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">                    <span class="comment">// TODO 每accept一次，就绑定socketChannel到selector上，并将buffer作为附件一并注册到selector</span></span><br><span class="line">                    <span class="comment">// TODO 这样每个channel就会对应一个buffer对象的附件attchment</span></span><br><span class="line">                    socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ, buffer);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> socketChannel.read(buffer);</span><br><span class="line">                    <span class="keyword">if</span> (read == -<span class="number">1</span>) &#123;  <span class="comment">// 如果read的值为-1，意味正常断开，</span></span><br><span class="line">                        key.cancel();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        split(buffer);</span><br><span class="line">                        <span class="comment">//TODO 当buffer满了，无法再添加数据的时候，需要扩容</span></span><br><span class="line">                        <span class="keyword">if</span>(buffer.position()==buffer.limit()) &#123;</span><br><span class="line">                            <span class="comment">// 扩容 </span></span><br><span class="line">                            <span class="type">ByteBuffer</span> <span class="variable">newBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(buffer.capacity() &lt;&lt; <span class="number">1</span>);</span><br><span class="line">                            <span class="comment">// 重置buffer的position，进行从头读取</span></span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            newBuffer.put(buffer);</span><br><span class="line">                            key.attach(newBuffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Server</span>().startServer();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        sc.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">9999</span>));</span><br><span class="line">        <span class="type">SocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> sc.getLocalAddress();</span><br><span class="line"><span class="comment">// sc.write(Charset.defaultCharset().encode(&quot;hello\nworld\n&quot;));</span></span><br><span class="line">        sc.write(Charset.defaultCharset().encode(<span class="string">&quot;0123\n456789abcdef&quot;</span>));</span><br><span class="line">        sc.write(Charset.defaultCharset().encode(<span class="string">&quot;0123456789abcdef3333\n&quot;</span>));</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ByteBuffer-大小分配"><a href="#ByteBuffer-大小分配" class="headerlink" title="ByteBuffer 大小分配"></a>ByteBuffer 大小分配</h4><ul>
<li><blockquote>
<p>每个channel都需要记录可能被切分的消息，因为ByteBuffer不能被多个channel共同使用，因此需要为每个channel维护一个独立的ByteBuffer</p>
</blockquote>
</li>
<li><blockquote>
<p>ByteBuffer不能太大，比如一个ByteBuffer 1Mb的话，要支持百万连接就需要1Tb内存，因此需要设计大小可变的ByteBuffer</p>
</blockquote>
<ul>
<li>一种思路是首先分配一个较小的buffer，例如4k，如果发现数据不够，再分配8k的buffer，将4kbuffer内容拷贝到8k buffer，优点是消息连续容易处理，缺点是数据拷贝耗费性能。参考实现<a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-performance/resizable-array.html">http://tutorials.jenkov.com/java-performance/resizable-array.html</a></li>
<li>另一种思路是用多个数组组成buffer，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续，解析复杂，优点是避免了拷贝引起的性能损耗。</li>
</ul>
</li>
</ul>
<h4 id="💡-为何要-iter-remove"><a href="#💡-为何要-iter-remove" class="headerlink" title="💡 为何要 iter.remove()"></a>💡 为何要 iter.remove()</h4><blockquote>
<p>因为 select 在事件发生后，就会将相关的 key 放入 selectedKeys 集合，但不会在处理完后从 selectedKeys 集合中移除，需要我们自己编码删除。例如</p>
<ul>
<li>第一次触发了 ssckey 上的 accept 事件，没有移除 ssckey </li>
<li>第二次触发了 sckey 上的 read 事件，但这时 selectedKeys 中还有上次的 ssckey ，在处理时因为没有真正的 serverSocket 连上了，就会导致空指针异常</li>
</ul>
</blockquote>
<h4 id="💡-cancel-的作用"><a href="#💡-cancel-的作用" class="headerlink" title="💡 cancel 的作用"></a>💡 cancel 的作用</h4><blockquote>
<p>cancel 会取消注册在 selector 上的 channel，并从 keys 集合中删除 key 后续不会再监听事件</p>
</blockquote>
<h3 id="处理write事件"><a href="#处理write事件" class="headerlink" title="处理write事件"></a>处理write事件</h3><h4 id="一次无法写完例子"><a href="#一次无法写完例子" class="headerlink" title="一次无法写完例子"></a>一次无法写完例子</h4><ul>
<li>非阻塞模式下，无法保证把buffer中所有数据都写入channel，因此需要追踪write方法的返回值（代表实际写入字节数）</li>
<li>用selector监听所有channel的可写事件，每个channel都需要一个key来跟踪buffer，但这样又会导致占用内存过多，就有两阶段策略<ul>
<li>当消息处理器第一次写入消息时，才将channel注册到selector上</li>
<li>selector检查channel上的可写事件，如果所有的数据写完了，就取消channel的注册<ul>
<li>如果不取消，会每次可写均会触发write事件</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>服务端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriteServer</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startServer</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>));</span><br><span class="line">        ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="comment">// 循环监听</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                <span class="comment">// 取出key，并及时移除key</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">                    socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">scKey</span> <span class="operator">=</span> socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    <span class="comment">// todo 服务端向客户端发送数据</span></span><br><span class="line">                    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">90000000</span>; i++) &#123;</span><br><span class="line">                        sb.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;UTF-8&quot;</span>).encode(sb.toString());</span><br><span class="line">                    <span class="type">int</span> <span class="variable">write</span> <span class="operator">=</span> socketChannel.write(byteBuffer);</span><br><span class="line">                    <span class="comment">// write 代表实际写入了多少字节</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;实际写入字节数：&quot;</span>+ write);</span><br><span class="line">                    <span class="keyword">if</span> (byteBuffer.hasRemaining())&#123;</span><br><span class="line">                        <span class="comment">// 如果buffer position 到 limit 还有数据, 这种情况就是一次性没有写完数据</span></span><br><span class="line">                        <span class="comment">// todo 在原有的事件上，增加 可写write 事件</span></span><br><span class="line">                        scKey.interestOps(scKey.interestOps() + SelectionKey.OP_WRITE);</span><br><span class="line">                        <span class="comment">// 由于buffer中的数据还没有全部被写入完，需要将buffer作为附件，传递给scKey</span></span><br><span class="line">                        scKey.attach(byteBuffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line"><span class="comment">//                    System.out.println(&quot;Selector 监控到可读状态&quot;);</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">write</span> <span class="operator">=</span> socketChannel.write(byteBuffer);</span><br><span class="line">                    System.out.println(<span class="string">&quot;实际写入字节数：&quot;</span>+ write);</span><br><span class="line">                    <span class="keyword">if</span>(!byteBuffer.hasRemaining())&#123;</span><br><span class="line">                        <span class="comment">// 如果buffer中的数据全部写入完成之后，就需要及时的移除 可写状态的监控杆</span></span><br><span class="line">                        key.interestOps(key.interestOps() - SelectionKey.OP_WRITE);</span><br><span class="line">                        <span class="comment">// 清除附件 buffer</span></span><br><span class="line">                        key.attach(<span class="literal">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriteClient</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>));</span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_CONNECT | SelectionKey.OP_READ);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">                    System.out.println(socketChannel.finishConnect());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">                    count += sc.read(buffer);</span><br><span class="line">                    System.out.println(count);</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="非阻塞-VS-阻塞"><a href="#非阻塞-VS-阻塞" class="headerlink" title="非阻塞 VS 阻塞"></a>非阻塞 VS 阻塞</h3><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><ul>
<li>阻塞模式下，相关方法都会导致线程暂停<ul>
<li><code>ServerSocketChannel.accept()</code>会在没有连接建立时让线程暂停</li>
<li><code>SocketChannel.read()</code>会在没有数据可读时让线程阻塞</li>
<li>阻塞的表现其实就是线程暂停了，暂停期间不会占用CPU，但是线程相当于闲置</li>
</ul>
</li>
<li>单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持</li>
<li>但在多线程下，有新的问题，体现在以下几个方面<ul>
<li>32位JVM一个线程占320K，64位JVM一个线程占1024K，如果连接数过多，必然导致OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低</li>
<li>可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接。</li>
</ul>
</li>
</ul>
<p>服务端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用nio来理解阻塞模式，单线程</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"><span class="comment">// 连接集合</span></span><br><span class="line">List&lt;SocketChannel&gt; channels = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept(); <span class="comment">// 阻塞方法，线程停止运行</span></span><br><span class="line">    channels.add(sc);</span><br><span class="line">    <span class="keyword">for</span>(SocketChannel channel : channels)&#123;</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        channel.read(buffer); <span class="comment">// 阻塞方法，线程停止运行</span></span><br><span class="line">        buffer.flip();  <span class="comment">// 重置position和limit</span></span><br><span class="line">        debugRead(buffer);</span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">sc.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">8080</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;wainting ...&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h4><ul>
<li>非阻塞模式下， 相关方法都不会让线程暂停<ul>
<li><code>ServerSocketChannel.accept()</code>没有连接建立时，会返回null，继续运行</li>
<li><code>SocketChannel.read()</code>在没有数据可读时，会返回0，但线程不必阻塞，可以去执行其他<code>SocketChannel</code>的<code>read</code>或是去执行<code>ServerSocketChannel.accept</code></li>
<li>写数据时，线程只是等待数据写入Channel即可，无需等<code>Channel</code>通过网络把数据发送出去</li>
</ul>
</li>
<li>但非阻塞模式下，即使没有连接建立，和可读数据，线程仍然在不断运行，白白浪费了cpu</li>
<li>数据复制过程中，线程实际还是阻塞的(AIO改进的地方)</li>
</ul>
<p>服务器端，客户端代码不变</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用nio来理解非阻塞模式，单线程</span></span><br><span class="line"><span class="comment">// 0. ByteBuffer</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line"><span class="comment">// 1. 创建了服务器</span></span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">ssc.configureBlocking(<span class="literal">false</span>); <span class="comment">// 非阻塞模式</span></span><br><span class="line"><span class="comment">// 2. 绑定监听端口</span></span><br><span class="line">ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"><span class="comment">// 3. 连接集合</span></span><br><span class="line">List&lt;SocketChannel&gt; channels = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信</span></span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept(); <span class="comment">// 非阻塞，线程还会继续运行，如果没有连接建立，但sc是null</span></span><br><span class="line">    <span class="keyword">if</span> (sc != <span class="literal">null</span>) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;connected... &#123;&#125;&quot;</span>, sc);</span><br><span class="line">        sc.configureBlocking(<span class="literal">false</span>); <span class="comment">// 非阻塞模式</span></span><br><span class="line">        channels.add(sc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (SocketChannel channel : channels) &#123;</span><br><span class="line">        <span class="comment">// 5. 接收客户端发送的数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(buffer);<span class="comment">// 非阻塞，线程仍然会继续运行，如果没有读到数据，read 返回 0</span></span><br><span class="line">        <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            debugRead(buffer);</span><br><span class="line">            buffer.clear();</span><br><span class="line">            log.debug(<span class="string">&quot;after read...&#123;&#125;&quot;</span>, channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>单线程可以配合Selector完成对多个Channel可读写事件的监控，这称之为多路复用</p>
<ul>
<li>多路复用仅针对网络IO，普通文件IO没法利用多路复用</li>
<li>如果不用Selector的非阻塞模式，线程大部分时间都在做无用功，而Selector能够保证<ul>
<li>有可连接事件时才去连接</li>
<li>有可读事件才去读取</li>
<li>有可写事件才去写入<ul>
<li>限于网络传输能力，Channel未必时时可写，一旦Channel可写，会触发Selector的可写事件。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-9-多线程版的NIO优化"><a href="#3-9-多线程版的NIO优化" class="headerlink" title="3.9 多线程版的NIO优化"></a>3.9 多线程版的NIO优化</h2><blockquote>
<p>现在都是多核cpu，设计时要充分考虑别让cpu的力量被白白浪费</p>
</blockquote>
<p>前面的代码只有一个选择器，没有充分利用多核cpu，如何改进呢？</p>
<p>分两组选择器</p>
<ul>
<li>单线程配一个选择器，专门处理<code>accept</code>事件——Boss</li>
<li>创建cpu核心数的线程，每个线程配一个选择器，轮流处理<strong>read</strong>事件——Workers</li>
</ul>
<p><img src="source/Java-IO%E4%B8%8ENIO/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96.png"></p>
<p>假设共有四个socket客户端<code>1,2,3,4</code>，通过Boss的单线程中的Selector连监听socket的<code>accept</code>事件，然后将相应的socket注册到具体的worker上进行具体的<code>read</code>和<code>write</code>事件的处理。</p>
<p><strong>基础版Server</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> utils.ByteBufferUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiThreadServer</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startServer</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;boss&quot;</span>);</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9999</span>));</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">boss</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">bossSelectionKey</span> <span class="operator">=</span> ssc.register(boss, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// boss线程中的selector专门负责监听accept事件</span></span><br><span class="line">        bossSelectionKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;workder-0&quot;</span>);</span><br><span class="line">        worker.register();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            boss.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = boss.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="comment">// 监听到accept事件，进行处理</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">                    socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    System.out.println(String.format(<span class="string">&quot;connected...&#123;&#125;&quot;</span>+ socketChannel.getRemoteAddress()));</span><br><span class="line">                    <span class="comment">// TODO 将 boss 通过监听accept所得到的socketChannel注册到 worker的selector上</span></span><br><span class="line">                    System.out.println(String.format(<span class="string">&quot;before register...&#123;&#125;&quot;</span>+socketChannel.getRemoteAddress()));</span><br><span class="line">                    socketChannel.register(worker.selector, SelectionKey.OP_READ, <span class="literal">null</span>);</span><br><span class="line">                    System.out.println(String.format(<span class="string">&quot;after register...&#123;&#125;&quot;</span>+socketChannel.getRemoteAddress()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Thread thread;</span><br><span class="line">        <span class="keyword">private</span> Selector selector;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">start</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 用于标识 Selector和Thread是否初始化，保证初始化一次</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 初始化线程，和selector</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="comment">// 保证 在 即使调用 多次register方法，worker和thread只被初始化一次</span></span><br><span class="line">            <span class="keyword">if</span> (!start) &#123;</span><br><span class="line">                selector = Selector.open();</span><br><span class="line">                thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>, name);</span><br><span class="line">                thread.start();</span><br><span class="line">                start = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    selector.select();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">                            <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> socketChannel.read(buffer);</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            ByteBufferUtil.debugAll(buffer);</span><br><span class="line">                            System.out.println(String.format(<span class="string">&quot;read register...&#123;&#125;&quot;</span>+socketChannel.getRemoteAddress()));</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况下，worker线程中进行监控，boss线程中进行注册。但是由于worker线程先执行，导致<code>selector.select();</code>一直阻塞着，后期boss向worker的selector上注册新的事件时，该线程一直在阻塞着，无法继续执行。</p>
<p><strong>改进1Server</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> utils.ByteBufferUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiThreadServer</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startServer</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;boss&quot;</span>);</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9999</span>));</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">boss</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">bossSelectionKey</span> <span class="operator">=</span> ssc.register(boss, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// boss线程中的selector专门负责监听accept事件</span></span><br><span class="line">        bossSelectionKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;workder-0&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            boss.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = boss.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="comment">// 监听到accept事件，进行处理</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">                    socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    System.out.println(String.format(<span class="string">&quot;connected...&#123;&#125;&quot;</span>+ socketChannel.getRemoteAddress()));</span><br><span class="line">                    <span class="comment">// TODO 将 boss 通过监听accept所得到的socketChannel注册到 worker的selector上</span></span><br><span class="line">                    System.out.println(String.format(<span class="string">&quot;before register...&#123;&#125;&quot;</span>+socketChannel.getRemoteAddress()));</span><br><span class="line">                    worker.register(socketChannel);</span><br><span class="line">                    System.out.println(String.format(<span class="string">&quot;after register...&#123;&#125;&quot;</span>+socketChannel.getRemoteAddress()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Thread thread;</span><br><span class="line">        <span class="keyword">private</span> Selector selector;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">start</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 用于标识 Selector和Thread是否初始化，保证初始化一次</span></span><br><span class="line">        <span class="comment">// 两个不同的线程传递执行代码，可以通过队列的方式进行传递</span></span><br><span class="line">        <span class="keyword">private</span> ConcurrentLinkedQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 初始化线程，和selector</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="comment">// 保证 在 即使调用 多次register方法，worker和thread只被初始化一次</span></span><br><span class="line">            <span class="keyword">if</span> (!start) &#123;</span><br><span class="line">                selector = Selector.open();</span><br><span class="line">                thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>, name);</span><br><span class="line">                thread.start();</span><br><span class="line">                start = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ, <span class="literal">null</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClosedChannelException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            selector.wakeup(); <span class="comment">// 唤醒selector的阻塞等待</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// run方法是在新的线程中进行运行的</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    selector.select();</span><br><span class="line">                    <span class="comment">// 获取boss线程中的任务</span></span><br><span class="line">                    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                    <span class="keyword">if</span>(task!=<span class="literal">null</span>)&#123;</span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125;</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">                            <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> socketChannel.read(buffer);</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            ByteBufferUtil.debugAll(buffer);</span><br><span class="line">                            System.out.println(String.format(<span class="string">&quot;read register...&#123;&#125;&quot;</span>+socketChannel.getRemoteAddress()));</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>多worker版本的Server</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> utils.ByteBufferUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiThreadServer</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startServer</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;boss&quot;</span>);</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9999</span>));</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">boss</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">bossSelectionKey</span> <span class="operator">=</span> ssc.register(boss, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// boss线程中的selector专门负责监听accept事件</span></span><br><span class="line">        bossSelectionKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line"><span class="comment">//        Worker[] workers = new Worker[Runtime.getRuntime().availableProcessors()];</span></span><br><span class="line">        Worker[] workers = <span class="keyword">new</span> <span class="title class_">Worker</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; workers.length; i++) &#123;</span><br><span class="line">            workers[i] = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;worker-&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">index</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            boss.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = boss.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="comment">// 监听到accept事件，进行处理</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">                    socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    System.out.println(String.format(Thread.currentThread().getName()+<span class="string">&quot;connected...&#123;&#125;&quot;</span>+ socketChannel.getRemoteAddress()));</span><br><span class="line">                    <span class="comment">// TODO 将 boss 通过监听accept所得到的socketChannel注册到 worker的selector上</span></span><br><span class="line">                    System.out.println(String.format(Thread.currentThread().getName()+<span class="string">&quot;before register...&#123;&#125;&quot;</span>+socketChannel.getRemoteAddress()));</span><br><span class="line">                    <span class="comment">// round robin 轮询</span></span><br><span class="line">                    workers[index.getAndIncrement() % workers.length].register(socketChannel);</span><br><span class="line">                    System.out.println(String.format(Thread.currentThread().getName()+<span class="string">&quot;after register...&#123;&#125;&quot;</span>+socketChannel.getRemoteAddress()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Thread thread;</span><br><span class="line">        <span class="keyword">private</span> Selector selector;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">start</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 用于标识 Selector和Thread是否初始化，保证初始化一次</span></span><br><span class="line">        <span class="comment">// 两个不同的线程传递执行代码，可以通过队列的方式进行传递</span></span><br><span class="line">        <span class="keyword">private</span> ConcurrentLinkedQueue&lt;Runnable&gt; tasks = <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 初始化线程，和selector</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="comment">// 保证 在 即使调用 多次register方法，worker和thread只被初始化一次</span></span><br><span class="line">            <span class="keyword">if</span> (!start) &#123;</span><br><span class="line">                selector = Selector.open();</span><br><span class="line">                thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>, name);</span><br><span class="line">                thread.start();</span><br><span class="line">                start = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tasks.add(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ, <span class="literal">null</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClosedChannelException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            selector.wakeup(); <span class="comment">// 唤醒selector的阻塞等待</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// run方法是在新的线程中进行运行的</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    selector.select();</span><br><span class="line">                    <span class="comment">// 获取boss线程中的任务</span></span><br><span class="line">                    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> tasks.poll();</span><br><span class="line">                    <span class="keyword">if</span>(task!=<span class="literal">null</span>)&#123;</span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125;</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">                            <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> socketChannel.read(buffer);</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            ByteBufferUtil.debugAll(buffer);</span><br><span class="line">                            System.out.println(String.format(Thread.currentThread().getName()+<span class="string">&quot;read register...&#123;&#125;&quot;</span>+socketChannel.getRemoteAddress()));</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-0-NIO-vs-BIO"><a href="#4-0-NIO-vs-BIO" class="headerlink" title="4.0 NIO vs BIO"></a>4.0 NIO vs BIO</h2><h3 id="1-stream-vs-channel"><a href="#1-stream-vs-channel" class="headerlink" title="1. stream vs channel"></a>1. stream vs channel</h3><ul>
<li>stream不会自动缓冲数据，channel会利用系统提供的发送缓冲区、接收缓冲区（更为底层）</li>
<li>stream仅支持阻塞api，channel同时支持阻塞、非阻塞api、网络channel可配合selector实现多路复用。</li>
<li>二者均为全双工，即读写可以同时进行</li>
</ul>
<h3 id="2-IO-模型"><a href="#2-IO-模型" class="headerlink" title="2. IO 模型"></a>2. IO 模型</h3><p>同步阻塞、同步非阻塞、同步多路复用、异步阻塞（没有此情况）、异步非阻塞</p>
<ul>
<li>同步：线程自己去获取结果（一个线程）</li>
<li>异步：线程自己不去获取结果，而是由其它线程送结果（至少两个线程）</li>
</ul>
<p>当调用一次 channel.read 或 stream.read 后，会切换至操作系统内核态来完成真正数据读取，而读取又分为两个阶段，分别为：</p>
<ul>
<li>等待数据阶段</li>
<li>复制数据阶段</li>
</ul>
<p><img src="source/Java-IO%E4%B8%8ENIO/0033.png"></p>
<ul>
<li><p>阻塞 IO</p>
<p><img src="source/Java-IO%E4%B8%8ENIO/0039.png"></p>
</li>
<li><p>非阻塞  IO</p>
<p><img src="source/Java-IO%E4%B8%8ENIO/0035.png"></p>
</li>
<li><p>多路复用</p>
<p><img src="source/Java-IO%E4%B8%8ENIO/0038.png"></p>
</li>
<li><p>信号驱动</p>
</li>
<li><p>异步 IO</p>
<p><img src="source/Java-IO%E4%B8%8ENIO/0037.png"></p>
</li>
<li><p>阻塞 IO vs 多路复用</p>
<p><img src="source/Java-IO%E4%B8%8ENIO/0034.png"></p>
<p><img src="source/Java-IO%E4%B8%8ENIO/0036.png"></p>
</li>
</ul>
<h4 id="🔖-参考"><a href="#🔖-参考" class="headerlink" title="🔖 参考"></a>🔖 参考</h4><p>UNIX 网络编程 - 卷 I</p>
<h3 id="3-零拷贝"><a href="#3-零拷贝" class="headerlink" title="3. 零拷贝"></a>3. 零拷贝</h3><h4 id="3-1-传统-IO-问题"><a href="#3-1-传统-IO-问题" class="headerlink" title="3.1 传统 IO 问题"></a>3.1 传统 IO 问题</h4><p>传统的 IO 将一个文件通过 socket 写出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;helloword/data.txt&quot;</span>);</span><br><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>)f.length()];</span><br><span class="line">file.read(buf);</span><br><span class="line"></span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ...;</span><br><span class="line">socket.getOutputStream().write(buf);</span><br></pre></td></tr></table></figure>

<p>内部工作流程是这样的：</p>
<p><img src="source/Java-IO%E4%B8%8ENIO/0024.png"></p>
<ol>
<li><p>java 本身并不具备 IO 读写能力，因此 read 方法调用后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，去调用操作系统（Kernel）的读能力，将数据读入<strong>内核缓冲区</strong>。这期间用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，其间也不会使用 cpu</p>
<blockquote>
<p>DMA 也可以理解为硬件单元，用来解放 cpu 完成文件 IO</p>
</blockquote>
</li>
<li><p>从<strong>内核态</strong>切换回<strong>用户态</strong>，将数据从<strong>内核缓冲区</strong>读入<strong>用户缓冲区</strong>（即 byte[] buf），这期间 cpu 会参与拷贝，无法利用 DMA</p>
</li>
<li><p>调用 write 方法，这时将数据从<strong>用户缓冲区</strong>（byte[] buf）写入 <strong>socket 缓冲区</strong>，cpu 会参与拷贝</p>
</li>
<li><p>接下来要向网卡写数据，这项能力 java 又不具备，因此又得从<strong>用户态</strong>切换至<strong>内核态</strong>，调用操作系统的写能力，使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu</p>
</li>
</ol>
<p>可以看到中间环节较多，java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的</p>
<ul>
<li>用户态与内核态的切换发生了 3 次，这个操作比较重量级</li>
<li>数据拷贝了共 4 次</li>
</ul>
<h4 id="3-2-NIO优化"><a href="#3-2-NIO优化" class="headerlink" title="3.2 NIO优化"></a>3.2 NIO优化</h4><p>通过 DirectByteBuf </p>
<ul>
<li>ByteBuffer.allocate(10)  HeapByteBuffer 使用的还是 java 内存</li>
<li>ByteBuffer.allocateDirect(10)  DirectByteBuffer 使用的是操作系统内存</li>
</ul>
<p><img src="source/Java-IO%E4%B8%8ENIO/0025.png"></p>
<p>大部分步骤与优化前相同，不再赘述。唯有一点：java 可以使用 DirectByteBuf 将堆外内存映射到 jvm 内存中来直接访问使用</p>
<ul>
<li>这块内存不受 jvm 垃圾回收的影响，因此内存地址固定，有助于 IO 读写</li>
<li>java 中的 DirectByteBuf 对象仅维护了此内存的虚引用，内存回收分成两步<ul>
<li>DirectByteBuf 对象被垃圾回收，将虚引用加入引用队列</li>
<li>通过专门线程访问引用队列，根据虚引用释放堆外内存</li>
</ul>
</li>
<li>减少了一次数据拷贝，用户态与内核态的切换次数没有减少</li>
</ul>
<p>进一步优化（底层采用了 linux 2.1 后提供的 sendFile 方法），java 中对应着两个 channel 调用 transferTo/transferFrom 方法拷贝数据</p>
<p><img src="source/Java-IO%E4%B8%8ENIO/0026.png"></p>
<ol>
<li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 cpu</li>
<li>数据从<strong>内核缓冲区</strong>传输到 <strong>socket 缓冲区</strong>，cpu 会参与拷贝</li>
<li>最后使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu</li>
</ol>
<p>可以看到</p>
<ul>
<li>只发生了一次用户态与内核态的切换</li>
<li>数据拷贝了 3 次</li>
</ul>
<p>进一步优化（linux 2.4）</p>
<p><img src="source/Java-IO%E4%B8%8ENIO/0027.png"></p>
<ol>
<li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 cpu</li>
<li>只会将一些 offset 和 length 信息拷入 <strong>socket 缓冲区</strong>，几乎无消耗</li>
<li>使用 DMA 将 <strong>内核缓冲区</strong>的数据写入网卡，不会使用 cpu</li>
</ol>
<p>整个过程仅只发生了一次用户态与内核态的切换，数据拷贝了 2 次。所谓的【零拷贝】，并不是真正无拷贝，而是在不会拷贝重复数据到 jvm 内存中，零拷贝的优点有</p>
<ul>
<li>更少的用户态与内核态的切换</li>
<li>不利用 cpu 计算，减少 cpu 缓存伪共享</li>
<li>零拷贝适合小文件传输</li>
</ul>
<h3 id="4-文件AIO"><a href="#4-文件AIO" class="headerlink" title="4. 文件AIO"></a>4. 文件AIO</h3><p>先来看看 AsynchronousFileChannel</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AioDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">AsynchronousFileChannel</span> <span class="variable">s</span> <span class="operator">=</span> </span><br><span class="line">                AsynchronousFileChannel.open(</span><br><span class="line">                	Paths.get(<span class="string">&quot;1.txt&quot;</span>), StandardOpenOption.READ);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">2</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">            s.read(buffer, <span class="number">0</span>, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;read completed...&#123;&#125;&quot;</span>, result);</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    debug(buffer);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;read failed...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;do other things...&quot;</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - begin...</span><br><span class="line">13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - do other things...</span><br><span class="line">13:44:56 [DEBUG] [Thread-5] c.i.aio.AioDemo1 - read completed...2</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 61 0d                                           |a.              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>

<p>可以看到</p>
<ul>
<li>响应文件读取成功的是另一个线程 Thread-5</li>
<li>主线程并没有 IO 操作阻塞</li>
</ul>
<h4 id="💡-守护线程"><a href="#💡-守护线程" class="headerlink" title="💡 守护线程"></a>💡 守护线程</h4><p>默认文件 AIO 使用的线程都是守护线程，所以最后要执行 <code>System.in.read()</code> 以避免守护线程意外结束</p>
<h4 id="网络-AIO"><a href="#网络-AIO" class="headerlink" title="网络 AIO"></a>网络 AIO</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AioServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">AsynchronousServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> AsynchronousServerSocketChannel.open();</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        ssc.accept(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">AcceptHandler</span>(ssc));</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeChannel</span><span class="params">(AsynchronousSocketChannel sc)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;[%s] %s close\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());</span><br><span class="line">            sc.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReadHandler</span> <span class="keyword">implements</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AsynchronousSocketChannel sc;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ReadHandler</span><span class="params">(AsynchronousSocketChannel sc)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.sc = sc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (result == -<span class="number">1</span>) &#123;</span><br><span class="line">                    closeChannel(sc);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.printf(<span class="string">&quot;[%s] %s read\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());</span><br><span class="line">                attachment.flip();</span><br><span class="line">                System.out.println(Charset.defaultCharset().decode(attachment));</span><br><span class="line">                attachment.clear();</span><br><span class="line">                <span class="comment">// 处理完第一个 read 时，需要再次调用 read 方法来处理下一个 read 事件</span></span><br><span class="line">                sc.read(attachment, attachment, <span class="built_in">this</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class="line">            closeChannel(sc);</span><br><span class="line">            exc.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WriteHandler</span> <span class="keyword">implements</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AsynchronousSocketChannel sc;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">WriteHandler</span><span class="params">(AsynchronousSocketChannel sc)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.sc = sc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class="line">            <span class="comment">// 如果作为附件的 buffer 还有内容，需要再次 write 写出剩余内容</span></span><br><span class="line">            <span class="keyword">if</span> (attachment.hasRemaining()) &#123;</span><br><span class="line">                sc.write(attachment);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class="line">            exc.printStackTrace();</span><br><span class="line">            closeChannel(sc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AcceptHandler</span> <span class="keyword">implements</span> <span class="title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel, Object&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AsynchronousServerSocketChannel ssc;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">AcceptHandler</span><span class="params">(AsynchronousServerSocketChannel ssc)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.ssc = ssc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(AsynchronousSocketChannel sc, Object attachment)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;[%s] %s connected\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">            <span class="comment">// 读事件由 ReadHandler 处理</span></span><br><span class="line">            sc.read(buffer, buffer, <span class="keyword">new</span> <span class="title class_">ReadHandler</span>(sc));</span><br><span class="line">            <span class="comment">// 写事件由 WriteHandler 处理</span></span><br><span class="line">            sc.write(Charset.defaultCharset().encode(<span class="string">&quot;server hello!&quot;</span>), ByteBuffer.allocate(<span class="number">16</span>), <span class="keyword">new</span> <span class="title class_">WriteHandler</span>(sc));</span><br><span class="line">            <span class="comment">// 处理完第一个 accpet 时，需要再次调用 accept 方法来处理下一个 accept 事件</span></span><br><span class="line">            ssc.accept(<span class="literal">null</span>, <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, Object attachment)</span> &#123;</span><br><span class="line">            exc.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
